<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="MAYAUL" name="product"><meta content="2017" name="release"><meta content="Developer" name="book"><meta content="2016-06-16" name="created"><meta content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887" name="topicid"><meta content="concept" name="topic-type">
<title>glslShader/adjacentTrianglesPrimitiveGenerator.cpp</title>
<meta content="C++" name="topic-subtype"/></meta></meta></meta></meta></meta></meta></meta></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('glsl_shader_2adjacent_triangles_primitive_generator_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>glslShader/adjacentTrianglesPrimitiveGenerator.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">glslShader/adjacentTrianglesPrimitiveGenerator.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk</span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download,</span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic</span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Example plugin: adjacentTrianglesPrimitiveGenerator.cpp</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This plug-in is an example of a custom MPxIndexBufferMutator.</span></div>
<div class="line"><span class="comment">// It provides custom primitives based on shader requirements coming from </span></div>
<div class="line"><span class="comment">// an MPxShaderOverride.  The name() in the MIndexBufferDescriptor is used </span></div>
<div class="line"><span class="comment">// to signify a unique identifier for a custom buffer.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Based on public domain code found here: http://prideout.net/blog/?p=54</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "adjacentTrianglesPrimitiveGenerator.h"</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MStatus.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MIntArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPxVertexBufferGenerator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHWGeometry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDrawRegistry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MComponentDataIndexing.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if defined(_MSC_VER)</span></div>
<div class="line"><span class="preprocessor">#if (_MSC_VER &lt; 1600)</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> __int64 uint64_t;</div>
<div class="line"><span class="comment">// Other compilers</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line"> <span class="keyword">struct </span>HalfEdge;</div>
<div class="line"> <span class="keyword">typedef</span> std::vector&lt;HalfEdge&gt; ThalfEdgeArray;</div>
<div class="line"> <span class="keyword">typedef</span> std::unordered_map&lt;uint64_t, size_t&gt; TedgeAdjacencyIndex;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>HalfEdge</div>
<div class="line">    {</div>
<div class="line">        uint64_t Vert;  <span class="comment">// Vertex index at the end of this half-edge</span></div>
<div class="line"> <span class="keywordtype">size_t</span> Twin; <span class="comment">// Oppositely oriented adjacent half-edge</span></div>
<div class="line"> <span class="keywordtype">size_t</span> Next; <span class="comment">// Next half-edge around the face</span></div>
<div class="line"></div>
<div class="line">        HalfEdge() : Vert(-1), Twin(-1), Next(-1) {};</div>
<div class="line"> <span class="keywordtype">bool</span> hasTwin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Twin != -1; };</div>
<div class="line"> <span class="keywordtype">size_t</span> twinVert(<span class="keyword">const</span> ThalfEdgeArray&amp; edgeArray)<span class="keyword"> const </span>{</div>
<div class="line"> <span class="keywordtype">size_t</span> next = edgeArray[Twin].Next;</div>
<div class="line"> <span class="keywordflow">return</span> edgeArray[next].Vert;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>VertexF</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> kTolerance;</div>
<div class="line">        VertexF(<span class="keyword">const</span> <span class="keywordtype">float</span>* buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufferPos = index * 3;</div>
<div class="line">            x = buffer[bufferPos++];</div>
<div class="line">            y = buffer[bufferPos++];</div>
<div class="line">            z = buffer[bufferPos++];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> isEqual(<span class="keyword">const</span> VertexF &amp;rhs)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> (fabs(x - rhs.x) &lt; kTolerance &amp;&amp; fabs(y - rhs.y) &lt; kTolerance &amp;&amp; fabs(z - rhs.z) &lt; kTolerance);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> VertexF::kTolerance = 1e-5f;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> operator&lt; (<span class="keyword">const</span> VertexF&amp; lhs, <span class="keyword">const</span> VertexF&amp; rhs)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> ((lhs.x - rhs.x) &lt; -VertexF::kTolerance) || </div>
<div class="line">               (fabs(lhs.x - rhs.x) &lt; VertexF::kTolerance &amp;&amp; (lhs.y - rhs.y) &lt; -VertexF::kTolerance) || </div>
<div class="line">               (fabs(lhs.x - rhs.x) &lt; VertexF::kTolerance &amp;&amp; fabs(lhs.y - rhs.y) &lt; VertexF::kTolerance &amp;&amp; (lhs.z - rhs.z) &lt; -VertexF::kTolerance);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>VertexFMap</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getVertexId( <span class="keyword">const</span> VertexF&amp; v );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> std::map&lt;VertexF, unsigned int&gt; TVtxMap;</div>
<div class="line">        TVtxMap vertexMap;</div>
<div class="line"> <span class="keywordtype">void</span> clear() { TVtxMap empty; vertexMap.swap(empty); }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> VertexFMap::getVertexId( <span class="keyword">const</span> VertexF&amp; v )</div>
<div class="line">    {</div>
<div class="line">        VertexFMap::TVtxMap::const_iterator itVtx = vertexMap.find(v);</div>
<div class="line"> <span class="keywordflow">if</span> (itVtx != vertexMap.end())</div>
<div class="line"> <span class="keywordflow">return</span> itVtx-&gt;second;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextId = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertexMap.size();</div>
<div class="line">        vertexMap.insert(TVtxMap::value_type(v,nextId));</div>
<div class="line"> <span class="keywordflow">return</span> nextId;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">AdjacentTrianglesPrimitiveGenerator::AdjacentTrianglesPrimitiveGenerator()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">AdjacentTrianglesPrimitiveGenerator::~AdjacentTrianglesPrimitiveGenerator() {}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> AdjacentTrianglesPrimitiveGenerator::mutateIndexBuffer( <span class="keyword">const</span> <a name="_a0"></a><a class="code" href="./class_m_uint_array.html">MUintArray</a>&amp; originalBufferIndices, </div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* positionBufferFloat, </div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MHWRender::MGeometry::DataType</a> indexBufferDataType,</div>
<div class="line"> <span class="keywordtype">void</span>* indexData )</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriVerts = originalBufferIndices.<a name="a1"></a><a class="code" href="./class_m_uint_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"></div>
<div class="line">    ThalfEdgeArray edgeArray;</div>
<div class="line">    edgeArray.resize(numTriVerts);</div>
<div class="line"></div>
<div class="line">    TedgeAdjacencyIndex adjacencyIndex;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Iterate all triangles found in the old index buffer:</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertexIndex = 0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> edgeIndex = 0;</div>
<div class="line"></div>
<div class="line">    VertexFMap vertexMap;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">while</span> (vertexIndex &lt; numTriVerts)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = originalBufferIndices[vertexIndex++];</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vA = vertexMap.getVertexId(VertexF(positionBufferFloat, A));</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = originalBufferIndices[vertexIndex++];</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vB = vertexMap.getVertexId(VertexF(positionBufferFloat, B));</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = originalBufferIndices[vertexIndex++];</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vC = vertexMap.getVertexId(VertexF(positionBufferFloat, C));</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create the half-edge that goes from C to A:</span></div>
<div class="line">        adjacencyIndex.insert(TedgeAdjacencyIndex::value_type(vC | (uint64_t(vA) &lt;&lt; 32), edgeIndex));</div>
<div class="line">        edgeArray[edgeIndex].Vert = A;</div>
<div class="line">        edgeArray[edgeIndex].Next = 1 + edgeIndex;</div>
<div class="line">        ++edgeIndex;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create the half-edge that goes from A to B:</span></div>
<div class="line">        adjacencyIndex.insert(TedgeAdjacencyIndex::value_type(vA | (uint64_t(vB) &lt;&lt; 32), edgeIndex));</div>
<div class="line">        edgeArray[edgeIndex].Vert = B;</div>
<div class="line">        edgeArray[edgeIndex].Next = 1 + edgeIndex;</div>
<div class="line">        ++edgeIndex;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create the half-edge that goes from B to C:</span></div>
<div class="line">        adjacencyIndex.insert(TedgeAdjacencyIndex::value_type(vB | (uint64_t(vC) &lt;&lt; 32), edgeIndex));</div>
<div class="line">        edgeArray[edgeIndex].Vert = C;</div>
<div class="line">        edgeArray[edgeIndex].Next = edgeIndex - 2;</div>
<div class="line">        ++edgeIndex;</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// Done with vertexMap:</span></div>
<div class="line">    vertexMap.clear();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (adjacencyIndex.size() != numTriVerts)</div>
<div class="line"> <span class="comment">// Bad mesh: duplicated edges or inconsistent winding.</span></div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Populate the twin pointers by iterating over the index:</span></div>
<div class="line"> <span class="keywordtype">int</span> boundaryCount = 0;</div>
<div class="line"> <span class="keywordflow">for</span> (TedgeAdjacencyIndex::const_iterator it = adjacencyIndex.begin(); it != adjacencyIndex.end(); ++it)</div>
<div class="line">    {</div>
<div class="line">        uint64_t edgeKey = it-&gt;first;</div>
<div class="line"> <span class="keywordtype">size_t</span> edgeIndex = it-&gt;second; </div>
<div class="line">        uint64_t twinKey = ((edgeKey &amp; 0xffffffff) &lt;&lt; 32) | (edgeKey &gt;&gt; 32);</div>
<div class="line">        TedgeAdjacencyIndex::const_iterator twinIt = adjacencyIndex.find(twinKey);</div>
<div class="line"> <span class="keywordflow">if</span> (twinIt != adjacencyIndex.end())</div>
<div class="line">        {</div>
<div class="line">            edgeArray[twinIt-&gt;second].Twin = edgeIndex;</div>
<div class="line">            edgeArray[edgeIndex].Twin = twinIt-&gt;second;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            ++boundaryCount;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Done with adjacencyIndex:</span></div>
<div class="line">    TedgeAdjacencyIndex emptyIndex;</div>
<div class="line">    adjacencyIndex.swap(emptyIndex);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Now that we have a half-edge structure, it's easy to create adjacency info:</span></div>
<div class="line"> <span class="keywordflow">if</span> (boundaryCount &gt; 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">size_t</span> destOffset = 0;</div>
<div class="line"> <span class="keywordtype">size_t</span> edgeIndex = 0;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> faceIndex = 0; faceIndex &lt; numTriVerts/3; ++faceIndex, edgeIndex += 3, destOffset += 6)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (indexBufferDataType == <a name="a2"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6aa93f90f58b3077bdbedeb9506e0143fd">MHWRender::MGeometry::kUnsignedInt32</a>) {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* pDest = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData) + destOffset;</div>
<div class="line">                pDest[0] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 2].Vert);</div>
<div class="line">                pDest[1] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 0].hasTwin() ? edgeArray[edgeIndex + 0].twinVert(edgeArray) : pDest[0]);</div>
<div class="line">                pDest[2] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 0].Vert);</div>
<div class="line">                pDest[3] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 1].hasTwin() ? edgeArray[edgeIndex + 1].twinVert(edgeArray) : pDest[2]);</div>
<div class="line">                pDest[4] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 1].Vert);</div>
<div class="line">                pDest[5] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 2].hasTwin() ? edgeArray[edgeIndex + 2].twinVert(edgeArray) : pDest[4]);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexBufferDataType == <a name="a3"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a3d97c6fcb525dc79fed35f39fd7bab76">MHWRender::MGeometry::kUnsignedInt16</a>) {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* pDest = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData) + destOffset;</div>
<div class="line">                pDest[0] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 2].Vert);</div>
<div class="line">                pDest[1] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 0].hasTwin() ? edgeArray[edgeIndex + 0].twinVert(edgeArray) : pDest[0]);</div>
<div class="line">                pDest[2] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 0].Vert);</div>
<div class="line">                pDest[3] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 1].hasTwin() ? edgeArray[edgeIndex + 1].twinVert(edgeArray) : pDest[2]);</div>
<div class="line">                pDest[4] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 1].Vert);</div>
<div class="line">                pDest[5] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 2].hasTwin() ? edgeArray[edgeIndex + 2].twinVert(edgeArray) : pDest[4]);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexBufferDataType == <a name="a4"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a771a88748799bba09da625ffee5c6945">MHWRender::MGeometry::kUnsignedChar</a>) {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pDest = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)indexData) + destOffset;</div>
<div class="line">                pDest[0] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 2].Vert);</div>
<div class="line">                pDest[1] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 0].hasTwin() ? edgeArray[edgeIndex + 0].twinVert(edgeArray) : pDest[0]);</div>
<div class="line">                pDest[2] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 0].Vert);</div>
<div class="line">                pDest[3] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 1].hasTwin() ? edgeArray[edgeIndex + 1].twinVert(edgeArray) : pDest[2]);</div>
<div class="line">                pDest[4] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 1].Vert);</div>
<div class="line">                pDest[5] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 2].hasTwin() ? edgeArray[edgeIndex + 2].twinVert(edgeArray) : pDest[4]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">size_t</span> destOffset = 0;</div>
<div class="line"> <span class="keywordtype">size_t</span> edgeIndex = 0;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> faceIndex = 0; faceIndex &lt; numTriVerts/3; ++faceIndex, edgeIndex += 3, destOffset += 6)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (indexBufferDataType == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6aa93f90f58b3077bdbedeb9506e0143fd">MHWRender::MGeometry::kUnsignedInt32</a>) {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* pDest = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData) + destOffset;</div>
<div class="line">                pDest[0] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 2].Vert);</div>
<div class="line">                pDest[1] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 0].twinVert(edgeArray));</div>
<div class="line">                pDest[2] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 0].Vert);</div>
<div class="line">                pDest[3] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 1].twinVert(edgeArray));</div>
<div class="line">                pDest[4] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 1].Vert);</div>
<div class="line">                pDest[5] = (<span class="keywordtype">unsigned</span> int)(edgeArray[edgeIndex + 2].twinVert(edgeArray));</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexBufferDataType == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a3d97c6fcb525dc79fed35f39fd7bab76">MHWRender::MGeometry::kUnsignedInt16</a>) {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* pDest = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData) + destOffset;</div>
<div class="line">                pDest[0] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 2].Vert);</div>
<div class="line">                pDest[1] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 0].twinVert(edgeArray));</div>
<div class="line">                pDest[2] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 0].Vert);</div>
<div class="line">                pDest[3] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 1].twinVert(edgeArray));</div>
<div class="line">                pDest[4] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 1].Vert);</div>
<div class="line">                pDest[5] = (<span class="keywordtype">unsigned</span> short)(edgeArray[edgeIndex + 2].twinVert(edgeArray));</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexBufferDataType == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a771a88748799bba09da625ffee5c6945">MHWRender::MGeometry::kUnsignedChar</a>) {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pDest = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)indexData) + destOffset;</div>
<div class="line">                pDest[0] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 2].Vert);</div>
<div class="line">                pDest[1] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 0].twinVert(edgeArray));</div>
<div class="line">                pDest[2] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 0].Vert);</div>
<div class="line">                pDest[3] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 1].twinVert(edgeArray));</div>
<div class="line">                pDest[4] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 1].Vert);</div>
<div class="line">                pDest[5] = (<span class="keywordtype">unsigned</span> char)(edgeArray[edgeIndex + 2].twinVert(edgeArray));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MHWRender::MGeometry::Primitive</a> AdjacentTrianglesPrimitiveGenerator::mutateIndexing(<span class="keyword">const</span> <a name="_a5"></a><a class="code" href="./class_m_h_w_render_1_1_m_component_data_indexing_list.html">MHWRender::MComponentDataIndexingList</a>&amp; sourceIndexBuffers, </div>
<div class="line"> <span class="keyword">const</span> <a name="_a6"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html">MHWRender::MVertexBufferArray</a>&amp; vertexBuffers,</div>
<div class="line"> <a name="_a7"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MHWRender::MIndexBuffer</a>&amp; indexBuffer,</div>
<div class="line"> <span class="keywordtype">int</span>&amp; primitiveStride)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a name="_a8"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a> *positionBuffer = NULL;</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ivb = 0; ivb &lt; vertexBuffers.<a name="a9"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html#ab1eb6de2bf3aa228929ab4b40c73507c">count</a>() &amp;&amp; positionBuffer == NULL; ++ivb)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a> *currBuffer = vertexBuffers.<a name="a10"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html#a621df52a0b7842e1bad3bb7472c8d5e0">getBuffer</a>(ivb);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer == NULL &amp;&amp; currBuffer-&gt;<a name="a11"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a331cfb987f5f4d632a747e7fbbbe4a43">descriptor</a>().<a name="a12"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>() == <a name="a13"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4aa20581584e5f9447cb96afb4f2e10703">MHWRender::MGeometry::kPosition</a>)</div>
<div class="line">            positionBuffer = currBuffer;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer == NULL)</div>
<div class="line"> <span class="comment">// We need at least the positions:</span></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a14"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea7354c5e6b4c4c152b77e663e2e59e0c3">MHWRender::MGeometry::kInvalidPrimitive</a>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">float</span>* positionBufferFloat = (<span class="keywordtype">float</span>*)positionBuffer-&gt;<a name="a15"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230">map</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; sourceIndexBuffers.<a name="a16"></a><a class="code" href="./class_m_h_w_render_1_1_m_component_data_indexing_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>(); ++x)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (sourceIndexBuffers[x]-&gt;componentType() != MHWRender::MComponentDataIndexing::kFaceVertex)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_uint_array.html">MUintArray</a>&amp; originalBufferIndices = sourceIndexBuffers[x]-&gt;indices();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriVerts = originalBufferIndices.<a class="code" href="./class_m_uint_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTri = numTriVerts / 3;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> triSize = 6;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufferSize = numTri * triSize;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* indexData = indexBuffer.<a name="a17"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(bufferSize, <span class="keyword">true</span> <span class="comment">/*writeOnly - we don't need the current buffer values*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (indexData != NULL)</div>
<div class="line">        {</div>
<div class="line">            mutateIndexBuffer( originalBufferIndices, positionBufferFloat,</div>
<div class="line">                               indexBuffer.<a name="a18"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#abc7588a483f61d3d4a1e8204ca14d6f6">dataType</a>(), indexData );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer) positionBuffer-&gt;<a name="a19"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a>();</div>
<div class="line">        indexBuffer.<a name="a20"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(indexData);</div>
<div class="line">        primitiveStride = triSize;</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a21"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea8f0eb61b069ef24cc331fb6e731725a3">MHWRender::MGeometry::kAdjacentTriangles</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer) positionBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a>();</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea7354c5e6b4c4c152b77e663e2e59e0c3">MHWRender::MGeometry::kInvalidPrimitive</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// This is the primitive generator creation function registered with the DrawRegistry.</span></div>
<div class="line"><span class="comment">// Used to initialize a custom primitive generator.</span></div>
<div class="line"><a name="_a22"></a><a class="code" href="./class_m_h_w_render_1_1_m_px_index_buffer_mutator.html">MHWRender::MPxIndexBufferMutator</a>* AdjacentTrianglesPrimitiveGenerator::createAdjacentTrianglesPrimitiveGenerator()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">new</span> AdjacentTrianglesPrimitiveGenerator();</div>
<div class="line">}</div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div><br/></div>
</link></link></link></link></div></body>
</html>

<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="product" content="MAYAUL"><meta name="release" content="2017"><meta name="book" content="Developer"><meta name="created" content="2016-06-16"><meta name="topicid" content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887"><meta name="topic-type" content="concept">
      <title>gpuCache/gpuCacheSpatialSubdivision.cpp</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2gpu_cache_spatial_subdivision_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>gpuCache/gpuCacheSpatialSubdivision.cpp</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">gpuCache/gpuCacheSpatialSubdivision.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc. All rights reserved.</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk</span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download,</span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic</span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description:  </span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      This file contains classes that implement the functionality</span></div>
<div class="line"><span class="comment">//      exposed by the gpuCacheSpatialSubdivision class.  The stuff that is</span></div>
<div class="line"><span class="comment">//      accomplished here is:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      1) Load a SpatialGrid data structure with our list of triangles.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      2) Intelligently walk through the grid using to find cells</span></div>
<div class="line"><span class="comment">//         that lie along a particular ray. This is done using</span></div>
<div class="line"><span class="comment">//         SpatialGridWalker.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      3) use all this to provide a ray-mesh intersection </span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      The file is organized into several parts:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      Part 1: Definition of gpuCacheAccelIsectParams, which encapsulates the</span></div>
<div class="line"><span class="comment">//              creation parameters for the spatial subdivision structure.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      Part 2: Definition of gpuCacheSpatialGrid, derived from SpatialGrid. </span></div>
<div class="line"><span class="comment">//              This class loads spatial grid with face/triangle data. </span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      Part 3: Definition of gpuCacheSpatialSubdivision, which finally</span></div>
<div class="line"><span class="comment">//              implements the various intersection methods.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/timeb.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheSpatialSubdivision.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MMatrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;tbb/parallel_for.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tbb/parallel_reduce.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tbb/blocked_range.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//=============================================================================</span></div>
<div class="line"><span class="comment">//=============================================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  PART 1:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  - defines gpuCacheAccelIsectParams class, which encapsulates parameters</span></div>
<div class="line"><span class="comment">//    for creating the spatial subdivision structure.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//=============================================================================</span></div>
<div class="line"><span class="comment">//=============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line">    gpuCacheIsectAccelParams</div>
<div class="line">        gpuCacheIsectAccelParams::uniformGridParams(</div>
<div class="line">        <span class="keywordtype">int</span> divX,</div>
<div class="line">        <span class="keywordtype">int</span> divY,</div>
<div class="line">        <span class="keywordtype">int</span> divZ</div>
<div class="line">        )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> gpuCacheIsectAccelParams( gpuCacheIsectAccelParams::kUniformGrid,</div>
<div class="line">            divX, divY, divZ );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    gpuCacheIsectAccelParams</div>
<div class="line">        gpuCacheIsectAccelParams::autoUniformGridParams()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> gpuCacheIsectAccelParams( gpuCacheIsectAccelParams::kAutoUniformGrid,</div>
<div class="line">            -1, -1, -1 );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    gpuCacheIsectAccelParams::gpuCacheIsectAccelParams()</div>
<div class="line">        : fAlgorithm( gpuCacheIsectAccelParams::kUniformGrid ),</div>
<div class="line">        fDivX(10),</div>
<div class="line">        fDivY(10),</div>
<div class="line">        fDivZ(10)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    gpuCacheIsectAccelParams::gpuCacheIsectAccelParams( </div>
<div class="line">        <span class="keywordtype">int</span> alg, </div>
<div class="line">        <span class="keywordtype">int</span> divX, </div>
<div class="line">        <span class="keywordtype">int</span> divY, </div>
<div class="line">        <span class="keywordtype">int</span> divZ </div>
<div class="line">        )</div>
<div class="line">        : fAlgorithm(alg),</div>
<div class="line">        fDivX(divX),</div>
<div class="line">        fDivY(divY),</div>
<div class="line">        fDivZ(divZ)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> gpuCacheIsectAccelParams::operator==( <span class="keyword">const</span> gpuCacheIsectAccelParams&amp; rhs )</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//  Description:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//      Compares two acceleration parameter settings to see if they</span></div>
<div class="line">        <span class="comment">//      are the same.  We need to know this in order to determine</span></div>
<div class="line">        <span class="comment">//      whether the acceleration structure needs to be rebuilt or not.</span></div>
<div class="line">        <span class="comment">//  </span></div>
<div class="line">        <span class="comment">//      We don&#39;t compare the verbosity field, as it doesn&#39;t actually</span></div>
<div class="line">        <span class="comment">//      affect the acceleration structure.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>( (fAlgorithm == rhs.fAlgorithm) &amp;&amp;</div>
<div class="line">            (fDivX == rhs.fDivX) &amp;&amp;</div>
<div class="line">            (fDivY == rhs.fDivY) &amp;&amp;</div>
<div class="line">            (fDivZ == rhs.fDivZ) )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> gpuCacheIsectAccelParams::operator!=( <span class="keyword">const</span> gpuCacheIsectAccelParams&amp; rhs )</div>
<div class="line">        <span class="comment">//  </span></div>
<div class="line">        <span class="comment">//  Description:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//      Opposite of ==</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !((*this)==rhs);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//=============================================================================</span></div>
<div class="line">    <span class="comment">//=============================================================================</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// PART 2: </span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">//  - Derive from SpatialGrid to support the data &amp; accessors that we need. </span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">//  This derive class holds on to the list of triangle indices.</span></div>
<div class="line">    <span class="comment">//  SpatialGrid is a data blind structure. Even though we only use it to store </span></div>
<div class="line">    <span class="comment">//  triangle indices in this case, we can store much more complex data by storing it in a</span></div>
<div class="line">    <span class="comment">//  gpuCacheVoxelGrid and storing its index in SpatialGrid if needed.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//=============================================================================</span></div>
<div class="line">    <span class="comment">//=============================================================================</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>gpuCacheVoxelGrid : <span class="keyword">public</span> SpatialGrid { </div>
<div class="line">    <span class="keyword">public</span>: </div>
<div class="line">        <span class="keyword">typedef</span> SpatialGrid ParentClass; </div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles;</div>
<div class="line">        <span class="keyword">const</span> index_t* srcTriangleVertIndices;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions;</div>
<div class="line">        gridPoint3&lt;int&gt;* indexArrayRange;</div>
<div class="line"></div>
<div class="line">        gpuCacheVoxelGrid( <span class="keyword">const</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> &amp;bound, <span class="keyword">const</span> gridPoint3&lt;int&gt; &amp;numVoxels, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> thisNumTriangles, <span class="keyword">const</span> index_t* thisSrcTriangleVertIndices, <span class="keyword">const</span> <span class="keywordtype">float</span>* thisSrcPositions):</div>
<div class="line">            SpatialGrid( bound, numVoxels ),</div>
<div class="line">            numTriangles(thisNumTriangles),</div>
<div class="line">            srcTriangleVertIndices(thisSrcTriangleVertIndices),</div>
<div class="line">            srcPositions(thisSrcPositions)</div>
<div class="line">        {</div>
<div class="line">            addTrianglesToGrid();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> ~gpuCacheVoxelGrid(); </div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> operator()( <span class="keyword">const</span> tbb::blocked_range&lt;unsigned int&gt; &amp;br ) <span class="keyword">const</span>;</div>
<div class="line">        <span class="keywordtype">void</span>                getTris( <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;triArray, <span class="keyword">const</span> gridPoint3&lt;int&gt; &amp;grid); </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">float</span>       getMemoryFootprint(); </div>
<div class="line">    <span class="keyword">private</span>: </div>
<div class="line">        <span class="keywordtype">void</span> addTrianglesToGrid();</div>
<div class="line">    }; </div>
<div class="line"></div>
<div class="line">    gpuCacheVoxelGrid::~gpuCacheVoxelGrid()</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span>TbbBuildVoxelGrid {</div>
<div class="line">        <span class="keyword">const</span> gpuCacheVoxelGrid *gpuGrid;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> operator()( <span class="keyword">const</span> tbb::blocked_range&lt;unsigned int&gt;&amp; br )<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = br.begin(); j != br.end(); j++) {</div>
<div class="line">                index_t idx0=gpuGrid-&gt;srcTriangleVertIndices[3*j]*3;</div>
<div class="line">                index_t idx1=gpuGrid-&gt;srcTriangleVertIndices[3*j+1]*3;</div>
<div class="line">                index_t idx2=gpuGrid-&gt;srcTriangleVertIndices[3*j+2]*3;</div>
<div class="line"></div>
<div class="line">                <a name="_a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex1(gpuGrid-&gt;srcPositions[idx0],gpuGrid-&gt;srcPositions[idx0+1],gpuGrid-&gt;srcPositions[idx0+2]);</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex2(gpuGrid-&gt;srcPositions[idx1],gpuGrid-&gt;srcPositions[idx1+1],gpuGrid-&gt;srcPositions[idx1+2]);</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex3(gpuGrid-&gt;srcPositions[idx2],gpuGrid-&gt;srcPositions[idx2+1],gpuGrid-&gt;srcPositions[idx2+2]);</div>
<div class="line"></div>
<div class="line">                <span class="comment">//create bbox for this tri</span></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> bbox; </div>
<div class="line">                bbox.<a name="a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">expand</a>(vertex1);</div>
<div class="line">                bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">expand</a>(vertex2);</div>
<div class="line">                bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">expand</a>(vertex3);</div>
<div class="line"></div>
<div class="line">                <span class="comment">//expand bbox by 1%</span></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> expandAmount(0.01 * bbox.<a name="a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a6cddcbf72c80144aa2e6501abb150c30">width</a>(),0.01 * bbox.<a name="a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afa7750092d5dcf402c83fb5adba91453">height</a>(),0.01 * bbox.<a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a65c72a51aba9fc4233b58751dd712e43">depth</a>());</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> bbox2(bbox.<a name="a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afb3213b98f3a6b4bda9759511e9b79a1">min</a>()-expandAmount,bbox.<a name="a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a1dfdbea9d5560e4aa09d34bdbd82480c">max</a>()+expandAmount);</div>
<div class="line"></div>
<div class="line">                gpuGrid-&gt;getVoxelRange( bbox2, gpuGrid-&gt;indexArrayRange[j*2], gpuGrid-&gt;indexArrayRange[j*2+1] );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        TbbBuildVoxelGrid( <span class="keyword">const</span> gpuCacheVoxelGrid *thisGpuGrid ) : gpuGrid(thisGpuGrid) {}</div>
<div class="line">        TbbBuildVoxelGrid( <span class="keyword">const</span> TbbBuildVoxelGrid &amp;thisTbbVoxelGrid ) : gpuGrid(thisTbbVoxelGrid.gpuGrid) {}</div>
<div class="line">        ~TbbBuildVoxelGrid() {}</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> gpuCacheVoxelGrid::addTrianglesToGrid() {</div>
<div class="line">        indexArrayRange = <span class="keyword">new</span> gridPoint3&lt;int&gt;[2*numTriangles];</div>
<div class="line"></div>
<div class="line">        TbbBuildVoxelGrid tbbBVG(<span class="keyword">this</span>);</div>
<div class="line">        tbb::parallel_for(tbb::blocked_range&lt;unsigned int&gt;(0, numTriangles, 100), tbbBVG, tbb::auto_partitioner());</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numTriangles; j++) {</div>
<div class="line">            <span class="keyword">const</span> gridPoint3&lt;int&gt;&amp; minIndices = indexArrayRange[j*2];</div>
<div class="line">            <span class="keyword">const</span> gridPoint3&lt;int&gt;&amp; maxIndices = indexArrayRange[j*2+1];</div>
<div class="line"></div>
<div class="line">            <span class="comment">//  add current triangle to all these voxels</span></div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">int</span> x = minIndices[0]; x &lt;= maxIndices[0]; x++ ) { </div>
<div class="line">                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> y = minIndices[1]; y &lt;= maxIndices[1]; y++ ) { </div>
<div class="line">                    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> z = minIndices[2]; z &lt;= maxIndices[2]; z++ ) { </div>
<div class="line">                        <a name="_a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html">MUintArray</a> *indices = getVoxelContents( gridPoint3&lt;int&gt;(x,y,z) );</div>
<div class="line">                        indices-&gt;<a name="a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html#a29ccefc020c96f15e099924ebe83eb07">append</a>( j ); </div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">delete</span> [] indexArrayRange;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> gpuCacheVoxelGrid::getTris( <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;triArray,</div>
<div class="line">    <span class="keyword">const</span> gridPoint3&lt;int&gt; &amp;gridLocation)</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Description: </span></div>
<div class="line">    <span class="comment">//  Get the triangles in the specified grid location. </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html">MUintArray</a> *values = getVoxelContents( gridLocation );</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles = values-&gt;<a name="a11"></a><a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); </div>
<div class="line"></div>
<div class="line">    <span class="comment">// preallocate max possible size to avoid continual reallocs in loop below</span></div>
<div class="line">    <span class="keywordflow">if</span>(triArray.<a name="a12"></a><a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &lt; numTriangles){</div>
<div class="line">        triArray.<a name="a13"></a><a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>(numTriangles);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nAdded = 0;</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numTriangles; i++ ) { </div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = (*values)[i]; </div>
<div class="line">        triArray[nAdded] = index;</div>
<div class="line">        nAdded++;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// shrink logical size down to actual size</span></div>
<div class="line">    <span class="keywordflow">if</span>(triArray.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; nAdded){ </div>
<div class="line">        triArray.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>(nAdded);</div>
<div class="line">    }   </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> </div>
<div class="line">    gpuCacheVoxelGrid::getMemoryFootprint() </div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">// Description: </span></div>
<div class="line">    <span class="comment">//  Get the memory footprint for this derived class. This value is the size</span></div>
<div class="line">    <span class="comment">//  of this class(which is 0 i nthis case) plus the size of the base class. </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> totalClassSize = ParentClass::getMemoryFootprint();</div>
<div class="line">    <span class="keywordflow">return</span> totalClassSize;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//=============================================================================</span></div>
<div class="line"><span class="comment">//=============================================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  PART 4:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  - finally, defines the gpuCacheSpatialSubdivision class, the top-level</span></div>
<div class="line"><span class="comment">//    class for accessing the accelerated ray intersect functionality.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  - class also provides some performance tracking and reporting </span></div>
<div class="line"><span class="comment">//    statistics, so users can tell how much they are paying in terms</span></div>
<div class="line"><span class="comment">//    of time and space for the accelerated intersections</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//=============================================================================</span></div>
<div class="line"><span class="comment">//=============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>SimpleTimer</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SimpleTimer() {};</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> startTimer()</div>
<div class="line">    {</div>
<div class="line">        fStartTime = GetMilliCount();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> elapsedTime()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> GetMilliSpan();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">int</span> GetMilliCount()</div>
<div class="line">    {</div>
<div class="line">        timeb tb;</div>
<div class="line">        ftime( &amp;tb );</div>
<div class="line">        <span class="keywordtype">int</span> nCount = tb.millitm + (tb.time &amp; 0xfffff) * 1000;</div>
<div class="line">        <span class="keywordflow">return</span> nCount;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> GetMilliSpan()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> nSpan = GetMilliCount() - fStartTime;</div>
<div class="line">        <span class="keywordflow">if</span> ( nSpan &lt; 0 )</div>
<div class="line">            nSpan += 0x100000 * 1000;</div>
<div class="line">        <span class="keywordflow">return</span> nSpan;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">int</span> fStartTime;</div>
<div class="line">}; </div>
<div class="line"></div>
<div class="line"><span class="comment">//  performance counters</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//  total number of spatial subdivisions currently in existence in Maya</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">int</span> gpuCacheSpatialSubdivision::fsTotalNumActiveSpatialSubdivisions = 0;</div>
<div class="line"></div>
<div class="line"><span class="comment">//  total number of spatial subdivisions that have been created</span></div>
<div class="line"><span class="comment">//  during this Maya session</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">int</span> gpuCacheSpatialSubdivision::fsTotalNumCreatedSpatialSubdivisions = 0;</div>
<div class="line"></div>
<div class="line"><span class="comment">//  total amount of memory used for the currently existing spatial </span></div>
<div class="line"><span class="comment">//  subdivisions</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">float</span> gpuCacheSpatialSubdivision::fsTotalMemoryFootprint = 0.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">//  peak memory footprint of all active subdivisions at any time</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">float</span> gpuCacheSpatialSubdivision::fsPeakMemoryFootprint = 0.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">//  total amount of time that has been spent building spatial acceleration</span></div>
<div class="line"><span class="comment">//  structures since Maya was started.  This counter is never reset during</span></div>
<div class="line"><span class="comment">//  a Maya session.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">float</span> gpuCacheSpatialSubdivision::fsTotalBuildTime = 0.0;</div>
<div class="line"></div>
<div class="line">gridPoint3&lt;int&gt; </div>
<div class="line">    computeBoundsFromTriangleDensity( </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles, <span class="keyword">const</span> index_t* srcTriangleVertIndices, <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>&amp; bounds<span class="comment">/*bbox for the whole mesh*/</span>,</div>
<div class="line">    <span class="keywordtype">int</span> trianglesPerVoxel,</div>
<div class="line">    <span class="keyword">const</span> gridPoint3&lt;int&gt;&amp; minVoxels,</div>
<div class="line">    <span class="keyword">const</span> gridPoint3&lt;int&gt;&amp; maxVoxels</div>
<div class="line">    )</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Comes up with an estimate of the number of grid cells in </span></div>
<div class="line">    <span class="comment">//      x, y, and z necessary to subdivide the given poly in order</span></div>
<div class="line">    <span class="comment">//      that each grid cell contain roughly &quot;trianglesPerVoxel&quot; triangles.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      The number of voxel subdivisions returned will be clamped to the</span></div>
<div class="line">    <span class="comment">//      specified minVoxels and maxVoxels value.  </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Notes:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      We have found that a trianglesPerVoxel value around 10 works well,</span></div>
<div class="line">    <span class="comment">//      and that subdividing more than 100x100x100 rarely increases performance,</span></div>
<div class="line">    <span class="comment">//      as the cost of walking the voxel structure overwhelms the ray </span></div>
<div class="line">    <span class="comment">//      intersection cost.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      The algorithm analyzes average triangle bounding box sizes along</span></div>
<div class="line">    <span class="comment">//      the x, y, and z axes to decide how big to make the voxels in order</span></div>
<div class="line">    <span class="comment">//      to contain the specified number of triangles, on average.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    gridPoint3&lt;int&gt; res;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//  take the cube root of the desired number of triangles to figure</span></div>
<div class="line">    <span class="comment">//  out roughly how many to place along each axis</span></div>
<div class="line">    <span class="comment">//  </span></div>
<div class="line">    <span class="keywordtype">float</span> trianglesAlongAxis = powf( <span class="keywordtype">float</span>(trianglesPerVoxel), 0.33f );</div>
<div class="line"></div>
<div class="line">    <span class="comment">//  compute the average sizes of triangle bounding boxes along each</span></div>
<div class="line">    <span class="comment">//  dimension</span></div>
<div class="line">    <span class="comment">//  </span></div>
<div class="line">    <span class="keywordtype">float</span> totalSize[3] = { 0.0, 0.0, 0.0 };</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numTriangles; j++) {</div>
<div class="line">        index_t idx0=srcTriangleVertIndices[3*j]*3;</div>
<div class="line">        index_t idx1=srcTriangleVertIndices[3*j+1]*3;</div>
<div class="line">        index_t idx2=srcTriangleVertIndices[3*j+2]*3;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex1(srcPositions[idx0],srcPositions[idx0+1],srcPositions[idx0+2]);</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex2(srcPositions[idx1],srcPositions[idx1+1],srcPositions[idx1+2]);</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex3(srcPositions[idx2],srcPositions[idx2+1],srcPositions[idx2+2]);</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  get bounding box for triangle</span></div>
<div class="line">        <span class="comment">//  </span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> triBound;</div>
<div class="line">        triBound.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">expand</a>( vertex1 );</div>
<div class="line">        triBound.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">expand</a>( vertex2 );</div>
<div class="line">        triBound.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">expand</a>( vertex3 );</div>
<div class="line"></div>
<div class="line">        totalSize[0] += triBound.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a6cddcbf72c80144aa2e6501abb150c30">width</a>();   </div>
<div class="line">        totalSize[1] += triBound.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afa7750092d5dcf402c83fb5adba91453">height</a>();</div>
<div class="line">        totalSize[2] += triBound.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a65c72a51aba9fc4233b58751dd712e43">depth</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> boundSize[3] = {</div>
<div class="line">        (float)bounds.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a6cddcbf72c80144aa2e6501abb150c30">width</a>(),</div>
<div class="line">        (float)bounds.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afa7750092d5dcf402c83fb5adba91453">height</a>(),</div>
<div class="line">        (float)bounds.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a65c72a51aba9fc4233b58751dd712e43">depth</a>()</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">//  for each dimension...</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; 3; i++ )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//  average triangle size along that dimension...</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">float</span> avgSize = totalSize[i] / numTriangles;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  size of required number of triangles in each voxel</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">float</span> voxelSize = avgSize * trianglesAlongAxis;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  number of voxels that should result in the proper distribution</span></div>
<div class="line">        <span class="comment">//  along this dimension</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">float</span> numVoxels = boundSize[i] / voxelSize;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  clamp to provided min/max values</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">int</span> iNumVoxels;</div>
<div class="line">        <span class="keywordflow">if</span>( numVoxels &lt; minVoxels[i] )</div>
<div class="line">        {</div>
<div class="line">            iNumVoxels = minVoxels[i];</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>( numVoxels &gt; maxVoxels[i] )</div>
<div class="line">        {</div>
<div class="line">            iNumVoxels = maxVoxels[i];</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            iNumVoxels = (int)ceil(numVoxels);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        res[i] = iNumVoxels;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">gpuCacheSpatialSubdivision::gpuCacheSpatialSubdivision( </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles, </div>
<div class="line">    <span class="keyword">const</span> index_t* srcTriangleVertIndices, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions,  </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> bounds,</div>
<div class="line">    <span class="keyword">const</span> gpuCacheIsectAccelParams&amp; accelParams</div>
<div class="line">    )</div>
<div class="line">    : fAccelParams(accelParams)</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      This constructor builds an acceleration structure for the </span></div>
<div class="line">    <span class="comment">//      given gpuCache, organized by the given acceleration parameters.</span></div>
<div class="line">    <span class="comment">//      Currently, the only type of grid supported is a uniform grid.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      To avoid numerical problems, expand each triangle&#39;s bounding</span></div>
<div class="line">    <span class="comment">//      box by 1% before adding it to the grid.  This ensures that</span></div>
<div class="line">    <span class="comment">//      we won&#39;t miss intersections where the triangle lies exactly</span></div>
<div class="line">    <span class="comment">//      on a voxel boundary.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">//  timing probe</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    SimpleTimer myTimer;</div>
<div class="line">    myTimer.startTimer();</div>
<div class="line">    <span class="keywordflow">if</span>( (accelParams.fAlgorithm == gpuCacheIsectAccelParams::kUniformGrid) ||</div>
<div class="line">        (accelParams.fAlgorithm == gpuCacheIsectAccelParams::kAutoUniformGrid) )</div>
<div class="line">    {</div>
<div class="line">        gridPoint3&lt;int&gt; numSub;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  for the straight uniform grid, just use the number of subdivisions</span></div>
<div class="line">        <span class="comment">//  passed in, but for the auto uniform grid compute the number of</span></div>
<div class="line">        <span class="comment">//  subdivisions based on average triangle density</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span>( fAccelParams.fAlgorithm == gpuCacheIsectAccelParams::kAutoUniformGrid )</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">//  we use 12 triangles/voxel, as this seems to produce </span></div>
<div class="line">            <span class="comment">//  a good number of voxels from an efficiency standpoint.</span></div>
<div class="line">            <span class="comment">//  Any subdivisions past 100x100x100 are usually not helpful</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            numSub = computeBoundsFromTriangleDensity( numTriangles, srcTriangleVertIndices, srcPositions,</div>
<div class="line">                bounds, </div>
<div class="line">                12, </div>
<div class="line">                gridPoint3&lt;int&gt;(1,1,1), </div>
<div class="line">                gridPoint3&lt;int&gt;(100,100,100) );</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            numSub = gridPoint3&lt;int&gt;( fAccelParams.fDivX, </div>
<div class="line">                fAccelParams.fDivY, </div>
<div class="line">                fAccelParams.fDivZ );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  Create the voxel grid and load it with our triangle data. </span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        fVoxelGrid = <span class="keyword">new</span> gpuCacheVoxelGrid( bounds, numSub, numTriangles, srcTriangleVertIndices, srcPositions);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//  update performance counters.  We need to do this regardless of</span></div>
<div class="line">    <span class="comment">//  the verbosity setting.  The user can turn verbosity on/off, so</span></div>
<div class="line">    <span class="comment">//  we need to make sure that the stats are always correct.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    fMemoryFootprint = fVoxelGrid-&gt;getMemoryFootprint();</div>
<div class="line">    fBuildTime = (float)myTimer.elapsedTime();</div>
<div class="line">    fsTotalMemoryFootprint += fMemoryFootprint;</div>
<div class="line">    <span class="keywordflow">if</span>( fsTotalMemoryFootprint &gt; fsPeakMemoryFootprint )</div>
<div class="line">    {</div>
<div class="line">        fsPeakMemoryFootprint = fsTotalMemoryFootprint;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fsTotalBuildTime += fBuildTime;</div>
<div class="line">    fsTotalNumActiveSpatialSubdivisions++;</div>
<div class="line">    fsTotalNumCreatedSpatialSubdivisions++;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">gpuCacheSpatialSubdivision::~gpuCacheSpatialSubdivision()</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Frees the voxel grid.  The grid can also be freed at other times,</span></div>
<div class="line">    <span class="comment">//      such as when it needs to be rebuilt due to frame change,</span></div>
<div class="line">    <span class="comment">//      or a change in acceleration parameters.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    deleteVoxelGrid();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> gpuCacheSpatialSubdivision::deleteVoxelGrid()</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Frees the voxel grid.  </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>( fVoxelGrid != NULL )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//  update global stats to reflect removal of this structure</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        fsTotalNumActiveSpatialSubdivisions--;</div>
<div class="line">        fsTotalMemoryFootprint -= fMemoryFootprint; </div>
<div class="line"></div>
<div class="line">        <span class="comment">//  free the grid</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keyword">delete</span> fVoxelGrid;</div>
<div class="line">        fVoxelGrid = NULL;</div>
<div class="line">    }           </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>TbbFindClosestEdgePoint {</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> closestPoint;</div>
<div class="line">    <span class="keywordtype">double</span> minDist;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> index_t* srcTriangleVertIndices;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;triArray;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;rayPoint;</div>
<div class="line">    <span class="keyword">const</span> <a name="_a14"></a><a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;rayDirection;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> reset() {</div>
<div class="line">        closestPoint = <a name="a15"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#a00b995f41b11d33118a799cfb2bf00ac">MPoint::origin</a>;</div>
<div class="line">        minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    TbbFindClosestEdgePoint( <span class="keyword">const</span> index_t * thisSrcTriangleVertIndices, <span class="keyword">const</span> <span class="keywordtype">float</span> *thisSrcPositions, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;thisRayPoint, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;thisRayDirection, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;thisTriArray) : </div>
<div class="line">                srcTriangleVertIndices(thisSrcTriangleVertIndices), srcPositions(thisSrcPositions), rayPoint(thisRayPoint), rayDirection(thisRayDirection), triArray(thisTriArray) {</div>
<div class="line">        reset();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    TbbFindClosestEdgePoint(<span class="keyword">const</span> TbbFindClosestEdgePoint&amp; fCEP, tbb::split) : </div>
<div class="line">                srcTriangleVertIndices(fCEP.srcTriangleVertIndices), srcPositions(fCEP.srcPositions), rayPoint(fCEP.rayPoint), rayDirection(fCEP.rayDirection), triArray(fCEP.triArray) {</div>
<div class="line">        reset();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> operator()(tbb::blocked_range&lt;size_t&gt; r) {</div>
<div class="line">        <span class="keywordtype">int</span> end=r.end();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> j=r.begin(); j!=end; ++j ) {</div>
<div class="line">                <span class="keywordtype">int</span> triIndex = triArray[j];</div>
<div class="line">                index_t idx0=srcTriangleVertIndices[3*triIndex]*3;</div>
<div class="line">                index_t idx1=srcTriangleVertIndices[3*triIndex+1]*3;</div>
<div class="line">                index_t idx2=srcTriangleVertIndices[3*triIndex+2]*3;</div>
<div class="line"></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex1(srcPositions[idx0],srcPositions[idx0+1],srcPositions[idx0+2]);</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex2(srcPositions[idx1],srcPositions[idx1+1],srcPositions[idx1+2]);</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex3(srcPositions[idx2],srcPositions[idx2+1],srcPositions[idx2+2]);</div>
<div class="line"></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> clsPoint;</div>
<div class="line">                <span class="keywordtype">double</span> dist = gpuCacheIsectUtil::getEdgeSnapPointOnTriangle(rayPoint,rayDirection,vertex1,vertex2,vertex3,clsPoint);</div>
<div class="line">                <span class="keywordflow">if</span>(dist&lt;minDist){</div>
<div class="line">                    minDist = dist;</div>
<div class="line">                    closestPoint = clsPoint;</div>
<div class="line">                }   </div>
<div class="line">            }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> join( TbbFindClosestEdgePoint &amp;other ) {</div>
<div class="line">        <span class="keywordflow">if</span>(other.minDist &lt; minDist ) {</div>
<div class="line">            minDist = other.minDist;</div>
<div class="line">            closestPoint = other.closestPoint;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//  find closest point to a ray on a set of triangles</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">double</span> gpuCacheSpatialSubdivision::getEdgeSnapPoint(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles, </div>
<div class="line">                                                   <span class="keyword">const</span> index_t*   srcTriangleVertIndices, </div>
<div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions,   </div>
<div class="line">                                                   <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;    rayPoint,</div>
<div class="line">                                                   <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp;   rayDirection,</div>
<div class="line">                                                   <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a>&amp;       triArray,</div>
<div class="line">                                                   <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; closestPoint)</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">    TbbFindClosestEdgePoint fCP( srcTriangleVertIndices, srcPositions, rayPoint, rayDirection, triArray );</div>
<div class="line">    tbb::parallel_reduce(tbb::blocked_range&lt;size_t&gt;(0, triArray.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>()), fCP );</div>
<div class="line">    closestPoint = fCP.closestPoint;</div>
<div class="line">        <span class="keywordflow">return</span> fCP.minDist;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//  find closest point to a ray on the entire surface</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">double</span> gpuCacheSpatialSubdivision::getEdgeSnapPoint(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles, </div>
<div class="line">                                                   <span class="keyword">const</span> index_t*   srcTriangleVertIndices, </div>
<div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions,   </div>
<div class="line">                                                   <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;    rayPoint,</div>
<div class="line">                                                   <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp;   rayDirection,</div>
<div class="line">                                                   <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; closestPoint)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> bbox = fVoxelGrid-&gt;getBounds();</div>
<div class="line">    std::set&lt; gridPoint3&lt;int&gt; &gt; potentialVoxels;</div>
<div class="line">    gridPoint3&lt;int&gt; numVoxelsByAxis = fVoxelGrid-&gt;getNumVoxels();</div>
<div class="line">    <span class="keywordtype">int</span> numVoxels = numVoxelsByAxis[0] * numVoxelsByAxis[1] * numVoxelsByAxis[2];</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> voxSizes(bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a6cddcbf72c80144aa2e6501abb150c30">width</a>()/numVoxelsByAxis[0],bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afa7750092d5dcf402c83fb5adba91453">height</a>()/numVoxelsByAxis[1],bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a65c72a51aba9fc4233b58751dd712e43">depth</a>()/numVoxelsByAxis[2]);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> expandAmount = 0.1*voxSizes;</div>
<div class="line">    <span class="keywordtype">double</span> minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">    <span class="keywordtype">bool</span> *checkedBox = <span class="keyword">new</span> <span class="keywordtype">bool</span>[numVoxels];</div>
<div class="line">    <span class="keywordtype">double</span> *allDists = <span class="keyword">new</span> <span class="keywordtype">double</span>[numVoxels];</div>
<div class="line">    gridPoint3&lt;int&gt; closestGridPoint;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numVoxelsByAxis[0];i++) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;numVoxelsByAxis[1];j++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;numVoxelsByAxis[2];k++) {</div>
<div class="line">                gridPoint3&lt;int&gt; gridLocation = gridPoint3&lt;int&gt;(i,j,k);</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_uint_array.html">MUintArray</a> *values = fVoxelGrid-&gt;getVoxelContents( gridLocation );</div>
<div class="line">                <span class="keywordtype">int</span> linearIndex = k * (numVoxelsByAxis[0] * numVoxelsByAxis[1]) + j * numVoxelsByAxis[0] + i;</div>
<div class="line">                checkedBox[linearIndex] = <span class="keyword">false</span>;</div>
<div class="line">                <span class="keywordflow">if</span>(values-&gt;length()&gt;0){</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> c1 = bbox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afb3213b98f3a6b4bda9759511e9b79a1">min</a>() + <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(i*voxSizes[0],j*voxSizes[1],k*voxSizes[2]);</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> c2 = c1 + voxSizes;</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> voxBox(c1-expandAmount, c2+expandAmount);</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> queryPoint;</div>
<div class="line">                    allDists[linearIndex] = gpuCacheIsectUtil::getEdgeSnapPointOnBox(rayPoint,rayDirection,voxBox,queryPoint);</div>
<div class="line">                    <span class="keywordflow">if</span>(allDists[linearIndex] &lt; minDist){</div>
<div class="line">                        minDist = allDists[linearIndex];</div>
<div class="line">                        closestGridPoint = gridLocation;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> {</div>
<div class="line">                    allDists[linearIndex] = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numVoxelsByAxis[0];i++) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;numVoxelsByAxis[1];j++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;numVoxelsByAxis[2];k++) {</div>
<div class="line">                <span class="keywordtype">int</span> linearIndex = k * (numVoxelsByAxis[0] * numVoxelsByAxis[1]) + j * numVoxelsByAxis[0] + i;</div>
<div class="line">                <span class="keywordflow">if</span>(allDists[linearIndex]&lt;=minDist){</div>
<div class="line">                    potentialVoxels.insert(gridPoint3&lt;int&gt;(i,j,k));</div>
<div class="line">                    checkedBox[linearIndex]=<span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">    <span class="keywordflow">while</span>(potentialVoxels.size()&gt;0){</div>
<div class="line">        std::set&lt; gridPoint3&lt;int&gt; &gt;::iterator voxelIt = potentialVoxels.begin();</div>
<div class="line">        gridPoint3&lt;int&gt; gridLoc = *voxelIt;</div>
<div class="line">        potentialVoxels.erase(voxelIt);</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">int</span> linearIndex = gridLoc[2] * (numVoxelsByAxis[0] * numVoxelsByAxis[1]) + gridLoc[1] * numVoxelsByAxis[0] + gridLoc[0];</div>
<div class="line">        <span class="keywordflow">if</span>(allDists[linearIndex]&gt;minDist) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> triArray;</div>
<div class="line">        fVoxelGrid-&gt;getTris( triArray, gridLoc ); </div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> clsPoint;</div>
<div class="line">        <span class="keywordtype">double</span> dist = getEdgeSnapPoint(numTriangles,srcTriangleVertIndices,srcPositions,rayPoint, rayDirection,triArray,clsPoint);</div>
<div class="line">        <span class="keywordflow">if</span>(dist&lt;minDist){</div>
<div class="line">            minDist = dist;</div>
<div class="line">            closestPoint = clsPoint;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numVoxelsByAxis[0];i++){</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;numVoxelsByAxis[1];j++){</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;numVoxelsByAxis[2];k++) {</div>
<div class="line">                        <span class="keywordtype">int</span> linearIndex = k * (numVoxelsByAxis[0] * numVoxelsByAxis[1]) + j * numVoxelsByAxis[0] + i;</div>
<div class="line">                        <span class="keywordflow">if</span>(!checkedBox[linearIndex] &amp;&amp; allDists[linearIndex]&lt;=minDist){</div>
<div class="line">                            potentialVoxels.insert(gridPoint3&lt;int&gt;(i,j,k));</div>
<div class="line">                            checkedBox[linearIndex]=<span class="keyword">true</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } </div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">delete</span>[] checkedBox;</div>
<div class="line">    <span class="keyword">delete</span>[] allDists;</div>
<div class="line">    <span class="keywordflow">return</span> minDist;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>TbbFindClosestPoint {</div>
<div class="line">    <span class="keywordtype">bool</span> foundPoint;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> closestPoint;</div>
<div class="line">    <span class="keywordtype">double</span> minDist;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> index_t *srcTriangleVertIndices;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> *srcPositions;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;triArray;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;queryPoint;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> reset() {</div>
<div class="line">        foundPoint = <span class="keyword">false</span>;</div>
<div class="line">        closestPoint = <a class="code" href="#!/url=./cpp_ref/class_m_point.html#a00b995f41b11d33118a799cfb2bf00ac">MPoint::origin</a>;</div>
<div class="line">        minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    TbbFindClosestPoint( <span class="keyword">const</span> index_t * thisSrcTriangleVertIndices, <span class="keyword">const</span> <span class="keywordtype">float</span> *thisSrcPositions, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;thisTriArray, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;thisQueryPoint ) :</div>
<div class="line">        srcTriangleVertIndices(thisSrcTriangleVertIndices), srcPositions(thisSrcPositions), triArray(thisTriArray), queryPoint(thisQueryPoint) {</div>
<div class="line">        reset();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    TbbFindClosestPoint(<span class="keyword">const</span> TbbFindClosestPoint&amp; fCP, tbb::split) :</div>
<div class="line">        srcTriangleVertIndices(fCP.srcTriangleVertIndices), srcPositions(fCP.srcPositions), triArray(fCP.triArray), queryPoint(fCP.queryPoint) {</div>
<div class="line">        reset();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> operator()(tbb::blocked_range&lt;size_t&gt; r) {</div>
<div class="line">        <span class="keywordtype">int</span> end=r.end();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j=r.begin(); j!=end; ++j ) {</div>
<div class="line">            <span class="keywordtype">int</span> triIndex = triArray[j];</div>
<div class="line">            index_t idx0=srcTriangleVertIndices[3*triIndex]*3;</div>
<div class="line">            index_t idx1=srcTriangleVertIndices[3*triIndex+1]*3;</div>
<div class="line">            index_t idx2=srcTriangleVertIndices[3*triIndex+2]*3;</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex1(srcPositions[idx0],srcPositions[idx0+1],srcPositions[idx0+2]);</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex2(srcPositions[idx1],srcPositions[idx1+1],srcPositions[idx1+2]);</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex3(srcPositions[idx2],srcPositions[idx2+1],srcPositions[idx2+2]);</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> clsPoint;</div>
<div class="line">            <span class="keywordflow">if</span>(gpuCacheIsectUtil::getClosestPointOnTri(queryPoint, vertex1, vertex2, vertex3, clsPoint, minDist)){</div>
<div class="line">                closestPoint = clsPoint;</div>
<div class="line">                foundPoint = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> join( TbbFindClosestPoint &amp;other ) {</div>
<div class="line">        <span class="keywordflow">if</span>( other.foundPoint &amp;&amp; other.minDist &lt; minDist ) {</div>
<div class="line">            foundPoint = <span class="keyword">true</span>;</div>
<div class="line">            minDist = other.minDist;</div>
<div class="line">            closestPoint = other.closestPoint;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> gpuCacheSpatialSubdivision::closestPointToPoint(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles, </div>
<div class="line">                                                     <span class="keyword">const</span> index_t* srcTriangleVertIndices, </div>
<div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">float</span>*   srcPositions,   </div>
<div class="line">                                                     <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;  queryPoint,</div>
<div class="line">                                                     <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a>&amp;     triArray,</div>
<div class="line">                                                     <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; closestPoint)</div>
<div class="line">{</div>
<div class="line">    TbbFindClosestPoint fCP( srcTriangleVertIndices, srcPositions, triArray, queryPoint );</div>
<div class="line">    tbb::parallel_reduce(tbb::blocked_range&lt;size_t&gt;(0, triArray.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>()), fCP );</div>
<div class="line">    <span class="keywordflow">if</span>( fCP.foundPoint ) {</div>
<div class="line">        closestPoint = fCP.closestPoint;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> gpuCacheSpatialSubdivision::closestPointToPoint(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles, </div>
<div class="line">                                                     <span class="keyword">const</span> index_t* srcTriangleVertIndices, </div>
<div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">float</span>*   srcPositions,   </div>
<div class="line">                                                     <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;  queryPoint,</div>
<div class="line">                                                     <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp; closestPoint)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">    <span class="comment">//Find voxel you are in</span></div>
<div class="line">    std::set&lt; gridPoint3&lt;int&gt; &gt; potentialVoxels;</div>
<div class="line">    std::set&lt; gridPoint3&lt;int&gt; &gt; checkedVoxels;</div>
<div class="line">    gridPoint3&lt;int&gt; gridLocOrg;</div>
<div class="line"></div>
<div class="line">    fVoxelGrid-&gt;getClosestVoxelCoords(queryPoint,gridLocOrg);</div>
<div class="line">    potentialVoxels.insert(gridLocOrg);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> foundPoint = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">int</span> expandVox = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (!foundPoint)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">while</span>(potentialVoxels.size()&gt;0){</div>
<div class="line">            std::set&lt; gridPoint3&lt;int&gt; &gt;::iterator voxelIt = potentialVoxels.begin();</div>
<div class="line">            gridPoint3&lt;int&gt; gridLoc = *voxelIt;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> triArray;</div>
<div class="line">            fVoxelGrid-&gt;getTris( triArray, gridLoc ); </div>
<div class="line"></div>
<div class="line">            checkedVoxels.<a name="a16"></a><a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a95aaff2c93e48e4da000d79e8324c714">insert</a>(gridLoc);</div>
<div class="line">            potentialVoxels.erase(voxelIt);</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> clsPoint;</div>
<div class="line">            <span class="keywordflow">if</span>(closestPointToPoint(numTriangles,srcTriangleVertIndices,srcPositions,queryPoint,triArray,clsPoint)){</div>
<div class="line">                <span class="keywordtype">double</span> dist = queryPoint.<a name="a17"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(clsPoint);</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span>(dist&lt;minDist){</div>
<div class="line">                    minDist = dist;</div>
<div class="line">                    closestPoint = clsPoint;</div>
<div class="line">                    foundPoint = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">                    gridPoint3&lt;int&gt; gridLocMin;</div>
<div class="line">                    gridPoint3&lt;int&gt; gridLocMax;</div>
<div class="line">                    fVoxelGrid-&gt;getClosestVoxelCoords(<a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(queryPoint[0] - dist, queryPoint[1] - dist, queryPoint[2] - dist),gridLocMin);</div>
<div class="line">                    fVoxelGrid-&gt;getClosestVoxelCoords(<a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>(queryPoint[0] + dist, queryPoint[1] + dist, queryPoint[2] + dist),gridLocMax);</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=gridLocMin[0]; i&lt;=gridLocMax[0]; i++) {</div>
<div class="line">                        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=gridLocMin[1]; j&lt;=gridLocMax[1]; j++) {</div>
<div class="line">                            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=gridLocMin[2]; k&lt;=gridLocMax[2]; k++) {</div>
<div class="line">                                gridPoint3&lt;int&gt; gridLocNew = gridPoint3&lt;int&gt;(i,j,k);</div>
<div class="line">                                <span class="keywordflow">if</span>(fVoxelGrid-&gt;isValidVoxel(gridLocNew) &amp;&amp; checkedVoxels.find(gridLocNew) == checkedVoxels.end()) {</div>
<div class="line">                                    potentialVoxels.insert(gridLocNew);</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            } </div>
<div class="line">        }</div>
<div class="line">        expandVox++;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(!foundPoint){</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=-expandVox; i&lt;=expandVox; i++) {</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=-expandVox; j&lt;=expandVox; j++) {</div>
<div class="line">                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=-expandVox; k&lt;=expandVox; k++) {</div>
<div class="line">                        gridPoint3&lt;int&gt; gridLocNew = gridLocOrg + gridPoint3&lt;int&gt;(i,j,k);</div>
<div class="line">                        <span class="keywordflow">if</span>(fVoxelGrid-&gt;isValidVoxel(gridLocNew) &amp;&amp; checkedVoxels.find(gridLocNew) == checkedVoxels.end()) {</div>
<div class="line">                            potentialVoxels.insert(gridLocNew);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>TbbFindClosestIntersection {</div>
<div class="line">    <span class="keywordtype">bool</span> foundIntersection;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> closestIntersection;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> closestNormal;</div>
<div class="line">    <span class="keywordtype">double</span> minDist;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> index_t *srcTriangleVertIndices;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> *srcPositions;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;triArray;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;raySource;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;rayDirection;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> reset() {</div>
<div class="line">        foundIntersection = <span class="keyword">false</span>;</div>
<div class="line">        closestIntersection = <a class="code" href="#!/url=./cpp_ref/class_m_point.html#a00b995f41b11d33118a799cfb2bf00ac">MPoint::origin</a>;</div>
<div class="line">        closestNormal = <a name="a18"></a><a class="code" href="#!/url=./cpp_ref/class_m_vector.html#ac8f3f9f995acebcf7f4f5b388f1fdb37">MVector::zero</a>;</div>
<div class="line">        minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    TbbFindClosestIntersection( <span class="keyword">const</span> index_t * thisSrcTriangleVertIndices, <span class="keyword">const</span> <span class="keywordtype">float</span> *thisSrcPositions, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;thisTriArray, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;thisRaySource, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;thisRayDirection ) :</div>
<div class="line">        srcTriangleVertIndices(thisSrcTriangleVertIndices), srcPositions(thisSrcPositions), triArray(thisTriArray), raySource(thisRaySource), rayDirection(thisRayDirection) {</div>
<div class="line">        reset();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    TbbFindClosestIntersection(<span class="keyword">const</span> TbbFindClosestIntersection&amp; fCIS, tbb::split) :</div>
<div class="line">        srcTriangleVertIndices(fCIS.srcTriangleVertIndices), srcPositions(fCIS.srcPositions), triArray(fCIS.triArray), raySource(fCIS.raySource), rayDirection(fCIS.rayDirection) {</div>
<div class="line">        reset();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> operator()(tbb::blocked_range&lt;size_t&gt; r) {</div>
<div class="line">        <span class="keywordtype">int</span> end=r.end();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=r.begin(); i!=end; ++i ) {</div>
<div class="line">            <span class="keywordtype">int</span> triIndex = triArray[i];</div>
<div class="line">            index_t idx0=srcTriangleVertIndices[3*triIndex]*3;</div>
<div class="line">            index_t idx1=srcTriangleVertIndices[3*triIndex+1]*3;</div>
<div class="line">            index_t idx2=srcTriangleVertIndices[3*triIndex+2]*3;</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex1(srcPositions[idx0],srcPositions[idx0+1],srcPositions[idx0+2]);</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex2(srcPositions[idx1],srcPositions[idx1+1],srcPositions[idx1+2]);</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> vertex3(srcPositions[idx2],srcPositions[idx2+1],srcPositions[idx2+2]);</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> c0, c1, rhs, crossc1c2, crossc0rhs;</div>
<div class="line">            <span class="keywordtype">double</span> beta, gamm, t, M;</div>
<div class="line"></div>
<div class="line">            c0 = vertex1 - vertex2;</div>
<div class="line">            c1 = vertex1 - vertex3;</div>
<div class="line">            rhs = vertex1 - <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>(raySource);</div>
<div class="line"></div>
<div class="line">            crossc1c2 = c1 ^ rayDirection;</div>
<div class="line">            crossc0rhs = c0 ^ rhs;</div>
<div class="line">            M = c0 * crossc1c2;</div>
<div class="line">            <span class="keywordflow">if</span> (M==0) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            t = -(c1 * crossc0rhs)/M; </div>
<div class="line">            <span class="keywordflow">if</span> (t &lt; 0.0 || t &gt; minDist) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            beta = (rhs * crossc1c2)/M;  </div>
<div class="line">            <span class="keywordflow">if</span> (beta &lt; 0  || beta &gt; 1) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            gamm = (rayDirection * crossc0rhs)/M;</div>
<div class="line">            <span class="keywordflow">if</span> (gamm &lt; 0 || gamm &gt; 1 - beta) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">//Passed all tests</span></div>
<div class="line">            minDist = t;</div>
<div class="line">            closestIntersection = raySource + t * rayDirection;</div>
<div class="line">            closestNormal = (c0 ^ c1).normal();</div>
<div class="line">            foundIntersection = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> join( TbbFindClosestIntersection &amp;other ) {</div>
<div class="line">        <span class="keywordflow">if</span>( other.foundIntersection &amp;&amp; other.minDist &lt; minDist ) {</div>
<div class="line">            foundIntersection = <span class="keyword">true</span>;</div>
<div class="line">            minDist = other.minDist;</div>
<div class="line">            closestIntersection = other.closestIntersection;</div>
<div class="line">            closestNormal = other.closestNormal;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a name="_a19"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> gpuCacheSpatialSubdivision::closestIntersection( </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles, </div>
<div class="line">    <span class="keyword">const</span> index_t*  srcTriangleVertIndices, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>*    srcPositions,   </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;   origin,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp;  direction,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a>&amp; triArray,</div>
<div class="line">    <span class="keywordtype">float</span>           maxParam,</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;         closestIsect,</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp;        isectNormal</div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    TbbFindClosestIntersection fCIS( srcTriangleVertIndices, srcPositions, triArray, origin, direction );</div>
<div class="line">    tbb::parallel_reduce(tbb::blocked_range&lt;size_t&gt;(0, triArray.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>()), fCIS );</div>
<div class="line">    <span class="keywordflow">if</span>( fCIS.foundIntersection ) {</div>
<div class="line">        closestIsect = fCIS.closestIntersection;</div>
<div class="line">        isectNormal = fCIS.closestNormal;</div>
<div class="line">        <span class="keywordflow">return</span> <a name="a20"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a name="a21"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> gpuCacheSpatialSubdivision::closestIntersection( </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles, </div>
<div class="line">    <span class="keyword">const</span> index_t*  srcTriangleVertIndices, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>*    srcPositions,   </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;   origin,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp;  direction,</div>
<div class="line">    <span class="keywordtype">float</span>           maxParam,</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>&amp;         closestIsect,</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a>&amp;        isectNormal</div>
<div class="line">    )</div>
<div class="line">    <span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Purpose:    Returns the closest intersection of the given ray with the</span></div>
<div class="line">    <span class="comment">//              contents of the intersection structure (which is assumed</span></div>
<div class="line">    <span class="comment">//              to be triangles from the given ShapeNode). </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Parameters:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      numTriangles            - number of triangles for the model</span></div>
<div class="line">    <span class="comment">//      srcTriangleVertIndices  - pointer to the index buffer that has triangle indices</span></div>
<div class="line">    <span class="comment">//      srcPositions            - pointer to the vertex buffer that has vertex positions</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      origin          - origin of the ray</span></div>
<div class="line">    <span class="comment">//      direction       - direction of the ray</span></div>
<div class="line">    <span class="comment">//      maxParam        - maximum parametric distance along the ray at which</span></div>
<div class="line">    <span class="comment">//                        an intersection will be considered valid.</span></div>
<div class="line">    <span class="comment">//      closestIsect    - receives the closest valid intersection, if one is</span></div>
<div class="line">    <span class="comment">//                        found.</span></div>
<div class="line">    <span class="comment">//      isectNormal     - receives the surface normal at the closest valid intersection, </span></div>
<div class="line">    <span class="comment">//                        if one is found.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Returns:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      MStatus::kSuccess if a valid hit was found</span></div>
<div class="line">    <span class="comment">//      MStatus::kFailure otherwise.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      If a hit was found, closestIsect and isectNormal will be set to the </span></div>
<div class="line">    <span class="comment">//      position and surface normal at the intersection.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">//  walks the grid voxels</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    SpatialGridWalker it = fVoxelGrid-&gt;getRayIterator( origin, direction );</div>
<div class="line"></div>
<div class="line">    maxParam = fabs(maxParam);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span>( !it.isDone() )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//  exit if the current voxel is past the maximum distance for hits</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span>( it.curVoxelStartRayParam() &gt; maxParam )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">//  consider the current voxel&#39;s contents</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        gridPoint3&lt;int&gt; gridLoc = it.gridLocation(); </div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> triArray;</div>
<div class="line">        fVoxelGrid-&gt;getTris( triArray, gridLoc); </div>
<div class="line">        <span class="keywordflow">if</span> ( triArray.<a class="code" href="#!/url=./cpp_ref/class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0 ) { </div>
<div class="line">            <span class="comment">//  make sure we only consider hits that lie within this voxel,</span></div>
<div class="line">            <span class="comment">//  otherwise we might get an incorrect result for the closest </span></div>
<div class="line">            <span class="comment">//  hit </span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="keywordtype">float</span> voxelMaxParam = std::min( it.curVoxelEndRayParam(), maxParam );</div>
<div class="line"></div>
<div class="line">            <span class="comment">//  intersect the ray with the current voxel&#39;s triangles</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="keywordflow">if</span>( <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a> == closestIntersection( numTriangles, srcTriangleVertIndices, srcPositions, origin, direction, </div>
<div class="line">                triArray, voxelMaxParam, closestIsect, isectNormal ) )</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        it.next();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> gpuCacheSpatialSubdivision::getMemoryFootprint()</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Returns the total amount of memory used by this structure.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fMemoryFootprint;</div>
<div class="line">}   </div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> gpuCacheSpatialSubdivision::getBuildTime()</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Returns the total number of seconds used to build this structure</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fBuildTime;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a name="_a22"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> gpuCacheSpatialSubdivision::getDescription( <span class="keywordtype">bool</span> includeStats )</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Returns a string describing the structure.  The description will</span></div>
<div class="line">    <span class="comment">//      look something like:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      10x10x10 Uniform Grid</span></div>
<div class="line">    <span class="comment">//      </span></div>
<div class="line">    <span class="comment">//      or</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      10x11x23 Auto-Configured Uniform Grid</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      If includeStats is true, the memory footprint and build time (in </span></div>
<div class="line">    <span class="comment">//      seconds) will be appended to the description string.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">    gridPoint3&lt;int&gt; numVoxels = fVoxelGrid-&gt;getNumVoxels();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">char</span> buf[512];</div>
<div class="line">    <span class="keywordflow">if</span>( fAccelParams.fAlgorithm == gpuCacheIsectAccelParams::kUniformGrid )</div>
<div class="line">    {</div>
<div class="line">        sprintf( buf, <span class="stringliteral">&quot;%dx%dx%d Uniform Grid&quot;</span>, numVoxels[0], </div>
<div class="line">            numVoxels[1], </div>
<div class="line">            numVoxels[2] );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( fAccelParams.fAlgorithm == gpuCacheIsectAccelParams::kAutoUniformGrid )</div>
<div class="line">    {</div>
<div class="line">        sprintf( buf, <span class="stringliteral">&quot;%dx%dx%d Auto-Configured Uniform Grid&quot;</span>, </div>
<div class="line">            numVoxels[0], numVoxels[1], numVoxels[2] );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> resultStr( buf );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( includeStats )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">char</span> buf2[512];</div>
<div class="line">        sprintf( buf2, <span class="stringliteral">&quot;build time %.2fs&quot;</span>, fBuildTime );</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> buildTimeStr( buf2 );</div>
<div class="line"></div>
<div class="line">        sprintf( buf2, <span class="stringliteral">&quot;memory footprint %.2fKB&quot;</span>, fMemoryFootprint );</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> footprintStr( buf2 );</div>
<div class="line"></div>
<div class="line">        resultStr += <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;, (&quot;</span>) + buildTimeStr + <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;), (&quot;</span>) + </div>
<div class="line">            footprintStr + <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;)&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> resultStr;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> gpuCacheSpatialSubdivision::systemStats()</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Returns an informative string describing the total resource</span></div>
<div class="line">    <span class="comment">//      usage for all spatial subdivisions in the system.  The string</span></div>
<div class="line">    <span class="comment">//      looks something like:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      total 10 isect accelerators, total build time = 5.13s, total memory = 1510.6KB</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> buf[1024];</div>
<div class="line">    sprintf( buf, <span class="stringliteral">&quot;total %d isect accelerators created (%d currently active - &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;total current memory = %.2f KB), total build time = %f ms, &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;peak memory = %.2f KB\n&quot;</span>,</div>
<div class="line">        fsTotalNumCreatedSpatialSubdivisions, </div>
<div class="line">        fsTotalNumActiveSpatialSubdivisions, </div>
<div class="line">        fsTotalMemoryFootprint, </div>
<div class="line">        fsTotalBuildTime, </div>
<div class="line">        fsPeakMemoryFootprint );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(buf);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> gpuCacheSpatialSubdivision::resetSystemStats()</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Resets the global statistics counters for the following:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      - total number of spatial subdivisions created so far</span></div>
<div class="line">    <span class="comment">//      - peak memory usage of all spatial subdivisions</span></div>
<div class="line">    <span class="comment">//      - total build time for all spatial subdivisions</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    fsTotalNumCreatedSpatialSubdivisions = 0;</div>
<div class="line">    fsTotalBuildTime = 0.0f;</div>
<div class="line">    fsPeakMemoryFootprint = 0.0f;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span></div>
<div class="line">    gpuCacheSpatialSubdivision::matchesParams( </div>
<div class="line">    <span class="keyword">const</span> gpuCacheIsectAccelParams&amp; accelParams </div>
<div class="line">    )</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Determines whether this accelerator was built with parameters</span></div>
<div class="line">    <span class="comment">//      identical to the given ones.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>( fVoxelGrid != NULL )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (fAccelParams == accelParams) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div><br></div>
   </div></body>
</html>

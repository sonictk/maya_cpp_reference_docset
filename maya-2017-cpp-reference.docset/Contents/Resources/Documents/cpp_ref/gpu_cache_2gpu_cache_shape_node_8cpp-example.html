<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="product" content="MAYAUL"><meta name="release" content="2017"><meta name="book" content="Developer"><meta name="created" content="2016-06-16"><meta name="topicid" content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887"><meta name="topic-type" content="concept">
      <title>gpuCache/gpuCacheShapeNode.cpp</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2gpu_cache_shape_node_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>gpuCache/gpuCacheShapeNode.cpp</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">gpuCache/gpuCacheShapeNode.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheShapeNode.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheStrings.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheConfig.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheRasterSelect.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheGLPickingSelect.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheUtil.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheSubSceneOverride.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheDrawTraversal.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheGLFT.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheUtil.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/M3dView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAnimControl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDagPath.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDagNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDrawData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFileIO.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFileObject.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDagNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MMaterial.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MMatrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MSelectionList.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MSelectionMask.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHWGeometryUtilities.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnTypedAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHardwareRenderer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MViewport2Renderer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDagPathArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDGMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MEventMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MModelMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MUiMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MItDag.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnCamera.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnSingleIndexedComponent.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnPluginData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MMaterialArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MObjectArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAttributeSpec.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAttributeSpecArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAttributeIndex.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPxSurfaceShapeUI.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPointArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MVectorArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MExternalContentInfoTable.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MExternalContentLocationTable.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;climits&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;tbb/parallel_reduce.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tbb/blocked_range.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// Error checking</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define MCHECKERROR(STAT,MSG)                   \</span></div>
<div class="line"><span class="preprocessor">    if (!STAT) {                                \</span></div>
<div class="line"><span class="preprocessor">        perror(MSG);                            \</span></div>
<div class="line"><span class="preprocessor">        return MS::kFailure;                    \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define MREPORTERROR(STAT,MSG)                  \</span></div>
<div class="line"><span class="preprocessor">    if (!STAT) {                                \</span></div>
<div class="line"><span class="preprocessor">        perror(MSG);                            \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define MCHECKERRORVOID(STAT,MSG)               \</span></div>
<div class="line"><span class="preprocessor">    if (!STAT) {                                \</span></div>
<div class="line"><span class="preprocessor">        perror(MSG);                            \</span></div>
<div class="line"><span class="preprocessor">        return;                                 \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>GPUCache;</div>
<div class="line"><span class="keyword">using namespace </span>GPUCache::ShapeNodePrivate;</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// LOCAL CLASSES</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line">    <span class="comment">// CLASS DrawWireframeTraversal</span></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>DrawWireframeState : <span class="keyword">public</span> DrawTraversalState</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        DrawWireframeState(</div>
<div class="line">            <span class="keyword">const</span> Frustum&amp;  frustrum,</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>    seconds)</div>
<div class="line">            : DrawTraversalState(frustrum, seconds, kPruneNone)</div>
<div class="line">        {}</div>
<div class="line">    };</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">class </span>DrawWireframeTraversal</div>
<div class="line">        : <span class="keyword">public</span> DrawTraversal&lt;DrawWireframeTraversal, DrawWireframeState&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">        <span class="keyword">typedef</span> DrawTraversal&lt;DrawWireframeTraversal, DrawWireframeState&gt; BaseClass;</div>
<div class="line"></div>
<div class="line">        DrawWireframeTraversal(</div>
<div class="line">            DrawWireframeState&amp;     state,</div>
<div class="line">            <span class="keyword">const</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp;          xform,</div>
<div class="line">            <span class="keywordtype">bool</span>                    isReflection,</div>
<div class="line">            Frustum::ClippingResult parentClippingResult)</div>
<div class="line">            : BaseClass(state, xform, isReflection, parentClippingResult)</div>
<div class="line">        {}</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">void</span> draw(<span class="keyword">const</span> boost::shared_ptr&lt;const ShapeSample&gt;&amp; sample)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!sample-&gt;visibility()) <span class="keywordflow">return</span>;</div>
<div class="line">            gGLFT-&gt;glLoadMatrixd(xform().matrix[0]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (sample-&gt;isBoundingBoxPlaceHolder()) {</div>
<div class="line">                state().vboProxy().drawBoundingBox(sample);</div>
<div class="line">                GlobalReaderCache::theCache().hintShapeReadOrder(subNode());</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            assert(sample-&gt;positions());</div>
<div class="line">            assert(sample-&gt;normals());</div>
<div class="line"></div>
<div class="line">            state().vboProxy().drawWireframe(sample);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line">    <span class="comment">// CLASS DrawShadedTraversal</span></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>DrawShadedTypes </div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">enum</span> ColorType {</div>
<div class="line">            kSubNodeColor,</div>
<div class="line">            kDefaultColor,</div>
<div class="line">            kBlackColor,</div>
<div class="line">            kXrayColor</div>
<div class="line">        };</div>
<div class="line">    </div>
<div class="line">        <span class="keyword">enum</span> NormalsType {</div>
<div class="line">            kFrontNormals,</div>
<div class="line">            kBackNormals</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>DrawShadedState : <span class="keyword">public</span> DrawTraversalState, <span class="keyword">public</span> DrawShadedTypes</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        DrawShadedState(</div>
<div class="line">            <span class="keyword">const</span> Frustum&amp;             frustrum,</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>               seconds,</div>
<div class="line">            <span class="keyword">const</span> TransparentPruneType transparentPrune,</div>
<div class="line">            <span class="keyword">const</span> ColorType            colorType,</div>
<div class="line">            <span class="keyword">const</span> <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>&amp;              defaultDiffuseColor,</div>
<div class="line">            <span class="keyword">const</span> NormalsType          normalsType)</div>
<div class="line">            : DrawTraversalState(frustrum, seconds, transparentPrune),</div>
<div class="line">              fColorType(colorType),</div>
<div class="line">              fDefaultDiffuseColor(defaultDiffuseColor),</div>
<div class="line">              fNormalsType(normalsType)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        ColorType      colorType()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> fColorType; }</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>&amp;  defaultDiffuseColor()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fDefaultDiffuseColor; } </div>
<div class="line">        NormalsType    normalsType()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> fNormalsType; }</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keyword">const</span> ColorType      fColorType;</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>         fDefaultDiffuseColor;</div>
<div class="line">        <span class="keyword">const</span> NormalsType    fNormalsType;</div>
<div class="line">    };</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">class </span>DrawShadedTraversal</div>
<div class="line">        : <span class="keyword">public</span> DrawTraversal&lt;DrawShadedTraversal, DrawShadedState&gt;,</div>
<div class="line">          <span class="keyword">public</span> DrawShadedTypes</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">        <span class="keyword">typedef</span> DrawTraversal&lt;DrawShadedTraversal, DrawShadedState&gt; BaseClass;</div>
<div class="line"></div>
<div class="line">        DrawShadedTraversal(</div>
<div class="line">            DrawShadedState&amp;        state,</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp;          xform,</div>
<div class="line">            <span class="keywordtype">bool</span>                    isReflection,</div>
<div class="line">            Frustum::ClippingResult parentClippingResult)</div>
<div class="line">            : BaseClass(state, xform, isReflection, parentClippingResult)</div>
<div class="line">        {}</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">void</span> draw(<span class="keyword">const</span> boost::shared_ptr&lt;const ShapeSample&gt;&amp; sample)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!sample-&gt;visibility()) <span class="keywordflow">return</span>;</div>
<div class="line">            gGLFT-&gt;glLoadMatrixd(xform().matrix[0]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (sample-&gt;isBoundingBoxPlaceHolder()) {</div>
<div class="line">                state().vboProxy().drawBoundingBox(sample, <span class="keyword">true</span>);</div>
<div class="line">                GlobalReaderCache::theCache().hintShapeReadOrder(subNode());</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            assert(sample-&gt;positions());</div>
<div class="line">            assert(sample-&gt;normals());</div>
<div class="line">            </div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> diffuseColor;</div>
<div class="line">            <span class="keywordflow">switch</span> (state().colorType()) {</div>
<div class="line">                <span class="keywordflow">case</span> kSubNodeColor:</div>
<div class="line">                    diffuseColor = sample-&gt;diffuseColor();</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> kDefaultColor:</div>
<div class="line">                    diffuseColor = state().defaultDiffuseColor();</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> kBlackColor:</div>
<div class="line">                    diffuseColor =</div>
<div class="line">                        <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>(0.0f, 0.0f, 0.0f, sample-&gt;diffuseColor()[3]);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> kXrayColor:</div>
<div class="line">                    diffuseColor = <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>(sample-&gt;diffuseColor()[0],</div>
<div class="line">                                          sample-&gt;diffuseColor()[1],</div>
<div class="line">                                          sample-&gt;diffuseColor()[2],</div>
<div class="line">                                          0.3f);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">default</span>:</div>
<div class="line">                    assert(0);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (diffuseColor[3] &lt;= 0.0 ||</div>
<div class="line">                (diffuseColor[3] &gt;= 1.0 &amp;&amp;</div>
<div class="line">                    state().transparentPrune() == DrawShadedState::kPruneOpaque) ||</div>
<div class="line">                (diffuseColor[3] &lt;  1.0 &amp;&amp;</div>
<div class="line">                    state().transparentPrune() == DrawShadedState::kPruneTransparent)) {</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            gGLFT-&gt;glColor4f(diffuseColor[0]*diffuseColor[3],</div>
<div class="line">                             diffuseColor[1]*diffuseColor[3],</div>
<div class="line">                             diffuseColor[2]*diffuseColor[3],</div>
<div class="line">                             diffuseColor[3]);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The meaning of front faces changes depending whether</span></div>
<div class="line">            <span class="comment">// the transformation has a reflection or not.</span></div>
<div class="line">            gGLFT-&gt;glFrontFace(isReflection() ? MGL_CW : MGL_CCW);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> groupId = 0; groupId &lt; sample-&gt;numIndexGroups(); ++groupId ) {</div>
<div class="line">                state().vboProxy().drawTriangles(</div>
<div class="line">                    sample, groupId,</div>
<div class="line">                    state().normalsType() == kFrontNormals ?</div>
<div class="line">                    VBOProxy::kFrontNormals : VBOProxy::kBackNormals,</div>
<div class="line">                    VBOProxy::kNoUVs);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line">    <span class="comment">// CLASS ReadBufferVisitor</span></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>ReadBufferVisitor : <span class="keyword">public</span> SubNodeVisitor</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        ReadBufferVisitor(<span class="keywordtype">double</span> seconds, BufferCache* buffer, <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> xformMatrix) </div>
<div class="line">            : fSeconds(seconds), fMyBufferCache(buffer), fthisXForm(xformMatrix) {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp;   xform,</div>
<div class="line">            <span class="keyword">const</span> SubNode&amp;     subNode)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> boost::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>
<div class="line">                xform.getSample(fSeconds);</div>
<div class="line">            </div>
<div class="line">            ReadBufferVisitor newVisitor(fSeconds, fMyBufferCache, sample-&gt;xform() * fthisXForm);</div>
<div class="line">            <span class="comment">// Recurse into children sub nodes. Expand all instances.</span></div>
<div class="line">            BOOST_FOREACH(<span class="keyword">const</span> SubNode::Ptr&amp; child,</div>
<div class="line">                subNode.getChildren() ) {</div>
<div class="line">                    child-&gt;accept(newVisitor);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> ShapeData&amp;   shape,</div>
<div class="line">            <span class="keyword">const</span> SubNode&amp;     subNode)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> boost::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">                shape.getSample(fSeconds);</div>
<div class="line">            <span class="keywordflow">if</span> (!sample) <span class="keywordflow">return</span>;</div>
<div class="line">            </div>
<div class="line">            fMyBufferCache-&gt;fNumTriangles.push_back(sample-&gt;numTriangles());</div>
<div class="line">            fMyBufferCache-&gt;fNumEdges.push_back(sample-&gt;numWires());</div>
<div class="line">            fMyBufferCache-&gt;fTotalNumVerts+=sample-&gt;numVerts();</div>
<div class="line">            fMyBufferCache-&gt;fTotalNumTris+=sample-&gt;numTriangles();</div>
<div class="line">            VertexBuffer::ReadInterfacePtr vertexPositionRead= sample-&gt;positions()-&gt;readableInterface();</div>
<div class="line">            <span class="keywordflow">if</span> (sample-&gt;triangleVertIndices(0) &amp;&amp; sample-&gt;wireVertIndices()) {</div>
<div class="line">                    fMyBufferCache-&gt;fPositions.push_back(vertexPositionRead);</div>
<div class="line">                    IndexBuffer::ReadInterfacePtr triangleIndexRead = sample-&gt;triangleVertIndices(0)-&gt;readableInterface();</div>
<div class="line">                    IndexBuffer::ReadInterfacePtr edgeIndexRead = sample-&gt;wireVertIndices()-&gt;readableInterface();</div>
<div class="line">                    fMyBufferCache-&gt;fTriangleVertIndices.push_back(triangleIndexRead);</div>
<div class="line">                    fMyBufferCache-&gt;fEdgeVertIndices.push_back(edgeIndexRead);</div>
<div class="line">                    fMyBufferCache-&gt;fBoundingBoxes.push_back(sample-&gt;boundingBox());</div>
<div class="line">                    fMyBufferCache-&gt;fXFormMatrix.push_back(fthisXForm);</div>
<div class="line">                    fMyBufferCache-&gt;fXFormMatrixInverse.push_back(fthisXForm.inverse());</div>
<div class="line">                    fMyBufferCache-&gt;fUseCachedBuffers = <span class="keyword">true</span>;</div>
<div class="line">                    fMyBufferCache-&gt;fNumShapes ++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        BufferCache* fMyBufferCache;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> fthisXForm;</div>
<div class="line">        <span class="keywordtype">double</span> fSeconds;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line">    <span class="comment">// CLASS NbPrimitivesVisitor</span></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>NbPrimitivesVisitor : <span class="keyword">public</span> SubNodeVisitor</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">        NbPrimitivesVisitor(<span class="keywordtype">double</span> seconds) </div>
<div class="line">            : fSeconds(seconds),</div>
<div class="line">              fNumWires(0),</div>
<div class="line">              fNumTriangles(0)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">size_t</span> numWires()       { <span class="keywordflow">return</span> fNumWires; }</div>
<div class="line">        <span class="keywordtype">size_t</span> numTriangles()   { <span class="keywordflow">return</span> fNumTriangles; }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp;   xform,</div>
<div class="line">                           <span class="keyword">const</span> SubNode&amp;     subNode)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Recurse into children sub nodes. Expand all instances.</span></div>
<div class="line">            BOOST_FOREACH(<span class="keyword">const</span> SubNode::Ptr&amp; child,</div>
<div class="line">                          subNode.getChildren() ) {</div>
<div class="line">                child-&gt;accept(*<span class="keyword">this</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> ShapeData&amp;   shape,</div>
<div class="line">                           <span class="keyword">const</span> SubNode&amp;     subNode)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> boost::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">                shape.getSample(fSeconds);</div>
<div class="line">            <span class="keywordflow">if</span> (!sample) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">            fNumWires       += sample-&gt;numWires();</div>
<div class="line">            fNumTriangles   += sample-&gt;numTriangles();</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">    </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>    fSeconds;</div>
<div class="line">        <span class="keywordtype">size_t</span>          fNumWires;</div>
<div class="line">        <span class="keywordtype">size_t</span>          fNumTriangles;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line">    <span class="comment">// CLASS SnapTraversal</span></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>SnapTraversalState : <span class="keyword">public</span> DrawTraversalState </div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">        SnapTraversalState(<span class="keyword">const</span> Frustum&amp;  frustrum,</div>
<div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span>    seconds,</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp;  localToPort,</div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp;  inclusiveMatrix,</div>
<div class="line">                           <a name="_a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_select_info.html">MSelectInfo</a>&amp;    snapInfo)</div>
<div class="line">            : DrawTraversalState(frustrum, seconds, kPruneNone),</div>
<div class="line">              fLocalToPort(localToPort),</div>
<div class="line">              fInclusiveMatrix(inclusiveMatrix),</div>
<div class="line">              fSnapInfo(snapInfo),</div>
<div class="line">              fSelected(<span class="keyword">false</span>)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp; localToPort()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> fLocalToPort; }</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp; inclusiveMatrix()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> fInclusiveMatrix; }</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_select_info.html">MSelectInfo</a>&amp; snapInfo()                 { <span class="keywordflow">return</span> fSnapInfo; }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">bool</span> selected()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fSelected; }</div>
<div class="line">        <span class="keywordtype">void</span> setSelected()    { fSelected  = <span class="keyword">true</span>; }</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>   fLocalToPort;</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>   fInclusiveMatrix;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_select_info.html">MSelectInfo</a>&amp;    fSnapInfo;</div>
<div class="line">        <span class="keywordtype">bool</span>            fSelected;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>SnapTraversal</div>
<div class="line">        : <span class="keyword">public</span> DrawTraversal&lt;SnapTraversal, SnapTraversalState&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">        <span class="keyword">typedef</span> DrawTraversal&lt;SnapTraversal, SnapTraversalState&gt; BaseClass;</div>
<div class="line"></div>
<div class="line">        SnapTraversal(</div>
<div class="line">            SnapTraversalState&amp;     state,</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a>&amp;          xform,</div>
<div class="line">            <span class="keywordtype">bool</span>                    isReflection,</div>
<div class="line">            Frustum::ClippingResult parentClippingResult)</div>
<div class="line">            : BaseClass(state, xform, <span class="keyword">false</span>, parentClippingResult)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> draw(<span class="keyword">const</span> boost::shared_ptr&lt;const ShapeSample&gt;&amp; sample)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!sample-&gt;visibility()) <span class="keywordflow">return</span>;</div>
<div class="line">            <span class="keywordflow">if</span> (sample-&gt;isBoundingBoxPlaceHolder()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">            assert(sample-&gt;positions());</div>
<div class="line">            VertexBuffer::ReadInterfacePtr readable = sample-&gt;positions()-&gt;readableInterface();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> positions = readable-&gt;get();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srx, sry, srw, srh;</div>
<div class="line">            state().snapInfo().selectRect(srx, sry, srw, srh);</div>
<div class="line">            <span class="keywordtype">double</span> srxl = srx;</div>
<div class="line">            <span class="keywordtype">double</span> sryl = sry;</div>
<div class="line">            <span class="keywordtype">double</span> srxh = srx + srw;</div>
<div class="line">            <span class="keywordtype">double</span> sryh = sry + srh;</div>
<div class="line"></div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> localToPort     = xform() * state().localToPort();</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> inclusiveMatrix = xform() * state().inclusiveMatrix();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Loop through all vertices of the mesh.</span></div>
<div class="line">            <span class="comment">// See if they lie withing the view frustum,</span></div>
<div class="line">            <span class="comment">// then send them to snapping check.</span></div>
<div class="line">            <span class="keywordtype">size_t</span> numVertices = sample-&gt;numVerts();</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> vertexIndex=0; vertexIndex&lt;numVertices; vertexIndex++)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> currentPoint = &amp;positions[vertexIndex*3];</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Find the closest snapping point using the CPU. This is</span></div>
<div class="line">                <span class="comment">// faster than trying to use OpenGL picking.</span></div>
<div class="line">                <a name="_a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> loPt(currentPoint[0], currentPoint[1], currentPoint[2]);</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> pt = loPt * localToPort;</div>
<div class="line">                pt.<a name="a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#ae280f5c6985389ac043ced0834c737aa">rationalize</a>();</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (pt.<a name="a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> &gt;= srxl &amp;&amp; pt.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> &lt;= srxh &amp;&amp;</div>
<div class="line">                    pt.<a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a> &gt;= sryl &amp;&amp; pt.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a> &lt;= sryh &amp;&amp;</div>
<div class="line">                    pt.<a name="a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a> &gt;= 0.0  &amp;&amp; pt.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a> &lt;= 1.0) {</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> wsPt = loPt * inclusiveMatrix;</div>
<div class="line">                    wsPt.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#ae280f5c6985389ac043ced0834c737aa">rationalize</a>();</div>
<div class="line">                    state().snapInfo().setSnapPoint(wsPt);</div>
<div class="line">                    state().setSelected();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line">    <span class="comment">// CLASS WaitCursor</span></div>
<div class="line">    <span class="comment">//==========================================================================</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>WaitCursor</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        WaitCursor()</div>
<div class="line">        {</div>
<div class="line">            <a name="a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#a09e405631e7cf680f8ac9d934ad73434">MGlobal::executeCommand</a>(<span class="stringliteral">&quot;waitCursor -state 1&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        ~WaitCursor()</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_global.html#a09e405631e7cf680f8ac9d934ad73434">MGlobal::executeCommand</a>(<span class="stringliteral">&quot;waitCursor -state 0&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="comment">// Forbidden and not implemented.</span></div>
<div class="line">        WaitCursor(<span class="keyword">const</span> WaitCursor&amp;);</div>
<div class="line">        <span class="keyword">const</span> WaitCursor&amp; operator=(<span class="keyword">const</span> WaitCursor&amp;);</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ShapeNode</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a name="_a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_type_id.html">MTypeId</a> ShapeNode::id(0x580000C4);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a name="_a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> ShapeNode::drawDbClassificationGeometry(</div>
<div class="line">    <span class="stringliteral">&quot;drawdb/geometry/gpuCache&quot;</span> );</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> ShapeNode::drawDbClassificationSubScene(</div>
<div class="line">    <span class="stringliteral">&quot;drawdb/subscene/gpuCache&quot;</span> );</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> ShapeNode::drawRegistrantId(<span class="stringliteral">&quot;gpuCache&quot;</span> );</div>
<div class="line"></div>
<div class="line"><a name="_a11"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> ShapeNode::aCacheFileName;</div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> ShapeNode::aCacheGeomPath;</div>
<div class="line">MCallbackId ShapeNode::fsModelEditorChangedCallbackId;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* ShapeNode::nodeTypeName = <span class="stringliteral">&quot;gpuCache&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* ShapeNode::selectionMaskName = <span class="stringliteral">&quot;gpuCache&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> std::vector&lt;MCallbackId&gt; s3dViewPostRenderCallbackIds;</div>
<div class="line"><span class="keyword">static</span> std::vector&lt;MCallbackId&gt; s3dViewDeletedCallbackIds;</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> sNb3dViewPostRenderCallbacks = 0;</div>
<div class="line"></div>
<div class="line"><span class="keyword">enum</span> ModelEditorState {</div>
<div class="line">    kDefaultViewportOnly,</div>
<div class="line">    kViewport2Only,</div>
<div class="line">    kDefaultViewportAndViewport2</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> ModelEditorState sModelEditorState = kDefaultViewportAndViewport2;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> viewPostRender(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str, <span class="keywordtype">void</span>* <span class="comment">/*clientData*/</span>)</div>
<div class="line">{</div>
<div class="line">    VBOBuffer::nextRefresh();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> clearPostRenderCallbacks()</div>
<div class="line">{</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;MCallbackId&gt;::iterator it  = s3dViewPostRenderCallbackIds.begin();</div>
<div class="line">        std::vector&lt;MCallbackId&gt;::iterator end = s3dViewPostRenderCallbackIds.end();</div>
<div class="line">        <span class="keywordflow">for</span> (; it != end; ++it) {</div>
<div class="line">            <a name="a12"></a><a class="code" href="#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(*it);</div>
<div class="line">        }</div>
<div class="line">        s3dViewPostRenderCallbackIds.clear();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;MCallbackId&gt;::iterator it  = s3dViewDeletedCallbackIds.begin();</div>
<div class="line">        std::vector&lt;MCallbackId&gt;::iterator end = s3dViewDeletedCallbackIds.end();</div>
<div class="line">        <span class="keywordflow">for</span> (; it != end; ++it) {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(*it);</div>
<div class="line">        }</div>
<div class="line">        s3dViewDeletedCallbackIds.clear();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    sNb3dViewPostRenderCallbacks = 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> uiDeleted(<span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line">    MUintPtrSz idx = <span class="keyword">reinterpret_cast&lt;</span>MUintPtrSz<span class="keyword">&gt;</span>(clientData);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(s3dViewPostRenderCallbackIds[idx]);</div>
<div class="line">    s3dViewPostRenderCallbackIds[idx] = MCallbackId();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(s3dViewDeletedCallbackIds[idx]);</div>
<div class="line">    s3dViewDeletedCallbackIds[idx] = MCallbackId();</div>
<div class="line"></div>
<div class="line">    --sNb3dViewPostRenderCallbacks;</div>
<div class="line">    assert(sNb3dViewPostRenderCallbacks &gt;= 0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> modelEditorChanged(<span class="keywordtype">void</span>* <span class="comment">/*clientData*/</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// When using the MPxSubSceneOverride, we have to free-up</span></div>
<div class="line">    <span class="comment">// the VBO used by a given renderer (default vs VP2.0) when it</span></div>
<div class="line">    <span class="comment">// is no longer in use!</span></div>
<div class="line">        </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> sVBOsClean             = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> sViewport2BuffersClean = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Loop through all the viewports to see if we have any</span></div>
<div class="line">    <span class="comment">// visible Viewport 1.0 or Viewport 2.0</span></div>
<div class="line">    <span class="keywordtype">bool</span> hasDefaultViewport = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> hasViewport2       = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> viewCount = <a name="a13"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#aae1d25978458eb7a6fec41d225eef647">M3dView::numberOf3dViews</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; viewCount; i++) {</div>
<div class="line">        <a name="_a14"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html">M3dView</a> view;</div>
<div class="line">        <a name="a15"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a9088fa9563a0ec6ed13602842d48ec8b">M3dView::get3dView</a>(i, view);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// the i-th viewport&#39;s renderer and visibility</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a5e6d2851c6b3057c33a11e60bfe978ee">M3dView::RendererName</a> renderer = view.<a name="a16"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a46db0090fc0e43745e878ef6d9b1e10c">getRendererName</a>(NULL);</div>
<div class="line">        <span class="keywordtype">bool</span> visible                   = view.<a name="a17"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a0e7d7f44dbe48bcfdb5b0c2500c1d051">isVisible</a>();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (visible &amp;&amp; (renderer == <a name="a18"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a5e6d2851c6b3057c33a11e60bfe978eea88c0a6407333d57f297deb81af90d840">M3dView::kDefaultQualityRenderer</a></div>
<div class="line">                || renderer == <a name="a19"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a5e6d2851c6b3057c33a11e60bfe978eeadfb72fb013d7989151dc1fa639ccd2c5">M3dView::kHighQualityRenderer</a></div>
<div class="line">                || renderer == <a name="a20"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a5e6d2851c6b3057c33a11e60bfe978eea6be94813861de0c2a7147ccd0c5e2f2f">M3dView::kExternalRenderer</a>)) {</div>
<div class="line">            hasDefaultViewport = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (visible &amp;&amp; renderer == <a name="a21"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a5e6d2851c6b3057c33a11e60bfe978eeade31a8b95b1b45f79cbc0533fbbfe39d">M3dView::kViewport2Renderer</a>) {</div>
<div class="line">            hasViewport2 = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if we have Default/High Quality viewports, we may want to clean VBOs</span></div>
<div class="line">    <span class="keywordflow">if</span> (hasDefaultViewport) {</div>
<div class="line">        sVBOsClean = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if we have Viewport 2.0, we may want to clean VP2 buffers</span></div>
<div class="line">    <span class="keywordflow">if</span> (hasViewport2) {</div>
<div class="line">        sViewport2BuffersClean = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// free VBOs if we have no Default/High Quality viewports</span></div>
<div class="line">    <span class="keywordflow">if</span> (!hasDefaultViewport &amp;&amp; !sVBOsClean) {</div>
<div class="line">        VBOBuffer::clear();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// we have cleaned all VBOs</span></div>
<div class="line">        sVBOsClean = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// free Viewport 2.0 buffers if we have no Viewport 2.0</span></div>
<div class="line">    <span class="keywordflow">if</span> (!hasViewport2 &amp;&amp; !sViewport2BuffersClean)  {</div>
<div class="line">        SubSceneOverride::clear();</div>
<div class="line">        sViewport2BuffersClean = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the current model editor state.</span></div>
<div class="line">    <span class="keywordflow">if</span> (hasDefaultViewport &amp;&amp; hasViewport2) {</div>
<div class="line">        sModelEditorState = kDefaultViewportAndViewport2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hasDefaultViewport) {</div>
<div class="line">        sModelEditorState = kDefaultViewportOnly;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hasViewport2) {</div>
<div class="line">        sModelEditorState = kViewport2Only;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        sModelEditorState = kDefaultViewportAndViewport2;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> nodeAddedToModel(<a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node, <span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line">    <a name="_a22"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dag_node.html">MFnDagNode</a> dagNode(node);</div>
<div class="line">    ShapeNode* shapeNode = (ShapeNode*)dagNode.userNode();</div>
<div class="line">    assert(shapeNode);</div>
<div class="line">    <span class="keywordflow">if</span> (!shapeNode) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    shapeNode-&gt;addedToModelCB();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> nodeRemovedFromModel(<a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node, <span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_fn_dag_node.html">MFnDagNode</a> dagNode(node);</div>
<div class="line">    ShapeNode* shapeNode = (ShapeNode*)dagNode.userNode();</div>
<div class="line">    assert(shapeNode);</div>
<div class="line">    <span class="keywordflow">if</span> (!shapeNode) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    shapeNode-&gt;removedFromModelCB();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> TimeChangeCallback(<a name="_a23"></a><a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time, <span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line">    assert(clientData);</div>
<div class="line">    <span class="keyword">reinterpret_cast&lt;</span>ShapeNode*<span class="keyword">&gt;</span>(clientData)-&gt;timeChangeCB(time.<a name="a24"></a><a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a name="a25"></a><a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span>* ShapeNode::creator()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ShapeNode;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a name="_a26"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> ShapeNode::initialize()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line">    <a name="_a27"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_typed_attribute.html">MFnTypedAttribute</a> typedAttrFn;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// file name</span></div>
<div class="line">    aCacheFileName = typedAttrFn.<a name="a28"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">&quot;cacheFileName&quot;</span>, <span class="stringliteral">&quot;cfn&quot;</span>,</div>
<div class="line">        <a name="a29"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7afab53ea4a643325262b9c140af093279">MFnData::kString</a>, <a name="a30"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">MObject::kNullObj</a>, &amp;stat);</div>
<div class="line">    typedAttrFn.<a name="a31"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#ae27cf2fd28a3c69b880b1096ea9e0103">setInternal</a>(<span class="keyword">true</span>);</div>
<div class="line">    typedAttrFn.<a name="a32"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#ab8fc03c313bed1f43387ad04e31bc87d">setUsedAsFilename</a>(<span class="keyword">true</span>);</div>
<div class="line">    stat = <a name="a33"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a837094252166c0b365fafb53e4a0203b">MPxNode::addAttribute</a>(aCacheFileName);</div>
<div class="line">    MCHECKERROR(stat, <span class="stringliteral">&quot;MPxNode::addAttribute(aCacheFileName)&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// geometry path used to find the geometry within the cache file</span></div>
<div class="line">    aCacheGeomPath = typedAttrFn.<a class="code" href="#!/url=./cpp_ref/class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">&quot;cacheGeomPath&quot;</span>, <span class="stringliteral">&quot;cmp&quot;</span>,</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7afab53ea4a643325262b9c140af093279">MFnData::kString</a>, <a class="code" href="#!/url=./cpp_ref/class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">MObject::kNullObj</a>, &amp;stat);</div>
<div class="line">    typedAttrFn.<a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#ae27cf2fd28a3c69b880b1096ea9e0103">setInternal</a>(<span class="keyword">true</span>);</div>
<div class="line">    stat = <a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a837094252166c0b365fafb53e4a0203b">MPxNode::addAttribute</a>(aCacheGeomPath);</div>
<div class="line">    MCHECKERROR(stat, <span class="stringliteral">&quot;MPxNode::addAttribute(aCacheFileName)&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (Config::vp2OverrideAPI() != Config::kMPxDrawOverride) {</div>
<div class="line">        fsModelEditorChangedCallbackId = <a name="a34"></a><a class="code" href="#!/url=./cpp_ref/class_m_event_message.html#a46fecb94aa00cc048f3cc0b80430f816">MEventMessage::addEventCallback</a>(</div>
<div class="line">            <span class="stringliteral">&quot;modelEditorChanged&quot;</span>, modelEditorChanged, NULL, &amp;stat);</div>
<div class="line">        MCHECKERROR(stat, <span class="stringliteral">&quot;MEventMessage::addEventCallback(modelEditorChanged)&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the correct initial state for the type of viewport that we have.</span></div>
<div class="line">    modelEditorChanged(NULL);</div>
<div class="line"></div>
<div class="line">    stat = DisplayPref::initCallback();</div>
<div class="line">    MCHECKERROR(stat, <span class="stringliteral">&quot;DisplayPref::initCallbacks()&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> stat;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> ShapeNode::uninitialize()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (Config::vp2OverrideAPI() != Config::kMPxDrawOverride) {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MEventMessage::removeCallback</a>(fsModelEditorChangedCallbackId);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    DisplayPref::removeCallback();</div>
<div class="line"></div>
<div class="line">    clearPostRenderCallbacks();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The CacheFileRegistry and GlobalReaderCache both contain static maps. The</span></div>
<div class="line">    <span class="comment">// CacheFileRegistry contains references to the GlobalReaderCache (via CacheReaderProxy)</span></div>
<div class="line">    <span class="comment">// We cannot rely on the order of static destruction. Ensure that the CacheFileRegistry</span></div>
<div class="line">    <span class="comment">// is cleared before we unload the plug-in.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// While the CacheFileRegistry should ideally already be emptied at this point,</span></div>
<div class="line">    <span class="comment">// (hence the assert) this provides an added guarantee.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    assert( CacheFileRegistry::theCache().size() == 0 );</div>
<div class="line">    CacheFileRegistry::theCache().clear();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <a name="a35"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> ShapeNode::init3dViewPostRenderCallbacks()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> exitStatus;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#aae1d25978458eb7a6fec41d225eef647">M3dView::numberOf3dViews</a>()) != sNb3dViewPostRenderCallbacks) {</div>
<div class="line">        clearPostRenderCallbacks();</div>
<div class="line"></div>
<div class="line">        <span class="keyword">static</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> listEditorPanelsCmd = <span class="stringliteral">&quot;gpuCacheListModelEditorPanels&quot;</span>;</div>
<div class="line">        <a name="_a36"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> editorPanels;</div>
<div class="line">        exitStatus = <a class="code" href="#!/url=./cpp_ref/class_m_global.html#a09e405631e7cf680f8ac9d934ad73434">MGlobal::executeCommand</a>(listEditorPanelsCmd, editorPanels);</div>
<div class="line">        MCHECKERROR(exitStatus, <span class="stringliteral">&quot;gpuCacheListModelEditorPanels&quot;</span>);</div>
<div class="line">    </div>
<div class="line">        <span class="keywordflow">if</span> (exitStatus == <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) {</div>
<div class="line">            sNb3dViewPostRenderCallbacks = editorPanels.<a name="a37"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;sNb3dViewPostRenderCallbacks; ++i) {</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">                MCallbackId callbackId = <a name="a38"></a><a class="code" href="#!/url=./cpp_ref/class_m_ui_message.html#af33879a7a29a0853f35ede9de091beb1">MUiMessage::add3dViewPostRenderMsgCallback</a>(</div>
<div class="line">                    editorPanels[i], viewPostRender, NULL, &amp;status);</div>
<div class="line">                MREPORTERROR(status, <span class="stringliteral">&quot;MUiMessage::add3dViewPostRenderMsgCallback()&quot;</span>);</div>
<div class="line">                <span class="keywordflow">if</span> (status != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) {</div>
<div class="line">                    s3dViewDeletedCallbackIds.push_back(MCallbackId());</div>
<div class="line">                    s3dViewPostRenderCallbackIds.push_back(MCallbackId());</div>
<div class="line">                    exitStatus = <a name="a39"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">                s3dViewPostRenderCallbackIds.push_back(callbackId);</div>
<div class="line"></div>
<div class="line">                callbackId = <a name="a40"></a><a class="code" href="#!/url=./cpp_ref/class_m_ui_message.html#ac524dcc11f54d3633fe575c7a11a37b9">MUiMessage::addUiDeletedCallback</a>(</div>
<div class="line">                    editorPanels[i], uiDeleted, reinterpret_cast&lt;void*&gt;(MUintPtrSz(i)), &amp;status);</div>
<div class="line">                MREPORTERROR(status, <span class="stringliteral">&quot;MUiMessage::addUiDeletedCallback()&quot;</span>);</div>
<div class="line">                <span class="keywordflow">if</span> (status != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) {</div>
<div class="line">                    s3dViewDeletedCallbackIds.push_back(MCallbackId());</div>
<div class="line">                    exitStatus = <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">                s3dViewDeletedCallbackIds.push_back(callbackId);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            assert(<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#aae1d25978458eb7a6fec41d225eef647">M3dView::numberOf3dViews</a>() == s3dViewPostRenderCallbackIds.size());</div>
<div class="line">            assert(<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#aae1d25978458eb7a6fec41d225eef647">M3dView::numberOf3dViews</a>() == s3dViewDeletedCallbackIds.size());</div>
<div class="line">            assert(<span class="keywordtype">int</span>(<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#aae1d25978458eb7a6fec41d225eef647">M3dView::numberOf3dViews</a>()) == sNb3dViewPostRenderCallbacks);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> exitStatus;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ShapeNode::ShapeNode()</div>
<div class="line">:   fCachedGeometry()</div>
<div class="line">,   fCacheReadingState(kCacheReadingDone)</div>
<div class="line">,   fTimeChangeCallbackId(0)</div>
<div class="line">{</div>
<div class="line">    fBufferCache = NULL;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ShapeNode::~ShapeNode()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">while</span>(!fSpatialSub.empty()){</div>
<div class="line">        <span class="keyword">delete</span> fSpatialSub.back();</div>
<div class="line">        fSpatialSub.pop_back();</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">delete</span> fBufferCache;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::postConstructor()</div>
<div class="line">{</div>
<div class="line">    setRenderable(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Explicitly initialize config when the first gpuCache node is created.</span></div>
<div class="line">    <span class="comment">//   When initializing Config, it will access video adapters via WMI </span></div>
<div class="line">    <span class="comment">//   and Windows will sometimes send OnPaint message to Maya and thus cause a refresh.</span></div>
<div class="line">    <span class="comment">//   The wired OnPaint message will crash VP2 and gpuCache.</span></div>
<div class="line">    Config::initialize();</div>
<div class="line"></div>
<div class="line">    <a name="a41"></a><a class="code" href="#!/url=./cpp_ref/class_m_model_message.html#a415a96325022b20c9b010d1547d991ee">MModelMessage::addNodeAddedToModelCallback</a>(thisMObject(), nodeAddedToModel);</div>
<div class="line">    <a name="a42"></a><a class="code" href="#!/url=./cpp_ref/class_m_model_message.html#a6e67073bed26d90f2d33eba01fe49aff">MModelMessage::addNodeRemovedFromModelCallback</a>(thisMObject(), nodeRemovedFromModel);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::isBounded()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ShapeNode::getIntersectionAccelerator(</div>
<div class="line">    <span class="keyword">const</span>       gpuCacheIsectAccelParams&amp; accelParams,</div>
<div class="line">                <span class="keywordtype">double</span>      seconds</div>
<div class="line">) <span class="keyword">const</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  Description:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      Creates a gpuCacheSpatialSubdivision intersection acceleration structure</span></div>
<div class="line">    <span class="comment">//      for this ShapeNode.  If cacheForReuse is true, then the structure will</span></div>
<div class="line">    <span class="comment">//      be stored, and subsequent requests for an identically-configured</span></div>
<div class="line">    <span class="comment">//      accelerator will return the cached one.  If cacheForReuse is false,</span></div>
<div class="line">    <span class="comment">//      then the method simply returns an accelerator that the client is</span></div>
<div class="line">    <span class="comment">//      responsible for deleting when they are done with it.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//      The supplied gpucacheIsectAccelParams object defines the configuration</span></div>
<div class="line">    <span class="comment">//      of the accelerator (subdivision algorithm, number of voxels).  These</span></div>
<div class="line">    <span class="comment">//      objects can be obtained from the static &quot;create*&quot; methods on </span></div>
<div class="line">    <span class="comment">//      gpuCacheIsectAccelParams.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!fCacheFileEntry || fCacheFileEntry-&gt;fReadState != CacheFileEntry::kReadingDone) {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( fBufferCache !=NULL &amp;&amp; (fBufferCache-&gt;fUseCachedBuffers &amp;&amp; fBufferCache-&gt;fBufferReadTime==seconds) &amp;&amp; (!fSpatialSub.empty()) &amp;&amp; (fSpatialSub[0]-&gt;matchesParams(accelParams)) )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fSpatialSub.size();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">while</span>(!fSpatialSub.empty()){</div>
<div class="line">            <span class="keyword">delete</span> fSpatialSub.back(); fSpatialSub.pop_back();</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">const</span> SubNode::Ptr subNode = getCachedGeometry();</div>
<div class="line">        <span class="keywordflow">if</span>(readBuffers(subNode,seconds)){</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s &lt; fBufferCache-&gt;fNumShapes; s++){</div>
<div class="line">                <span class="keyword">const</span> index_t* srcTriangleVertIndices = fBufferCache-&gt;fTriangleVertIndices[s]-&gt;get();</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions = fBufferCache-&gt;fPositions[s]-&gt;get();</div>
<div class="line">                fSpatialSub.push_back (<span class="keyword">new</span> gpuCacheSpatialSubdivision(fBufferCache-&gt;fNumTriangles[s], srcTriangleVertIndices, srcPositions, fBufferCache-&gt;fBoundingBoxes[s], accelParams));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> fSpatialSub.size();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::getEdgeSnapPoint(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;rayPointSrc, <span class="keyword">const</span> <a name="_a43"></a><a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;rayDirectionSrc, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;theClosestPoint) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> seconds = <a name="a44"></a><a class="code" href="#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line">    gpuCacheIsectAccelParams accelParams = gpuCacheIsectAccelParams::autoUniformGridParams(); </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numAccels = getIntersectionAccelerator(accelParams, seconds);</div>
<div class="line">    <span class="keywordtype">bool</span> foundPoint = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(numAccels &gt; 0 &amp;&amp; numAccels == fBufferCache-&gt;fNumShapes) {</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> closestShape=0;</div>
<div class="line">        <span class="keywordtype">double</span> minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">        <span class="keywordtype">bool</span> *checkedBox = <span class="keyword">new</span> <span class="keywordtype">bool</span>[fBufferCache-&gt;fNumShapes];</div>
<div class="line">        <span class="keywordtype">double</span> *allDists = <span class="keyword">new</span> <span class="keywordtype">double</span>[fBufferCache-&gt;fNumShapes];</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s&lt;fBufferCache-&gt;fNumShapes; s++){</div>
<div class="line">            checkedBox[s] = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">if</span>(fBufferCache-&gt;fNumTriangles[s]&gt;0){</div>
<div class="line">                <a name="_a45"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> xformBBox = fBufferCache-&gt;fBoundingBoxes[s];</div>
<div class="line">                xformBBox.<a name="a46"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a61b840da0866a8eea629857e067a5037">transformUsing</a>(fBufferCache-&gt;fXFormMatrix[s]);</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> closestPointOnBox;</div>
<div class="line">                allDists[s] = gpuCacheIsectUtil::getEdgeSnapPointOnBox(rayPointSrc, rayDirectionSrc, xformBBox, closestPointOnBox);</div>
<div class="line">                <span class="keywordflow">if</span>(allDists[s] &lt; minDist){</div>
<div class="line">                    minDist = allDists[s];</div>
<div class="line">                    closestShape = s;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                allDists[s] = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        std::vector&lt;int&gt; potentialShapes;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s&lt;fBufferCache-&gt;fNumShapes; s++){</div>
<div class="line">            <span class="keywordflow">if</span>(allDists[s]==minDist){</div>
<div class="line">                potentialShapes.push_back(s);</div>
<div class="line">                checkedBox[s]=<span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">double</span> coef_plane = rayDirectionSrc * rayPointSrc;</div>
<div class="line">        minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">        <span class="keywordflow">while</span>(!potentialShapes.empty()){    </div>
<div class="line">            closestShape = potentialShapes.back();</div>
<div class="line">            potentialShapes.pop_back();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span>(allDists[closestShape]&lt;=minDist){</div>
<div class="line">                <span class="keyword">const</span> index_t* srcTriangleVertIndices = fBufferCache-&gt;fTriangleVertIndices[closestShape]-&gt;get();</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions = fBufferCache-&gt;fPositions[closestShape]-&gt;get();</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> clsPoint;</div>
<div class="line">                <span class="keywordtype">double</span> dist = fSpatialSub[closestShape]-&gt;getEdgeSnapPoint(fBufferCache-&gt;fNumTriangles[closestShape], srcTriangleVertIndices, srcPositions,</div>
<div class="line">                    rayPointSrc*fBufferCache-&gt;fXFormMatrixInverse[closestShape], rayDirectionSrc*fBufferCache-&gt;fXFormMatrixInverse[closestShape], clsPoint);</div>
<div class="line">                clsPoint *= fBufferCache-&gt;fXFormMatrix[closestShape];</div>
<div class="line">                <span class="comment">// project onto coef_plane to find closest</span></div>
<div class="line">                <span class="keywordtype">double</span> d = coef_plane - rayDirectionSrc * clsPoint;</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> projectedClsPoint = clsPoint + rayDirectionSrc * d;</div>
<div class="line">                dist = rayPointSrc.distanceTo(projectedClsPoint);</div>
<div class="line">                <span class="keywordflow">if</span>(dist &lt; minDist){</div>
<div class="line">                    minDist = dist;</div>
<div class="line">                    theClosestPoint = clsPoint;</div>
<div class="line">                    foundPoint = <span class="keyword">true</span>;</div>
<div class="line">                    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s&lt;fBufferCache-&gt;fNumShapes; s++){</div>
<div class="line">                        <span class="keywordflow">if</span>(!checkedBox[s] &amp;&amp; allDists[s]&lt;=minDist){</div>
<div class="line">                            std::vector&lt;int&gt;::iterator it = potentialShapes.begin();</div>
<div class="line">                            <span class="keywordflow">while</span> (it != potentialShapes.end() &amp;&amp; allDists[s]&lt;allDists[*it])</div>
<div class="line">                            {</div>
<div class="line">                                it++;</div>
<div class="line">                            }</div>
<div class="line">                            potentialShapes.insert(it,s);</div>
<div class="line">                            checkedBox[s]=<span class="keyword">true</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">delete</span>[] checkedBox;</div>
<div class="line">        <span class="keyword">delete</span>[] allDists;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> foundPoint;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::closestPoint( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;raySource, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;rayDirection, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;theClosestPoint, <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;theClosestNormal, <span class="keywordtype">bool</span> findClosestOnMiss, <span class="keywordtype">double</span> tolerance) </div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(closestIntersectWithNorm(raySource,rayDirection,theClosestPoint,theClosestNormal)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(findClosestOnMiss) {</div>
<div class="line">        <span class="keywordflow">if</span>(getEdgeSnapPoint(raySource,rayDirection,theClosestPoint)) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::canMakeLive()<span class="keyword"> const </span>{ </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>; </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">This function is used to create a cache </span></div>
<div class="line"><span class="comment">with everything a live gpuCache will require.</span></div>
<div class="line"><span class="comment">The cache is re-created every time the frame</span></div>
<div class="line"><span class="comment">changes.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::readBuffers(<span class="keyword">const</span> SubNode::Ptr subNode, <span class="keywordtype">double</span> seconds)<span class="keyword">const</span>{</div>
<div class="line">    <span class="keywordflow">if</span>(subNode == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span>(fBufferCache!=NULL &amp;&amp; fBufferCache-&gt;fUseCachedBuffers &amp;&amp; fBufferCache-&gt;fBufferReadTime==seconds) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">if</span>(fBufferCache!=NULL){</div>
<div class="line">        <span class="keyword">delete</span> fBufferCache;</div>
<div class="line">    }</div>
<div class="line">    seconds = <a class="code" href="#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line">    fBufferCache = <span class="keyword">new</span> BufferCache(seconds);</div>
<div class="line">    <span class="keywordflow">if</span>(fBufferCache == NULL){</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    } </div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> identMat;</div>
<div class="line">    identMat.<a name="a47"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a1353e697af6f95ba0b8c0331c6af7f2f">setToIdentity</a>();</div>
<div class="line">    ReadBufferVisitor visitor(seconds, fBufferCache, identMat);</div>
<div class="line">    subNode-&gt;accept(visitor);</div>
<div class="line">    <span class="keywordflow">if</span>(fBufferCache-&gt;fUseCachedBuffers &amp;&amp; (fBufferCache-&gt;fNumShapes)&gt;1 &amp;&amp; (fBufferCache-&gt;fTotalNumTris) &gt; 1000000){</div>
<div class="line">        <a name="a48"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#a2c877a6e116f8fd3a6e76387403c023a">MGlobal::executeCommandOnIdle</a>( <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;gpuCacheManyShapesDialog(&quot;</span>) + fBufferCache-&gt;fTotalNumVerts + <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(<span class="stringliteral">&quot;)&quot;</span>) );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> fBufferCache-&gt;fUseCachedBuffers;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::closestPoint(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;toThisPoint, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;theClosestPoint, <span class="keywordtype">double</span> tolerance) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> seconds = <a class="code" href="#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line">    gpuCacheIsectAccelParams accelParams = gpuCacheIsectAccelParams::autoUniformGridParams(); </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numAccels = getIntersectionAccelerator(accelParams, seconds);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span>(numAccels &gt; 0 &amp;&amp; numAccels == fBufferCache-&gt;fNumShapes) {</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> closestShape=0;</div>
<div class="line">        <span class="keywordtype">double</span> minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">        <span class="keywordtype">bool</span> *checkedBox = <span class="keyword">new</span> <span class="keywordtype">bool</span>[fBufferCache-&gt;fNumShapes];</div>
<div class="line">        <span class="keywordtype">double</span> *allDists = <span class="keyword">new</span> <span class="keywordtype">double</span>[fBufferCache-&gt;fNumShapes];</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s&lt;fBufferCache-&gt;fNumShapes; s++){</div>
<div class="line">            checkedBox[s] = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">if</span>(fBufferCache-&gt;fNumTriangles[s]&gt;0){</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> xformBBox = fBufferCache-&gt;fBoundingBoxes[s];</div>
<div class="line">                xformBBox.<a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a61b840da0866a8eea629857e067a5037">transformUsing</a>(fBufferCache-&gt;fXFormMatrix[s]);</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> closestPointOnBox;</div>
<div class="line">                allDists[s] = gpuCacheIsectUtil::getClosestPointOnBox(toThisPoint,xformBBox,closestPointOnBox);</div>
<div class="line">                <span class="keywordflow">if</span>(allDists[s] &lt; minDist){</div>
<div class="line">                    minDist = allDists[s];</div>
<div class="line">                    closestShape = s;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                allDists[s] = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        std::vector&lt;int&gt; potentialShapes;</div>
<div class="line">        potentialShapes.push_back(closestShape);</div>
<div class="line">        minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">        <span class="keywordflow">while</span>(!potentialShapes.empty()){    </div>
<div class="line">            closestShape = potentialShapes.back();</div>
<div class="line">            potentialShapes.pop_back();</div>
<div class="line">            checkedBox[closestShape]=<span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">if</span>(allDists[closestShape]&lt;minDist){</div>
<div class="line">                <span class="keyword">const</span> index_t* srcTriangleVertIndices = fBufferCache-&gt;fTriangleVertIndices[closestShape]-&gt;get();</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions = fBufferCache-&gt;fPositions[closestShape]-&gt;get();</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> clsPoint;</div>
<div class="line">                fSpatialSub[closestShape]-&gt;closestPointToPoint(fBufferCache-&gt;fNumTriangles[closestShape], srcTriangleVertIndices, srcPositions, toThisPoint * fBufferCache-&gt;fXFormMatrixInverse[closestShape], clsPoint);</div>
<div class="line">                clsPoint *= fBufferCache-&gt;fXFormMatrix[closestShape];</div>
<div class="line">                <span class="keywordtype">double</span> dist = clsPoint.<a name="a49"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(toThisPoint);</div>
<div class="line">                <span class="keywordflow">if</span>(dist &lt; minDist){</div>
<div class="line">                    minDist = dist;</div>
<div class="line">                    theClosestPoint = clsPoint;</div>
<div class="line">                    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s&lt;fBufferCache-&gt;fNumShapes; s++){</div>
<div class="line">                        <span class="keywordflow">if</span>(!checkedBox[s] &amp;&amp; allDists[s]&lt;minDist){</div>
<div class="line">                            std::vector&lt;int&gt;::iterator it = potentialShapes.begin();</div>
<div class="line">                            <span class="keywordflow">while</span> (it != potentialShapes.end() &amp;&amp; allDists[s]&lt;allDists[*it])</div>
<div class="line">                            {</div>
<div class="line">                                it++;</div>
<div class="line">                            }</div>
<div class="line">                            potentialShapes.insert(it,s);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">delete</span>[] checkedBox;</div>
<div class="line">        <span class="keyword">delete</span>[] allDists;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> ShapeNode::closestIntersectWithNorm (<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;toThisPoint, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;thisDirection, <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> &amp;theClosestPoint, <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> &amp;theClosestNormal){</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> seconds = <a class="code" href="#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line">    gpuCacheIsectAccelParams accelParams = gpuCacheIsectAccelParams::autoUniformGridParams(); </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numAccels = getIntersectionAccelerator(accelParams, seconds); </div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> returnStatus = <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line">    <span class="keywordflow">if</span>(numAccels &gt; 0 &amp;&amp; numAccels == fBufferCache-&gt;fNumShapes) {</div>
<div class="line">        <span class="keywordtype">double</span> minDist = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s&lt;fBufferCache-&gt;fNumShapes; s++){</div>
<div class="line">            <span class="keyword">const</span> index_t* srcTriangleVertIndices = fBufferCache-&gt;fTriangleVertIndices[s]-&gt;get();</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions = fBufferCache-&gt;fPositions[s]-&gt;get();</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> clsPoint;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> clsNormal;</div>
<div class="line">            <span class="keywordflow">if</span>( fSpatialSub[s]-&gt;closestIntersection(fBufferCache-&gt;fNumTriangles[s], srcTriangleVertIndices, srcPositions, toThisPoint * fBufferCache-&gt;fXFormMatrixInverse[s], thisDirection * fBufferCache-&gt;fXFormMatrixInverse[s], </div>
<div class="line">                <span class="comment">/*maxParam = */</span>999999, clsPoint, clsNormal)){</div>
<div class="line">                    clsPoint *= fBufferCache-&gt;fXFormMatrix[s];</div>
<div class="line">                    clsNormal *= fBufferCache-&gt;fXFormMatrix[s];</div>
<div class="line">                    <span class="keywordtype">double</span> dist = clsPoint.<a class="code" href="#!/url=./cpp_ref/class_m_point.html#a2afaa6122ee5ec4a0bff234d499b4c63">distanceTo</a>(toThisPoint);</div>
<div class="line">                    <span class="keywordflow">if</span>(dist &lt; minDist){</div>
<div class="line">                        minDist = dist;</div>
<div class="line">                        theClosestPoint = clsPoint;</div>
<div class="line">                        theClosestNormal = clsNormal;</div>
<div class="line">                        returnStatus = <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">                    }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">        } </div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> returnStatus;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> ShapeNode::boundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Extract the cached geometry.</span></div>
<div class="line">    <span class="keyword">const</span> SubNode::Ptr subNode = getCachedGeometry();</div>
<div class="line">    <span class="keywordflow">if</span> (!subNode) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> SubNodeData::Ptr subNodeData = subNode-&gt;getData();</div>
<div class="line">    <span class="keywordflow">if</span> (!subNodeData) <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> seconds = <a class="code" href="#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle transforms.</span></div>
<div class="line">    <span class="keyword">const</span> XformData::Ptr xform =</div>
<div class="line">        boost::dynamic_pointer_cast&lt;<span class="keyword">const</span> XformData&gt;(subNodeData);</div>
<div class="line">    <span class="keywordflow">if</span> (xform) {</div>
<div class="line">        <span class="keyword">const</span> boost::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>
<div class="line">            xform-&gt;getSample(seconds);</div>
<div class="line">        <span class="keywordflow">return</span> sample-&gt;boundingBox();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle shapes.</span></div>
<div class="line">    <span class="keyword">const</span> ShapeData::Ptr shape =</div>
<div class="line">        boost::dynamic_pointer_cast&lt;<span class="keyword">const</span> ShapeData&gt;(subNodeData);</div>
<div class="line">    <span class="keywordflow">if</span> (shape) {</div>
<div class="line">        <span class="keyword">const</span> boost::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">            shape-&gt;getSample(seconds);</div>
<div class="line">        <span class="keywordflow">return</span> sample-&gt;boundingBox();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::getInternalValueInContext(<span class="keyword">const</span> <a name="_a50"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug,</div>
<div class="line">    <a name="_a51"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html">MDataHandle</a>&amp; dataHandle, <a name="_a52"></a><a class="code" href="#!/url=./cpp_ref/class_m_d_g_context.html">MDGContext</a>&amp; ctx)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (plug == aCacheFileName) {</div>
<div class="line">        dataHandle.<a name="a53"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a35259cf4b39ca3fda1f82a262414df1f">setString</a>(fCacheFileName);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug == aCacheGeomPath) {</div>
<div class="line">        dataHandle.<a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a35259cf4b39ca3fda1f82a262414df1f">setString</a>(fCacheGeomPath);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a name="a54"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a765069394bb461e3480ada2c67efd7bf">MPxNode::getInternalValueInContext</a>(plug, dataHandle, ctx);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::setInternalValues(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; newFileName,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; newGeomPath</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> oldFileName = fCacheFileName;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> oldResolvedFileName = fResolvedCacheFileName;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> oldGeomPath = fCacheGeomPath;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute the resolved filename</span></div>
<div class="line">    <a name="_a55"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a> newFile;</div>
<div class="line">    newFile.<a name="a56"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#ac14aefbfe38c2711256eb8c14a3194ee">setRawFullName</a>(newFileName);</div>
<div class="line">    newFile.<a name="a57"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a4b3d5deec3dc9475f712c8e0f2f4d9a2">setResolveMethod</a>(<a name="a58"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#af71e719034e8e9a4c69adcc174ca9049ac1ce1604eaae6e61df873510a9254fb3">MFileObject::kInputFile</a>);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> newResolvedFileName = newFile.<a name="a59"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a9484f49594e6f95729f1be1608a6ae8f">resolvedFullName</a>();</div>
<div class="line">    <span class="keywordflow">if</span>( newResolvedFileName.<a name="a60"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0 )</div>
<div class="line">    {</div>
<div class="line">        newResolvedFileName = newFileName;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Early out if nothing has changed.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Compare only the raw file names. We still want to update the attributes</span></div>
<div class="line">    <span class="comment">// if the raw file names have changed, even if the resolved file names still</span></div>
<div class="line">    <span class="comment">// point to the same file.</span></div>
<div class="line">    <span class="keywordtype">bool</span> fileChanged = (newFileName != oldFileName);</div>
<div class="line">    <span class="keywordtype">bool</span> pathChanged = (newGeomPath != oldGeomPath);</div>
<div class="line">    <span class="keywordflow">if</span> (!fileChanged &amp;&amp; !pathChanged)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( fileChanged )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Early out if the new file path has already been read.</span></div>
<div class="line">        <span class="keywordflow">if</span>( newResolvedFileName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0 )</div>
<div class="line">        {</div>
<div class="line">            CacheFileEntry::MPtr entry = CacheFileRegistry::theCache().find(newResolvedFileName);</div>
<div class="line">            <span class="keywordflow">if</span>( entry )</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Invalidate viewport and this shape&#39;s cache data.</span></div>
<div class="line">                fCachedGeometry.reset();</div>
<div class="line">                fCachedMaterial.reset();</div>
<div class="line">                <a name="a61"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#ab2843a350b76cdcbf16dd70d884f9766">MHWRender::MRenderer::setGeometryDrawDirty</a>(thisMObject());</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Set the new cache file, path and entry</span></div>
<div class="line">                fCacheFileName = newFileName;</div>
<div class="line">                fResolvedCacheFileName = newResolvedFileName;</div>
<div class="line">                fCacheGeomPath = newGeomPath;</div>
<div class="line">                fCacheFileEntry = entry;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Set to reading file - this will poll for updates against the</span></div>
<div class="line">                <span class="comment">// entry in getCachedGeometry().</span></div>
<div class="line">                fCacheReadingState = kCacheReadingFile;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// The fCacheFileName has changed, update the shape registry</span></div>
<div class="line">                <span class="comment">// NOTE: Use resolved file name for registry.</span></div>
<div class="line">                CacheShapeRegistry::theCache().remove(oldResolvedFileName, thisMObject());</div>
<div class="line">                CacheShapeRegistry::theCache().insert(newResolvedFileName, thisMObject());</div>
<div class="line"></div>
<div class="line">                <span class="comment">// The fCacheFileEntry has changed, clean up the registry as necessary</span></div>
<div class="line">                <span class="comment">// NOTE: Use resolved file name for registry.</span></div>
<div class="line">                CacheFileRegistry::theCache().cleanUp(oldResolvedFileName);</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Update the internal attributes</span></div>
<div class="line">        fCacheFileName = newFileName;</div>
<div class="line">        fResolvedCacheFileName = newResolvedFileName;</div>
<div class="line">        fCacheGeomPath = newGeomPath;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The fCacheFileName has changed, update the shape registry</span></div>
<div class="line">        <span class="comment">// NOTE: Use resolved file name for registry.</span></div>
<div class="line">        CacheShapeRegistry::theCache().remove(oldResolvedFileName, thisMObject());</div>
<div class="line">        CacheShapeRegistry::theCache().insert(newResolvedFileName, thisMObject());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Invalidate viewport and force a re-reading of the cache file.</span></div>
<div class="line">        fCachedGeometry.reset();</div>
<div class="line">        fCachedMaterial.reset();</div>
<div class="line">        fCacheFileEntry.reset();</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#ab2843a350b76cdcbf16dd70d884f9766">MHWRender::MRenderer::setGeometryDrawDirty</a>(thisMObject());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The fCacheFileEntry has changed, clean up the registry as necessary</span></div>
<div class="line">        CacheFileRegistry::theCache().cleanUp(oldResolvedFileName);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Insert a CacheFileEntry into the registry so only one read is scheduled</span></div>
<div class="line">        <span class="comment">// for a given file/path pair.</span></div>
<div class="line">        <span class="keywordflow">if</span>( newResolvedFileName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0 )</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// NOTE: Use resolved file name for registry.</span></div>
<div class="line">            CacheFileEntry::MPtr newEntry = CacheFileEntry::create( newResolvedFileName );</div>
<div class="line">            CacheFileRegistry::theCache().insert( newResolvedFileName, newEntry );</div>
<div class="line">            fCacheFileEntry = newEntry;</div>
<div class="line">            fCacheReadingState = kCacheReadingFile;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Only the geomPath changed</span></div>
<div class="line">        fCacheGeomPath = newGeomPath;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set to reading file - this will poll for updates against the</span></div>
<div class="line">        <span class="comment">// entry in getCachedGeometry().</span></div>
<div class="line">        fCacheReadingState = kCacheReadingFile;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::setInternalValueInContext(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html">MDataHandle</a>&amp; dataHandle, <a class="code" href="#!/url=./cpp_ref/class_m_d_g_context.html">MDGContext</a>&amp; ctx)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (plug == aCacheFileName) {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> newFileName = dataHandle.<a name="a62"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a858b071eda071f265c130e30d0b98622">asString</a>();</div>
<div class="line">        <span class="keywordflow">return</span> setInternalValues(newFileName, fCacheGeomPath);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug == aCacheGeomPath) {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> newGeomPath = dataHandle.<a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a858b071eda071f265c130e30d0b98622">asString</a>();</div>
<div class="line">        <span class="keywordflow">return</span> setInternalValues(fCacheFileName, newGeomPath);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a name="a63"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a67f0c9bc691a04b63023ed4b61f10e46">MPxNode::setInternalValueInContext</a>(plug, dataHandle, ctx);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::refreshCachedGeometry( <span class="keywordtype">bool</span> clearFileCache <span class="comment">/* = false */</span> )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Back up attributes</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> cacheFileName = fCacheFileName;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> resolvedCacheFileName = fResolvedCacheFileName;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> cacheGeomPath = fCacheGeomPath;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cancel background read</span></div>
<div class="line">    <span class="keywordflow">if</span> (fCacheFileEntry &amp;&amp; fCacheFileEntry-&gt;fReadState != CacheFileEntry::kReadingDone) {</div>
<div class="line">        GlobalReaderCache::theCache().cancelRead(fCacheFileEntry.get());</div>
<div class="line">        fCacheFileEntry-&gt;fReadState = CacheFileEntry::kReadingDone;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cancel cache read</span></div>
<div class="line">    <span class="keywordflow">if</span> (fCacheReadingState != kCacheReadingDone) {</div>
<div class="line">        fCacheReadingState = kCacheReadingDone;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Remove any CacheFileEntry for this file.</span></div>
<div class="line">    <span class="keywordflow">if</span>( clearFileCache )</div>
<div class="line">    {</div>
<div class="line">        CacheFileRegistry::theCache().remove(resolvedCacheFileName);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Remove any CacheShapeRegistry entry for this shape.</span></div>
<div class="line">    CacheShapeRegistry::theCache().remove(resolvedCacheFileName, thisMObject());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Reset this node</span></div>
<div class="line">    fCacheFileName.<a name="a64"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>();</div>
<div class="line">    fResolvedCacheFileName.clear();</div>
<div class="line">    fCacheGeomPath.clear();</div>
<div class="line">    fCachedGeometry.reset();</div>
<div class="line">    fCachedMaterial.reset();</div>
<div class="line">    fCacheFileEntry.reset();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the attributes again</span></div>
<div class="line">    setInternalValues(cacheFileName, cacheGeomPath);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update any other shapes that refer to the same file to refresh as well.</span></div>
<div class="line">    <span class="keywordflow">if</span>( clearFileCache )</div>
<div class="line">    {</div>
<div class="line">        refreshOtherCachedShapes( resolvedCacheFileName );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::refreshOtherCachedShapes( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; cacheFileName )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Do not refresh other shapes while reading a file.</span></div>
<div class="line">    <span class="keywordflow">if</span>( <a name="a65"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_i_o.html#accbcaffc37fcbee9f7974aae80c8014b">MFileIO::isReadingFile</a>() )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Determine the full resolved path from the cacheFileName</span></div>
<div class="line">    <a name="_a66"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html">MFnDependencyNode</a> nodeFn;</div>
<div class="line">    std::vector&lt;MObjectHandle&gt; otherShapes;</div>
<div class="line">    CacheShapeRegistry::theCache().find( cacheFileName, otherShapes );</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; otherShapes.size(); i++ )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>( !otherShapes[i].isValid() )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        nodeFn.<a name="a67"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>( otherShapes[i].<span class="keywordtype">object</span>() );</div>
<div class="line">        assert( nodeFn.<a name="a68"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#a1d0bbd4d50dae591f8e003c0aedc8135">typeId</a>() == id );</div>
<div class="line">        ShapeNode* shape = (ShapeNode*) nodeFn.<a name="a69"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#a4f2c53c9d1dcf25a6462c70fb25aead1">userNode</a>();</div>
<div class="line">        assert( shape );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// File cache has already been cleared, do not request clearFileCache</span></div>
<div class="line">        shape-&gt;refreshCachedGeometry( <span class="keyword">false</span> );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> SubNode::Ptr&amp; ShapeNode::getCachedGeometry()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// We can&#39;t have both a reader and geometry/material that has already been</span></div>
<div class="line">    <span class="comment">// read!</span></div>
<div class="line">    CacheFileEntry::MPtr entry = fCacheFileEntry;</div>
<div class="line">    assert(!(entry &amp;&amp; entry-&gt;fCacheReaderProxy &amp;&amp; (entry-&gt;fCachedGeometry || entry-&gt;fCachedMaterial)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Retrieve the CacheFileEntry for this shape&#39;s cacheFile</span></div>
<div class="line">    <span class="keywordflow">if</span>( fCacheReadingState == kCacheReadingFile )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Must have a valid entry if this shape is reading from the cache.</span></div>
<div class="line">        assert(entry);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (fCacheFileEntry-&gt;fCacheReaderProxy) {</div>
<div class="line">            <span class="keywordflow">if</span> (Config::backgroundReading() &amp;&amp; <a name="a70"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#ac7296da94b1d0b659833fc653a6af10e">MGlobal::mayaState</a>() != <a name="a71"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#afb0008b4212928b7913ba9cfc64fe88ba347100316aff63bf166232d8145a44f6">MGlobal::kBatch</a>) {</div>
<div class="line">                <span class="comment">// We are going to read the cache file in background.</span></div>
<div class="line">                GlobalReaderCache::theCache().scheduleRead(entry.get(), </div>
<div class="line">                                                           <span class="stringliteral">&quot;|&quot;</span>, </div>
<div class="line">                                                           fCacheFileEntry-&gt;fCacheReaderProxy);</div>
<div class="line">                entry-&gt;fReadState = CacheFileEntry::kReadingHierarchyInProgress;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// Display a wait cursor</span></div>
<div class="line">                WaitCursor waitCursor;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Read the cache file now.</span></div>
<div class="line">                <span class="comment">// Make sure that we have a valid cache reader.</span></div>
<div class="line">                GlobalReaderCache::CacheReaderHolder holder(fCacheFileEntry-&gt;fCacheReaderProxy);</div>
<div class="line">                <span class="keyword">const</span> boost::shared_ptr&lt;CacheReader&gt; cacheReader = holder.getCacheReader();</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (cacheReader &amp;&amp; cacheReader-&gt;valid()) {</div>
<div class="line">                    entry-&gt;fCachedGeometry = cacheReader-&gt;readScene(</div>
<div class="line">                        <span class="stringliteral">&quot;|&quot;</span>, !Config::isIgnoringUVs());</div>
<div class="line">                    entry-&gt;fCachedMaterial = cacheReader-&gt;readMaterials();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        </div>
<div class="line">            <span class="comment">// We get rid of the fCacheReaderProxy as soon as we start</span></div>
<div class="line">            <span class="comment">// drawing to free up memory. The fCacheReaderProxy was kept</span></div>
<div class="line">            <span class="comment">// opened just in case that another ShapeData node would have</span></div>
<div class="line">            <span class="comment">// been reading from the same cache file to save the reopening</span></div>
<div class="line">            <span class="comment">// of the file.</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// This assumes that setInternalValueInContext() is called on</span></div>
<div class="line">            <span class="comment">// all ShapeNode on scene load before getCachedGeometry() is</span></div>
<div class="line">            <span class="comment">// called on any of them!</span></div>
<div class="line">            fCacheFileEntry-&gt;fCacheReaderProxy.reset();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check if we are reading cache files in the background.</span></div>
<div class="line">        <span class="keywordflow">if</span> (entry-&gt;fReadState == CacheFileEntry::kReadingHierarchyInProgress) {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> validatedGeometryPath;</div>
<div class="line">            <span class="keywordflow">if</span> (GlobalReaderCache::theCache().pullHierarchy(entry.get(), entry-&gt;fCachedGeometry, validatedGeometryPath, entry-&gt;fCachedMaterial)) {</div>
<div class="line">                <span class="comment">// Background reading is done (hierarchy).</span></div>
<div class="line">                entry-&gt;fReadState = CacheFileEntry::kReadingShapesInProgress;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Jump to shape done if we have no sub node hierarchy</span></div>
<div class="line">                <span class="keywordflow">if</span> (!entry-&gt;fCachedGeometry) {</div>
<div class="line">                    entry-&gt;fReadState = CacheFileEntry::kReadingDone;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Dirty bounding box cache</span></div>
<div class="line">                <span class="keyword">const_cast&lt;</span>ShapeNode*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;childChanged(kBoundingBoxChanged);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (entry-&gt;fReadState == CacheFileEntry::kReadingShapesInProgress) {</div>
<div class="line">            <span class="keywordflow">if</span> (GlobalReaderCache::theCache().pullShape(entry.get(), entry-&gt;fCachedGeometry)) {</div>
<div class="line">                <span class="comment">// Background reading is done (shapes).</span></div>
<div class="line">                entry-&gt;fReadState = CacheFileEntry::kReadingDone;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Retrieve read state from the entry</span></div>
<div class="line">        <span class="keywordtype">bool</span> readingDone = (entry-&gt;fReadState == CacheFileEntry::kReadingDone);</div>
<div class="line">        <span class="keywordtype">bool</span> readingHierarchyDone = readingDone || (entry-&gt;fReadState == CacheFileEntry::kReadingShapesInProgress);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>( readingHierarchyDone )</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Generate the SubNode hierarchy for this shape&#39;s geomPath</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> validatedGeomPath;</div>
<div class="line">            CreateSubNodeHierarchy(entry-&gt;fCachedGeometry, fCacheGeomPath, validatedGeomPath, fCachedGeometry);</div>
<div class="line">            fCachedMaterial = entry-&gt;fCachedMaterial;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Update the geomPath with the validated path.</span></div>
<div class="line">            updateGeomPath( validatedGeomPath );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>( readingDone )</div>
<div class="line">        {</div>
<div class="line">            fCacheReadingState = kCacheReadingDone;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> fCachedGeometry;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::updateGeomPath( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; validatedGeomPath )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Check the validated geometry path</span></div>
<div class="line">    <span class="keywordflow">if</span> (fCacheGeomPath != validatedGeomPath) {</div>
<div class="line">        <span class="keywordflow">if</span> (fCacheGeomPath.length() &gt; 0) {</div>
<div class="line">            <span class="comment">// display a warning showing that the user&#39;s geometry path is wrong</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> msgFmt = <a name="a72"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_resource.html#a121315f443a9c4ea512738dc1d39414d">MStringResource::getString</a>(kFileNotFindWarningMsg, stat);</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> warningMsg;</div>
<div class="line">            warningMsg.<a name="a73"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#a07ae464181c795f43fa1bcc288acff91">format</a>(msgFmt,</div>
<div class="line">                fCacheGeomPath, fCacheFileName, validatedGeomPath);</div>
<div class="line">            <a name="a74"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#acb043e7fc4eb7fc0f39833d31364b8a4">MGlobal::displayWarning</a>(warningMsg);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fCacheGeomPath = validatedGeomPath;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Update the attribute editor. We shouldn&#39;t post too many</span></div>
<div class="line">        <span class="comment">// `autoUpdateAttrEd;` to the idle queue.</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_global.html#a09e405631e7cf680f8ac9d934ad73434">MGlobal::executeCommand</a>(<span class="stringliteral">&quot;if (!stringArrayContains(\&quot;autoUpdateAttrEd;\&quot;,`evalDeferred -list`)) &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;evalDeferred \&quot;autoUpdateAttrEd;\&quot;;&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> MaterialGraphMap::Ptr&amp; ShapeNode::getCachedMaterial()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    getCachedGeometry();  <span class="comment">// side effect to load the cached geometry/material</span></div>
<div class="line">    <span class="keywordflow">return</span> fCachedMaterial;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> CacheFileEntry::MPtr&amp; ShapeNode::getCacheFileEntry()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fCacheFileEntry;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> CacheFileEntry::BackgroundReadingState ShapeNode::backgroundReadingState()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">if</span>( fCacheFileEntry )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fCacheFileEntry-&gt;fReadState;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> CacheFileEntry::kReadingDone;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> ShapeNode::getFilesToArchive(</div>
<div class="line">    <span class="keywordtype">bool</span> shortName, <span class="keywordtype">bool</span> unresolvedName, <span class="keywordtype">bool</span> markCouldBeImageSequence )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> files;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(unresolvedName)</div>
<div class="line">    {</div>
<div class="line">        files.<a name="a75"></a><a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>(fCacheFileName);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//unresolvedName is false, resolve the path via MFileObject.</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a> fileObject;</div>
<div class="line">        fileObject.<a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#ac14aefbfe38c2711256eb8c14a3194ee">setRawFullName</a>(fCacheFileName);</div>
<div class="line">        files.<a class="code" href="#!/url=./cpp_ref/class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>(fileObject.<a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a9484f49594e6f95729f1be1608a6ae8f">resolvedFullName</a>());</div>
<div class="line">    }    </div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> files;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::copyInternalData(<a name="_a76"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html">MPxNode</a>* source)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (source &amp;&amp; source-&gt;<a name="a77"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a9a842aadc96ca39565ad68e366d6b83e">typeId</a>() == id) {</div>
<div class="line">        ShapeNode* node = <span class="keyword">dynamic_cast&lt;</span>ShapeNode*<span class="keyword">&gt;</span>(source);</div>
<div class="line">        fCacheFileName = node-&gt;fCacheFileName;</div>
<div class="line">        fCacheGeomPath = node-&gt;fCacheGeomPath;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// WARNING: This assumes that the geometry is read-only once</span></div>
<div class="line">        <span class="comment">// read.</span></div>
<div class="line">        fCachedGeometry   = node-&gt;fCachedGeometry;</div>
<div class="line">        fCachedMaterial   = node-&gt;fCachedMaterial;</div>
<div class="line">        fCacheFileEntry   = node-&gt;fCacheFileEntry;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Setup this shape to read the contents of the entry in the</span></div>
<div class="line">        <span class="comment">// getCachedGeometry() call.</span></div>
<div class="line">        fCacheReadingState = kCacheReadingFile;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::match( <span class="keyword">const</span> <a name="_a78"></a><a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html">MSelectionMask</a> &amp; mask,</div>
<div class="line">                   <span class="keyword">const</span> <a name="_a79"></a><a class="code" href="#!/url=./cpp_ref/class_m_object_array.html">MObjectArray</a>&amp; componentList )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html">MSelectionMask</a> gpuCacheMask(ShapeNode::selectionMaskName);</div>
<div class="line">    <span class="keywordflow">return</span> mask.<a name="a80"></a><a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html#ab0107f35df7fbf5b2b293ae20cdd2670">intersects</a>(gpuCacheMask) &amp;&amp; componentList.<a name="a81"></a><a class="code" href="#!/url=./cpp_ref/class_m_object_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>()==0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html">MSelectionMask</a> ShapeNode::getShapeSelectionMask()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html">MSelectionMask</a>(ShapeNode::selectionMaskName);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeNode::excludeAsPluginShape()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// gpuCache node has its own display filter &quot;GPU Cache&quot; in Show menu.</span></div>
<div class="line">    <span class="comment">// We don&#39;t want &quot;Plugin Shapes&quot; to filter out gpuCache nodes.</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::addedToModelCB()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Update the shape registry with this item.</span></div>
<div class="line">    CacheShapeRegistry::theCache().insert(fResolvedCacheFileName, thisMObject());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This shape has been added to the scene. Refresh the cached geometry</span></div>
<div class="line">    <span class="comment">// to ensure that our cache file entry is valid. This is particularly</span></div>
<div class="line">    <span class="comment">// important in the case of (Undo: delete).</span></div>
<div class="line">    refreshCachedGeometry(<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add time changed callback</span></div>
<div class="line">    fTimeChangeCallbackId = <a name="a82"></a><a class="code" href="#!/url=./cpp_ref/class_m_d_g_message.html#afa9ac531604456cec3e065991484e817">MDGMessage::addTimeChangeCallback</a>(TimeChangeCallback, <span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::removedFromModelCB()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Remove time changed callback</span></div>
<div class="line">    <span class="keywordflow">if</span> (fTimeChangeCallbackId)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fTimeChangeCallbackId);</div>
<div class="line">        fTimeChangeCallbackId = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the shape registry with this item.</span></div>
<div class="line">    CacheShapeRegistry::theCache().remove(fResolvedCacheFileName, thisMObject());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This shape has been removed from the scene. Clear the cache file entry</span></div>
<div class="line">    <span class="comment">// and notify the registry for clean up.</span></div>
<div class="line">    fCacheReadingState = kCacheReadingDone;</div>
<div class="line">    fCacheFileEntry.reset();</div>
<div class="line">    CacheFileRegistry::theCache().cleanUp(fResolvedCacheFileName);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::timeChangeCB(<span class="keywordtype">double</span> timeInSeconds)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> prevBoundingBox = fBoundingBox;</div>
<div class="line">    fBoundingBox = boundingBox();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (prevBoundingBox.<a name="a83"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#afb3213b98f3a6b4bda9759511e9b79a1">min</a>() != fBoundingBox.min() ||</div>
<div class="line">        prevBoundingBox.<a name="a84"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html#a1dfdbea9d5560e4aa09d34bdbd82480c">max</a>() != fBoundingBox.max())</div>
<div class="line">    {</div>
<div class="line">        childChanged(<a name="a85"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_surface_shape.html#ae6e3d315c5dd375e845a29ffeb5f8727a3cf2a789a428c68c537cf3ba6b9ad743">MPxSurfaceShape::kBoundingBoxChanged</a>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::dirtyVP2Geometry( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; fileName )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Dirty VP2 geometry</span></div>
<div class="line">    <span class="comment">// We don&#39;t need to call setGeometryDrawDirty() for MPxSubSceneOverride API.</span></div>
<div class="line">    <span class="keywordflow">if</span>( Config::vp2OverrideAPI() == Config::kMPxDrawOverride )</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;MObjectHandle&gt; shapes;</div>
<div class="line">        CacheShapeRegistry::theCache().find( fileName, shapes );</div>
<div class="line">        <span class="keywordtype">size_t</span> nShapes = shapes.size();</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; nShapes; i++ )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span>( !shapes[i].isValid() )</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> shape = shapes[i].object();</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#ab2843a350b76cdcbf16dd70d884f9766">MHWRender::MRenderer::setGeometryDrawDirty</a>( shape, <span class="keyword">true</span> );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS CacheShapeRegistry</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">CacheShapeRegistry CacheShapeRegistry::fsSingleton;</div>
<div class="line">CacheShapeRegistry::Map CacheShapeRegistry::fMap;</div>
<div class="line"></div>
<div class="line">CacheShapeRegistry::CacheShapeRegistry()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">CacheShapeRegistry::~CacheShapeRegistry()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">CacheShapeRegistry&amp; CacheShapeRegistry::theCache()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fsSingleton;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> CacheShapeRegistry::getAll( std::vector&lt;MObjectHandle&gt;&amp; shapes )</div>
<div class="line">{</div>
<div class="line">    shapes.clear();</div>
<div class="line">    <span class="keywordflow">for</span>( Map::iterator it = fMap.begin(); it != fMap.end(); it++ )</div>
<div class="line">    {</div>
<div class="line">        shapes.push_back( it-&gt;second );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> CacheShapeRegistry::find( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; key, std::vector&lt;MObjectHandle&gt;&amp; shapes )</div>
<div class="line">{</div>
<div class="line">    shapes.clear();</div>
<div class="line"></div>
<div class="line">    std::pair&lt;Map::iterator, Map::iterator&gt; its = fMap.equal_range(key);</div>
<div class="line">    <span class="keywordflow">for</span>( Map::iterator it = its.first; it != its.second; it++ )</div>
<div class="line">    {</div>
<div class="line">        shapes.push_back(it-&gt;second);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> CacheShapeRegistry::insert( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; key, <span class="keyword">const</span> <a name="_a86"></a><a class="code" href="#!/url=./cpp_ref/class_m_object_handle.html">MObjectHandle</a>&amp; shape )</div>
<div class="line">{</div>
<div class="line">    Map::value_type item( key, shape );</div>
<div class="line">    fMap.insert( item );</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> CacheShapeRegistry::remove( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; key, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object_handle.html">MObjectHandle</a>&amp; shape )</div>
<div class="line">{</div>
<div class="line">    std::pair&lt;Map::iterator, Map::iterator&gt; its = fMap.equal_range(key);</div>
<div class="line">    <span class="keywordflow">for</span>( Map::iterator it = its.first; it != its.second; it++ )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>( it-&gt;first == key &amp;&amp;</div>
<div class="line">            it-&gt;second == shape )</div>
<div class="line">        {</div>
<div class="line">            fMap.erase(it);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> CacheShapeRegistry::clear()</div>
<div class="line">{</div>
<div class="line">    fMap.clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS DisplayPref</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">DisplayPref::WireframeOnShadedMode DisplayPref::fsWireframeOnShadedMode;</div>
<div class="line">MCallbackId DisplayPref::fsDisplayPrefChangedCallbackId;</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> DisplayPref::initCallback()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Register DisplayPreferenceChanged callback</span></div>
<div class="line">    fsDisplayPrefChangedCallbackId = <a class="code" href="#!/url=./cpp_ref/class_m_event_message.html#a46fecb94aa00cc048f3cc0b80430f816">MEventMessage::addEventCallback</a>(</div>
<div class="line">        <span class="stringliteral">&quot;DisplayPreferenceChanged&quot;</span>, DisplayPref::displayPrefChanged, NULL, &amp;stat);</div>
<div class="line">    MCHECKERROR(stat, <span class="stringliteral">&quot;MEventMessage::addEventCallback(DisplayPreferenceChanged&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Trigger the callback manually to init class members</span></div>
<div class="line">    displayPrefChanged(NULL);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> DisplayPref::removeCallback()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Remove DisplayPreferenceChanged callback</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MEventMessage::removeCallback</a>(fsDisplayPrefChangedCallbackId);</div>
<div class="line">    MCHECKERROR(stat, <span class="stringliteral">&quot;MEventMessage::removeCallback(DisplayPreferenceChanged)&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> DisplayPref::displayPrefChanged(<span class="keywordtype">void</span>*)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line">    <span class="comment">// Wireframe on shaded mode: Full/Reduced/None</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> wireframeOnShadedActive = <a name="a87"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#a8dd71fbf4d71dacf626180777ba91a62">MGlobal::executeCommandStringResult</a>(</div>
<div class="line">        <span class="stringliteral">&quot;displayPref -q -wireframeOnShadedActive&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;stat);</div>
<div class="line">    <span class="keywordflow">if</span> (stat) {</div>
<div class="line">        <span class="keywordflow">if</span> (wireframeOnShadedActive == <span class="stringliteral">&quot;full&quot;</span>) {</div>
<div class="line">            fsWireframeOnShadedMode = kWireframeOnShadedFull;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wireframeOnShadedActive == <span class="stringliteral">&quot;reduced&quot;</span>) {</div>
<div class="line">            fsWireframeOnShadedMode = kWireframeOnShadedReduced;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wireframeOnShadedActive == <span class="stringliteral">&quot;none&quot;</span>) {</div>
<div class="line">            fsWireframeOnShadedMode = kWireframeOnShadedNone;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            assert(0);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">DisplayPref::WireframeOnShadedMode DisplayPref::wireframeOnShadedMode()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fsWireframeOnShadedMode;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ShapeUI</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span>* ShapeUI::creator()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ShapeUI;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ShapeUI::ShapeUI()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">ShapeUI::~ShapeUI()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeUI::getDrawRequests(<span class="keyword">const</span> <a name="_a88"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html">MDrawInfo</a> &amp; info,</div>
<div class="line">                              <span class="keywordtype">bool</span> objectAndActiveOnly,</div>
<div class="line">                              <a name="_a89"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request_queue.html">MDrawRequestQueue</a> &amp; queue)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Make sure that the post render callbacks have been properly</span></div>
<div class="line">    <span class="comment">// initialized. We have to verify at each refresh because there is</span></div>
<div class="line">    <span class="comment">// no easy way to recieve a callback when a new modelEditor is</span></div>
<div class="line">    <span class="comment">// created.</span></div>
<div class="line">    ShapeNode::init3dViewPostRenderCallbacks();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Get the data necessary to draw the shape</span></div>
<div class="line">    <a name="_a90"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_data.html">MDrawData</a> data;</div>
<div class="line">    getDrawData( 0, data );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Decode the draw info and determine what needs to be drawn</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a1b68f8823b8e275a4b548fdd27263e8a">M3dView::DisplayStyle</a>  appearance    = info.<a name="a91"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a16a1754d1de4e7ad544766e128fdfd2a">displayStyle</a>();</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#ad9c34c5373567566950642c16a7c4bca">M3dView::DisplayStatus</a> displayStatus = info.<a name="a92"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#aea5775805aed7f93884084d4cf6607b7">displayStatus</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Are we displaying gpuCache?</span></div>
<div class="line">    <span class="keywordflow">if</span> (!info.<a name="a93"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a083b286557d3c316d9c7652ebae4800b">pluginObjectDisplayStatus</a>(Config::kDisplayFilter)) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a name="_a94"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> path = info.<a name="a95"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a29c5fd43c9e42c958ae3455eba8e3e8e">multiPath</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">switch</span> ( appearance )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> <a name="a96"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a1b68f8823b8e275a4b548fdd27263e8aa74c3784e844e54dab272e794fa6bcaa9">M3dView::kBoundingBox</a> :</div>
<div class="line">        {</div>
<div class="line">            <a name="_a97"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> request = info.<a name="a98"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a7056c15c87746a72e32634d684694bc0">getPrototype</a>( *<span class="keyword">this</span> );</div>
<div class="line">            request.<a name="a99"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a5d3e9bc6ae679a823b6c3fcace09d796">setDrawData</a>( data );</div>
<div class="line">            request.<a name="a100"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#abe62a517ec22e2000ec81e0ec774831b">setToken</a>( kBoundingBox );</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> wireframeColor = <a name="a101"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#a6221bc7407b14246b14f79a751496276">MHWRender::MGeometryUtilities::wireframeColor</a>(path);</div>
<div class="line">            request.<a name="a102"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#ac3ee612a0b7ad10c46bb22294660620c">setColor</a>(wireframeColor);</div>
<div class="line"></div>
<div class="line">            queue.<a name="a103"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request_queue.html#a94a649d06791f74a76864a980e41ed63">add</a>( request );</div>
<div class="line">        }<span class="keywordflow">break</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">case</span> <a name="a104"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a1b68f8823b8e275a4b548fdd27263e8aa53c5241bb4e72f6c9547de918125d068">M3dView::kWireFrame</a> :</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> request = info.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a7056c15c87746a72e32634d684694bc0">getPrototype</a>( *<span class="keyword">this</span> );</div>
<div class="line">            request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a5d3e9bc6ae679a823b6c3fcace09d796">setDrawData</a>( data );</div>
<div class="line">            request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#abe62a517ec22e2000ec81e0ec774831b">setToken</a>( kDrawWireframe );</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> wireframeColor = <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#a6221bc7407b14246b14f79a751496276">MHWRender::MGeometryUtilities::wireframeColor</a>(path);</div>
<div class="line">            request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#ac3ee612a0b7ad10c46bb22294660620c">setColor</a>(wireframeColor);</div>
<div class="line"></div>
<div class="line">            queue.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request_queue.html#a94a649d06791f74a76864a980e41ed63">add</a>( request );</div>
<div class="line">        } <span class="keywordflow">break</span>;</div>
<div class="line">    </div>
<div class="line"></div>
<div class="line">        <span class="comment">// All of these modes are interpreted as meaning smooth shaded</span></div>
<div class="line">        <span class="comment">// just as it is done in the viewport 2.0.</span></div>
<div class="line">        <span class="keywordflow">case</span> <a name="a105"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a1b68f8823b8e275a4b548fdd27263e8aa7914d385424ca72fdf84654b735a5a50">M3dView::kFlatShaded</a> :</div>
<div class="line">        <span class="keywordflow">case</span> <a name="a106"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a1b68f8823b8e275a4b548fdd27263e8aa620925ec70781a5f5de890d906660d24">M3dView::kGouraudShaded</a> :</div>
<div class="line">        <span class="keywordflow">default</span>:    </div>
<div class="line">        {</div>
<div class="line">            ShapeNode* node = (ShapeNode*)surfaceShape();</div>
<div class="line">            <span class="keywordflow">if</span> (!node) <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keyword">const</span> SubNode::Ptr geom = node-&gt;getCachedGeometry();</div>
<div class="line">            <span class="keywordflow">if</span> (!geom) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get the view to draw to</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html">M3dView</a> view = info.<a name="a107"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#aa9f517a1406259b47e15937aa3166678">view</a>();</div>
<div class="line"></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> needWireframe = ((displayStatus == <a name="a108"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#ad9c34c5373567566950642c16a7c4bcaab6a8784b4cf96692e0d71d19c44ce732">M3dView::kActive</a>) ||</div>
<div class="line">                                        (displayStatus == <a name="a109"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#ad9c34c5373567566950642c16a7c4bcaa1606a62e097fcfa55af6251a83b44243">M3dView::kLead</a>)   ||</div>
<div class="line">                                        (displayStatus == <a name="a110"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#ad9c34c5373567566950642c16a7c4bcaa88694d85749c9c85738c56c4912c385a">M3dView::kHilite</a>) ||</div>
<div class="line">                                        (view.<a name="a111"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a60237ce77a011fbec5a49e12888f19b0">wireframeOnShaded</a>()));</div>
<div class="line"></div>
<div class="line">            <span class="comment">// When we need to draw both the shaded geometry and the</span></div>
<div class="line">            <span class="comment">// wireframe mesh, we need to offset the shaded geometry</span></div>
<div class="line">            <span class="comment">// in depth to avoid Z-fighting against the wireframe</span></div>
<div class="line">            <span class="comment">// mesh.</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// On the hand, we don&#39;t want to use depth offset when</span></div>
<div class="line">            <span class="comment">// drawing only the shaded geometry because it leads to</span></div>
<div class="line">            <span class="comment">// some drawing artifacts. The reason is a litle bit</span></div>
<div class="line">            <span class="comment">// subtle. At silouhette edges, both front-facing and</span></div>
<div class="line">            <span class="comment">// back-facing faces are meeting. These faces can have a</span></div>
<div class="line">            <span class="comment">// different slope in Z and this can lead to a different</span></div>
<div class="line">            <span class="comment">// Z-offset being applied. When unlucky, the back-facing</span></div>
<div class="line">            <span class="comment">// face can be drawn in front of the front-facing face. If</span></div>
<div class="line">            <span class="comment">// two-sided lighting is enabled, the back-facing fragment</span></div>
<div class="line">            <span class="comment">// can have a different resultant color. This can lead to</span></div>
<div class="line">            <span class="comment">// a rim of either dark or bright pixels around silouhette</span></div>
<div class="line">            <span class="comment">// edges.</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// When the wireframe mesh is drawn on top (even a dotted</span></div>
<div class="line">            <span class="comment">// one), it masks this effect sufficiently that it is no</span></div>
<div class="line">            <span class="comment">// longer distracting for the user, so it is OK to use</span></div>
<div class="line">            <span class="comment">// depth offset when the wireframe mesh is drawn on top.</span></div>
<div class="line">            <span class="keyword">const</span> DrawToken shadedDrawToken = needWireframe ?</div>
<div class="line">                kDrawSmoothShadedDepthOffset : kDrawSmoothShaded;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Get the default material.</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// Note that we will only use the material if the viewport</span></div>
<div class="line">            <span class="comment">// option &quot;Use default material&quot; has been selected. But,</span></div>
<div class="line">            <span class="comment">// we still need to set a material (even an unevaluated</span></div>
<div class="line">            <span class="comment">// one), so that the draw request is indentified as</span></div>
<div class="line">            <span class="comment">// drawing geometry instead of drawing the wireframe mesh.</span></div>
<div class="line">            <a name="_a112"></a><a class="code" href="#!/url=./cpp_ref/class_m_material.html">MMaterial</a> material = <a name="a113"></a><a class="code" href="#!/url=./cpp_ref/class_m_material.html#aeb352454ee40fce918ddbc7c55d89018">MMaterial::defaultMaterial</a>();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (view.<a name="a114"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#ae4b4678ef01f58e0ef190c045559f9ae">usingDefaultMaterial</a>()) {</div>
<div class="line">                <span class="comment">// Evaluate the material.</span></div>
<div class="line">                <span class="keywordflow">if</span> ( !material.<a name="a115"></a><a class="code" href="#!/url=./cpp_ref/class_m_material.html#a6d63e4963e97825dc4aff1990173ac62">evaluateMaterial</a>(view, path) ) {</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> stat;</div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> msg = <a class="code" href="#!/url=./cpp_ref/class_m_string_resource.html#a121315f443a9c4ea512738dc1d39414d">MStringResource::getString</a>(kEvaluateMaterialErrorMsg, stat);</div>
<div class="line">                    perror(msg.<a name="a116"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Create the smooth shaded draw request</span></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> request = info.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a7056c15c87746a72e32634d684694bc0">getPrototype</a>( *<span class="keyword">this</span> );</div>
<div class="line">                request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a5d3e9bc6ae679a823b6c3fcace09d796">setDrawData</a>( data );</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// This draw request will draw all sub nodes using an</span></div>
<div class="line">                <span class="comment">// opaque default material.</span></div>
<div class="line">                request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#abe62a517ec22e2000ec81e0ec774831b">setToken</a>( shadedDrawToken );</div>
<div class="line">                request.<a name="a117"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#ac3e4724dadceededf8e8a9ebf8ad7049">setIsTransparent</a>( <span class="keyword">false</span> );</div>
<div class="line"></div>
<div class="line">                request.<a name="a118"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a161ccc1e96ef0fce46f6e300a620c232">setMaterial</a>( material );</div>
<div class="line">                queue.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request_queue.html#a94a649d06791f74a76864a980e41ed63">add</a>( request );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (view.<a name="a119"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a7ff6ccd4600c5e1d33e05fd734c97d66">xray</a>()) {</div>
<div class="line">                <span class="comment">// Create the smooth shaded draw request</span></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> request = info.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a7056c15c87746a72e32634d684694bc0">getPrototype</a>( *<span class="keyword">this</span> );</div>
<div class="line">                request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a5d3e9bc6ae679a823b6c3fcace09d796">setDrawData</a>( data );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// This draw request will draw all sub nodes using in X-Ray mode</span></div>
<div class="line">                request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#abe62a517ec22e2000ec81e0ec774831b">setToken</a>( shadedDrawToken );</div>
<div class="line">                request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#ac3e4724dadceededf8e8a9ebf8ad7049">setIsTransparent</a>( <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line">                request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a161ccc1e96ef0fce46f6e300a620c232">setMaterial</a>( material );</div>
<div class="line">                queue.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request_queue.html#a94a649d06791f74a76864a980e41ed63">add</a>( request );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// Opaque draw request</span></div>
<div class="line">                <span class="keywordflow">if</span> (geom-&gt;transparentType() != SubNode::kTransparent) {</div>
<div class="line">                    <span class="comment">// Create the smooth shaded draw request</span></div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> request = info.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a7056c15c87746a72e32634d684694bc0">getPrototype</a>( *<span class="keyword">this</span> );</div>
<div class="line">                    request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a5d3e9bc6ae679a823b6c3fcace09d796">setDrawData</a>( data );</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// This draw request will draw opaque sub nodes</span></div>
<div class="line">                    request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#abe62a517ec22e2000ec81e0ec774831b">setToken</a>( shadedDrawToken );</div>
<div class="line"></div>
<div class="line">                    request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a161ccc1e96ef0fce46f6e300a620c232">setMaterial</a>( material );</div>
<div class="line">                    queue.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request_queue.html#a94a649d06791f74a76864a980e41ed63">add</a>( request );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Transparent draw request</span></div>
<div class="line">                <span class="keywordflow">if</span> (geom-&gt;transparentType() != SubNode::kOpaque) {</div>
<div class="line">                    <span class="comment">// Create the smooth shaded draw request</span></div>
<div class="line">                    <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> request = info.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a7056c15c87746a72e32634d684694bc0">getPrototype</a>( *<span class="keyword">this</span> );</div>
<div class="line">                    request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a5d3e9bc6ae679a823b6c3fcace09d796">setDrawData</a>( data );</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// This draw request will draw transparent sub nodes</span></div>
<div class="line">                    request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#abe62a517ec22e2000ec81e0ec774831b">setToken</a>( shadedDrawToken );</div>
<div class="line">                    request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#ac3e4724dadceededf8e8a9ebf8ad7049">setIsTransparent</a>( <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line">                    request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a161ccc1e96ef0fce46f6e300a620c232">setMaterial</a>( material );</div>
<div class="line">                    queue.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request_queue.html#a94a649d06791f74a76864a980e41ed63">add</a>( request );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// create a draw request for wireframe on shaded if</span></div>
<div class="line">            <span class="comment">// necessary.</span></div>
<div class="line">            <span class="keywordflow">if</span> (needWireframe &amp;&amp; </div>
<div class="line">                DisplayPref::wireframeOnShadedMode() != DisplayPref::kWireframeOnShadedNone)</div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> wireRequest = info.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a7056c15c87746a72e32634d684694bc0">getPrototype</a>( *<span class="keyword">this</span> );</div>
<div class="line">                wireRequest.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a5d3e9bc6ae679a823b6c3fcace09d796">setDrawData</a>( data );</div>
<div class="line">                wireRequest.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#abe62a517ec22e2000ec81e0ec774831b">setToken</a>( kDrawWireframeOnShaded );</div>
<div class="line">                wireRequest.<a name="a120"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a6021f26912668f091b824b68803d20c0">setDisplayStyle</a>( <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a1b68f8823b8e275a4b548fdd27263e8aa53c5241bb4e72f6c9547de918125d068">M3dView::kWireFrame</a> );</div>
<div class="line"></div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> wireframeColor = <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#a6221bc7407b14246b14f79a751496276">MHWRender::MGeometryUtilities::wireframeColor</a>(path);</div>
<div class="line">                wireRequest.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#ac3ee612a0b7ad10c46bb22294660620c">setColor</a>(wireframeColor);</div>
<div class="line"></div>
<div class="line">                queue.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request_queue.html#a94a649d06791f74a76864a980e41ed63">add</a>( wireRequest );</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeUI::draw(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> &amp; request, <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html">M3dView</a> &amp; view)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Initialize GL Function Table.</span></div>
<div class="line">    InitializeGLFT();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the token from the draw request.</span></div>
<div class="line">    <span class="comment">// The token specifies what needs to be drawn.</span></div>
<div class="line">    DrawToken token = DrawToken(request.<a name="a121"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#aa1fffc9ae537c640417f539883dc973e">token</a>());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">switch</span>( token )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> kBoundingBox :</div>
<div class="line">            drawBoundingBox( request, view );</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">case</span> kDrawWireframe :</div>
<div class="line">        <span class="keywordflow">case</span> kDrawWireframeOnShaded :</div>
<div class="line">            drawWireframe( request, view );</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">case</span> kDrawSmoothShaded :</div>
<div class="line">            drawShaded( request, view, <span class="keyword">false</span> );</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">case</span> kDrawSmoothShadedDepthOffset :</div>
<div class="line">            drawShaded( request, view, <span class="keyword">true</span> );</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeUI::drawBoundingBox(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> &amp; request, <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html">M3dView</a> &amp; view)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Get the surface shape</span></div>
<div class="line">    ShapeNode* node = (ShapeNode*)surfaceShape();</div>
<div class="line">    <span class="keywordflow">if</span> (!node) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the bounding box    </span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> box = node-&gt;boundingBox();</div>
<div class="line"></div>
<div class="line">    view.<a name="a122"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a0e318e5634c7aaf31c4eb7232d2013d4">beginGL</a>(); </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Query current state so it can be restored</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">bool</span> lightingWasOn = gGLFT-&gt;glIsEnabled( MGL_LIGHTING ) == MGL_TRUE;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Setup the OpenGL state as necessary</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span> ( lightingWasOn ) {</div>
<div class="line">            gGLFT-&gt;glDisable( MGL_LIGHTING );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        gGLFT-&gt;glEnable( MGL_LINE_STIPPLE );</div>
<div class="line">        gGLFT-&gt;glLineStipple(1,  Config::kLineStippleShortDashed);</div>
<div class="line"></div>
<div class="line">        VBOProxy vboProxy;</div>
<div class="line">        vboProxy.drawBoundingBox(box);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Restore the state</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span> ( lightingWasOn ) {</div>
<div class="line">            gGLFT-&gt;glEnable( MGL_LIGHTING );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        gGLFT-&gt;glDisable( MGL_LINE_STIPPLE );</div>
<div class="line">    }</div>
<div class="line">    view.<a name="a123"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#ab810c5a46d728df70ff5f44b604559f4">endGL</a>();    </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeUI::drawWireframe(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> &amp; request, <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html">M3dView</a> &amp; view)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Get the surface shape</span></div>
<div class="line">    ShapeNode* node = (ShapeNode*)surfaceShape();</div>
<div class="line">    <span class="keywordflow">if</span> ( !node ) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Extract the cached geometry.</span></div>
<div class="line">    <span class="keyword">const</span> SubNode::Ptr rootNode = node-&gt;getCachedGeometry();</div>
<div class="line">    <span class="keywordflow">if</span> (!rootNode) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> seconds = <a class="code" href="#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> projMatrix;</div>
<div class="line">    view.<a name="a124"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a62a9c2eb33aec66f3f92e02657c5b341">projectionMatrix</a>(projMatrix);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> modelViewMatrix;</div>
<div class="line">    view.<a name="a125"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a32e07853a952c88e39d32d5c27b8db3a">modelViewMatrix</a>(modelViewMatrix);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> localToPort = modelViewMatrix * projMatrix;</div>
<div class="line"></div>
<div class="line">    view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a0e318e5634c7aaf31c4eb7232d2013d4">beginGL</a>(); </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Query current state so it can be restored</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">bool</span> lightingWasOn = gGLFT-&gt;glIsEnabled( MGL_LIGHTING ) == MGL_TRUE;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Setup the OpenGL state as necessary</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span> ( lightingWasOn ) {</div>
<div class="line">            gGLFT-&gt;glDisable( MGL_LIGHTING );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        gGLFT-&gt;glEnable( MGL_LINE_STIPPLE );</div>
<div class="line">        <span class="keywordflow">if</span> (request.<a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#aa1fffc9ae537c640417f539883dc973e">token</a>() == kDrawWireframeOnShaded) {</div>
<div class="line">            <span class="comment">// Wireframe on shaded is affected by wireframe on shaded mode</span></div>
<div class="line">            DisplayPref::WireframeOnShadedMode wireframeOnShadedMode = </div>
<div class="line">                DisplayPref::wireframeOnShadedMode();</div>
<div class="line">            <span class="keywordflow">if</span> (wireframeOnShadedMode == DisplayPref::kWireframeOnShadedReduced) {</div>
<div class="line">                gGLFT-&gt;glLineStipple(1, Config::kLineStippleDotted);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                assert(wireframeOnShadedMode != DisplayPref::kWireframeOnShadedNone);</div>
<div class="line">                gGLFT-&gt;glLineStipple(1, Config::kLineStippleShortDashed);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            gGLFT-&gt;glLineStipple(1, Config::kLineStippleShortDashed);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Draw the wireframe mesh</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        {</div>
<div class="line">            Frustum frustum(localToPort.<a name="a126"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a8ca5ebc404566e2c4a16d4754772e082">inverse</a>());</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> xform(modelViewMatrix);</div>
<div class="line">        </div>
<div class="line">            DrawWireframeState state(frustum, seconds);</div>
<div class="line">            DrawWireframeTraversal traveral(state, xform, <span class="keyword">false</span>, Frustum::kUnknown);</div>
<div class="line">            rootNode-&gt;accept(traveral);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Restore the state</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span> ( lightingWasOn ) {</div>
<div class="line">            gGLFT-&gt;glEnable( MGL_LIGHTING );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        gGLFT-&gt;glDisable( MGL_LINE_STIPPLE );</div>
<div class="line">    }</div>
<div class="line">    view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#ab810c5a46d728df70ff5f44b604559f4">endGL</a>(); </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeUI::drawShaded(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html">MDrawRequest</a> &amp; request, <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html">M3dView</a> &amp; view, <span class="keywordtype">bool</span> depthOffset)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Get the surface shape</span></div>
<div class="line">    ShapeNode* node = (ShapeNode*)surfaceShape();</div>
<div class="line">    <span class="keywordflow">if</span> ( !node ) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Extract the cached geometry.</span></div>
<div class="line">    <span class="keyword">const</span> SubNode::Ptr rootNode = node-&gt;getCachedGeometry();</div>
<div class="line">    <span class="keywordflow">if</span> (!rootNode) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> seconds = <a class="code" href="#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> projMatrix;</div>
<div class="line">    view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a62a9c2eb33aec66f3f92e02657c5b341">projectionMatrix</a>(projMatrix);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> modelViewMatrix;</div>
<div class="line">    view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a32e07853a952c88e39d32d5c27b8db3a">modelViewMatrix</a>(modelViewMatrix);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> localToNDC = modelViewMatrix * projMatrix;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a3cea85bd9127b51d9ff35de2ffc9ca33">M3dView::LightingMode</a> lightingMode;</div>
<div class="line">    view.<a name="a127"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a81510d35bc4111a82aeb9eed2fd1e1d3">getLightingMode</a>(lightingMode);</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lightCount;</div>
<div class="line">    view.<a name="a128"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a6d7dd7077570a84fb10857346d4dfabb">getLightCount</a>(lightCount);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> noLightSoDrawAsBlack =</div>
<div class="line">        (lightingMode == <a name="a129"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a3cea85bd9127b51d9ff35de2ffc9ca33ae053ea6be7bc791c1fa1bc8aec185892">M3dView::kLightAll</a> ||</div>
<div class="line">         lightingMode == <a name="a130"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a3cea85bd9127b51d9ff35de2ffc9ca33a66faf3b4c1951230f846bf1ce6b8b479">M3dView::kLightSelected</a> ||</div>
<div class="line">         lightingMode == <a name="a131"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a3cea85bd9127b51d9ff35de2ffc9ca33ac3e4474296a0fbfe1de021d341f85d70">M3dView::kLightActive</a>)</div>
<div class="line">        &amp;&amp; lightCount == 0;</div>
<div class="line">    </div>
<div class="line">    view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a0e318e5634c7aaf31c4eb7232d2013d4">beginGL</a>(); </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Setup the OpenGL state as necessary</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// The most straightforward way to ensure that the OpenGL</span></div>
<div class="line">        <span class="comment">// material parameters are properly restored after drawing is</span></div>
<div class="line">        <span class="comment">// to use push/pop attrib as we have no easy of knowing the</span></div>
<div class="line">        <span class="comment">// current values of all the parameters.</span></div>
<div class="line">        gGLFT-&gt;glPushAttrib(MGL_LIGHTING_BIT);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Reset specular and emission materials as we only display diffuse color.</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> sBlack[4] = {0.0f, 0.0f, 0.0f, 1.0f};</div>
<div class="line">            gGLFT-&gt;glMaterialfv(MGL_FRONT_AND_BACK, MGL_SPECULAR, sBlack);</div>
<div class="line">            gGLFT-&gt;glMaterialfv(MGL_FRONT_AND_BACK, MGL_EMISSION, sBlack);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        DrawShadedState::TransparentPruneType transparentPrune =</div>
<div class="line">                DrawShadedState::kPruneTransparent;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> isTransparent = request.<a name="a132"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a9af8d1d3490a3fa7779927df11c7c039">isTransparent</a>();</div>
<div class="line">        <span class="keywordflow">if</span> (isTransparent) {</div>
<div class="line">            <span class="comment">// We use premultiplied alpha</span></div>
<div class="line">            gGLFT-&gt;glBlendFunc(MGL_ONE, MGL_ONE_MINUS_SRC_ALPHA);</div>
<div class="line">            transparentPrune = DrawShadedState::kPruneOpaque;</div>
<div class="line"></div>
<div class="line">            gGLFT-&gt;glDepthMask( <span class="keyword">false</span> );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> defaultDiffuseColor;</div>
<div class="line">        DrawShadedTypes::ColorType colorType = DrawShadedTypes::kSubNodeColor;</div>
<div class="line">        <span class="keywordflow">if</span> (view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#ae4b4678ef01f58e0ef190c045559f9ae">usingDefaultMaterial</a>()) {</div>
<div class="line">            <span class="keywordflow">if</span> (!noLightSoDrawAsBlack) {</div>
<div class="line">                <a class="code" href="#!/url=./cpp_ref/class_m_material.html">MMaterial</a> material = request.<a name="a133"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#ad8d3426de607892e954c7698c52a8373">material</a>();</div>
<div class="line">                material.<a name="a134"></a><a class="code" href="#!/url=./cpp_ref/class_m_material.html#a5dd0244ce46c3c8593aa06e390f1cd19">setMaterial</a>(request.<a name="a135"></a><a class="code" href="#!/url=./cpp_ref/class_m_draw_request.html#a29c5fd43c9e42c958ae3455eba8e3e8e">multiPath</a>(), isTransparent);</div>
<div class="line">                material.<a name="a136"></a><a class="code" href="#!/url=./cpp_ref/class_m_material.html#a861059e539c057e505cb67a16e1bf4ab">getDiffuse</a>(defaultDiffuseColor);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// We must ignore the alpha channel of the default</span></div>
<div class="line">            <span class="comment">// material when the option &quot;Use default material&quot; is</span></div>
<div class="line">            <span class="comment">// selected.</span></div>
<div class="line">            defaultDiffuseColor[3] = 1.0f;</div>
<div class="line">            transparentPrune = DrawShadedState::kPruneNone;</div>
<div class="line">            colorType = DrawShadedTypes::kDefaultColor;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a7ff6ccd4600c5e1d33e05fd734c97d66">xray</a>()) {</div>
<div class="line">            transparentPrune = DrawShadedState::kPruneNone;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (noLightSoDrawAsBlack) {</div>
<div class="line">                defaultDiffuseColor = <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>(0, 0, 0, 0.3f);</div>
<div class="line">                colorType           = DrawShadedTypes::kDefaultColor;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                colorType = DrawShadedTypes::kXrayColor;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noLightSoDrawAsBlack) {</div>
<div class="line">            colorType = DrawShadedTypes::kBlackColor;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (noLightSoDrawAsBlack) {</div>
<div class="line">            <span class="comment">// The default viewport leaves an unrelated light enabled</span></div>
<div class="line">            <span class="comment">// in the OpenGL state even when there are no light in the</span></div>
<div class="line">            <span class="comment">// scene. We therefore manually disable lighting in that</span></div>
<div class="line">            <span class="comment">// case.</span></div>
<div class="line">            gGLFT-&gt;glDisable(MGL_LIGHTING);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> depthOffsetWasEnabled = gGLFT-&gt;glIsEnabled(MGL_POLYGON_OFFSET_FILL);</div>
<div class="line">        <span class="keywordflow">if</span> (depthOffset &amp;&amp; !depthOffsetWasEnabled) {</div>
<div class="line">            <span class="comment">// Viewport has set the offset, just enable it</span></div>
<div class="line">            gGLFT-&gt;glEnable(MGL_POLYGON_OFFSET_FILL);  </div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// We will override the material color for each individual sub-nodes.!</span></div>
<div class="line">        gGLFT-&gt;glColorMaterial(MGL_FRONT_AND_BACK, MGL_AMBIENT_AND_DIFFUSE);</div>
<div class="line">        gGLFT-&gt;glEnable(MGL_COLOR_MATERIAL) ;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// On Geforce cards, we emulate two-sided lighting by drawing</span></div>
<div class="line">        <span class="comment">// triangles twice because two-sided lighting is 10 times</span></div>
<div class="line">        <span class="comment">// slower than single-sided lighting.</span></div>
<div class="line">        <span class="keywordtype">bool</span> needEmulateTwoSidedLighting = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (Config::emulateTwoSidedLighting()) {</div>
<div class="line">            <span class="comment">// Query face-culling and two-sided lighting state</span></div>
<div class="line">            <span class="keywordtype">bool</span>  cullFace = (gGLFT-&gt;glIsEnabled(MGL_CULL_FACE) == MGL_TRUE);</div>
<div class="line">            MGLint twoSidedLighting = MGL_FALSE;</div>
<div class="line">            gGLFT-&gt;glGetIntegerv(MGL_LIGHT_MODEL_TWO_SIDE, &amp;twoSidedLighting);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Need to emulate two-sided lighting when back-face</span></div>
<div class="line">            <span class="comment">// culling is off (i.e. drawing both sides) and two-sided</span></div>
<div class="line">            <span class="comment">// lLighting is on.</span></div>
<div class="line">            needEmulateTwoSidedLighting = (!cullFace &amp;&amp; twoSidedLighting);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        {</div>
<div class="line">            Frustum frustum(localToNDC.<a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a8ca5ebc404566e2c4a16d4754772e082">inverse</a>());</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> xform(modelViewMatrix);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (needEmulateTwoSidedLighting) {</div>
<div class="line">                gGLFT-&gt;glEnable(MGL_CULL_FACE);</div>
<div class="line">                gGLFT-&gt;glLightModeli(MGL_LIGHT_MODEL_TWO_SIDE, 0);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// first, draw with back-face culling</span></div>
<div class="line">                {</div>
<div class="line">                    gGLFT-&gt;glCullFace(MGL_FRONT);</div>
<div class="line">                    DrawShadedState state(frustum, </div>
<div class="line">                                          seconds, </div>
<div class="line">                                          transparentPrune,</div>
<div class="line">                                          colorType,</div>
<div class="line">                                          defaultDiffuseColor,</div>
<div class="line">                                          DrawShadedState::kBackNormals);</div>
<div class="line">                    DrawShadedTraversal traveral(</div>
<div class="line">                        state, xform, xform.det3x3() &lt; 0.0, Frustum::kUnknown);</div>
<div class="line">                    rootNode-&gt;accept(traveral);</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// then, draw with front-face culling</span></div>
<div class="line">                {</div>
<div class="line">                    gGLFT-&gt;glCullFace(MGL_BACK);</div>
<div class="line">                    DrawShadedState state(frustum, </div>
<div class="line">                                          seconds, </div>
<div class="line">                                          transparentPrune,</div>
<div class="line">                                          colorType,</div>
<div class="line">                                          defaultDiffuseColor,</div>
<div class="line">                                          DrawShadedState::kFrontNormals);</div>
<div class="line">                    DrawShadedTraversal traveral(</div>
<div class="line">                        state, xform, xform.det3x3() &lt; 0.0, Frustum::kUnknown);</div>
<div class="line">                    rootNode-&gt;accept(traveral);</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// restore the OpenGL state</span></div>
<div class="line">                gGLFT-&gt;glDisable(MGL_CULL_FACE);</div>
<div class="line">                gGLFT-&gt;glLightModeli(MGL_LIGHT_MODEL_TWO_SIDE, 1);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                DrawShadedState state(frustum, </div>
<div class="line">                                      seconds, </div>
<div class="line">                                      transparentPrune,</div>
<div class="line">                                      colorType,</div>
<div class="line">                                      defaultDiffuseColor,</div>
<div class="line">                                      DrawShadedState::kFrontNormals);</div>
<div class="line">                DrawShadedTraversal traveral(</div>
<div class="line">                    state, xform, xform.det3x3() &lt; 0.0, Frustum::kUnknown);</div>
<div class="line">                rootNode-&gt;accept(traveral);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Restore the state</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span> (isTransparent) {</div>
<div class="line">            gGLFT-&gt;glDepthMask( <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line">            gGLFT-&gt;glBlendFunc(MGL_SRC_ALPHA, MGL_ONE_MINUS_SRC_ALPHA);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (depthOffset &amp;&amp; !depthOffsetWasEnabled) {</div>
<div class="line">            gGLFT-&gt;glDisable(MGL_POLYGON_OFFSET_FILL);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        gGLFT-&gt;glFrontFace(MGL_CCW);</div>
<div class="line"></div>
<div class="line">        gGLFT-&gt;glPopAttrib();</div>
<div class="line">    }</div>
<div class="line">    view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#ab810c5a46d728df70ff5f44b604559f4">endGL</a>(); </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns the point in world space corresponding to a given</span></div>
<div class="line"><span class="comment">// depth. The depth is specified as 0.0 for the near clipping plane and</span></div>
<div class="line"><span class="comment">// 1.0 for the far clipping plane.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> ShapeUI::getPointAtDepth(</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_select_info.html">MSelectInfo</a> &amp;selectInfo,</div>
<div class="line">    <span class="keywordtype">double</span>     depth)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> cameraPath;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html">M3dView</a> view = selectInfo.<a name="a137"></a><a class="code" href="#!/url=./cpp_ref/class_m_select_info.html#a77faa45e5c6d7563829fb86054d97dd2">view</a>();</div>
<div class="line"></div>
<div class="line">    view.<a name="a138"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a5e6ea41ec1bab5ed980b2ddffe398a73">getCamera</a>(cameraPath);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    <a name="_a139"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_camera.html">MFnCamera</a> camera(cameraPath, &amp;status);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Ortho cam maps [0,1] to [near,far] linearly</span></div>
<div class="line">    <span class="comment">// persp cam has non linear z:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//        fp np</span></div>
<div class="line">    <span class="comment">// -------------------</span></div>
<div class="line">    <span class="comment">// 1. fp - d fp + d np</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Maps [0,1] -&gt; [np,fp]. Then using linear mapping to get back to</span></div>
<div class="line">    <span class="comment">// [0,1] gives.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//       d np</span></div>
<div class="line">    <span class="comment">// ----------------  for linear mapped distance</span></div>
<div class="line">    <span class="comment">// fp - d fp + d np</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!camera.isOrtho())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">double</span> np = camera.nearClippingPlane();</div>
<div class="line">        <span class="keywordtype">double</span> fp = camera.farClippingPlane();</div>
<div class="line"></div>
<div class="line">        depth *= np / (fp - depth * (fp - np));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a>     cursor;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_vector.html">MVector</a> rayVector;</div>
<div class="line">    selectInfo.<a name="a140"></a><a class="code" href="#!/url=./cpp_ref/class_m_select_info.html#a877518dc1c6584ae1f7fc65cf0750dd5">getLocalRay</a>(cursor, rayVector);</div>
<div class="line">    cursor = cursor * selectInfo.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a29c5fd43c9e42c958ae3455eba8e3e8e">multiPath</a>().<a name="a141"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html#a229ff721947ec3ded47b5a071a7311ec">inclusiveMatrix</a>();</div>
<div class="line">    <span class="keywordtype">short</span> x,y;</div>
<div class="line">    view.<a name="a142"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a187f0712a1a973e26c87fc6dba9acede">worldToView</a>(cursor, x, y);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> res, neardb, fardb;</div>
<div class="line">    view.<a name="a143"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a0accd26d35f3e627c34f521085366476">viewToWorld</a>(x,y, neardb, fardb);</div>
<div class="line">    res = neardb + depth*(fardb-neardb);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeUI::select(</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_select_info.html">MSelectInfo</a> &amp;selectInfo,</div>
<div class="line">    <a name="_a144"></a><a class="code" href="#!/url=./cpp_ref/class_m_selection_list.html">MSelectionList</a> &amp;selectionList,</div>
<div class="line">    <a name="_a145"></a><a class="code" href="#!/url=./cpp_ref/class_m_point_array.html">MPointArray</a> &amp;worldSpaceSelectPts )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Initialize GL Function Table.</span></div>
<div class="line">    InitializeGLFT();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html">MSelectionMask</a> mask(ShapeNode::selectionMaskName);</div>
<div class="line">    <span class="keywordflow">if</span> (!selectInfo.<a name="a146"></a><a class="code" href="#!/url=./cpp_ref/class_m_select_info.html#a9fbfd46de4d0417a412e5a9ba1a9294f">selectable</a>(mask)){</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check plugin display filter. Invisible geometry can&#39;t be selected</span></div>
<div class="line">    <span class="keywordflow">if</span> (!selectInfo.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a083b286557d3c316d9c7652ebae4800b">pluginObjectDisplayStatus</a>(Config::kDisplayFilter)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the geometry information</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    ShapeNode* node = (ShapeNode*)surfaceShape();</div>
<div class="line">    <span class="keyword">const</span> SubNode::Ptr rootNode = node-&gt;getCachedGeometry();</div>
<div class="line">    <span class="keywordflow">if</span> (!rootNode) { <span class="keywordflow">return</span> <span class="keyword">false</span>;}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> seconds = <a class="code" href="#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> boundingboxSelection =</div>
<div class="line">        (<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a1b68f8823b8e275a4b548fdd27263e8aa74c3784e844e54dab272e794fa6bcaa9">M3dView::kBoundingBox</a> == selectInfo.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a16a1754d1de4e7ad544766e128fdfd2a">displayStyle</a>());</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> wireframeSelection =</div>
<div class="line">        (<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a1b68f8823b8e275a4b548fdd27263e8aa53c5241bb4e72f6c9547de918125d068">M3dView::kWireFrame</a> == selectInfo.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a16a1754d1de4e7ad544766e128fdfd2a">displayStyle</a>() ||</div>
<div class="line">         !selectInfo.<a name="a147"></a><a class="code" href="#!/url=./cpp_ref/class_m_select_info.html#abcff67903287e6a1bcc8797b4c8da413">singleSelection</a>());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If all the model editors are Viewport2.0, we will not use VBO for select</span></div>
<div class="line">    <span class="comment">// because VBO will double the memory consumption.</span></div>
<div class="line">    VBOProxy::VBOMode vboMode = VBOProxy::kUseVBOIfPossible;</div>
<div class="line">    <span class="keywordflow">if</span> (Config::vp2OverrideAPI() != Config::kMPxDrawOverride) {</div>
<div class="line">        vboMode = (sModelEditorState == kViewport2Only) ?</div>
<div class="line">            VBOProxy::kDontUseVBO : VBOProxy::kUseVBOIfPossible;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// We select base on edges if the object is displayed in wireframe</span></div>
<div class="line">    <span class="comment">// mode or if we are performing a marquee selection. Else, we</span></div>
<div class="line">    <span class="comment">// select using the object faces (i.e. single-click selection in</span></div>
<div class="line">    <span class="comment">// shaded mode).</span></div>
<div class="line">    GLfloat minZ;</div>
<div class="line">    {</div>
<div class="line">        Select* selector;</div>
<div class="line">        NbPrimitivesVisitor nbPrimitives(seconds);</div>
<div class="line">        rootNode-&gt;accept(nbPrimitives);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (boundingboxSelection) {</div>
<div class="line">            <span class="comment">// We are only drawing 12 edges so we only use GL picking selection.</span></div>
<div class="line">            selector = <span class="keyword">new</span> GLPickingSelect(selectInfo);</div>
<div class="line"></div>
<div class="line">            selector-&gt;processBoundingBox(rootNode, seconds);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wireframeSelection) {</div>
<div class="line">            <span class="keywordflow">if</span> (nbPrimitives.numWires() &lt; Config::openGLPickingWireframeThreshold()) </div>
<div class="line">                selector = <span class="keyword">new</span> GLPickingSelect(selectInfo);</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                selector = <span class="keyword">new</span> RasterSelect(selectInfo);</div>
<div class="line">        </div>
<div class="line">            selector-&gt;processEdges(rootNode, seconds, nbPrimitives.numWires(), vboMode);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (nbPrimitives.numTriangles() &lt; Config::openGLPickingSurfaceThreshold())</div>
<div class="line">                selector = <span class="keyword">new</span> GLPickingSelect(selectInfo);</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                selector = <span class="keyword">new</span> RasterSelect(selectInfo);</div>
<div class="line"></div>
<div class="line">            selector-&gt;processTriangles(rootNode, seconds, nbPrimitives.numTriangles(), vboMode);</div>
<div class="line">        }</div>
<div class="line">        selector-&gt;end();</div>
<div class="line">        minZ = selector-&gt;minZ();</div>
<div class="line">        <span class="keyword">delete</span> selector;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> selected = (minZ &lt;= 1.0f);</div>
<div class="line">    <span class="keywordflow">if</span> ( selected ) {</div>
<div class="line">        <span class="comment">// Add the selected item to the selection list</span></div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_selection_list.html">MSelectionList</a> selectionItem;</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> path = selectInfo.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a29c5fd43c9e42c958ae3455eba8e3e8e">multiPath</a>();</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> lStatus = path.<a name="a148"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html#ac71eca2b78b8cfc088adc9af6f851dfd">pop</a>();</div>
<div class="line">            <span class="keywordflow">while</span> (lStatus == <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (path.<a name="a149"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html#abea5b1e5057d0e1088877be2573be47b">hasFn</a>(<a name="a150"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7adafa274206df602835f0f22ae887e126">MFn::kTransform</a>))</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    lStatus = path.<a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html#ac71eca2b78b8cfc088adc9af6f851dfd">pop</a>();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            selectionItem.<a name="a151"></a><a class="code" href="#!/url=./cpp_ref/class_m_selection_list.html#a23929aeafb29672f2652128eac9c4dec">add</a>(path);</div>
<div class="line">        }        </div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> worldSpaceselectionPoint =</div>
<div class="line">            getPointAtDepth(selectInfo, minZ);</div>
<div class="line"></div>
<div class="line">        selectInfo.<a name="a152"></a><a class="code" href="#!/url=./cpp_ref/class_m_select_info.html#aa32cdc7111f8356802a04413a19c80a7">addSelection</a>(</div>
<div class="line">            selectionItem,</div>
<div class="line">            worldSpaceselectionPoint,</div>
<div class="line">            selectionList, worldSpaceSelectPts,</div>
<div class="line">            mask, <span class="keyword">false</span> );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> selected;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShapeUI::snap(<a class="code" href="#!/url=./cpp_ref/class_m_select_info.html">MSelectInfo</a>&amp; snapInfo)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Initialize GL Function Table.</span></div>
<div class="line">    InitializeGLFT();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check plugin display filter. Invisible geometry can&#39;t be snapped</span></div>
<div class="line">    <span class="keywordflow">if</span> (!snapInfo.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a083b286557d3c316d9c7652ebae4800b">pluginObjectDisplayStatus</a>(Config::kDisplayFilter)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the geometry information</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    ShapeNode* node = (ShapeNode*)surfaceShape();</div>
<div class="line">    <span class="keyword">const</span> SubNode::Ptr rootNode = node-&gt;getCachedGeometry();</div>
<div class="line">    <span class="keywordflow">if</span> (!rootNode) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> seconds = <a class="code" href="#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m3d_view.html">M3dView</a> view = snapInfo.<a class="code" href="#!/url=./cpp_ref/class_m_select_info.html#a77faa45e5c6d7563829fb86054d97dd2">view</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp; path = snapInfo.<a class="code" href="#!/url=./cpp_ref/class_m_draw_info.html#a29c5fd43c9e42c958ae3455eba8e3e8e">multiPath</a>();</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> inclusiveMatrix = path.<a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html#a229ff721947ec3ded47b5a071a7311ec">inclusiveMatrix</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> projMatrix;</div>
<div class="line">    view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a62a9c2eb33aec66f3f92e02657c5b341">projectionMatrix</a>(projMatrix);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> modelViewMatrix;</div>
<div class="line">    view.<a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#a32e07853a952c88e39d32d5c27b8db3a">modelViewMatrix</a>(modelViewMatrix);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vpx, vpy, vpw, vph;</div>
<div class="line">    view.<a name="a153"></a><a class="code" href="#!/url=./cpp_ref/class_m3d_view.html#abf198a1eaaec64f89430b2bb7cca959d">viewport</a>(vpx, vpy, vpw, vph);</div>
<div class="line">    <span class="keywordtype">double</span> w_over_two = vpw * 0.5;</div>
<div class="line">    <span class="keywordtype">double</span> h_over_two = vph * 0.5;</div>
<div class="line">    <span class="keywordtype">double</span> vpoff_x = w_over_two + vpx;</div>
<div class="line">    <span class="keywordtype">double</span> vpoff_y = h_over_two + vpy;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> ndcToPort;</div>
<div class="line">    ndcToPort(0,0) = w_over_two;</div>
<div class="line">    ndcToPort(1,1) = h_over_two;</div>
<div class="line">    ndcToPort(2,2) = 0.5;</div>
<div class="line">    ndcToPort(3,0) = vpoff_x;</div>
<div class="line">    ndcToPort(3,1) = vpoff_y;</div>
<div class="line">    ndcToPort(3,2) = 0.5;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> localToNDC  = modelViewMatrix * projMatrix;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_matrix.html">MMatrix</a> localToPort = localToNDC * ndcToPort;</div>
<div class="line"></div>
<div class="line">    Frustum frustum(localToNDC.<a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a8ca5ebc404566e2c4a16d4754772e082">inverse</a>());</div>
<div class="line">    </div>
<div class="line">    SnapTraversalState state(</div>
<div class="line">        frustum, seconds, localToPort, inclusiveMatrix, snapInfo);</div>
<div class="line">    SnapTraversal visitor(state, <a name="a154"></a><a class="code" href="#!/url=./cpp_ref/class_m_matrix.html#a85de986c9f953535d185c6780cecb77e">MMatrix::identity</a>, <span class="keyword">false</span>, Frustum::kUnknown);</div>
<div class="line">    rootNode-&gt;accept(visitor);</div>
<div class="line">    <span class="keywordflow">return</span> state.selected();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::getExternalContent(<a name="_a155"></a><a class="code" href="#!/url=./cpp_ref/class_m_external_content_info_table.html">MExternalContentInfoTable</a>&amp; table)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    addExternalContentForFileAttr(table, aCacheFileName);</div>
<div class="line">    <a name="a156"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#abfc494661ea0f7f957a9e437cebb2642">MPxSurfaceShape::getExternalContent</a>(table);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeNode::setExternalContent(<span class="keyword">const</span> <a name="_a157"></a><a class="code" href="#!/url=./cpp_ref/class_m_external_content_location_table.html">MExternalContentLocationTable</a>&amp; table)</div>
<div class="line">{</div>
<div class="line">    setExternalContentForFileAttr(aCacheFileName, table);</div>
<div class="line">    <a name="a158"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a6f6412d2df249be356a8f2cf5844b763">MPxSurfaceShape::setExternalContent</a>(table);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div><br></div>
   </div></body>
</html>

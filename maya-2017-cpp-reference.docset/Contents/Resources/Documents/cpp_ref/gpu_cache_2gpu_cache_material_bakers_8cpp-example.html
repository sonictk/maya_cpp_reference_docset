<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="product" content="MAYAUL"><meta name="release" content="2017"><meta name="book" content="Developer"><meta name="created" content="2016-06-16"><meta name="topicid" content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887"><meta name="topic-type" content="concept">
      <title>gpuCache/gpuCacheMaterialBakers.cpp</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2gpu_cache_material_bakers_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>gpuCache/gpuCacheMaterialBakers.cpp</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">gpuCache/gpuCacheMaterialBakers.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheMaterialBakers.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheMaterialNodes.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheShapeNode.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheUtil.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDagNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNumericData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPlugArray.h&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line"><span class="comment">// Bakers for concrete materials.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">namespace </span>MaterialBakers {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This class is the base class for all shading node bakers.</span></div>
<div class="line">    <span class="keyword">class </span>BaseMaterialNodeBaker : boost::noncopyable</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> boost::shared_ptr&lt;BaseMaterialNodeBaker&gt; Ptr;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Create a material baker for the given DG node.</span></div>
<div class="line">        <span class="keyword">static</span> BaseMaterialNodeBaker::Ptr create(</div>
<div class="line">            <span class="keyword">const</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp;         node,</div>
<div class="line">            std::set&lt;std::string&gt;* traversedNodes);</div>
<div class="line"></div>
<div class="line">        BaseMaterialNodeBaker(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">            : fNode(node), fTraversedNodes(NULL)</div>
<div class="line">        {}</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">virtual</span> ~BaseMaterialNodeBaker()</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Create the baked material node and collect the </span></div>
<div class="line">        <span class="comment">// properties and plugs for sampling.</span></div>
<div class="line">        <span class="keywordtype">void</span> setupNetwork()</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// There are virtual function calls so we can&#39;t do this in c&#39;tor.</span></div>
<div class="line">            fBakedNode = createNode(fNode.name());</div>
<div class="line">            assert(fBakedNode);</div>
<div class="line"></div>
<div class="line">            collectPlugsAndProperties();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample the shading node at the given time.</span></div>
<div class="line">        <span class="keywordtype">void</span> sample(<span class="keyword">const</span> <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time)</div>
<div class="line">        {</div>
<div class="line">            assert(fBakedNode); </div>
<div class="line">            <span class="comment">// Loop over all channels.</span></div>
<div class="line">            BOOST_FOREACH (Channel&amp; channel, fChannels) {</div>
<div class="line">                <span class="comment">// Sample the plug and add the sample to the property</span></div>
<div class="line">                <span class="keywordflow">switch</span> (channel.prop()-&gt;type()) {</div>
<div class="line">                <span class="keywordflow">case</span> MaterialProperty::kBool:</div>
<div class="line">                    sampleBoolPlug(time, channel.plug(), channel.prop());</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> MaterialProperty::kInt32:</div>
<div class="line">                    sampleInt32Plug(time, channel.plug(), channel.prop());</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> MaterialProperty::kFloat:</div>
<div class="line">                    sampleFloatPlug(time, channel.plug(), channel.prop());</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> MaterialProperty::kFloat2:</div>
<div class="line">                    sampleFloat2Plug(time, channel.plug(), channel.prop());</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> MaterialProperty::kFloat3:</div>
<div class="line">                    sampleFloat3Plug(time, channel.plug(), channel.prop());</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> MaterialProperty::kRGB:</div>
<div class="line">                    sampleFloat3PlugAsColor(time, channel.plug(), channel.prop());</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> MaterialProperty::kString:</div>
<div class="line">                    sampleStringPlug(time, channel.plug(), channel.prop());</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">default</span>:</div>
<div class="line">                    assert(0); <span class="comment">// the data type is not implemented!</span></div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Recursively sample source nodes.</span></div>
<div class="line">                BaseMaterialNodeBaker::Ptr&amp; srcBaker = channel.srcBaker();</div>
<div class="line">                <span class="keywordflow">if</span> (srcBaker) {</div>
<div class="line">                    srcBaker-&gt;sample(time);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add the shading node to the graph.</span></div>
<div class="line">        <span class="comment">// The graph will have the ownership of all the shading nodes.</span></div>
<div class="line">        <span class="keywordtype">void</span> addToGraph(MaterialGraph::MPtr&amp; graph)</div>
<div class="line">        {</div>
<div class="line">            assert(fBakedNode);  <span class="comment">// created by derived classes</span></div>
<div class="line">            <span class="keywordflow">if</span> (fBakedNode) {</div>
<div class="line">                graph-&gt;addNode(fBakedNode);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Recursively add the connected shading nodes</span></div>
<div class="line">            BOOST_FOREACH (Channel&amp; channel, fChannels) {</div>
<div class="line">                BaseMaterialNodeBaker::Ptr&amp; srcBaker = channel.srcBaker();</div>
<div class="line">                <span class="keywordflow">if</span> (srcBaker) {</div>
<div class="line">                    srcBaker-&gt;addToGraph(graph);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Connect the shading nodes.</span></div>
<div class="line">        <span class="keywordtype">void</span> connect()</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Loop over all the channels and connect to its source node.</span></div>
<div class="line">            BOOST_FOREACH (Channel&amp; channel, fChannels) {</div>
<div class="line">                MaterialProperty::MPtr     dstProp  = channel.prop();</div>
<div class="line">                BaseMaterialNodeBaker::Ptr srcBaker = channel.srcBaker();</div>
<div class="line">                MaterialProperty::MPtr     srcProp  = channel.srcProp();</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Connect to srcNode.srcProp</span></div>
<div class="line">                <span class="keywordflow">if</span> (dstProp &amp;&amp; srcBaker &amp;&amp; srcProp) {</div>
<div class="line">                    MaterialNode::Ptr srcNode = srcBaker-&gt;bakedNode();</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> (srcNode) {</div>
<div class="line">                        dstProp-&gt;connect(srcNode, srcProp);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Return the baked material node.</span></div>
<div class="line">        MaterialNode::MPtr bakedNode()</div>
<div class="line">        { assert(fBakedNode); <span class="keywordflow">return</span> fBakedNode; }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="comment">// Override by derived classes.</span></div>
<div class="line">        <span class="keyword">virtual</span> MaterialNode::MPtr createNode(<span class="keyword">const</span> <a name="_a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; name) = 0;</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span>               collectPlugsAndProperties() = 0;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample a Maya bool plug</span></div>
<div class="line">        <span class="keywordtype">void</span> sampleBoolPlug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time, <span class="keyword">const</span> <a name="_a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, MaterialProperty::MPtr&amp; prop)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> timeInSeconds = time.<a name="a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a name="a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">bool</span> value = plug.<a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#aea1ddab8d4272d03146b3dad29be3af0">asBool</a>();</div>
<div class="line">            <span class="keywordflow">if</span> (prop-&gt;isDefault() || prop-&gt;asBool(timeInSeconds) != value) {</div>
<div class="line">                prop-&gt;setBool(timeInSeconds, value);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample a Maya int plug</span></div>
<div class="line">        <span class="keywordtype">void</span> sampleInt32Plug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, MaterialProperty::MPtr&amp; prop)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> timeInSeconds = time.<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">int</span> value = plug.<a name="a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a22f1eaa836ac421f53d0a745e8eb2cd8">asInt</a>();</div>
<div class="line">            <span class="keywordflow">if</span> (prop-&gt;isDefault() || prop-&gt;asInt32(timeInSeconds) != value) {</div>
<div class="line">                prop-&gt;setInt32(timeInSeconds, value);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample a Maya float plug</span></div>
<div class="line">        <span class="keywordtype">void</span> sampleFloatPlug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, MaterialProperty::MPtr&amp; prop)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> timeInSeconds = time.<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">float</span> value = plug.<a name="a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a958d457bf7cf14cbbc689ec670aef0f5">asFloat</a>();</div>
<div class="line">            <span class="keywordflow">if</span> (prop-&gt;isDefault() || prop-&gt;asFloat(timeInSeconds) != value) {</div>
<div class="line">                prop-&gt;setFloat(timeInSeconds, value);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample a Maya (float,float) plug</span></div>
<div class="line">        <span class="keywordtype">void</span> sampleFloat2Plug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, MaterialProperty::MPtr&amp; prop)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> timeInSeconds = time.<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> data = plug.<a name="a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a44f3e668994b66b89ceeeafc9d640a2c">asMObject</a>();</div>
<div class="line">            assert(data.<a name="a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a11"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a12074ae4ecdf28e10a09c28af61942c0">MFn::kNumericData</a>));</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">float</span> value[2], prev[2];</div>
<div class="line">            <a name="_a12"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_data.html">MFnNumericData</a>(data).<a name="a13"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_data.html#a6a9240f3a50508d68b447d21cfdb48e3">getData2Float</a>(value[0], value[1]);</div>
<div class="line">            prop-&gt;asFloat2(timeInSeconds, prev[0], prev[1]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (prop-&gt;isDefault() || value[0] != prev[0] || value[1] != prev[1]) {</div>
<div class="line">                prop-&gt;setFloat2(timeInSeconds, value[0], value[1]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample a Maya (float,float,float) plug</span></div>
<div class="line">        <span class="keywordtype">void</span> sampleFloat3Plug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, MaterialProperty::MPtr&amp; prop)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> timeInSeconds = time.<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> data = plug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a44f3e668994b66b89ceeeafc9d640a2c">asMObject</a>();</div>
<div class="line">            assert(data.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a12074ae4ecdf28e10a09c28af61942c0">MFn::kNumericData</a>));</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">float</span> value[3], prev[3];</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_data.html">MFnNumericData</a>(data).<a name="a14"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_data.html#a1ed1d66504a91f683f126491d2f6ffc8">getData3Float</a>(value[0], value[1], value[2]);</div>
<div class="line">            prop-&gt;asFloat3(timeInSeconds, prev[0], prev[1], prev[2]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (prop-&gt;isDefault() || value[0] != prev[0] || value[1] != prev[1] || value[2] != prev[2]) {</div>
<div class="line">                prop-&gt;setFloat3(timeInSeconds, value[0], value[1], value[2]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample a Maya (float,float,float) plug as MColor</span></div>
<div class="line">        <span class="keywordtype">void</span> sampleFloat3PlugAsColor(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, MaterialProperty::MPtr prop)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> timeInSeconds = time.<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> data = plug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a44f3e668994b66b89ceeeafc9d640a2c">asMObject</a>();</div>
<div class="line">            assert(data.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a12074ae4ecdf28e10a09c28af61942c0">MFn::kNumericData</a>));</div>
<div class="line"></div>
<div class="line">            <a name="_a15"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> value;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_data.html">MFnNumericData</a>(data).<a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_data.html#a1ed1d66504a91f683f126491d2f6ffc8">getData3Float</a>(value.r, value.g, value.b);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (prop-&gt;isDefault() || value != prop-&gt;asColor(timeInSeconds)) {</div>
<div class="line">                prop-&gt;setColor(timeInSeconds, value);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sample a Maya MString plug</span></div>
<div class="line">        <span class="keywordtype">void</span> sampleStringPlug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, MaterialProperty::MPtr&amp; prop)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> timeInSeconds = time.<a class="code" href="#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> value = plug.<a name="a16"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a62862fba0a492c17b4d2836b18630181">asString</a>();</div>
<div class="line">            <span class="keywordflow">if</span> (prop-&gt;isDefault() || value != prop-&gt;asString(timeInSeconds)) {</div>
<div class="line">                prop-&gt;setString(timeInSeconds, value);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Register the plug and its source plugs for sampling.</span></div>
<div class="line">        <span class="keywordtype">void</span> sampleChannel(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; name, MaterialProperty::MPtr&amp; prop)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Find the plug by its name</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> plug = fNode.findPlug(name, <span class="keyword">false</span>);</div>
<div class="line">            assert(!plug.<a name="a17"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a1c18142e8f09680711f472aa2ddf8ac6">isNull</a>());</div>
<div class="line">            assert(prop);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!plug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a1c18142e8f09680711f472aa2ddf8ac6">isNull</a>() &amp;&amp; prop) {</div>
<div class="line">                <span class="comment">// Track the connection to the source node.</span></div>
<div class="line">                BaseMaterialNodeBaker::Ptr srcBaker;</div>
<div class="line">                MaterialProperty::MPtr     srcProp;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (plug.<a name="a18"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a2914a42ceb556760af045852f1f57a08">isDestination</a>()) {</div>
<div class="line">                    <span class="comment">// Find the source node.</span></div>
<div class="line">                    <a name="_a19"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html">MPlugArray</a> plugArray;</div>
<div class="line">                    plug.<a name="a20"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a3727c18c58fc5ba8be5fb2582b5d06f1">connectedTo</a>(plugArray, <span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="line">                    assert(plugArray.<a name="a21"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 1);</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> (plugArray.<a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0) {</div>
<div class="line">                        <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> srcPlug = plugArray[0];</div>
<div class="line">                        assert(!srcPlug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a1c18142e8f09680711f472aa2ddf8ac6">isNull</a>());</div>
<div class="line"></div>
<div class="line">                        <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> srcNode = srcPlug.<a name="a22"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ad1aa507eb8e63e89e8d46a0abc18aa8c">node</a>();</div>
<div class="line">                        assert(!srcNode.isNull());</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// If there is a circular connection, we stop tracking the</span></div>
<div class="line">                        <span class="comment">// connection to the source node. Instead, we sample the</span></div>
<div class="line">                        <span class="comment">// plug value directly.</span></div>
<div class="line">                        <span class="keywordflow">if</span> (!isTraversed(srcNode)) {</div>
<div class="line">                            <span class="comment">// Create the baker for the source node.</span></div>
<div class="line">                            srcBaker = BaseMaterialNodeBaker::create(srcNode, fTraversedNodes);</div>
<div class="line">                            <span class="keywordflow">if</span> (srcBaker) {</div>
<div class="line">                                <span class="comment">// We recognize the node. Find the source property.</span></div>
<div class="line">                                BOOST_FOREACH (Channel&amp; channel, srcBaker-&gt;fChannels) {</div>
<div class="line">                                    <span class="keywordflow">if</span> (channel.plug() == srcPlug) {</div>
<div class="line">                                        srcProp = channel.prop();</div>
<div class="line">                                        <span class="keywordflow">break</span>;</div>
<div class="line">                                    }</div>
<div class="line">                                }</div>
<div class="line"></div>
<div class="line">                                <span class="comment">// Can&#39;t find a source property.. give up.</span></div>
<div class="line">                                <span class="keywordflow">if</span> (!srcProp) {</div>
<div class="line">                                    srcBaker.reset();</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Add this channel to the list (with optional source baker)</span></div>
<div class="line">                fChannels.push_back(Channel(plug, prop, srcBaker, srcProp));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set the traversed nodes to prevent infinite recursive.</span></div>
<div class="line">        <span class="keywordtype">void</span> setTraversedNodes(std::set&lt;std::string&gt;* traversedNodes)</div>
<div class="line">        {</div>
<div class="line">            fTraversedNodes = traversedNodes;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Query if the node has been traversed.</span></div>
<div class="line">        <span class="keywordtype">bool</span> isTraversed(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">        {</div>
<div class="line">            std::string name = <a name="_a23"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html">MFnDependencyNode</a>(node).<a name="a24"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1">name</a>().<a name="a25"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">            assert(!name.empty());</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (fTraversedNodes &amp;&amp; (*fTraversedNodes).find(name) != (*fTraversedNodes).end()) {</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set the traversed state of the node.</span></div>
<div class="line">        <span class="keywordtype">void</span> setTraversed(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">        {</div>
<div class="line">            std::string name = <a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html">MFnDependencyNode</a>(node).<a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1">name</a>().<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">            assert(!name.empty());</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (fTraversedNodes) {</div>
<div class="line">                (*fTraversedNodes).insert(name);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keyword">class </span>Channel</div>
<div class="line">        {</div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            Channel(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp;                plug, </div>
<div class="line">                    MaterialProperty::MPtr&amp;     prop,</div>
<div class="line">                    BaseMaterialNodeBaker::Ptr&amp; srcBaker,</div>
<div class="line">                    MaterialProperty::MPtr&amp;     srcProp)</div>
<div class="line">                : fPlug(plug), </div>
<div class="line">                  fProp(prop), </div>
<div class="line">                  fSrcBaker(srcBaker), </div>
<div class="line">                  fSrcProp(srcProp)</div>
<div class="line">            {}</div>
<div class="line">            ~Channel() {}</div>
<div class="line"></div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp;                plug()     { <span class="keywordflow">return</span> fPlug; }</div>
<div class="line">            MaterialProperty::MPtr&amp;     prop()     { <span class="keywordflow">return</span> fProp; }</div>
<div class="line">            BaseMaterialNodeBaker::Ptr&amp; srcBaker() { <span class="keywordflow">return</span> fSrcBaker; }</div>
<div class="line">            MaterialProperty::MPtr&amp;     srcProp()  { <span class="keywordflow">return</span> fSrcProp; }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">private</span>:</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>                      fPlug;</div>
<div class="line">            MaterialProperty::MPtr     fProp;</div>
<div class="line">            BaseMaterialNodeBaker::Ptr fSrcBaker;</div>
<div class="line">            MaterialProperty::MPtr     fSrcProp;</div>
<div class="line">        };</div>
<div class="line">        std::vector&lt;Channel&gt; fChannels;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html">MFnDependencyNode</a>      fNode;</div>
<div class="line">        MaterialNode::MPtr     fBakedNode;</div>
<div class="line">        std::set&lt;std::string&gt;* fTraversedNodes;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>SurfaceMaterialBaker : <span class="keyword">public</span> BaseMaterialNodeBaker</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        SurfaceMaterialBaker(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">            : BaseMaterialNodeBaker(node) {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> MaterialNode::MPtr createNode(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; name)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> boost::make_shared&lt;SurfaceMaterial&gt;(name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> collectPlugsAndProperties()</div>
<div class="line">        {</div>
<div class="line">            boost::shared_ptr&lt;SurfaceMaterial&gt; surfaceMaterial = </div>
<div class="line">                boost::dynamic_pointer_cast&lt;SurfaceMaterial&gt;(bakedNode());</div>
<div class="line"></div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;outColor&quot;</span>,        surfaceMaterial-&gt;OutColor);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;outTransparency&quot;</span>, surfaceMaterial-&gt;OutTransparency);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>LambertBaker : <span class="keyword">public</span> SurfaceMaterialBaker</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        LambertBaker(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">            : SurfaceMaterialBaker(node) {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> MaterialNode::MPtr createNode(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; name)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> boost::make_shared&lt;LambertMaterial&gt;(name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> collectPlugsAndProperties()</div>
<div class="line">        {</div>
<div class="line">            SurfaceMaterialBaker::collectPlugsAndProperties();</div>
<div class="line"></div>
<div class="line">            boost::shared_ptr&lt;LambertMaterial&gt; lambert = </div>
<div class="line">                boost::dynamic_pointer_cast&lt;LambertMaterial&gt;(bakedNode());</div>
<div class="line"></div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;color&quot;</span>,             lambert-&gt;Color);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;transparency&quot;</span>,      lambert-&gt;Transparency);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;ambientColor&quot;</span>,      lambert-&gt;AmbientColor);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;incandescence&quot;</span>,     lambert-&gt;Incandescence);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;diffuse&quot;</span>,           lambert-&gt;Diffuse);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;translucence&quot;</span>,      lambert-&gt;Translucence);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;translucenceDepth&quot;</span>, lambert-&gt;TranslucenceDepth);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;translucenceFocus&quot;</span>, lambert-&gt;TranslucenceFocus);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;hideSource&quot;</span>,        lambert-&gt;HideSource);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;glowIntensity&quot;</span>,     lambert-&gt;GlowIntensity);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>PhongBaker : <span class="keyword">public</span> LambertBaker</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        PhongBaker(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">            : LambertBaker(node) {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> MaterialNode::MPtr createNode(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; name)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> boost::make_shared&lt;PhongMaterial&gt;(name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> collectPlugsAndProperties()</div>
<div class="line">        {</div>
<div class="line">            LambertBaker::collectPlugsAndProperties();</div>
<div class="line"></div>
<div class="line">            boost::shared_ptr&lt;PhongMaterial&gt; phong = </div>
<div class="line">                boost::dynamic_pointer_cast&lt;PhongMaterial&gt;(bakedNode());</div>
<div class="line"></div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;cosinePower&quot;</span>,    phong-&gt;CosinePower);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;specularColor&quot;</span>,  phong-&gt;SpecularColor);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;reflectivity&quot;</span>,   phong-&gt;Reflectivity);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;reflectedColor&quot;</span>, phong-&gt;ReflectedColor);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>BlinnBaker : <span class="keyword">public</span> LambertBaker</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        BlinnBaker(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">            : LambertBaker(node) {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> MaterialNode::MPtr createNode(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; name)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> boost::make_shared&lt;BlinnMaterial&gt;(name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> collectPlugsAndProperties()</div>
<div class="line">        {</div>
<div class="line">            LambertBaker::collectPlugsAndProperties();</div>
<div class="line"></div>
<div class="line">            boost::shared_ptr&lt;BlinnMaterial&gt; phong = </div>
<div class="line">                boost::dynamic_pointer_cast&lt;BlinnMaterial&gt;(bakedNode());</div>
<div class="line"></div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;eccentricity&quot;</span>,   phong-&gt;Eccentricity);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;specularRollOff&quot;</span>,phong-&gt;SpecularRollOff);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;specularColor&quot;</span>,  phong-&gt;SpecularColor);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;reflectivity&quot;</span>,   phong-&gt;Reflectivity);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;reflectedColor&quot;</span>, phong-&gt;ReflectedColor);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>Texture2dBaker : <span class="keyword">public</span> BaseMaterialNodeBaker</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        Texture2dBaker(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">            : BaseMaterialNodeBaker(node) {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> MaterialNode::MPtr createNode(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; name) = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> collectPlugsAndProperties()</div>
<div class="line">        {</div>
<div class="line">            boost::shared_ptr&lt;Texture2d&gt; texture2d = </div>
<div class="line">                boost::dynamic_pointer_cast&lt;Texture2d&gt;(bakedNode());</div>
<div class="line"></div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;defaultColor&quot;</span>, texture2d-&gt;DefaultColor);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;outColor&quot;</span>, texture2d-&gt;OutColor);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;outAlpha&quot;</span>, texture2d-&gt;OutAlpha);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>FileTextureBaker : <span class="keyword">public</span> Texture2dBaker</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        FileTextureBaker(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">            : Texture2dBaker(node) </div>
<div class="line">        {</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> MaterialNode::MPtr createNode(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; name)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> boost::make_shared&lt;FileTexture&gt;(name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> collectPlugsAndProperties()</div>
<div class="line">        {</div>
<div class="line">            Texture2dBaker::collectPlugsAndProperties();</div>
<div class="line"></div>
<div class="line">            boost::shared_ptr&lt;FileTexture&gt; file = </div>
<div class="line">                boost::dynamic_pointer_cast&lt;FileTexture&gt;(bakedNode());</div>
<div class="line"></div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;outTransparency&quot;</span>, file-&gt;OutTransparency);</div>
<div class="line">            sampleChannel(<span class="stringliteral">&quot;fileTextureName&quot;</span>, file-&gt;FileTextureName);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>UnknownTexture2dBaker : <span class="keyword">public</span> Texture2dBaker</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        UnknownTexture2dBaker(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">            : Texture2dBaker(node) {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> MaterialNode::MPtr createNode(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; name)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> boost::make_shared&lt;UnknownTexture2d&gt;(name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> collectPlugsAndProperties()</div>
<div class="line">        {</div>
<div class="line">            Texture2dBaker::collectPlugsAndProperties();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    BaseMaterialNodeBaker::Ptr BaseMaterialNodeBaker::create(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp;         node,</div>
<div class="line">        std::set&lt;std::string&gt;* traversedNodes)</div>
<div class="line">    {</div>
<div class="line">        BaseMaterialNodeBaker::Ptr baker;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (node.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a26"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ac63710c958c0b5ec88dbe5ea5b026b66">MFn::kPhong</a>)) {</div>
<div class="line">            baker = boost::make_shared&lt;PhongBaker&gt;(boost::ref(node));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a27"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a704312c00695bbbc10315c7cf15738fd">MFn::kBlinn</a>)) {</div>
<div class="line">            baker = boost::make_shared&lt;BlinnBaker&gt;(boost::ref(node));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a28"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a2af9af308555c50cf68e2c14595b680b">MFn::kLambert</a>)) {</div>
<div class="line">            baker = boost::make_shared&lt;LambertBaker&gt;(boost::ref(node));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a29"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ac3bee92500cdc3a4ccbec4cb35e91f2a">MFn::kFileTexture</a>)) {</div>
<div class="line">            baker = boost::make_shared&lt;FileTextureBaker&gt;(boost::ref(node));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a30"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a6c4cc284d93d1816f92a7386ebe8df94">MFn::kTexture2d</a>)) {</div>
<div class="line">            baker = boost::make_shared&lt;UnknownTexture2dBaker&gt;(boost::ref(node));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Recursively create connected bakers.</span></div>
<div class="line">        <span class="keywordflow">if</span> (baker) {</div>
<div class="line">            baker-&gt;setTraversedNodes(traversedNodes);</div>
<div class="line">            baker-&gt;setTraversed(node);</div>
<div class="line">            baker-&gt;setupNetwork();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> baker;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>MaterialBakers;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*==============================================================================</span></div>
<div class="line"><span class="comment"> * CLASS MaterialBaker</span></div>
<div class="line"><span class="comment"> *============================================================================*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class bakes a material graph that has a surface material as its root.</span></div>
<div class="line"><span class="keyword">class </span>MaterialBaker::MaterialGraphBaker : boost::noncopyable</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MaterialGraphBaker(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; node)</div>
<div class="line">    {</div>
<div class="line">        fRootBaker = BaseMaterialNodeBaker::create(node, &amp;fTraversedNodes);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~MaterialGraphBaker() {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> sample(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (fRootBaker) {</div>
<div class="line">            fRootBaker-&gt;sample(time);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> buildGraph()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (fRootBaker) {</div>
<div class="line">            MaterialNode::Ptr rootNode = fRootBaker-&gt;bakedNode();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">                <span class="comment">// Create the material graph.</span></div>
<div class="line">                MaterialGraph::MPtr graph = boost::make_shared&lt;MaterialGraph&gt;(rootNode-&gt;name());</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Add all shading nodes to the graph</span></div>
<div class="line">                fRootBaker-&gt;addToGraph(graph);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Connect the shading nodes</span></div>
<div class="line">                fRootBaker-&gt;connect();</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Set the root node of the graph</span></div>
<div class="line">                graph-&gt;setRootNode(rootNode);</div>
<div class="line"></div>
<div class="line">                fGraph = graph;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// We are done with the bakers</span></div>
<div class="line">            fRootBaker.reset();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    MaterialGraph::Ptr <span class="keyword">get</span>() <span class="keyword">const</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fGraph;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    BaseMaterialNodeBaker::Ptr fRootBaker;</div>
<div class="line">    MaterialGraph::MPtr        fGraph;</div>
<div class="line">    std::set&lt;std::string&gt;      fTraversedNodes;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">MaterialBaker::MaterialBaker()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">MaterialBaker::~MaterialBaker()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><a name="_a31"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> MaterialBaker::addShapePath(<span class="keyword">const</span> <a name="_a32"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a>&amp; dagPath)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Must be a shape.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!dagPath.<a name="a33"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html#ad1aa507eb8e63e89e8d46a0abc18aa8c">node</a>().<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a34"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a750b5e8123336c2306a300249b57201d">MFn::kShape</a>)) {</div>
<div class="line">        <span class="keywordflow">return</span> <a name="a35"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MS::kFailure</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if we are recursively baking gpuCache nodes</span></div>
<div class="line">    <a name="_a36"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dag_node.html">MFnDagNode</a> dagNode(dagPath);</div>
<div class="line">    <span class="keywordflow">if</span> (dagNode.<a name="a37"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#a1d0bbd4d50dae591f8e003c0aedc8135">typeId</a>() == ShapeNode::id) {</div>
<div class="line">        <span class="keyword">const</span> ShapeNode* node = (<span class="keyword">const</span> ShapeNode*)dagNode.<a name="a38"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#a4f2c53c9d1dcf25a6462c70fb25aead1">userNode</a>();</div>
<div class="line">        <span class="keywordflow">if</span> (node) {</div>
<div class="line">            <span class="keyword">const</span> MaterialGraphMap::Ptr materials = node-&gt;getCachedMaterial();</div>
<div class="line">            <span class="keywordflow">if</span> (materials) {</div>
<div class="line">                <span class="comment">// Grab the existing materials.</span></div>
<div class="line">                <span class="keyword">const</span> MaterialGraphMap::NamedMap&amp; graphs = materials-&gt;getGraphs();</div>
<div class="line">                <span class="keywordflow">if</span> (!graphs.empty()) {</div>
<div class="line">                    fExistingGraphs.insert(graphs.cbegin(), graphs.cend());</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <a name="a39"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find all connected materials.</span></div>
<div class="line">    InstanceMaterialLookup lookup(dagPath);</div>
<div class="line">    <span class="keywordflow">if</span> (lookup.hasWholeObjectMaterial()) {</div>
<div class="line">        <span class="comment">// Single material applied to the whole object.</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> surfaceMaterial = lookup.findWholeObjectSurfaceMaterial();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// No material, silently ignored.</span></div>
<div class="line">        <span class="keywordflow">if</span> (surfaceMaterial.<a name="a40"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>()) {</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Get the name of the surface material</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html">MFnDependencyNode</a> dgNode(surfaceMaterial);</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> name = dgNode.<a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1">name</a>();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Create a new material baker</span></div>
<div class="line">        MaterialGraphBakers::iterator iter = fMaterialGraphBakers.find(name);</div>
<div class="line">        <span class="keywordflow">if</span> (iter == fMaterialGraphBakers.end()) {</div>
<div class="line">            MaterialGraphBakerPtr baker = </div>
<div class="line">                boost::make_shared&lt;MaterialGraphBaker&gt;(surfaceMaterial);</div>
<div class="line">            fMaterialGraphBakers.insert(std::make_pair(name, baker));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lookup.hasComponentMaterials()) {</div>
<div class="line">        <span class="comment">// Multiple materials applied to components.</span></div>
<div class="line">        std::vector&lt;MObject&gt; surfaceMaterials;</div>
<div class="line">        lookup.findSurfaceMaterials(surfaceMaterials);</div>
<div class="line"></div>
<div class="line">        BOOST_FOREACH (<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; surfaceMaterial, surfaceMaterials) {</div>
<div class="line">            <span class="keywordflow">if</span> (surfaceMaterial.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>()) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get the name of the surface material</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html">MFnDependencyNode</a> dgNode(surfaceMaterial);</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> name = dgNode.<a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1">name</a>();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Create a new material baker</span></div>
<div class="line">            MaterialGraphBakers::iterator iter = fMaterialGraphBakers.find(name);</div>
<div class="line">            <span class="keywordflow">if</span> (iter == fMaterialGraphBakers.end()) {</div>
<div class="line">                MaterialGraphBakerPtr baker = </div>
<div class="line">                    boost::make_shared&lt;MaterialGraphBaker&gt;(surfaceMaterial);</div>
<div class="line">                fMaterialGraphBakers.insert(std::make_pair(name, baker));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> MaterialBaker::sample(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_time.html">MTime</a>&amp; time)</div>
<div class="line">{</div>
<div class="line">    BOOST_FOREACH (MaterialGraphBakers::value_type&amp; val, fMaterialGraphBakers) {</div>
<div class="line">        val.second-&gt;sample(time);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> MaterialBaker::buildGraph()</div>
<div class="line">{</div>
<div class="line">    BOOST_FOREACH (MaterialGraphBakers::value_type&amp; val, fMaterialGraphBakers) {</div>
<div class="line">        val.second-&gt;buildGraph();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">MaterialGraphMap::Ptr MaterialBaker::get()</div>
<div class="line">{</div>
<div class="line">    MaterialGraphMap::MPtr graphMap = boost::make_shared&lt;MaterialGraphMap&gt;();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add baked materials.</span></div>
<div class="line">    BOOST_FOREACH (<span class="keyword">const</span> MaterialGraphBakers::value_type&amp; val, fMaterialGraphBakers) {</div>
<div class="line">        MaterialGraph::Ptr graph = val.second-&gt;get();</div>
<div class="line">        <span class="keywordflow">if</span> (graph) {</div>
<div class="line">            graphMap-&gt;addMaterialGraph(graph);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add existing materials</span></div>
<div class="line">    BOOST_FOREACH (<span class="keyword">const</span> NamedMaterialGraphs::value_type&amp; val, fExistingGraphs) {</div>
<div class="line">        <span class="keywordflow">if</span> (val.second &amp;&amp; !graphMap-&gt;find(val.first)) {</div>
<div class="line">            graphMap-&gt;addMaterialGraph(val.second);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> !graphMap-&gt;getGraphs().empty() ? graphMap : MaterialGraphMap::Ptr();</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace GPUCache</span></div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div><br></div>
   </div></body>
</html>

<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="MAYAUL" name="product"><meta content="2017" name="release"><meta content="Developer" name="book"><meta content="2016-06-16" name="created"><meta content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887" name="topicid"><meta content="concept" name="topic-type">
<title>apiMeshShape/apiMeshShape.cpp</title>
<meta content="C++" name="topic-subtype"/></meta></meta></meta></meta></meta></meta></meta></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('api_mesh_shape_2api_mesh_shape_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>apiMeshShape/apiMeshShape.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">apiMeshShape/apiMeshShape.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk</span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download,</span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic</span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This plug-in produces the shape node "apiMesh", dependency graph node "apiMeshCreator", and data type "apiMeshData".</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// It demonstrates how to create a polygonal mesh shape with vertices that can be selected, moved, animated, and deformed.</span></div>
<div class="line"><span class="comment">// This shape also supports OpenGL display of materials.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This plug-in also registers a new kind of geometry data called "apiMeshData", and demonstrates how to pass this data between nodes.</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// The "apiMeshCreator" node can create two types of "apiMeshData": cube and sphere.</span></div>
<div class="line"><span class="comment">// The "shapeType" attribute is used to specify the type of shape to create.</span></div>
<div class="line"><span class="comment">// This node also takes normal mesh data as an input and converts it to "apiMeshData".</span></div>
<div class="line"><span class="comment">// If there is no input mesh, the output is based on the shapeType attribute.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// To create an "apiMesh" shape, you must first create the "apiMesh" node, then create an "apiMeshCreator" node, and connect the two nodes as follows:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// createNode apiMesh -n m1;</span></div>
<div class="line"><span class="comment">// createNode apiMeshCreator -n c1;</span></div>
<div class="line"><span class="comment">// connectAttr c1.outputSurface m1.inputSurface;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MIOStream.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "apiMeshShape.h"</span></div>
<div class="line"><span class="preprocessor">#include "apiMeshShapeUI.h"</span></div>
<div class="line"><span class="preprocessor">#include "apiMeshGeometryOverride.h"</span></div>
<div class="line"><span class="preprocessor">#include "apiMeshSubSceneOverride.h"</span></div>
<div class="line"><span class="preprocessor">#include "apiMeshCreator.h"</span></div>
<div class="line"><span class="preprocessor">#include "apiMeshData.h"</span></div>
<div class="line"><span class="preprocessor">#include &lt;api_macros.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDependencyNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnPlugin.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnPluginData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDrawRegistry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MMatrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAttributeSpecArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAttributeSpec.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAttributeIndex.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MObjectArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnSingleIndexedComponent.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDagPath.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNumericAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnTypedAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPointArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MViewport2Renderer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPlane.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MArrayDataBuilder.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> debug = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* sPlugConnection = <span class="stringliteral">"-&gt;-"</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// If there is any connection change to the shading group, we should mark the</span></div>
<div class="line"><span class="comment">// material dirty in order to tell the subscene override to bind the shader again.</span></div>
<div class="line"><span class="keywordtype">void</span> MaterialDirtyCb(<a class="code" href="./class_m_node_message.html#a2f710b68ff75e657f3be4b17a9dbe1e7">MNodeMessage::AttributeMessage</a> msg,</div>
<div class="line"> <a name="_a0"></a><a class="code" href="./class_m_plug.html">MPlug</a> &amp;plug,</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> &amp;otherPlug,</div>
<div class="line"> <span class="keywordtype">void</span> *clientData)</div>
<div class="line">{</div>
<div class="line">    apiMesh *pMesh = <span class="keyword">static_cast&lt;</span>apiMesh *<span class="keyword">&gt;</span>(clientData);</div>
<div class="line"> <span class="keywordflow">if</span> (pMesh &amp;&amp; (msg &amp; (<a name="a1"></a><a class="code" href="./class_m_node_message.html#a2f710b68ff75e657f3be4b17a9dbe1e7ac6e3b13a568648320a5874a5a3426c6f">MNodeMessage::kConnectionMade</a>|<a name="a2"></a><a class="code" href="./class_m_node_message.html#a2f710b68ff75e657f3be4b17a9dbe1e7a03593b1898a65ccdeb57195bedf5fc20">MNodeMessage::kConnectionBroken</a>)))</div>
<div class="line">    {</div>
<div class="line">        pMesh-&gt;setMaterialDirty(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Shape implementation</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><a name="_a3"></a><a class="code" href="./class_m_object.html">MObject</a> apiMesh::inputSurface;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::outputSurface;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::cachedSurface;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::worldSurface;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::bboxCorner1;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::bboxCorner2;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::useWeightedTransformUsingFunction;</div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::useWeightedTweakUsingFunction;</div>
<div class="line"></div>
<div class="line"><a name="_a4"></a><a class="code" href="./class_m_type_id.html">MTypeId</a> apiMesh::id( 0x80099 );</div>
<div class="line"></div>
<div class="line">apiMesh::apiMesh() {}</div>
<div class="line"></div>
<div class="line">apiMesh::~apiMesh()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">for</span>(std::map&lt;std::string, MCallbackId&gt;::const_iterator i = fMaterialDirtyCbIds.begin();</div>
<div class="line">        i != fMaterialDirtyCbIds.end(); i++)</div>
<div class="line">    {</div>
<div class="line"> <a name="a5"></a><a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(i-&gt;second);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Overrides</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::postConstructor()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    When instances of this node are created internally, the MObject associated</span></div>
<div class="line"><span class="comment">//    with the instance is not created until after the constructor of this class</span></div>
<div class="line"><span class="comment">//    is called. This means that no member functions of MPxSurfaceShape can</span></div>
<div class="line"><span class="comment">//    be called in the constructor.</span></div>
<div class="line"><span class="comment">//    The postConstructor solves this problem. Maya will call this function</span></div>
<div class="line"><span class="comment">//    after the internal object has been created.</span></div>
<div class="line"><span class="comment">//    As a general rule do all of your initialization in the postConstructor.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="comment">// This call allows the shape to have shading groups assigned</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    setRenderable( <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Is there input history to this node</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    fHasHistoryOnCreate = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Used by VP2.0 sub-scene evaluator</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    fShapeDirty = <span class="keyword">true</span>;</div>
<div class="line">    fMaterialDirty = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a name="_a6"></a><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::compute( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <a name="_a7"></a><a class="code" href="./class_m_data_block.html">MDataBlock</a>&amp; datablock )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    When input attributes are dirty this method will be called to</span></div>
<div class="line"><span class="comment">//    recompute the output attributes.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    plug      - the attribute that triggered the compute</span></div>
<div class="line"><span class="comment">//    datablock - the nodes data</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    kSuccess          - this method could compute the dirty attribute,</span></div>
<div class="line"><span class="comment">//    kUnknownParameter - the dirty attribute can not be handled at this level</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (debug)</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"apiMesh::compute : plug "</span> &lt;&lt; plug.<a name="a8"></a><a class="code" href="./class_m_plug.html#aeefa96f5abd664721e49ad9d96aa8b83">info</a>() &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( plug == outputSurface ) {</div>
<div class="line"> <span class="keywordflow">return</span> computeOutputSurface( plug, datablock );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( plug == cachedSurface ) {</div>
<div class="line"> <span class="keywordflow">return</span> computeOutputSurface( plug, datablock );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( plug == worldSurface ) {</div>
<div class="line"> <span class="keywordflow">return</span> computeWorldSurface( plug, datablock );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a9"></a><a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a7f858db05022c8bc860d685e13bab6ae">MS::kUnknownParameter</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Horribly abuse the purpose of this method to notify the Viewport 2.0</span></div>
<div class="line"><span class="comment">//  renderer that something about this shape has changed and that it should</span></div>
<div class="line"><span class="comment">//  be retranslated.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::setDependentsDirty( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <a name="_a10"></a><a class="code" href="./class_m_plug_array.html">MPlugArray</a>&amp; plugArray)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// if the dirty attribute is the output mesh then we need to signal the</span></div>
<div class="line"> <span class="comment">// the renderer that it needs to update the object</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( plug == inputSurface ||</div>
<div class="line">         plug == mControlPoints ||</div>
<div class="line">         plug == mControlValueX ||</div>
<div class="line">         plug == mControlValueY ||</div>
<div class="line">         plug == mControlValueZ )</div>
<div class="line">    {</div>
<div class="line">        signalDirtyToViewport();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a11"></a><a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Handle internal attributes.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Attributes that require special storage, bounds checking,</span></div>
<div class="line"><span class="comment">//    or other non-standard behavior can be marked as "Internal" by</span></div>
<div class="line"><span class="comment">//    using the "MFnAttribute::setInternal" method.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    The get/setInternalValue methods will get called for internal</span></div>
<div class="line"><span class="comment">//    attributes whenever the attribute values are stored or retrieved</span></div>
<div class="line"><span class="comment">//    using getAttr/setAttr or MPlug getValue/setValue.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    The inherited attribute mControlPoints is internal and we want</span></div>
<div class="line"><span class="comment">//    its values to get stored only if there is input history. Otherwise</span></div>
<div class="line"><span class="comment">//    any changes to the vertices are stored in the cachedMesh and outputMesh</span></div>
<div class="line"><span class="comment">//    directly.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    If values are retrieved then we want the controlPoints value</span></div>
<div class="line"><span class="comment">//    returned if there is history, this will be the offset or tweak.</span></div>
<div class="line"><span class="comment">//    In the case of no history, the vertex position of the cached mesh</span></div>
<div class="line"><span class="comment">//    is returned.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::getInternalValue( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <a name="_a12"></a><a class="code" href="./class_m_data_handle.html">MDataHandle</a>&amp; result )</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span> isOk = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( (plug == mControlPoints) ||</div>
<div class="line">        (plug == mControlValueX) ||</div>
<div class="line">        (plug == mControlValueY) ||</div>
<div class="line">        (plug == mControlValueZ) )</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// If there is input history then the control point value is</span></div>
<div class="line"> <span class="comment">// directly returned. This is the tweak or offset that</span></div>
<div class="line"> <span class="comment">// was applied to the vertex.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// If there is no input history then return the actual vertex</span></div>
<div class="line"> <span class="comment">// position and ignore the controlPoints attribute.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> ( hasHistory() ) {</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a13"></a><a class="code" href="./class_m_px_node.html#a4d71aa2b223bea98e4997d86992933a7">MPxNode::getInternalValue</a>( plug, result );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordtype">double</span> val = 0.0;</div>
<div class="line"> <span class="keywordflow">if</span> ( (plug == mControlPoints) &amp;&amp; !plug.<a name="a14"></a><a class="code" href="./class_m_plug.html#a42a62e7e85c661ab761d25ba77504f15">isArray</a>() ) {</div>
<div class="line"> <a name="_a15"></a><a class="code" href="./class_m_point.html">MPoint</a> pnt;</div>
<div class="line"> <span class="keywordtype">int</span> index = plug.<a name="a16"></a><a class="code" href="./class_m_plug.html#a7ee0cc502aa499c01ff2e41c76ac53c7">logicalIndex</a>();</div>
<div class="line">                value( index, pnt );</div>
<div class="line">                result.<a name="a17"></a><a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( pnt[0], pnt[1], pnt[2] );</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( plug == mControlValueX ) {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> parentPlug = plug.<a name="a18"></a><a class="code" href="./class_m_plug.html#a8178bc238db363b987ba394a10aaf0ff">parent</a>();</div>
<div class="line"> <span class="keywordtype">int</span> index = parentPlug.<a class="code" href="./class_m_plug.html#a7ee0cc502aa499c01ff2e41c76ac53c7">logicalIndex</a>();</div>
<div class="line">                value( index, 0, val );</div>
<div class="line">                result.<a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( val );</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( plug == mControlValueY ) {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> parentPlug = plug.<a class="code" href="./class_m_plug.html#a8178bc238db363b987ba394a10aaf0ff">parent</a>();</div>
<div class="line"> <span class="keywordtype">int</span> index = parentPlug.<a class="code" href="./class_m_plug.html#a7ee0cc502aa499c01ff2e41c76ac53c7">logicalIndex</a>();</div>
<div class="line">                value( index, 1, val );</div>
<div class="line">                result.<a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( val );</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( plug == mControlValueZ ) {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> parentPlug = plug.<a class="code" href="./class_m_plug.html#a8178bc238db363b987ba394a10aaf0ff">parent</a>();</div>
<div class="line"> <span class="keywordtype">int</span> index = parentPlug.<a class="code" href="./class_m_plug.html#a7ee0cc502aa499c01ff2e41c76ac53c7">logicalIndex</a>();</div>
<div class="line">                value( index, 2, val );</div>
<div class="line">                result.<a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( val );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// This inherited attribute is used to specify whether or</span></div>
<div class="line"> <span class="comment">// not this shape has history. During a file read, the shape</span></div>
<div class="line"> <span class="comment">// is created before any input history can get connected.</span></div>
<div class="line"> <span class="comment">// This attribute, also called "tweaks", provides a way to</span></div>
<div class="line"> <span class="comment">// for the shape to determine if there is input history</span></div>
<div class="line"> <span class="comment">// during file reads.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( plug == mHasHistoryOnCreate ) {</div>
<div class="line">        result.<a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( fHasHistoryOnCreate );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">        isOk = <a class="code" href="./class_m_px_node.html#a4d71aa2b223bea98e4997d86992933a7">MPxSurfaceShape::getInternalValue</a>( plug, result );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> isOk;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Handle internal attributes.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Attributes that require special storage, bounds checking,</span></div>
<div class="line"><span class="comment">//    or other non-standard behavior can be marked as "Internal" by</span></div>
<div class="line"><span class="comment">//    using the "MFnAttribute::setInternal" method.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    The get/setInternalValue methods will get called for internal</span></div>
<div class="line"><span class="comment">//    attributes whenever the attribute values are stored or retrieved</span></div>
<div class="line"><span class="comment">//    using getAttr/setAttr or MPlug getValue/setValue.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    The inherited attribute mControlPoints is internal and we want</span></div>
<div class="line"><span class="comment">//    its values to get stored only if there is input history. Otherwise</span></div>
<div class="line"><span class="comment">//    any changes to the vertices are stored in the cachedMesh and outputMesh</span></div>
<div class="line"><span class="comment">//    directly.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    If values are retrieved then we want the controlPoints value</span></div>
<div class="line"><span class="comment">//    returned if there is history, this will be the offset or tweak.</span></div>
<div class="line"><span class="comment">//    In the case of no history, the vertex position of the cached mesh</span></div>
<div class="line"><span class="comment">//    is returned.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::setInternalValue( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <span class="keyword">const</span> <a class="code" href="./class_m_data_handle.html">MDataHandle</a>&amp; handle )</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span> isOk = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( (plug == mControlPoints) ||</div>
<div class="line">        (plug == mControlValueX) ||</div>
<div class="line">        (plug == mControlValueY) ||</div>
<div class="line">        (plug == mControlValueZ) )</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// If there is input history then set the control points value</span></div>
<div class="line"> <span class="comment">// using the normal mechanism. In this case we are setting</span></div>
<div class="line"> <span class="comment">// the tweak or offset that will get applied to the input</span></div>
<div class="line"> <span class="comment">// history.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// If there is no input history then ignore the controlPoints</span></div>
<div class="line"> <span class="comment">// attribute and set the vertex position directly in the</span></div>
<div class="line"> <span class="comment">// cachedMesh.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> ( hasHistory() ) {</div>
<div class="line">            verticesUpdated();</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a19"></a><a class="code" href="./class_m_px_node.html#a1274aa85381b268a398ae8929b8f4ad1">MPxNode::setInternalValue</a>( plug, handle );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordflow">if</span>( plug == mControlPoints &amp;&amp; !plug.<a class="code" href="./class_m_plug.html#a42a62e7e85c661ab761d25ba77504f15">isArray</a>()) {</div>
<div class="line"> <span class="keywordtype">int</span> index = plug.<a class="code" href="./class_m_plug.html#a7ee0cc502aa499c01ff2e41c76ac53c7">logicalIndex</a>();</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> point;</div>
<div class="line">                double3&amp; ptData = handle.<a name="a20"></a><a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line">                point.<a name="a21"></a><a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> = ptData[0];</div>
<div class="line">                point.<a name="a22"></a><a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a> = ptData[1];</div>
<div class="line">                point.<a name="a23"></a><a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a> = ptData[2];</div>
<div class="line">                setValue( index, point );</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( plug == mControlValueX ) {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> parentPlug = plug.<a class="code" href="./class_m_plug.html#a8178bc238db363b987ba394a10aaf0ff">parent</a>();</div>
<div class="line"> <span class="keywordtype">int</span> index = parentPlug.<a class="code" href="./class_m_plug.html#a7ee0cc502aa499c01ff2e41c76ac53c7">logicalIndex</a>();</div>
<div class="line">                setValue( index, 0, handle.<a name="a24"></a><a class="code" href="./class_m_data_handle.html#ac1983b7d41a8dae60dc5b1eb9f44a53c">asDouble</a>() );</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( plug == mControlValueY ) {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> parentPlug = plug.<a class="code" href="./class_m_plug.html#a8178bc238db363b987ba394a10aaf0ff">parent</a>();</div>
<div class="line"> <span class="keywordtype">int</span> index = parentPlug.<a class="code" href="./class_m_plug.html#a7ee0cc502aa499c01ff2e41c76ac53c7">logicalIndex</a>();</div>
<div class="line">                setValue( index, 1, handle.<a class="code" href="./class_m_data_handle.html#ac1983b7d41a8dae60dc5b1eb9f44a53c">asDouble</a>() );</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( plug == mControlValueZ ) {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> parentPlug = plug.<a class="code" href="./class_m_plug.html#a8178bc238db363b987ba394a10aaf0ff">parent</a>();</div>
<div class="line"> <span class="keywordtype">int</span> index = parentPlug.<a class="code" href="./class_m_plug.html#a7ee0cc502aa499c01ff2e41c76ac53c7">logicalIndex</a>();</div>
<div class="line">                setValue( index, 2, handle.<a class="code" href="./class_m_data_handle.html#ac1983b7d41a8dae60dc5b1eb9f44a53c">asDouble</a>() );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// This inherited attribute is used to specify whether or</span></div>
<div class="line"> <span class="comment">// not this shape has history. During a file read, the shape</span></div>
<div class="line"> <span class="comment">// is created before any input history can get connected.</span></div>
<div class="line"> <span class="comment">// This attribute, also called "tweaks", provides a way to</span></div>
<div class="line"> <span class="comment">// for the shape to determine if there is input history</span></div>
<div class="line"> <span class="comment">// during file reads.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( plug == mHasHistoryOnCreate ) {</div>
<div class="line">        fHasHistoryOnCreate = handle.<a name="a25"></a><a class="code" href="./class_m_data_handle.html#a69fdebf4dcdf33c1b313eb4a426e0d45">asBool</a>();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">        isOk = <a class="code" href="./class_m_px_node.html#a1274aa85381b268a398ae8929b8f4ad1">MPxSurfaceShape::setInternalValue</a>( plug, handle );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> isOk;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::connectionMade( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; otherPlug,</div>
<div class="line"> <span class="keywordtype">bool</span> asSrc )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Whenever a connection is made to this node, this method</span></div>
<div class="line"><span class="comment">//    will get called.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> ( plug == inputSurface )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> thisObj = thisMObject();</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> historyPlug( thisObj, mHasHistoryOnCreate );</div>
<div class="line">        stat = historyPlug.setValue( <span class="keyword">true</span> );</div>
<div class="line">        MCHECKERROR( stat, <span class="stringliteral">"connectionMade: setValue(mHasHistoryOnCreate)"</span> );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( asSrc )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> otherNode = otherPlug.<a name="a26"></a><a class="code" href="./class_m_plug.html#ad1aa507eb8e63e89e8d46a0abc18aa8c">node</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (otherNode.<a name="a27"></a><a class="code" href="./class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a28"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a1fe410ba33fcc24e08a319ee3db38896">MFn::kShadingEngine</a>) &amp;&amp;</div>
<div class="line">            (plug.<a name="a29"></a><a class="code" href="./class_m_plug.html#a18baf7e7504bc90d54dea49a7d2d924b">attribute</a>() == instObjGroups || plug.<a class="code" href="./class_m_plug.html#a18baf7e7504bc90d54dea49a7d2d924b">attribute</a>() == objectGroups) )</div>
<div class="line">        {</div>
<div class="line">            setMaterialDirty(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat; </div>
<div class="line">            MCallbackId cbId = <a name="a30"></a><a class="code" href="./class_m_node_message.html#a92573fa0091e7c9de4412b467e928810">MNodeMessage::addAttributeChangedCallback</a>(</div>
<div class="line">                otherNode, MaterialDirtyCb, <span class="keyword">this</span>, &amp;stat);</div>
<div class="line"> <span class="keywordflow">if</span> (stat)</div>
<div class="line">            {</div>
<div class="line">                std::string k = plug.<a name="a31"></a><a class="code" href="./class_m_plug.html#a049384adbea0396ea2f03d1ad4d69df1">name</a>().<a name="a32"></a><a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">                k += sPlugConnection;</div>
<div class="line">                k += otherPlug.<a class="code" href="./class_m_plug.html#a049384adbea0396ea2f03d1ad4d69df1">name</a>().<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line"><span class="preprocessor">#ifdef _DEBUG</span></div>
<div class="line">                cout &lt;&lt; <span class="stringliteral">"apiMesh::connectionMade: "</span> &lt;&lt; k &lt;&lt; endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">                fMaterialDirtyCbIds[k] = cbId;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a33"></a><a class="code" href="./class_m_px_node.html#a30e5847b6ec18d5907a277b8a3931eb4">MPxNode::connectionMade</a>( plug, otherPlug, asSrc );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::connectionBroken( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; otherPlug,</div>
<div class="line"> <span class="keywordtype">bool</span> asSrc )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Whenever a connection to this node is broken, this method</span></div>
<div class="line"><span class="comment">//    will get called.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> ( plug == inputSurface )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> thisObj = thisMObject();</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> historyPlug( thisObj, mHasHistoryOnCreate );</div>
<div class="line">        stat = historyPlug.setValue( <span class="keyword">false</span> );</div>
<div class="line">        MCHECKERROR( stat, <span class="stringliteral">"connectionBroken: setValue(mHasHistoryOnCreate)"</span> );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (asSrc &amp;&amp; otherPlug.<a class="code" href="./class_m_plug.html#ad1aa507eb8e63e89e8d46a0abc18aa8c">node</a>().<a class="code" href="./class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a1fe410ba33fcc24e08a319ee3db38896">MFn::kShadingEngine</a>) &amp;&amp;</div>
<div class="line">             (plug.<a class="code" href="./class_m_plug.html#a18baf7e7504bc90d54dea49a7d2d924b">attribute</a>() == instObjGroups || plug.<a class="code" href="./class_m_plug.html#a18baf7e7504bc90d54dea49a7d2d924b">attribute</a>() == objectGroups))</div>
<div class="line">    {</div>
<div class="line">        setMaterialDirty(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">        std::string k = plug.<a class="code" href="./class_m_plug.html#a049384adbea0396ea2f03d1ad4d69df1">name</a>().<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">        k += sPlugConnection;</div>
<div class="line">        k += otherPlug.<a class="code" href="./class_m_plug.html#a049384adbea0396ea2f03d1ad4d69df1">name</a>().<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line"><span class="preprocessor">#ifdef _DEBUG</span></div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">"apiMesh::connectionBroken: "</span> &lt;&lt; k &lt;&lt; endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fMaterialDirtyCbIds.find(k) != fMaterialDirtyCbIds.end())</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fMaterialDirtyCbIds[k]);</div>
<div class="line">            fMaterialDirtyCbIds.erase(k);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a34"></a><a class="code" href="./class_m_px_node.html#a073eb39de928af52bd0cbdc36aaa242d">MPxNode::connectionBroken</a>( plug, otherPlug, asSrc );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::shouldSave( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <span class="keywordtype">bool</span>&amp; result )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    During file save this method is called to determine which</span></div>
<div class="line"><span class="comment">//    attributes of this node should get written. The default behavior</span></div>
<div class="line"><span class="comment">//    is to only save attributes whose values differ from the default.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status = <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( plug == mControlPoints || plug == mControlValueX ||</div>
<div class="line">        plug == mControlValueY || plug == mControlValueZ )</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span>( hasHistory() ) {</div>
<div class="line"> <span class="comment">// Calling this will only write tweaks if they are</span></div>
<div class="line"> <span class="comment">// different than the default value.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">            status = <a name="a35"></a><a class="code" href="./class_m_px_node.html#a05d382822f7e10179808066246c65443">MPxNode::shouldSave</a>( plug, result );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">            result = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( plug == cachedSurface ) {</div>
<div class="line"> <span class="keywordflow">if</span> ( hasHistory() ) {</div>
<div class="line">            result = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> data;</div>
<div class="line">            status = plug.<a name="a36"></a><a class="code" href="./class_m_plug.html#a64f7093bfde5c5eb9d89b32635b772aa">getValue</a>( data );</div>
<div class="line">            MCHECKERROR( status, <span class="stringliteral">"shouldSave: MPlug::getValue"</span> );</div>
<div class="line">            result = ( ! data.<a name="a37"></a><a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>() );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">        status = <a class="code" href="./class_m_px_node.html#a05d382822f7e10179808066246c65443">MPxNode::shouldSave</a>( plug, result );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::componentToPlugs( <a class="code" href="./class_m_object.html">MObject</a> &amp; component,</div>
<div class="line"> <a name="_a38"></a><a class="code" href="./class_m_selection_list.html">MSelectionList</a> &amp; list ) <span class="keyword">const</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Converts the given component values into a selection list of plugs.</span></div>
<div class="line"><span class="comment">//    This method is used to map components to attributes.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    component - the component to be translated to a plug/attribute</span></div>
<div class="line"><span class="comment">//    list      - a list of plugs representing the passed in component</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> ( component.hasFn(<a name="a39"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7aea2131a2c31c27566ba5ec99ada19fe6">MFn::kSingleIndexedComponent</a>) ) {</div>
<div class="line">        apiMesh* nonConstPtr = (apiMesh*)<span class="keyword">this</span>;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> vtxComp = nonConstPtr-&gt;convertToVertexComponent(component);</div>
<div class="line"> <a name="_a40"></a><a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnVtxComp( vtxComp );</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> thisNode = thisMObject();</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> plug( thisNode, mControlPoints );</div>
<div class="line"> <span class="comment">// If this node is connected to a tweak node, reset the</span></div>
<div class="line"> <span class="comment">// plug to point at the tweak node.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">        convertToTweakNodePlug(plug);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> len = fnVtxComp.elementCount();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; len; i++ )</div>
<div class="line">        {</div>
<div class="line">            plug.<a name="a41"></a><a class="code" href="./class_m_plug.html#a732963807cfd727b7e90eb1342121ce9">selectAncestorLogicalIndex</a>(fnVtxComp.element(i),</div>
<div class="line">                                            plug.<a class="code" href="./class_m_plug.html#a18baf7e7504bc90d54dea49a7d2d924b">attribute</a>());</div>
<div class="line">            list.add(plug);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_px_surface_shape.html#aff52e9d9ee5dc357de01943832391b2c">MPxSurfaceShape::MatchResult</a></div>
<div class="line">apiMesh::matchComponent( <span class="keyword">const</span> <a class="code" href="./class_m_selection_list.html">MSelectionList</a>&amp; item,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a42"></a><a class="code" href="./class_m_attribute_spec_array.html">MAttributeSpecArray</a>&amp; spec,</div>
<div class="line"> <a class="code" href="./class_m_selection_list.html">MSelectionList</a>&amp; list )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Component/attribute matching method.</span></div>
<div class="line"><span class="comment">//    This method validates component names and indices which are</span></div>
<div class="line"><span class="comment">//    specified as a string and adds the corresponding component</span></div>
<div class="line"><span class="comment">//    to the passed in selection list.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    For instance, select commands such as "select shape1.vtx[0:7]"</span></div>
<div class="line"><span class="comment">//    are validated with this method and the corresponding component</span></div>
<div class="line"><span class="comment">//    is added to the selection list.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    item - DAG selection item for the object being matched</span></div>
<div class="line"><span class="comment">//    spec - attribute specification object</span></div>
<div class="line"><span class="comment">//    list - list to add components to</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    the result of the match</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_px_surface_shape.html#aff52e9d9ee5dc357de01943832391b2c">MPxSurfaceShape::MatchResult</a> result = <a name="a43"></a><a class="code" href="./class_m_px_surface_shape.html#aff52e9d9ee5dc357de01943832391b2ca023cdc99dda44caa5412f12a5b117d62">MPxSurfaceShape::kMatchOk</a>;</div>
<div class="line"> <a name="_a44"></a><a class="code" href="./class_m_attribute_spec.html">MAttributeSpec</a> attrSpec = spec[0];</div>
<div class="line"> <span class="keywordtype">int</span> dim = attrSpec.<a name="a45"></a><a class="code" href="./class_m_attribute_spec.html#abdbc6a0efd0a3c187df67a0895c2e115">dimensions</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Look for attributes specifications of the form :</span></div>
<div class="line"> <span class="comment">//     vtx[ index ]</span></div>
<div class="line"> <span class="comment">//     vtx[ lower:upper ]</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> ( (1 == spec.<a name="a46"></a><a class="code" href="./class_m_attribute_spec_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>()) &amp;&amp; (dim &gt; 0) &amp;&amp; (attrSpec.<a name="a47"></a><a class="code" href="./class_m_attribute_spec.html#a2e8d4c38a60806df8c2ffd6d09e70b96">name</a>() == <span class="stringliteral">"vtx"</span>) ) {</div>
<div class="line"> <span class="keywordtype">int</span> numVertices = meshGeom()-&gt;vertices.length();</div>
<div class="line"> <a name="_a48"></a><a class="code" href="./class_m_attribute_index.html">MAttributeIndex</a> attrIndex = attrSpec[0];</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> upper = 0;</div>
<div class="line"> <span class="keywordtype">int</span> lower = 0;</div>
<div class="line"> <span class="keywordflow">if</span> ( attrIndex.<a name="a49"></a><a class="code" href="./class_m_attribute_index.html#a6ccae4069bed342bc3099a27e95f1fbb">hasLowerBound</a>() ) {</div>
<div class="line">            attrIndex.<a name="a50"></a><a class="code" href="./class_m_attribute_index.html#a424c59dc5963c79877ba071026f703d8">getLower</a>( lower );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">if</span> ( attrIndex.<a name="a51"></a><a class="code" href="./class_m_attribute_index.html#a91fe8323a865ca2f0789be32ede111b3">hasUpperBound</a>() ) {</div>
<div class="line">            attrIndex.<a name="a52"></a><a class="code" href="./class_m_attribute_index.html#a318bbe3400f72a3007b2d875dd7f8167">getUpper</a>( upper );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check the attribute index range is valid</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> ( (lower &gt; upper) || (upper &gt;= numVertices) ) {</div>
<div class="line">            result = <a name="a53"></a><a class="code" href="./class_m_px_surface_shape.html#aff52e9d9ee5dc357de01943832391b2ca3948a336c42780f6083fcebec4656f25">MPxSurfaceShape::kMatchInvalidAttributeRange</a>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <a name="_a54"></a><a class="code" href="./class_m_dag_path.html">MDagPath</a> path;</div>
<div class="line">            item.<a name="a55"></a><a class="code" href="./class_m_selection_list.html#a16dda1a34d5f10be257d8421ac6deabd">getDagPath</a>( 0, path );</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnVtxComp;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> vtxComp = fnVtxComp.<a name="a56"></a><a class="code" href="./class_m_fn_single_indexed_component.html#ae3b7a9c926f9770f786893bbea825d6b">create</a>( <a name="a57"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522">MFn::kMeshVertComponent</a> );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=lower; i&lt;=upper; i++ )</div>
<div class="line">            {</div>
<div class="line">                fnVtxComp.<a name="a58"></a><a class="code" href="./class_m_fn_single_indexed_component.html#ac611414173082c0660277269ea6a4671">addElement</a>( i );</div>
<div class="line">            }</div>
<div class="line">            list.<a name="a59"></a><a class="code" href="./class_m_selection_list.html#a23929aeafb29672f2652128eac9c4dec">add</a>( path, vtxComp );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// Pass this to the parent class</span></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a60"></a><a class="code" href="./class_m_px_surface_shape.html#a19499831f6a63ee7b57c942a23764abe">MPxSurfaceShape::matchComponent</a>( item, spec, list );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::match( <span class="keyword">const</span> <a name="_a61"></a><a class="code" href="./class_m_selection_mask.html">MSelectionMask</a> &amp; mask,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a62"></a><a class="code" href="./class_m_object_array.html">MObjectArray</a>&amp; componentList ) <span class="keyword">const</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      Check for matches between selection type / component list, and</span></div>
<div class="line"><span class="comment">//      the type of this shape / or it's components</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      This is used by sets and deformers to make sure that the selected</span></div>
<div class="line"><span class="comment">//      components fall into the "vertex only" category.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      mask          - selection type mask</span></div>
<div class="line"><span class="comment">//      componentList - possible component list</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//      true if matched any</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( componentList.length() == 0 ) {</div>
<div class="line">        result = mask.intersects( <a name="a63"></a><a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da4e61eacbb5f904df37be9e14d36286b1">MSelectionMask::kSelectMeshes</a> );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;(int)componentList.length(); i++ ) {</div>
<div class="line"> <span class="keywordflow">if</span> ( (componentList[i].apiType() == <a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522">MFn::kMeshVertComponent</a>) &amp;&amp;</div>
<div class="line">                 (mask.intersects(<a name="a64"></a><a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da705847d327f5166f435cb6ed017ead15">MSelectionMask::kSelectMeshVerts</a>))</div>
<div class="line">            ) {</div>
<div class="line">                result = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_selection_mask.html">MSelectionMask</a> apiMesh::getShapeSelectionMask() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//     This method is overriden to support interactive object selection in Viewport 2.0</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    The selection mask of the shape</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879d">MSelectionMask::SelectionType</a> selType = <a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da4e61eacbb5f904df37be9e14d36286b1">MSelectionMask::kSelectMeshes</a>;</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_selection_mask.html">MSelectionMask</a>( selType );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_selection_mask.html">MSelectionMask</a> apiMesh::getComponentSelectionMask() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//     This method is overriden to support interactive component selection in Viewport 2.0</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    The selection mask of the shape components</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_selection_mask.html">MSelectionMask</a> retVal(<a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da705847d327f5166f435cb6ed017ead15">MSelectionMask::kSelectMeshVerts</a>);</div>
<div class="line">    retVal.addMask(<a name="a65"></a><a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da865581859e2396d43e835facc4807ebc">MSelectionMask::kSelectMeshEdges</a>);</div>
<div class="line">    retVal.addMask(<a name="a66"></a><a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da22bda3732b520fcd2aa70d5d422f10fa">MSelectionMask::kSelectMeshFaces</a>);</div>
<div class="line"> <span class="keywordflow">return</span> retVal;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::createFullVertexGroup() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//     This method is used by maya when it needs to create a component</span></div>
<div class="line"><span class="comment">//     containing every vertex (or control point) in the shape.</span></div>
<div class="line"><span class="comment">//     This will get called if you apply some deformer to the whole</span></div>
<div class="line"><span class="comment">//     shape, i.e. select the shape in object mode and add a deformer to it.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    A "complete" component representing all vertices in the shape.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Create a vertex component</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComponent;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> fullComponent = fnComponent.<a class="code" href="./class_m_fn_single_indexed_component.html#ae3b7a9c926f9770f786893bbea825d6b">create</a>( <a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522">MFn::kMeshVertComponent</a> );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set the component to be complete, i.e. the elements in</span></div>
<div class="line"> <span class="comment">// the component will be [0:numVertices-1]</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordtype">int</span> numVertices = ((apiMesh*)<span class="keyword">this</span>)-&gt;meshGeom()-&gt;vertices.length();</div>
<div class="line">    fnComponent.<a name="a67"></a><a class="code" href="./class_m_fn_single_indexed_component.html#ae4dcbac2a79082a32f18c613803a1c3f">setCompleteData</a>( numVertices );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> fullComponent;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::localShapeInAttr() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns the input attribute of the shape. This is used by</span></div>
<div class="line"><span class="comment">//    maya to establish input connections for deformers etc.</span></div>
<div class="line"><span class="comment">//    This attribute must be data of type kGeometryData.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    input attribute for the shape</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> inputSurface;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::localShapeOutAttr() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns the output attribute of the shape. This is used by</span></div>
<div class="line"><span class="comment">//    maya to establish out connections for deformers etc.</span></div>
<div class="line"><span class="comment">//    This attribute must be data of tye kGeometryData.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    output attribute for the shape</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> outputSurface;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::worldShapeOutAttr() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns the world space output "array" attribute of the shape.</span></div>
<div class="line"><span class="comment">//    This is used by maya to establish out connections for deformers etc.</span></div>
<div class="line"><span class="comment">//    This attribute must be an array attribute, each element representing</span></div>
<div class="line"><span class="comment">//    a particular instance of the shape.</span></div>
<div class="line"><span class="comment">//    This attribute must be data of type kGeometryData.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    world space "array" attribute for the shape</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> worldSurface;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::cachedShapeAttr() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns the cached shape attribute of the shape.</span></div>
<div class="line"><span class="comment">//    This attribute must be data of type kGeometryData.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    cached shape attribute</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> cachedSurface;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::geometryData() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns the data object for the surface. This gets</span></div>
<div class="line"><span class="comment">//    called internally for grouping (set) information.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    apiMesh* nonConstThis = (apiMesh*)<span class="keyword">this</span>;</div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> datablock = nonConstThis-&gt;forceCache();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> handle = datablock.<a name="a68"></a><a class="code" href="./class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>( inputSurface );</div>
<div class="line"> <span class="keywordflow">return</span> handle.<a name="a69"></a><a class="code" href="./class_m_data_handle.html#a31773b870681e1f6b3ad82ff58de33bc">data</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*override */</span></div>
<div class="line"><span class="keywordtype">void</span> apiMesh:: closestPoint ( <span class="keyword">const</span> <a class="code" href="./class_m_point.html">MPoint</a> &amp; toThisPoint, \</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> &amp; theClosestPoint, <span class="keywordtype">double</span> tolerance ) <span class="keyword">const</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      Returns the closest point to the given point in space.</span></div>
<div class="line"><span class="comment">//      Used for rigid bind of skin.  Currently returns wrong results;</span></div>
<div class="line"><span class="comment">//      override it by implementing a closest point calculation.</span></div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Iterate through the geometry to find the closest point within</span></div>
<div class="line"> <span class="comment">// the given tolerance.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    apiMeshGeom* geomPtr = ((apiMesh*)<span class="keyword">this</span>)-&gt;meshGeom();</div>
<div class="line"> <span class="keywordtype">int</span> numVertices = geomPtr-&gt;vertices.length();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii=0; ii&lt;numVertices; ii++)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> tryThisOne = geomPtr-&gt;vertices[ii];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set the output point to the result (hardcode for debug just now)</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    theClosestPoint = geomPtr-&gt;vertices[0];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::transformUsing( <span class="keyword">const</span> <a name="_a70"></a><a class="code" href="./class_m_matrix.html">MMatrix</a> &amp; mat,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_object_array.html">MObjectArray</a> &amp; componentList )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Transforms by the matrix the given components, or the entire shape</span></div>
<div class="line"><span class="comment">//    if the componentList is empty. This method is used by the freezeTransforms command.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    mat           - matrix to tranform the components by</span></div>
<div class="line"><span class="comment">//    componentList - list of components to be transformed,</span></div>
<div class="line"><span class="comment">//                    or an empty list to indicate the whole surface</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Let the other version of transformUsing do the work for us.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    transformUsing( mat,</div>
<div class="line">                    componentList,</div>
<div class="line"> <a name="a71"></a><a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540a06197a5a5b86b633bb5e473d9385c8a7">MPxSurfaceShape::kNoPointCaching</a>,</div>
<div class="line">                    NULL);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Transforms the given components. This method is used by</span></div>
<div class="line"><span class="comment">//    the move, rotate, and scale tools in component mode.</span></div>
<div class="line"><span class="comment">//    The bounding box has to be updated here, so do the normals and</span></div>
<div class="line"><span class="comment">//    any other attributes that depend on vertex positions.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//    mat           - matrix to tranform the components by</span></div>
<div class="line"><span class="comment">//    componentList - list of components to be transformed,</span></div>
<div class="line"><span class="comment">//                    or an empty list to indicate the whole surface</span></div>
<div class="line"><span class="comment">//    cachingMode   - how to use the supplied pointCache (kSavePoints, kRestorePoints)</span></div>
<div class="line"><span class="comment">//    pointCache    - if non-null, save or restore points from this list base</span></div>
<div class="line"><span class="comment">//                    on the cachingMode</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::transformUsing( <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a> &amp; mat,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_object_array.html">MObjectArray</a> &amp; componentList,</div>
<div class="line">                              MVertexCachingMode cachingMode,</div>
<div class="line"> <a name="_a72"></a><a class="code" href="./class_m_point_array.html">MPointArray</a>* pointCache)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line">    apiMeshGeom* geomPtr = meshGeom();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create cachingMode boolean values for clearer reading of conditional code below</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordtype">bool</span> savePoints    = (cachingMode == <a name="a73"></a><a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540a7880e840faa9de43057b0b41a1e84639">MPxSurfaceShape::kSavePoints</a>);</div>
<div class="line"> <span class="keywordtype">bool</span> restorePoints = (cachingMode == <a name="a74"></a><a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540af7320699eeaf840fd0bc89aee27c91fc">MPxSurfaceShape::kRestorePoints</a>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0,j=0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = componentList.<a name="a75"></a><a class="code" href="./class_m_object_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( restorePoints ) {</div>
<div class="line"> <span class="comment">// restore the points based on the data provided in the pointCache attribute</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cacheLen = pointCache-&gt;<a name="a76"></a><a class="code" href="./class_m_point_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (len &gt; 0) {</div>
<div class="line"> <span class="comment">// traverse the component list</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">for</span> ( i = 0; i &lt; len &amp;&amp; j &lt; cacheLen; i++ )</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> comp = convertToVertexComponent(componentList[i]);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComp( comp );</div>
<div class="line"> <span class="keywordtype">int</span> elemCount = fnComp.elementCount();</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> idx=0; idx&lt;elemCount &amp;&amp; j &lt; cacheLen; idx++, ++j ) {</div>
<div class="line"> <span class="keywordtype">int</span> elemIndex = fnComp.element( idx );</div>
<div class="line">                    geomPtr-&gt;vertices[elemIndex] = (*pointCache)[j];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// if the component list is of zero-length, it indicates that we</span></div>
<div class="line"> <span class="comment">// should transform the entire surface</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">            len = geomPtr-&gt;vertices.length();</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; len &amp;&amp; j &lt; cacheLen; ++idx, ++j ) {</div>
<div class="line">                geomPtr-&gt;vertices[idx] = (*pointCache)[j];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// Transform the surface vertices with the matrix.</span></div>
<div class="line"> <span class="comment">// If savePoints is true, save the points to the pointCache.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (len &gt; 0) {</div>
<div class="line"> <span class="comment">// Traverse the componentList</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">for</span> ( i=0; i&lt;len; i++ )</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> comp = convertToVertexComponent(componentList[i]);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComp( comp );</div>
<div class="line"> <span class="keywordtype">int</span> elemCount = fnComp.elementCount();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (savePoints &amp;&amp; 0 == i) {</div>
<div class="line">                    pointCache-&gt;<a name="a77"></a><a class="code" href="./class_m_point_array.html#ab463a783d0657af39ca2fa7294287662">setSizeIncrement</a>(elemCount);</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> idx=0; idx&lt;elemCount; idx++ )</div>
<div class="line">                {</div>
<div class="line"> <span class="keywordtype">int</span> elemIndex = fnComp.element( idx );</div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line">                        pointCache-&gt;<a name="a78"></a><a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(geomPtr-&gt;vertices[elemIndex]);</div>
<div class="line">                    }</div>
<div class="line">                    geomPtr-&gt;vertices[elemIndex] *= mat;</div>
<div class="line">                    geomPtr-&gt;normals[idx] =</div>
<div class="line">                        geomPtr-&gt;normals[idx].transformAsNormal( mat );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// If the component list is of zero-length, it indicates that we</span></div>
<div class="line"> <span class="comment">// should transform the entire surface</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">            len = geomPtr-&gt;vertices.length();</div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line">                pointCache-&gt;<a class="code" href="./class_m_point_array.html#ab463a783d0657af39ca2fa7294287662">setSizeIncrement</a>(len);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; len; ++idx ) {</div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line">                    pointCache-&gt;<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(geomPtr-&gt;vertices[idx]);</div>
<div class="line">                }</div>
<div class="line">                geomPtr-&gt;vertices[idx] *= mat;</div>
<div class="line">                geomPtr-&gt;normals[idx] =</div>
<div class="line">                    geomPtr-&gt;normals[idx].transformAsNormal( mat );</div>
<div class="line"></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the surface</span></div>
<div class="line">    updateCachedSurface( geomPtr, componentList );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Update the cached surface attribute, handle the tweak history as appropriate,</span></div>
<div class="line"><span class="comment">//    and trigger a bounding box change calculation.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//    geomPtr       - the modified geometry to apply to the cached surface attribute</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::updateCachedSurface( <span class="keyword">const</span> apiMeshGeom* geomPtr, <span class="keyword">const</span> <a class="code" href="./class_m_object_array.html">MObjectArray</a> &amp; componentList )</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = componentList.<a class="code" href="./class_m_object_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Retrieve the value of the cached surface attribute.</span></div>
<div class="line"> <span class="comment">// We will set the new geometry data into the cached surface attribute</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Access the datablock directly. This code has to be efficient</span></div>
<div class="line"> <span class="comment">// and so we bypass the compute mechanism completely.</span></div>
<div class="line"> <span class="comment">// NOTE: In general we should always go though compute for getting</span></div>
<div class="line"> <span class="comment">// and setting attributes.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> datablock = forceCache();</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> cachedHandle = datablock.<a name="a79"></a><a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>( cachedSurface, &amp;stat );</div>
<div class="line">    MCHECKERRORNORET( stat, <span class="stringliteral">"computeInputSurface error getting cachedSurface"</span>)</div>
<div class="line">    apiMeshData* cached = (apiMeshData*) cachedHandle.asPluginData();</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> dHandle = datablock.outputValue( mControlPoints, &amp;stat );</div>
<div class="line">    MCHECKERRORNORET( stat, "updateCachedSurface get dHandle" )</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If there is history then calculate the tweaks necessary for</span></div>
<div class="line"> <span class="comment">// setting the final positions of the vertices.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    if ( hasHistory() &amp;&amp; (NULL != cached) ) {</div>
<div class="line"> <span class="comment">// Since the shape has history, we need to store the tweaks (deltas)</span></div>
<div class="line"> <span class="comment">// between the input shape and the tweaked shape in the control points</span></div>
<div class="line"> <span class="comment">// attribute.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">        stat = buildControlPoints( datablock, geomPtr-&gt;vertices.length() );</div>
<div class="line">        MCHECKERRORNORET( stat, <span class="stringliteral">"updateCachedSurface buildControlPoints"</span> )</div>
<div class="line"></div>
<div class="line"> <a name="_a80"></a><a class="code" href="./class_m_array_data_handle.html">MArrayDataHandle</a> cpHandle( dHandle, &amp;stat );</div>
<div class="line">        MCHECKERRORNORET( stat, "updateCachedSurface get cpHandle" )</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Loop through the component list and transform each vertex.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">        for ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;len; i++ )</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> comp = convertToVertexComponent(componentList[i]);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComp( comp );</div>
<div class="line"> <span class="keywordtype">int</span> elemCount = fnComp.elementCount();</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> idx=0; idx&lt;elemCount; idx++ )</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">int</span> elemIndex = fnComp.element( idx );</div>
<div class="line">                cpHandle.jumpToElement( elemIndex );</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> pntHandle = cpHandle.outputValue();</div>
<div class="line">                double3&amp; pnt = pntHandle.<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> oldPnt = cached-&gt;fGeometry-&gt;vertices[elemIndex];</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> newPnt = geomPtr-&gt;vertices[elemIndex];</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> offset = newPnt - oldPnt;</div>
<div class="line"></div>
<div class="line">                pnt[0] += offset[0];</div>
<div class="line">                pnt[1] += offset[1];</div>
<div class="line">                pnt[2] += offset[2];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Copy outputSurface to cachedSurface</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> ( NULL == cached ) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"NULL cachedSurface data found\n"</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">        *(cached-&gt;fGeometry) = *geomPtr;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> pCPs(thisMObject(),mControlPoints);</div>
<div class="line">    pCPs.setValue(dHandle);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Moving vertices will likely change the bounding box.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    computeBoundingBox( datablock );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Tell maya the bounding box for this object has changed</span></div>
<div class="line"> <span class="comment">// and thus "boundingBox()" needs to be called.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    childChanged( <a name="a81"></a><a class="code" href="./class_m_px_surface_shape.html#ae6e3d315c5dd375e845a29ffeb5f8727a3cf2a789a428c68c537cf3ba6b9ad743">MPxSurfaceShape::kBoundingBoxChanged</a> );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Signal to the viewport that it needs to update the object</span></div>
<div class="line">    signalDirtyToViewport();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Transforms the given components. This method is used by</span></div>
<div class="line"><span class="comment">//    the move, rotate, and scale tools in component mode when the</span></div>
<div class="line"><span class="comment">//    tweaks for the shape are stored on a separate tweak node.</span></div>
<div class="line"><span class="comment">//    The bounding box has to be updated here, so do the normals and</span></div>
<div class="line"><span class="comment">//    any other attributes that depend on vertex positions.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//    mat           - matrix to tranform the components by</span></div>
<div class="line"><span class="comment">//    componentList - list of components to be transformed,</span></div>
<div class="line"><span class="comment">//                    or an empty list to indicate the whole surface</span></div>
<div class="line"><span class="comment">//    cachingMode   - how to use the supplied pointCache (kSavePoints, kRestorePoints, kUpdatePoints)</span></div>
<div class="line"><span class="comment">//    pointCache    - if non-null, save or restore points from this list base</span></div>
<div class="line"><span class="comment">//                    on the cachingMode</span></div>
<div class="line"><span class="comment">//    handle        - handle to the attribute on the tweak node where the</span></div>
<div class="line"><span class="comment">//                    tweaks should be stored</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">apiMesh::tweakUsing( <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a> &amp; mat,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_object_array.html">MObjectArray</a> &amp; componentList,</div>
<div class="line">                     MVertexCachingMode cachingMode,</div>
<div class="line"> <a class="code" href="./class_m_point_array.html">MPointArray</a>* pointCache,</div>
<div class="line"> <a class="code" href="./class_m_array_data_handle.html">MArrayDataHandle</a>&amp; handle )</div>
<div class="line">{</div>
<div class="line">    apiMeshGeom* geomPtr = meshGeom();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create cachingMode boolean values for clearer reading of conditional code below</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordtype">bool</span> savePoints    = (cachingMode == <a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540a7880e840faa9de43057b0b41a1e84639">MPxSurfaceShape::kSavePoints</a>);</div>
<div class="line"> <span class="keywordtype">bool</span> updatePoints  = (cachingMode == <a name="a82"></a><a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540ab169f7f366f434196216f2bfaaa05017">MPxSurfaceShape::kUpdatePoints</a>);</div>
<div class="line"> <span class="keywordtype">bool</span> restorePoints = (cachingMode == <a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540af7320699eeaf840fd0bc89aee27c91fc">MPxSurfaceShape::kRestorePoints</a>);</div>
<div class="line"></div>
<div class="line"> <a name="_a83"></a><a class="code" href="./class_m_array_data_builder.html">MArrayDataBuilder</a> builder = handle.<a name="a84"></a><a class="code" href="./class_m_array_data_handle.html#a48b34beab40fa4ae60cfe40e556f591a">builder</a>();</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> delta, currPt, newPt;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = componentList.<a class="code" href="./class_m_object_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cacheIndex = 0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cacheLen = (NULL != pointCache) ? pointCache-&gt;<a class="code" href="./class_m_point_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() : 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( restorePoints ) {</div>
<div class="line"> <span class="comment">// restore points from the pointCache</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (len &gt; 0) {</div>
<div class="line"> <span class="comment">// traverse the component list</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">for</span> ( i=0; i&lt;len; i++ )</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> comp = convertToVertexComponent(componentList[i]);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComp( comp );</div>
<div class="line"> <span class="keywordtype">int</span> elemCount = fnComp.elementCount();</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> idx=0; idx&lt;elemCount &amp;&amp; cacheIndex &lt; cacheLen; idx++, cacheIndex++) {</div>
<div class="line"> <span class="keywordtype">int</span> elemIndex = fnComp.element( idx );</div>
<div class="line">                    double3 &amp; pt = builder.<a name="a85"></a><a class="code" href="./class_m_array_data_builder.html#a6d195a24b9624f2e38079e1ce412c9bb">addElement</a>( elemIndex ).<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a>&amp; cachePt = (*pointCache)[cacheIndex];</div>
<div class="line">                    pt[0] += cachePt.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                    pt[1] += cachePt.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                    pt[2] += cachePt.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// if the component list is of zero-length, it indicates that we</span></div>
<div class="line"> <span class="comment">// should transform the entire surface</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">            len = geomPtr-&gt;vertices.length();</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; len &amp;&amp; idx &lt; cacheLen; ++idx ) {</div>
<div class="line">                double3 &amp; pt = builder.<a class="code" href="./class_m_array_data_builder.html#a6d195a24b9624f2e38079e1ce412c9bb">addElement</a>( idx ).<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a>&amp; cachePt = (*pointCache)[cacheIndex];</div>
<div class="line">                pt[0] += cachePt.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                pt[1] += cachePt.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                pt[2] += cachePt.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// Tweak the points. If savePoints is true, also save the tweaks in the</span></div>
<div class="line"> <span class="comment">// pointCache. If updatePoints is true, add the new tweaks to the existing</span></div>
<div class="line"> <span class="comment">// data in the pointCache.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (len &gt; 0) {</div>
<div class="line"> <span class="keywordflow">for</span> ( i=0; i&lt;len; i++ )</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> comp = convertToVertexComponent(componentList[i]);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComp( comp );</div>
<div class="line"> <span class="keywordtype">int</span> elemCount = fnComp.elementCount();</div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line">                    pointCache-&gt;<a class="code" href="./class_m_point_array.html#ab463a783d0657af39ca2fa7294287662">setSizeIncrement</a>(elemCount);</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> idx=0; idx&lt;elemCount; idx++ )</div>
<div class="line">                {</div>
<div class="line"> <span class="keywordtype">int</span> elemIndex = fnComp.element( idx );</div>
<div class="line">                    double3 &amp; pt = builder.<a class="code" href="./class_m_array_data_builder.html#a6d195a24b9624f2e38079e1ce412c9bb">addElement</a>( elemIndex ).<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line">                    currPt = newPt = geomPtr-&gt;vertices[elemIndex];</div>
<div class="line">                    newPt *= mat;</div>
<div class="line">                    delta.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> = newPt.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> - currPt.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                    delta.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a> = newPt.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a> - currPt.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                    delta.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a> = newPt.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a> - currPt.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line">                    pt[0] += delta.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                    pt[1] += delta.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                    pt[2] += delta.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line"> <span class="comment">// store the points in the pointCache for undo</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">                        pointCache-&gt;<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(delta*(-1.0));</div>
<div class="line">                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (updatePoints &amp;&amp; cacheIndex &lt; cacheLen) {</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a>&amp; cachePt = (*pointCache)[cacheIndex];</div>
<div class="line">                        cachePt[0] -= delta.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                        cachePt[1] -= delta.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                        cachePt[2] -= delta.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line">                        cacheIndex++;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// if the component list is of zero-length, it indicates that we</span></div>
<div class="line"> <span class="comment">// should transform the entire surface</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">            len = geomPtr-&gt;vertices.length();</div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line">                pointCache-&gt;<a class="code" href="./class_m_point_array.html#ab463a783d0657af39ca2fa7294287662">setSizeIncrement</a>(len);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; len; ++idx ) {</div>
<div class="line">                double3 &amp; pt = builder.<a class="code" href="./class_m_array_data_builder.html#a6d195a24b9624f2e38079e1ce412c9bb">addElement</a>( idx ).<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line">                currPt = newPt = geomPtr-&gt;vertices[idx];</div>
<div class="line">                newPt *= mat;</div>
<div class="line">                delta.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> = newPt.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> - currPt.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                delta.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a> = newPt.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a> - currPt.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                delta.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a> = newPt.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a> - currPt.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line">                pt[0] += delta.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                pt[1] += delta.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                pt[2] += delta.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line"> <span class="comment">// store the points in the pointCache for undo</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">                    pointCache-&gt;<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(delta*-1.0);</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (updatePoints &amp;&amp; idx &lt; cacheLen) {</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a>&amp; cachePt = (*pointCache)[idx];</div>
<div class="line">                    cachePt[0] -= delta.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                    cachePt[1] -= delta.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                    cachePt[2] -= delta.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// Set the builder into the handle.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    handle.<a name="a86"></a><a class="code" href="./class_m_array_data_handle.html#a575cf7adebfd8e3c29e588d2cd1c47a6">set</a>(builder);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Tell maya the bounding box for this object has changed</span></div>
<div class="line"> <span class="comment">// and thus "boundingBox()" needs to be called.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    childChanged( <a class="code" href="./class_m_px_surface_shape.html#ae6e3d315c5dd375e845a29ffeb5f8727a3cf2a789a428c68c537cf3ba6b9ad743">MPxSurfaceShape::kBoundingBoxChanged</a> );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Signal to the viewport that it needs to update the object</span></div>
<div class="line">    signalDirtyToViewport();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Transforms the given soft-selected components interpolated using the specified weights.</span></div>
<div class="line"><span class="comment">//    This method is used by the move, rotate, and scale tools in component mode.</span></div>
<div class="line"><span class="comment">//    The bounding box has to be updated here, so do the normals and</span></div>
<div class="line"><span class="comment">//    any other attributes that depend on vertex positions.</span></div>
<div class="line"><span class="comment">//    It is similar to the transformUsing() virtual function.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    xform           the matrix representing the transformation that is to be applied to the components</span></div>
<div class="line"><span class="comment">//    space           the matrix representing the transformation space to perform the interpolated transformation.</span></div>
<div class="line"><span class="comment">//                    A value of NULL indicates it should be ignored.</span></div>
<div class="line"><span class="comment">//    componentList   a list of components to be transformed and their weights.  This list will not be empty.</span></div>
<div class="line"><span class="comment">//    cachingMode     whether the points should be added/updated in the pointCache, or restored from</span></div>
<div class="line"><span class="comment">//                    the pointCache, or transform using the original values in the pointCache.</span></div>
<div class="line"><span class="comment">//    pointCache      used to store for undo and restore points during undo</span></div>
<div class="line"><span class="comment">//    freezePlane     used for symmetric transformation of components.  A value of NULL indicates</span></div>
<div class="line"><span class="comment">//                    it is not used and there is no symmetric transformation.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::weightedTransformUsing(   <span class="keyword">const</span> <a name="_a87"></a><a class="code" href="./class_m_transformation_matrix.html">MTransformationMatrix</a>&amp; xform,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a>* space,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_object_array.html">MObjectArray</a>&amp; componentList,</div>
<div class="line">                                        MVertexCachingMode cachingMode,</div>
<div class="line"> <a class="code" href="./class_m_point_array.html">MPointArray</a>* pointCache,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a88"></a><a class="code" href="./class_m_plane.html">MPlane</a>* freezePlane )</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// For example purposes only, use the default MPxSurfaceShape::weightedTransformUsing() if the</span></div>
<div class="line"> <span class="comment">// useWeightedTransformUsingFunction is false</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> plg_useWeightedTransformUsingFunction( thisMObject(), useWeightedTransformUsingFunction );</div>
<div class="line"> <span class="keywordtype">bool</span> val_useWeightedTransformUsingFunction = plg_useWeightedTransformUsingFunction.asBool();</div>
<div class="line"> <span class="keywordflow">if</span> (!val_useWeightedTransformUsingFunction)</div>
<div class="line">    {</div>
<div class="line"> <a name="a89"></a><a class="code" href="./class_m_px_surface_shape.html#a66ccd127d36b5dc896459eddff2b7587">MPxSurfaceShape::weightedTransformUsing</a>(xform, space, componentList, cachingMode, pointCache, freezePlane);</div>
<div class="line">        signalDirtyToViewport();</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create cachingMode boolean values for clearer reading of conditional code below</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordtype">bool</span> savePoints    = (cachingMode == <a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540a7880e840faa9de43057b0b41a1e84639">MPxSurfaceShape::kSavePoints</a>);</div>
<div class="line"> <span class="keywordtype">bool</span> updatePoints  = (cachingMode == <a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540ab169f7f366f434196216f2bfaaa05017">MPxSurfaceShape::kUpdatePoints</a>);</div>
<div class="line"> <span class="keywordtype">bool</span> restorePoints  = (cachingMode == <a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540af7320699eeaf840fd0bc89aee27c91fc">MPxSurfaceShape::kRestorePoints</a>);</div>
<div class="line"> <span class="keywordtype">bool</span> transformOrigPoints  = (cachingMode == <a name="a90"></a><a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540a1681e97d030f79b2cd45f3bb33644934">MPxSurfaceShape::kTransformOriginalPoints</a>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Pre-calculate parameters</span></div>
<div class="line"> <a class="code" href="./class_m_matrix.html">MMatrix</a> spaceInv;</div>
<div class="line"> <span class="keywordflow">if</span> (space) {</div>
<div class="line">        spaceInv = space-&gt;<a name="a91"></a><a class="code" href="./class_m_matrix.html#a8ca5ebc404566e2c4a16d4754772e082">inverse</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Traverse the componentList and modify the control points</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    apiMeshGeom* geomPtr = meshGeom();</div>
<div class="line"> <span class="keywordtype">float</span> almostZero = 1.0e-5f; <span class="comment">// Hardcoded tolerance</span></div>
<div class="line"> <span class="keywordtype">int</span> pointCacheIndex = 0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = componentList.<a class="code" href="./class_m_object_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;len; i++ )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> comp = convertToVertexComponent(componentList[i]);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComp( comp );</div>
<div class="line"> <span class="keywordtype">int</span> elemCount = fnComp.elementCount();</div>
<div class="line"> <span class="keywordtype">bool</span> hasWeights = fnComp.hasWeights();</div>
<div class="line"> <span class="keywordtype">bool</span> hasSeam = (NULL != freezePlane);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (savePoints &amp;&amp; (0 == i) ) {</div>
<div class="line">            pointCache-&gt;<a class="code" href="./class_m_point_array.html#ab463a783d0657af39ca2fa7294287662">setSizeIncrement</a>(elemCount);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> idx=0; idx&lt;elemCount; idx++ )</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">int</span> elemIndex = fnComp.element( idx );</div>
<div class="line"> <span class="keywordtype">float</span> perc = (hasWeights) ? fnComp.weight(idx).influence() : 1.0f;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Only act upon points (store in pointCache, transform, etc) that have a non-zero weight</span></div>
<div class="line"> <span class="keywordflow">if</span> (perc &gt; almostZero) { <span class="comment">// if the point has enough weight to be transformed</span></div>
<div class="line"> <span class="keywordflow">if</span> (restorePoints) {</div>
<div class="line"> <span class="comment">// restore the original point from the point cache</span></div>
<div class="line">                    geomPtr-&gt;vertices[elemIndex] = <a name="_a92"></a><a class="code" href="./class_m_vector.html">MVector</a>( (*pointCache)[pointCacheIndex] );</div>
<div class="line">                    pointCacheIndex++;</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span> { <span class="comment">// perform point transformation</span></div>
<div class="line"> <span class="comment">// Update the pointCache with the original value</span></div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line">                        pointCache-&gt;<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>( geomPtr-&gt;vertices[elemIndex] );</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( transformOrigPoints ) { <span class="comment">// start by reverting points back to their original values stored in the pointCache for the transformation</span></div>
<div class="line">                        geomPtr-&gt;vertices[elemIndex] = <a class="code" href="./class_m_vector.html">MVector</a>( (*pointCache)[pointCacheIndex] );</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( updatePoints ) { <span class="comment">// update the pointCache with the current values</span></div>
<div class="line">                        (*pointCache)[pointCacheIndex] = geomPtr-&gt;vertices[elemIndex];</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Compute interpolated transformation matrix</span></div>
<div class="line"> <a class="code" href="./class_m_matrix.html">MMatrix</a> mat;</div>
<div class="line"> <span class="keywordflow">if</span> (perc == 1.0) {</div>
<div class="line">                        mat = xform.<a name="a93"></a><a class="code" href="./class_m_transformation_matrix.html#a8e2933c5f73e8cfb7409366582caa596">asMatrix</a>();</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                        mat = (space) ? (*space) * xform.<a class="code" href="./class_m_transformation_matrix.html#a8e2933c5f73e8cfb7409366582caa596">asMatrix</a>(perc) * (spaceInv) : xform.<a class="code" href="./class_m_transformation_matrix.html#a8e2933c5f73e8cfb7409366582caa596">asMatrix</a>(perc) ;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// transform to new position</span></div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> pt = geomPtr-&gt;vertices[elemIndex];  <span class="comment">// convert from MVector to MPoint</span></div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> newp(pt);</div>
<div class="line">                    newp *= mat;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// handle symmetry and reflection</span></div>
<div class="line"> <span class="keywordflow">if</span>( hasSeam &amp;&amp; fnComp.weight(idx).seam() &gt; 0.0f)</div>
<div class="line">                    {</div>
<div class="line">                        newp += freezePlane-&gt;<a name="a94"></a><a class="code" href="./class_m_plane.html#ae4e3074eb251d7f127ac9ccd2bbac916">normal</a>() * (fnComp.weight(idx).seam() * (freezePlane-&gt;<a name="a95"></a><a class="code" href="./class_m_plane.html#ab9c91d6dfd555a8afc3614baed180ce6">directedDistance</a>(pt) - freezePlane-&gt;<a class="code" href="./class_m_plane.html#ab9c91d6dfd555a8afc3614baed180ce6">directedDistance</a>( newp)));</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the geomPtr with the new point</span></div>
<div class="line">                    geomPtr-&gt;vertices[elemIndex] = <a class="code" href="./class_m_vector.html">MVector</a>( newp );</div>
<div class="line">                    pointCacheIndex++;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the surface</span></div>
<div class="line">    updateCachedSurface( geomPtr, componentList );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Transforms the given soft-selected components interpolated using the specified weights.</span></div>
<div class="line"><span class="comment">//    This method is used by the move, rotate, and scale tools in component mode when the</span></div>
<div class="line"><span class="comment">//    tweaks for the shape are stored on a separate tweak node.</span></div>
<div class="line"><span class="comment">//    The bounding box has to be updated here, so do the normals and</span></div>
<div class="line"><span class="comment">//    any other attributes that depend on vertex positions.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    It is similar to the tweakUsing() virtual function and is based on apiMesh::tweakUsing().</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    xform           the matrix representing the transformation that is to be applied to the components</span></div>
<div class="line"><span class="comment">//    space           the matrix representing the transformation space to perform the interpolated transformation.</span></div>
<div class="line"><span class="comment">//                    A value of NULL indicates it should be ignored.</span></div>
<div class="line"><span class="comment">//    componentList   a list of components to be transformed and their weights.  This list will not be empty.</span></div>
<div class="line"><span class="comment">//    cachingMode     whether the points should be added/updated in the pointCache, or restored from</span></div>
<div class="line"><span class="comment">//                    the pointCache, or transform using use the original values in the pointCache.</span></div>
<div class="line"><span class="comment">//    pointCache      used to store for undo and restore points during undo</span></div>
<div class="line"><span class="comment">//    freezePlane     used for symmetric transformation of components.  A value of NULL indicates</span></div>
<div class="line"><span class="comment">//                    it is not used and there is no symmetric transformation.</span></div>
<div class="line"><span class="comment">//    handle        - handle to the attribute on the tweak node where the</span></div>
<div class="line"><span class="comment">//                    tweaks should be stored</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::weightedTweakUsing(</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_transformation_matrix.html">MTransformationMatrix</a>&amp; xform,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a>* space,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_object_array.html">MObjectArray</a>&amp; componentList,</div>
<div class="line">                            MVertexCachingMode cachingMode,</div>
<div class="line"> <a class="code" href="./class_m_point_array.html">MPointArray</a>* pointCache,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_plane.html">MPlane</a>* freezePlane,</div>
<div class="line"> <a class="code" href="./class_m_array_data_handle.html">MArrayDataHandle</a>&amp; handle )</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// For example purposes only, use the default MPxSurfaceShape::weightedTransformUsing() if the</span></div>
<div class="line"> <span class="comment">// useWeightedTweakUsingFunction is false</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> plg_useWeightedTweakUsingFunction( thisMObject(), useWeightedTweakUsingFunction );</div>
<div class="line"> <span class="keywordtype">bool</span> val_useWeightedTweakUsingFunction = plg_useWeightedTweakUsingFunction.asBool();</div>
<div class="line"> <span class="keywordflow">if</span> (!val_useWeightedTweakUsingFunction) {</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a96"></a><a class="code" href="./class_m_px_surface_shape.html#aa704affe596b61074b4eb2bf087e8092">MPxSurfaceShape::weightedTweakUsing</a>(xform, space, componentList, cachingMode, pointCache, freezePlane, handle);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    apiMeshGeom* geomPtr = meshGeom();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create cachingMode boolean values for clearer reading of conditional code below</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordtype">bool</span> savePoints    = (cachingMode == <a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540a7880e840faa9de43057b0b41a1e84639">MPxSurfaceShape::kSavePoints</a>);</div>
<div class="line"> <span class="keywordtype">bool</span> updatePoints  = (cachingMode == <a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540ab169f7f366f434196216f2bfaaa05017">MPxSurfaceShape::kUpdatePoints</a>);</div>
<div class="line"> <span class="keywordtype">bool</span> restorePoints = (cachingMode == <a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540af7320699eeaf840fd0bc89aee27c91fc">MPxSurfaceShape::kRestorePoints</a>);</div>
<div class="line"> <span class="keywordtype">bool</span> transformOrigPoints  = (cachingMode == <a class="code" href="./class_m_px_surface_shape.html#ac725bb831745e05294cf2bc255514540a1681e97d030f79b2cd45f3bb33644934">MPxSurfaceShape::kTransformOriginalPoints</a>);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_array_data_builder.html">MArrayDataBuilder</a> builder = handle.<a class="code" href="./class_m_array_data_handle.html#a48b34beab40fa4ae60cfe40e556f591a">builder</a>();</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> delta, currPt, newPt;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = componentList.<a class="code" href="./class_m_object_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cacheIndex = 0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cacheLen = (NULL != pointCache) ? pointCache-&gt;<a class="code" href="./class_m_point_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() : 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( restorePoints ) {</div>
<div class="line"> <span class="comment">// restore points from the pointCache</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// traverse the component list</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">for</span> ( i=0; i&lt;len; i++ )</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> comp = convertToVertexComponent(componentList[i]);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComp( comp );</div>
<div class="line"> <span class="keywordtype">int</span> elemCount = fnComp.elementCount();</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> idx=0; idx&lt;elemCount &amp;&amp; cacheIndex &lt; cacheLen; idx++, cacheIndex++) {</div>
<div class="line"> <span class="keywordtype">int</span> elemIndex = fnComp.element( idx );</div>
<div class="line">                double3 &amp; pt = builder.<a class="code" href="./class_m_array_data_builder.html#a6d195a24b9624f2e38079e1ce412c9bb">addElement</a>( elemIndex ).<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a>&amp; cachePt = (*pointCache)[cacheIndex];</div>
<div class="line">                pt[0] += cachePt.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                pt[1] += cachePt.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                pt[2] += cachePt.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// Tweak the points. If savePoints is true, also save the tweaks in the</span></div>
<div class="line"> <span class="comment">// pointCache. If updatePoints is true, add the new tweaks to the existing</span></div>
<div class="line"> <span class="comment">// data in the pointCache.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Specify a few parameters (for weighted transformation)</span></div>
<div class="line"> <span class="keywordtype">float</span> almostZero = 1.0e-5f; <span class="comment">// Hardcoded tolerance</span></div>
<div class="line"> <a class="code" href="./class_m_matrix.html">MMatrix</a> spaceInv;</div>
<div class="line"> <span class="keywordflow">if</span> (space) {</div>
<div class="line">            spaceInv = space-&gt;<a class="code" href="./class_m_matrix.html#a8ca5ebc404566e2c4a16d4754772e082">inverse</a>();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> ( i=0; i&lt;len; i++ )</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> comp = convertToVertexComponent(componentList[i]);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComp( comp );</div>
<div class="line"> <span class="keywordtype">int</span> elemCount = fnComp.elementCount();</div>
<div class="line"> <span class="keywordtype">bool</span> hasWeights = fnComp.hasWeights(); <span class="comment">// (for weighted transformation)</span></div>
<div class="line"> <span class="keywordtype">bool</span> hasSeam = (NULL != freezePlane);  <span class="comment">// (for weighted transformation)</span></div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line">                pointCache-&gt;<a class="code" href="./class_m_point_array.html#ab463a783d0657af39ca2fa7294287662">setSizeIncrement</a>(elemCount);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> idx=0; idx&lt;elemCount; idx++ )</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">int</span> elemIndex = fnComp.element( idx );</div>
<div class="line"> <span class="keywordtype">float</span> perc = (hasWeights) ? fnComp.weight(idx).influence() : 1.0f; <span class="comment">// get the weight for the component</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Only act upon points (store in pointCache, transform, etc) that have a non-zero weight</span></div>
<div class="line"> <span class="keywordflow">if</span> (perc &gt; almostZero) { <span class="comment">// if the point has enough weight to be transformed (for weighted transformation)</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Compute interpolated transformation matrix (for weighted transformation)</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_matrix.html">MMatrix</a> mat;</div>
<div class="line"> <span class="keywordflow">if</span> (perc == 1.0) {</div>
<div class="line">                        mat = xform.<a class="code" href="./class_m_transformation_matrix.html#a8e2933c5f73e8cfb7409366582caa596">asMatrix</a>();</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                        mat = (space) ? (*space) * xform.<a class="code" href="./class_m_transformation_matrix.html#a8e2933c5f73e8cfb7409366582caa596">asMatrix</a>(perc) * (spaceInv) : xform.<a class="code" href="./class_m_transformation_matrix.html#a8e2933c5f73e8cfb7409366582caa596">asMatrix</a>(perc) ;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Start by reverting points back to their original values stored in</span></div>
<div class="line"> <span class="comment">// the pointCache for the transformation</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> ( transformOrigPoints ) {</div>
<div class="line">                        geomPtr-&gt;vertices[elemIndex] = <a class="code" href="./class_m_vector.html">MVector</a>( (*pointCache)[cacheIndex] );</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Perform transformation of the point</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">                    double3 &amp; pt = builder.<a class="code" href="./class_m_array_data_builder.html#a6d195a24b9624f2e38079e1ce412c9bb">addElement</a>( elemIndex ).<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line">                    currPt = newPt = geomPtr-&gt;vertices[elemIndex];</div>
<div class="line">                    newPt *= mat;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Handle symmetry and reflection (for weighted transformation)</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span>( hasSeam &amp;&amp; fnComp.weight(idx).seam() &gt; 0.0f)</div>
<div class="line">                    {</div>
<div class="line">                        newPt += freezePlane-&gt;<a class="code" href="./class_m_plane.html#ae4e3074eb251d7f127ac9ccd2bbac916">normal</a>() * (fnComp.weight(idx).seam() * (freezePlane-&gt;<a class="code" href="./class_m_plane.html#ab9c91d6dfd555a8afc3614baed180ce6">directedDistance</a>(currPt) - freezePlane-&gt;<a class="code" href="./class_m_plane.html#ab9c91d6dfd555a8afc3614baed180ce6">directedDistance</a>( newPt)));</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Calculate deltas and final positions</span></div>
<div class="line">                    delta.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> = newPt.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a> - currPt.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                    delta.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a> = newPt.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a> - currPt.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                    delta.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a> = newPt.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a> - currPt.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line">                    pt[0] += delta.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                    pt[1] += delta.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                    pt[2] += delta.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line"> <span class="keywordflow">if</span> (savePoints) {</div>
<div class="line"> <span class="comment">// store the points in the pointCache for undo</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">                        pointCache-&gt;<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(delta*(-1.0));</div>
<div class="line">                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (updatePoints &amp;&amp; cacheIndex &lt; cacheLen) {</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a>&amp; cachePt = (*pointCache)[cacheIndex];</div>
<div class="line">                        cachePt[0] -= delta.<a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>;</div>
<div class="line">                        cachePt[1] -= delta.<a class="code" href="./class_m_point.html#ab927965981178aa1fba979a37168db2a">y</a>;</div>
<div class="line">                        cachePt[2] -= delta.<a class="code" href="./class_m_point.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>;</div>
<div class="line">                        cacheIndex++;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// Set the builder into the handle.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    handle.<a class="code" href="./class_m_array_data_handle.html#a575cf7adebfd8e3c29e588d2cd1c47a6">set</a>(builder);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Tell maya the bounding box for this object has changed</span></div>
<div class="line"> <span class="comment">// and thus "boundingBox()" needs to be called.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    childChanged( <a class="code" href="./class_m_px_surface_shape.html#ae6e3d315c5dd375e845a29ffeb5f8727a3cf2a789a428c68c537cf3ba6b9ad743">MPxSurfaceShape::kBoundingBoxChanged</a> );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns offsets for the given components to be used my the</span></div>
<div class="line"><span class="comment">//    move tool in normal/u/v mode.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    component - components to calculate offsets for</span></div>
<div class="line"><span class="comment">//    direction - array of offsets to be filled</span></div>
<div class="line"><span class="comment">//    mode      - the type of offset to be calculated</span></div>
<div class="line"><span class="comment">//    normalize - specifies whether the offsets should be normalized</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    true if the offsets could be calculated, false otherwise</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::vertexOffsetDirection( <a class="code" href="./class_m_object.html">MObject</a> &amp; component,</div>
<div class="line"> <a name="_a97"></a><a class="code" href="./class_m_vector_array.html">MVectorArray</a> &amp; direction,</div>
<div class="line">                                     MVertexOffsetMode mode,</div>
<div class="line"> <span class="keywordtype">bool</span> normalize )</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"> <span class="keywordtype">bool</span> offsetOkay = false ;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> vtxComp = convertToVertexComponent(component);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> fnComp( vtxComp, &amp;stat );</div>
<div class="line"> <span class="keywordflow">if</span> ( !stat || (component.<a name="a98"></a><a class="code" href="./class_m_object.html#a7e5fd5d37dde6df8c0cf350e00ca0a75">apiType</a>() != <a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522">MFn::kMeshVertComponent</a>) ) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    offsetOkay = true ;</div>
<div class="line"></div>
<div class="line">    apiMeshGeom * geomPtr = meshGeom();</div>
<div class="line"> <span class="keywordflow">if</span> ( NULL == geomPtr ) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// For each vertex add the appropriate offset</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordtype">int</span> count = fnComp.elementCount();</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> idx=0; idx&lt;count; idx++ )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_vector.html">MVector</a> normal = geomPtr-&gt;normals[ fnComp.element(idx) ];</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( mode == <a name="a99"></a><a class="code" href="./class_m_px_surface_shape.html#ad259dc95ef1fc8497f892abae4f4011aa227e8416235cd3b43077ca91504a463f">MPxSurfaceShape::kNormal</a> ) {</div>
<div class="line"> <span class="keywordflow">if</span>( normalize ) normal.<a name="a100"></a><a class="code" href="./class_m_vector.html#ab66b0c7697d96a278da9bca810f4dee1">normalize</a>() ;</div>
<div class="line">            direction.<a name="a101"></a><a class="code" href="./class_m_vector_array.html#a01b5503917181b1b379579cc1d6d802e">append</a>( normal );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// Construct an orthonormal basis from the normal</span></div>
<div class="line"> <span class="comment">// uAxis, and vAxis are the new vectors.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_vector.html">MVector</a> uAxis, vAxis ;</div>
<div class="line"> <span class="keywordtype">int</span>    i, j, k;</div>
<div class="line"> <span class="keywordtype">double</span> a;</div>
<div class="line">            normal.<a class="code" href="./class_m_vector.html#ab66b0c7697d96a278da9bca810f4dee1">normalize</a>();</div>
<div class="line"></div>
<div class="line">            i = 0;  a = fabs( normal[0] );</div>
<div class="line"> <span class="keywordflow">if</span> ( a &lt; fabs(normal[1]) ) { i = 1; a = fabs(normal[1]); }</div>
<div class="line"> <span class="keywordflow">if</span> ( a &lt; fabs(normal[2]) ) i = 2;</div>
<div class="line">            j = (i+1)%3;  k = (j+1)%3;</div>
<div class="line">            a = sqrt(normal[i]*normal[i] + normal[j]*normal[j]);</div>
<div class="line">            uAxis[i] = -normal[j]/a; uAxis[j] = normal[i]/a; uAxis[k] = 0.0;</div>
<div class="line">            vAxis = normal^uAxis;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( mode == <a name="a102"></a><a class="code" href="./class_m_px_surface_shape.html#ad259dc95ef1fc8497f892abae4f4011aadfff66fea897672bdd592274b932a9f8">MPxSurfaceShape::kUTangent</a> ||</div>
<div class="line">                 mode == <a name="a103"></a><a class="code" href="./class_m_px_surface_shape.html#ad259dc95ef1fc8497f892abae4f4011aab595fe9b8dffcc6e9c50a6d2bd1645c0">MPxSurfaceShape::kUVNTriad</a> )</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">if</span>( normalize ) uAxis.<a class="code" href="./class_m_vector.html#ab66b0c7697d96a278da9bca810f4dee1">normalize</a>() ;</div>
<div class="line">                direction.<a class="code" href="./class_m_vector_array.html#a01b5503917181b1b379579cc1d6d802e">append</a>( uAxis );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( mode == <a name="a104"></a><a class="code" href="./class_m_px_surface_shape.html#ad259dc95ef1fc8497f892abae4f4011aa811abdab0088108bccc954d7234bfe58">MPxSurfaceShape::kVTangent</a> ||</div>
<div class="line">                 mode == <a class="code" href="./class_m_px_surface_shape.html#ad259dc95ef1fc8497f892abae4f4011aab595fe9b8dffcc6e9c50a6d2bd1645c0">MPxSurfaceShape::kUVNTriad</a> )</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">if</span>( normalize ) vAxis.<a class="code" href="./class_m_vector.html#ab66b0c7697d96a278da9bca810f4dee1">normalize</a>() ;</div>
<div class="line">                direction.<a class="code" href="./class_m_vector_array.html#a01b5503917181b1b379579cc1d6d802e">append</a>( vAxis );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( mode == <a class="code" href="./class_m_px_surface_shape.html#ad259dc95ef1fc8497f892abae4f4011aab595fe9b8dffcc6e9c50a6d2bd1645c0">MPxSurfaceShape::kUVNTriad</a> ) {</div>
<div class="line"> <span class="keywordflow">if</span>( normalize ) normal.<a class="code" href="./class_m_vector.html#ab66b0c7697d96a278da9bca810f4dee1">normalize</a>() ;</div>
<div class="line">                direction.<a class="code" href="./class_m_vector_array.html#a01b5503917181b1b379579cc1d6d802e">append</a>( normal );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> offsetOkay ;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::isBounded() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Specifies that this object has a boundingBox.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a name="_a105"></a><a class="code" href="./class_m_bounding_box.html">MBoundingBox</a> apiMesh::boundingBox() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns the bounding box for this object.</span></div>
<div class="line"><span class="comment">//    It is a good idea not to recompute here as this funcion is called often.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> ( fShapeDirty )</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Cast away the constant</span></div>
<div class="line">        apiMesh *msPtr = (apiMesh *)<span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Force update</span></div>
<div class="line">        msPtr-&gt;meshDataRef();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> thisNode = thisMObject();</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   c1Plug( thisNode, bboxCorner1 );</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a>   c2Plug( thisNode, bboxCorner2 );</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> corner1Object;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> corner2Object;</div>
<div class="line">    c1Plug.getValue( corner1Object );</div>
<div class="line">    c2Plug.getValue( corner2Object );</div>
<div class="line"></div>
<div class="line">    double3 corner1, corner2;</div>
<div class="line"></div>
<div class="line"> <a name="_a106"></a><a class="code" href="./class_m_fn_numeric_data.html">MFnNumericData</a> fnData;</div>
<div class="line">    fnData.<a name="a107"></a><a class="code" href="./class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>( corner1Object );</div>
<div class="line">    fnData.<a name="a108"></a><a class="code" href="./class_m_fn_numeric_data.html#a6b776208995f972692845a9f2809ff2f">getData</a>( corner1[0], corner1[1], corner1[2] );</div>
<div class="line">    fnData.<a class="code" href="./class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>( corner2Object );</div>
<div class="line">    fnData.<a class="code" href="./class_m_fn_numeric_data.html#a6b776208995f972692845a9f2809ff2f">getData</a>( corner2[0], corner2[1], corner2[2] );</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> corner1Point( corner1[0], corner1[1], corner1[2] );</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> corner2Point( corner2[0], corner2[1], corner2[2] );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>( corner1Point, corner2Point );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::convertToVertexComponent(<span class="keyword">const</span> <a class="code" href="./class_m_object.html">MObject</a>&amp; components)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> retVal = components;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (components.<a class="code" href="./class_m_object.html#a7e5fd5d37dde6df8c0cf350e00ca0a75">apiType</a>() != <a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522">MFn::kMeshVertComponent</a>)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Convert:</span></div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> srcComponent(components);</div>
<div class="line"> <a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7">MFn::Type</a> srcComponentType = srcComponent.componentType();</div>
<div class="line"></div>
<div class="line">        std::set&lt;int&gt; srcIndices;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;srcComponent.elementCount(); ++i)</div>
<div class="line">            srcIndices.insert( srcComponent.element(i) );</div>
<div class="line"></div>
<div class="line">        retVal = srcComponent.create(<a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522">MFn::kMeshVertComponent</a>);</div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> vtxComponent(retVal);</div>
<div class="line"> <span class="keyword">const</span> apiMeshGeom* geomPtr = meshGeom();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> base = 0;</div>
<div class="line"> <span class="keywordtype">int</span> edgeId = 0;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> faceIdx=0; faceIdx&lt;geomPtr-&gt;faceCount; faceIdx++)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// ignore degenerate faces</span></div>
<div class="line"> <span class="keywordtype">int</span> numVerts = geomPtr-&gt;face_counts[faceIdx];</div>
<div class="line"> <span class="keywordflow">if</span> (numVerts &gt; 2)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v=0; v&lt;numVerts; v++)</div>
<div class="line">                {</div>
<div class="line"> <span class="keywordflow">if</span> (srcComponentType == <a name="a109"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a18f788d50a75ca81a0dc5a2538f364ae">MFn::kMeshEdgeComponent</a>)</div>
<div class="line">                    {</div>
<div class="line"> <span class="keywordflow">if</span> (srcIndices.count(edgeId))</div>
<div class="line">                        {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vindex1 = base + (v % numVerts);</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vindex2 = base + ((v+1) % numVerts);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> vertexId1 = geomPtr-&gt;face_connects[vindex1];</div>
<div class="line"> <span class="keywordtype">int</span> vertexId2 = geomPtr-&gt;face_connects[vindex2];</div>
<div class="line"></div>
<div class="line">                            vtxComponent.addElement(vertexId1);</div>
<div class="line">                            vtxComponent.addElement(vertexId2);</div>
<div class="line">                        }</div>
<div class="line">                        ++edgeId;</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                    {</div>
<div class="line"> <span class="comment">// Face component:</span></div>
<div class="line"> <span class="keywordflow">if</span> (srcIndices.count(faceIdx))</div>
<div class="line">                        {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vindex = base + (v % numVerts);</div>
<div class="line"> <span class="keywordtype">int</span> vertexId = geomPtr-&gt;face_connects[vindex];</div>
<div class="line">                            vtxComponent.addElement(vertexId);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                base += numVerts;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> retVal;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><a name="_a110"></a><a class="code" href="./class_m_px_geometry_iterator.html">MPxGeometryIterator</a>* apiMesh::geometryIteratorSetup(<a class="code" href="./class_m_object_array.html">MObjectArray</a>&amp; componentList,</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a>&amp; components,</div>
<div class="line"> <span class="keywordtype">bool</span> forReadOnly )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Creates a geometry iterator compatible with his shape.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    componentList - list of components to be iterated</span></div>
<div class="line"><span class="comment">//    components    - component to be iterator</span></div>
<div class="line"><span class="comment">//    forReadOnly   -</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Returns</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    An iterator for the components</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    apiMeshGeomIterator * result = NULL;</div>
<div class="line"> <span class="keywordflow">if</span> ( components.<a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>() ) {</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_object_array.html">MObjectArray</a> vtxComponents;</div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;(int)componentList.<a class="code" href="./class_m_object_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++ ) </div>
<div class="line">        {</div>
<div class="line">            vtxComponents.<a name="a111"></a><a class="code" href="./class_m_object_array.html#a3694392863ba632bca5d76cbbf190ef5">append</a>(convertToVertexComponent(componentList[i]));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        result = <span class="keyword">new</span> apiMeshGeomIterator( meshGeom(), vtxComponents );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> vtxComponent = convertToVertexComponent(components);</div>
<div class="line">        result = <span class="keyword">new</span> apiMeshGeomIterator( meshGeom(), vtxComponent );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::acceptsGeometryIterator( <span class="keywordtype">bool</span> writeable )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Specifies that this shape can provide an iterator for getting/setting</span></div>
<div class="line"><span class="comment">//    control point values.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    writable - maya asks for an iterator that can set points if this is true</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* override */</span></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::acceptsGeometryIterator( <a class="code" href="./class_m_object.html">MObject</a>&amp;, <span class="keywordtype">bool</span> writeable,</div>
<div class="line"> <span class="keywordtype">bool</span> forReadOnly )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Specifies that this shape can provide an iterator for getting/setting</span></div>
<div class="line"><span class="comment">//    control point values.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Arguments</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    writable   - maya asks for an iterator that can set points if this is true</span></div>
<div class="line"><span class="comment">//    forReadOnly - maya asking for an iterator for querying only</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Helper functions</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::hasHistory()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns true if the shape has input history, false otherwise.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fHasHistoryOnCreate;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::shapeDirty()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns true if the input surface of the shape has been dirtied since</span></div>
<div class="line"><span class="comment">//    the last reset of the flag</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fShapeDirty;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::resetShapeDirty()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Reset the shape dirty state of the node</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    fShapeDirty = <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::materialDirty() const</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns true if the shading group of the shape has been changed since</span></div>
<div class="line"><span class="comment">//    the last reset of the flag</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fMaterialDirty;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::setMaterialDirty(<span class="keywordtype">bool</span> dirty)</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Reset the material dirty state of the node</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    fMaterialDirty = dirty;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::computeBoundingBox( <a class="code" href="./class_m_data_block.html">MDataBlock</a>&amp; datablock )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Use the larges/smallest vertex positions to set the corners</span></div>
<div class="line"><span class="comment">//    of the bounding box.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat = <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update bounding box</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> lowerHandle = datablock.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>( bboxCorner1 );</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> upperHandle = datablock.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>( bboxCorner2 );</div>
<div class="line">    double3 &amp;lower = lowerHandle.<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line">    double3 &amp;upper = upperHandle.<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line"></div>
<div class="line">    apiMeshGeom* geomPtr = meshGeom();</div>
<div class="line"> <span class="keywordtype">int</span> cnt = geomPtr-&gt;vertices.length();</div>
<div class="line"> <span class="keywordflow">if</span> ( cnt == 0 ) <span class="keywordflow">return</span> stat;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This clears any old bbox values</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> tmppnt = geomPtr-&gt;vertices[0];</div>
<div class="line">    lower[0] = tmppnt[0]; lower[1] = tmppnt[1]; lower[2] = tmppnt[2];</div>
<div class="line">    upper[0] = tmppnt[0]; upper[1] = tmppnt[1]; upper[2] = tmppnt[2];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;cnt; i++ )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> pnt = geomPtr-&gt;vertices[i];</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( pnt[0] &lt; lower[0] ) lower[0] = pnt[0];</div>
<div class="line"> <span class="keywordflow">if</span> ( pnt[1] &lt; lower[1] ) lower[1] = pnt[1];</div>
<div class="line"> <span class="keywordflow">if</span> ( pnt[2] &gt; lower[2] ) lower[2] = pnt[2];</div>
<div class="line"> <span class="keywordflow">if</span> ( pnt[0] &gt; upper[0] ) upper[0] = pnt[0];</div>
<div class="line"> <span class="keywordflow">if</span> ( pnt[1] &gt; upper[1] ) upper[1] = pnt[1];</div>
<div class="line"> <span class="keywordflow">if</span> ( pnt[2] &lt; upper[2] ) upper[2] = pnt[2];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    lowerHandle.<a name="a112"></a><a class="code" href="./class_m_data_handle.html#a7bdd61b8405188bb547fdba3fddace91">setClean</a>();</div>
<div class="line">    upperHandle.<a class="code" href="./class_m_data_handle.html#a7bdd61b8405188bb547fdba3fddace91">setClean</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Signal that the bounding box has changed.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    childChanged( <a class="code" href="./class_m_px_surface_shape.html#ae6e3d315c5dd375e845a29ffeb5f8727a3cf2a789a428c68c537cf3ba6b9ad743">MPxSurfaceShape::kBoundingBoxChanged</a> );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::computeInputSurface( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <a class="code" href="./class_m_data_block.html">MDataBlock</a>&amp; datablock )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    If there is input history, evaluate the input attribute</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat = <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MS::kSuccess</a>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the input surface if there is history</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> ( hasHistory() ) {</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> inputHandle = datablock.<a class="code" href="./class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>( inputSurface, &amp;stat );</div>
<div class="line">        MCHECKERROR( stat, <span class="stringliteral">"computeInputSurface error getting inputSurface"</span>)</div>
<div class="line"></div>
<div class="line">            apiMeshData* surf = (apiMeshData*) inputHandle.asPluginData();</div>
<div class="line">        if ( NULL == surf ) {</div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">"NULL inputSurface data found\n"</span>;</div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        apiMeshGeom* geomPtr = surf-&gt;fGeometry;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create the cachedSurface and copy the input surface into it</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a name="_a113"></a><a class="code" href="./class_m_fn_plugin_data.html">MFnPluginData</a> fnDataCreator;</div>
<div class="line"> <a class="code" href="./class_m_type_id.html">MTypeId</a> tmpid( apiMeshData::id );</div>
<div class="line">        fnDataCreator.<a name="a114"></a><a class="code" href="./class_m_fn_plugin_data.html#a7f9c5cbd4b1f86d66d0f5ec3c221b9e4">create</a>( tmpid, &amp;stat );</div>
<div class="line">        MCHECKERROR( stat, <span class="stringliteral">"compute : error creating Cached apiMeshData"</span>)</div>
<div class="line">            apiMeshData * newCachedData = (apiMeshData*)fnDataCreator.data( &amp;stat );</div>
<div class="line">        MCHECKERROR( stat, " error gettin proxy cached apiMeshData <span class="keywordtype">object</span>")</div>
<div class="line">            *(newCachedData-&gt;fGeometry) = *geomPtr;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> cachedHandle = datablock.outputValue( cachedSurface,&amp;stat );</div>
<div class="line">        MCHECKERROR( stat, "computeInputSurface error getting cachedSurface")</div>
<div class="line">            cachedHandle.set( newCachedData );</div>
<div class="line">    }</div>
<div class="line">    return stat;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::computeOutputSurface( const <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug,</div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a>&amp; datablock )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Compute the outputSurface attribute.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    If there is no history, use cachedSurface as the</span></div>
<div class="line"><span class="comment">//    input surface. All tweaks will get written directly</span></div>
<div class="line"><span class="comment">//    to it. Output is just a copy of the cached surface</span></div>
<div class="line"><span class="comment">//    that can be connected etc.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check for an input surface. The input surface, if it</span></div>
<div class="line"> <span class="comment">// exists, is copied to the cached surface.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> ( ! computeInputSurface( plug, datablock ) ) {</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a115"></a><a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MS::kFailure</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get a handle to the cached data</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> cachedHandle = datablock.outputValue( cachedSurface, &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, <span class="stringliteral">"computeInputSurface error getting cachedSurface"</span>)</div>
<div class="line">    apiMeshData* cached = (apiMeshData*) cachedHandle.asPluginData();</div>
<div class="line">    if ( NULL == cached ) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"NULL cachedSurface data found\n"</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    datablock.<a class="code" href="./class_m_data_handle.html#a7bdd61b8405188bb547fdba3fddace91">setClean</a>( plug );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Apply any vertex offsets.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> ( hasHistory() ) {</div>
<div class="line">        applyTweaks( datablock, cached-&gt;fGeometry );</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <a class="code" href="./class_m_array_data_handle.html">MArrayDataHandle</a> cpHandle = datablock.<a name="a116"></a><a class="code" href="./class_m_array_data_handle.html#a2cee08084f8de2a3394fffe7356e2002">inputArrayValue</a>( mControlPoints,</div>
<div class="line">                                                           &amp;stat );</div>
<div class="line">        cpHandle.<a name="a117"></a><a class="code" href="./class_m_array_data_handle.html#aff40e8c8c255448d5d19a05148b83058">setAllClean</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create some output data</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_fn_plugin_data.html">MFnPluginData</a> fnDataCreator;</div>
<div class="line"> <a class="code" href="./class_m_type_id.html">MTypeId</a> tmpid( apiMeshData::id );</div>
<div class="line">    fnDataCreator.<a class="code" href="./class_m_fn_plugin_data.html#a7f9c5cbd4b1f86d66d0f5ec3c221b9e4">create</a>( tmpid, &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, <span class="stringliteral">"compute : error creating apiMeshData"</span>)</div>
<div class="line">    apiMeshData * newData = (apiMeshData*)fnDataCreator.data( &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, "compute : error gettin at proxy apiMeshData <span class="keywordtype">object</span>")</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Copy the data</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    if ( NULL != cached ) {</div>
<div class="line">        *(newData-&gt;fGeometry) = *(cached-&gt;fGeometry);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"computeOutputSurface: NULL cachedSurface data\n"</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Assign the new data to the outputSurface handle</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> outHandle = datablock.outputValue( outputSurface );</div>
<div class="line">    outHandle.<a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( newData );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the bounding box attributes</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    stat = computeBoundingBox( datablock );</div>
<div class="line">    MCHECKERROR( stat, <span class="stringliteral">"computeBoundingBox"</span> )</div>
<div class="line"></div>
<div class="line">    return stat;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::computeWorldSurface( const <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <a class="code" href="./class_m_data_block.html">MDataBlock</a>&amp; datablock )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Compute the worldSurface attribute.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"></div>
<div class="line">    computeOutputSurface( plug, datablock );</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> inHandle = datablock.outputValue( outputSurface );</div>
<div class="line">    apiMeshData* outSurf = (apiMeshData*)inHandle.<a name="a118"></a><a class="code" href="./class_m_data_handle.html#ab5d7bebbf1c087c1ff803b1c41ad4c00">asPluginData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> ( NULL == outSurf ) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"computeWorldSurface: outSurf NULL\n"</span>;</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MS::kFailure</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create some output data</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_fn_plugin_data.html">MFnPluginData</a> fnDataCreator;</div>
<div class="line"> <a class="code" href="./class_m_type_id.html">MTypeId</a> tmpid( apiMeshData::id );</div>
<div class="line"></div>
<div class="line">    fnDataCreator.<a class="code" href="./class_m_fn_plugin_data.html#a7f9c5cbd4b1f86d66d0f5ec3c221b9e4">create</a>( tmpid, &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, <span class="stringliteral">"compute : error creating apiMeshData"</span>)</div>
<div class="line"></div>
<div class="line">    apiMeshData * newData = (apiMeshData*)fnDataCreator.data( &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, "compute : error gettin at proxy apiMeshData <span class="keywordtype">object</span>")</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get worldMatrix from MPxSurfaceShape and set it to MPxGeometryData</span></div>
<div class="line"> <a class="code" href="./class_m_matrix.html">MMatrix</a> worldMat = getWorldMatrix(datablock, 0);</div>
<div class="line">    newData-&gt;setMatrix( worldMat );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Copy the data</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    *(newData-&gt;fGeometry) = *(outSurf-&gt;fGeometry);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Assign the new data to the outputSurface handle</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordtype">int</span> arrayIndex = plug.logicalIndex( &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, "computWorldSurface : logicalIndex" );</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_array_data_handle.html">MArrayDataHandle</a> worldHandle = datablock.outputArrayValue( worldSurface,</div>
<div class="line">                                                               &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, "computWorldSurface : outputArrayValue" );</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_array_data_builder.html">MArrayDataBuilder</a> builder = worldHandle.builder( &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, "computWorldSurface : builder" );</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> outHandle = builder.addElement( arrayIndex, &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, "computWorldSurface : addElement" );</div>
<div class="line"></div>
<div class="line">    outHandle.set( newData );</div>
<div class="line"></div>
<div class="line">    return stat;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::applyTweaks( <a class="code" href="./class_m_data_block.html">MDataBlock</a>&amp; datablock, apiMeshGeom* geomPtr )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    If the shape has history, apply any tweaks (offsets) made</span></div>
<div class="line"><span class="comment">//    to the control points.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_array_data_handle.html">MArrayDataHandle</a> cpHandle = datablock.<a class="code" href="./class_m_array_data_handle.html#a2cee08084f8de2a3394fffe7356e2002">inputArrayValue</a>( mControlPoints,</div>
<div class="line">                                                           &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, <span class="stringliteral">"applyTweaks get cpHandle"</span> )</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Loop through the component list and transform each vertex.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    int elemCount = cpHandle.elementCount();</div>
<div class="line">    for ( <span class="keywordtype">int</span> idx=0; idx&lt;elemCount; idx++ )</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">int</span> elemIndex = cpHandle.<a name="a119"></a><a class="code" href="./class_m_array_data_handle.html#a2ca3c3d60cf2f3ac005b651379f26143">elementIndex</a>();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> pntHandle = cpHandle.<a name="a120"></a><a class="code" href="./class_m_array_data_handle.html#ae7d0b57302500d19b7a3f57f8aef45df">outputValue</a>();</div>
<div class="line">        double3&amp; pnt = pntHandle.<a class="code" href="./class_m_data_handle.html#a077d60a4a74d54e7a892d3c6ed115cc1">asDouble3</a>();</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> offset( pnt[0], pnt[1], pnt[2] );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Apply the tweaks to the output surface</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (elemIndex &lt; (<span class="keywordtype">int</span>)geomPtr-&gt;vertices.length())</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a>&amp; oldPnt = geomPtr-&gt;vertices[elemIndex];</div>
<div class="line">            oldPnt = oldPnt + offset;</div>
<div class="line">        }</div>
<div class="line">        cpHandle.<a name="a121"></a><a class="code" href="./class_m_array_data_handle.html#a73616f002814b8abe6d921db72d7a496">next</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::value( <span class="keywordtype">int</span> pntInd, <span class="keywordtype">int</span> vlInd, <span class="keywordtype">double</span> &amp; val ) <span class="keyword">const</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Helper function to return the value of a given vertex</span></div>
<div class="line"><span class="comment">//    from the cachedMesh.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    apiMesh* nonConstThis = (apiMesh*)<span class="keyword">this</span>;</div>
<div class="line">    apiMeshGeom* geomPtr = nonConstThis-&gt;cachedGeom();</div>
<div class="line"> <span class="keywordflow">if</span> ( NULL != geomPtr ) {</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> point = geomPtr-&gt;vertices[ pntInd ];</div>
<div class="line">        val = point[ vlInd ];</div>
<div class="line">        result = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::value( <span class="keywordtype">int</span> pntInd, <a class="code" href="./class_m_point.html">MPoint</a> &amp; val ) <span class="keyword">const</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Helper function to return the value of a given vertex</span></div>
<div class="line"><span class="comment">//    from the cachedMesh.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    apiMesh* nonConstThis = (apiMesh*)<span class="keyword">this</span>;</div>
<div class="line">    apiMeshGeom* geomPtr = nonConstThis-&gt;cachedGeom();</div>
<div class="line"> <span class="keywordflow">if</span> ( NULL != geomPtr ) {</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> point = geomPtr-&gt;vertices[ pntInd ];</div>
<div class="line">        val = point;</div>
<div class="line">        result = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::setValue( <span class="keywordtype">int</span> pntInd, <span class="keywordtype">int</span> vlInd, <span class="keywordtype">double</span> val )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Helper function to set the value of a given vertex</span></div>
<div class="line"><span class="comment">//    in the cachedMesh.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    apiMesh* nonConstThis = (apiMesh*)<span class="keyword">this</span>;</div>
<div class="line">    apiMeshGeom* geomPtr = nonConstThis-&gt;cachedGeom();</div>
<div class="line"> <span class="keywordflow">if</span> ( NULL != geomPtr ) {</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a>&amp; point = geomPtr-&gt;vertices[ pntInd ];</div>
<div class="line">        point[ vlInd ] = val;</div>
<div class="line">        result = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    verticesUpdated();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> apiMesh::setValue( <span class="keywordtype">int</span> pntInd, <span class="keyword">const</span> <a class="code" href="./class_m_point.html">MPoint</a> &amp; val )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Helper function to set the value of a given vertex</span></div>
<div class="line"><span class="comment">//    in the cachedMesh.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    apiMesh* nonConstThis = (apiMesh*)<span class="keyword">this</span>;</div>
<div class="line">    apiMeshGeom* geomPtr = nonConstThis-&gt;cachedGeom();</div>
<div class="line"> <span class="keywordflow">if</span> ( NULL != geomPtr ) {</div>
<div class="line">        geomPtr-&gt;vertices[ pntInd ] = val;</div>
<div class="line">        result = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    verticesUpdated();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::meshDataRef()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Get a reference to the mesh data (outputSurface)</span></div>
<div class="line"><span class="comment">//    from the datablock. If dirty then an evaluation is</span></div>
<div class="line"><span class="comment">//    triggered.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Get the datablock for this node</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> datablock = forceCache();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Calling inputValue will force a recompute if the</span></div>
<div class="line"> <span class="comment">// connection is dirty. This means the most up-to-date</span></div>
<div class="line"> <span class="comment">// mesh data will be returned by this method.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> handle = datablock.<a class="code" href="./class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>( outputSurface );</div>
<div class="line"> <span class="keywordflow">return</span> handle.<a class="code" href="./class_m_data_handle.html#a31773b870681e1f6b3ad82ff58de33bc">data</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">apiMeshGeom* apiMesh::meshGeom()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns a pointer to the apiMeshGeom underlying the shape.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line">    apiMeshGeom * result = NULL;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> tmpObj = meshDataRef();</div>
<div class="line"> <a class="code" href="./class_m_fn_plugin_data.html">MFnPluginData</a> fnData( tmpObj );</div>
<div class="line">    apiMeshData * data = (apiMeshData*)fnData.data( &amp;stat );</div>
<div class="line">    MCHECKERRORNORET( stat, <span class="stringliteral">"meshGeom : Failed to get apiMeshData"</span>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( NULL != data ) {</div>
<div class="line">        result = data-&gt;fGeometry;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_object.html">MObject</a> apiMesh::cachedDataRef()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Get a reference to the mesh data (cachedSurface)</span></div>
<div class="line"><span class="comment">//    from the datablock. No evaluation is triggered.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Get the datablock for this node</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_data_block.html">MDataBlock</a> datablock = forceCache();</div>
<div class="line"> <a class="code" href="./class_m_data_handle.html">MDataHandle</a> handle = datablock.<a class="code" href="./class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>( cachedSurface );</div>
<div class="line"> <span class="keywordflow">return</span> handle.<a class="code" href="./class_m_data_handle.html#a31773b870681e1f6b3ad82ff58de33bc">data</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">apiMeshGeom* apiMesh::cachedGeom()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Returns a pointer to the apiMeshGeom underlying the shape.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line">    apiMeshGeom * result = NULL;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> tmpObj = cachedDataRef();</div>
<div class="line"> <a class="code" href="./class_m_fn_plugin_data.html">MFnPluginData</a> fnData( tmpObj );</div>
<div class="line">    apiMeshData * data = (apiMeshData*)fnData.data( &amp;stat );</div>
<div class="line">    MCHECKERRORNORET( stat, <span class="stringliteral">"cachedGeom : Failed to get apiMeshData"</span>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( NULL != data ) {</div>
<div class="line">        result = data-&gt;fGeometry;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::buildControlPoints( <a class="code" href="./class_m_data_block.html">MDataBlock</a>&amp; datablock, <span class="keywordtype">int</span> count )</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Check the controlPoints array. If there is input history</span></div>
<div class="line"><span class="comment">//    then we will use this array to store tweaks (vertex movements).</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_array_data_handle.html">MArrayDataHandle</a> cpH = datablock.<a name="a122"></a><a class="code" href="./class_m_data_block.html#a11fd41c7d97d656a2bffdc23015f1496">outputArrayValue</a>( mControlPoints, &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, <span class="stringliteral">"compute get cpH"</span> )</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_array_data_builder.html">MArrayDataBuilder</a> oldBuilder = cpH.builder();</div>
<div class="line">    if ( count != (<span class="keywordtype">int</span>)oldBuilder.elementCount() )</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Make and set the new builder based on the</span></div>
<div class="line"> <span class="comment">// info from the old builder.</span></div>
<div class="line"> <a class="code" href="./class_m_array_data_builder.html">MArrayDataBuilder</a> builder( oldBuilder );</div>
<div class="line">        MCHECKERROR( stat, <span class="stringliteral">"compute - create builder"</span> )</div>
<div class="line"></div>
<div class="line">        for ( <span class="keywordtype">int</span> vtx=0; vtx&lt;count; vtx++ )</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">/* double3 &amp; pt = */</span> builder.addElement( vtx ).asDouble3();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        cpH.<a class="code" href="./class_m_array_data_handle.html#a575cf7adebfd8e3c29e588d2cd1c47a6">set</a>( builder );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    cpH.<a class="code" href="./class_m_array_data_handle.html#aff40e8c8c255448d5d19a05148b83058">setAllClean</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::verticesUpdated()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Helper function to tell maya that this shape's</span></div>
<div class="line"><span class="comment">//    vertices have updated and that the bbox needs</span></div>
<div class="line"><span class="comment">//    to be recalculated and the shape redrawn.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    childChanged( <a class="code" href="./class_m_px_surface_shape.html#ae6e3d315c5dd375e845a29ffeb5f8727a3cf2a789a428c68c537cf3ba6b9ad743">MPxSurfaceShape::kBoundingBoxChanged</a> );</div>
<div class="line">    childChanged( <a name="a123"></a><a class="code" href="./class_m_px_surface_shape.html#ae6e3d315c5dd375e845a29ffeb5f8727a33e6468f044ba0e80a5e0b34fe856d42">MPxSurfaceShape::kObjectChanged</a> );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> apiMesh::signalDirtyToViewport()</div>
<div class="line">{</div>
<div class="line">    fShapeDirty = <span class="keyword">true</span>;</div>
<div class="line"> <a name="a124"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#ab2843a350b76cdcbf16dd70d884f9766">MHWRender::MRenderer::setGeometryDrawDirty</a>(thisMObject());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span>* apiMesh::creator()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Called internally to create a new instance of the users MPx node.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">new</span> apiMesh();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> apiMesh::initialize()</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Description</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//    Attribute (static) initialization.</span></div>
<div class="line"><span class="comment">//    See api_macros.h.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a>             stat;</div>
<div class="line"> <a name="_a125"></a><a class="code" href="./class_m_fn_typed_attribute.html">MFnTypedAttribute</a>   typedAttr;</div>
<div class="line"> <a name="_a126"></a><a class="code" href="./class_m_fn_numeric_attribute.html">MFnNumericAttribute</a> numericAttr;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// ----------------------- INPUTS --------------------------</span></div>
<div class="line">    inputSurface = typedAttr.<a name="a127"></a><a class="code" href="./class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>( <span class="stringliteral">"inputSurface"</span>, <span class="stringliteral">"is"</span>,</div>
<div class="line">                                      apiMeshData::id,</div>
<div class="line"> <a name="a128"></a><a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">MObject::kNullObj</a>, &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, <span class="stringliteral">"create inputSurface attribute"</span> )</div>
<div class="line">    typedAttr.setStorable( false );</div>
<div class="line">    ADD_ATTRIBUTE( inputSurface );</div>
<div class="line"></div>
<div class="line">    useWeightedTransformUsingFunction = numericAttr.create( "useWeightedTransformUsingFunction", "utru", <a class="code" href="./class_m_fn_numeric_data.html">MFnNumericData</a>::kBoolean, true, &amp;stat);</div>
<div class="line">    MCHECKERROR( stat, "create useWeightedTransformUsingFunction attribute" )</div>
<div class="line">    numericAttr.setKeyable(true);</div>
<div class="line">    ADD_ATTRIBUTE( useWeightedTransformUsingFunction );</div>
<div class="line"></div>
<div class="line">    useWeightedTweakUsingFunction = numericAttr.create( "useWeightedTweakUsingFunction", "utwu", <a class="code" href="./class_m_fn_numeric_data.html">MFnNumericData</a>::kBoolean, true, &amp;stat);</div>
<div class="line">    MCHECKERROR( stat, "create useWeightedTweakUsingFunction attribute" )</div>
<div class="line">    numericAttr.setKeyable(true);</div>
<div class="line">    ADD_ATTRIBUTE( useWeightedTweakUsingFunction );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// ----------------------- OUTPUTS -------------------------</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// bbox attributes</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    MAKE_NUMERIC_ATTR(  bboxCorner1, "bboxCorner1", "bb1",</div>
<div class="line"> <a class="code" href="./class_m_fn_numeric_data.html">MFnNumericData</a>::k3Double, 0,</div>
<div class="line">                        false, false, false );</div>
<div class="line">    MAKE_NUMERIC_ATTR(  bboxCorner2, "bboxCorner2", "bb2",</div>
<div class="line"> <a class="code" href="./class_m_fn_numeric_data.html">MFnNumericData</a>::k3Double, 0,</div>
<div class="line">                        false, false, false );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// local/world output surface attributes</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    outputSurface = typedAttr.create( "outputSurface", "os",</div>
<div class="line">                                      apiMeshData::<span class="keywordtype">id</span>,</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a>::kNullObj, &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, "create outputSurface attribute" )</div>
<div class="line">    ADD_ATTRIBUTE( outputSurface );</div>
<div class="line">    typedAttr.setWritable( false );</div>
<div class="line"></div>
<div class="line">    worldSurface = typedAttr.create( "worldSurface", "ws",</div>
<div class="line">                                      apiMeshData::<span class="keywordtype">id</span>,</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a>::kNullObj, &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, "create worldSurface attribute" );</div>
<div class="line"></div>
<div class="line">    typedAttr.setCached( false );</div>
<div class="line"></div>
<div class="line">    typedAttr.setWritable( false );</div>
<div class="line"></div>
<div class="line">    stat = typedAttr.setArray( true );</div>
<div class="line">    MCHECKERROR( stat, "set array" );</div>
<div class="line"></div>
<div class="line">    stat = typedAttr.setUsesArrayDataBuilder( true );</div>
<div class="line">    MCHECKERROR( stat, "set uses array data builder" );</div>
<div class="line"></div>
<div class="line">    stat = typedAttr.setDisconnectBehavior( <a name="_a129"></a><a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a>::kDelete );</div>
<div class="line">    MCHECKERROR( stat, "set disconnect behavior data builder" );</div>
<div class="line"></div>
<div class="line">    stat = typedAttr.setWorldSpace( true );</div>
<div class="line">    MCHECKERROR( stat, "set world space" );</div>
<div class="line"></div>
<div class="line">    ADD_ATTRIBUTE( worldSurface );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cached surface used for file IO</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    cachedSurface = typedAttr.create( "cachedSurface", "cs",</div>
<div class="line">                                      apiMeshData::<span class="keywordtype">id</span>,</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a>::kNullObj, &amp;stat );</div>
<div class="line">    MCHECKERROR( stat, "create cachedSurface attribute" )</div>
<div class="line">    typedAttr.setReadable( true );</div>
<div class="line">    typedAttr.setWritable( true );</div>
<div class="line">    typedAttr.setStorable( true );</div>
<div class="line">    ADD_ATTRIBUTE( cachedSurface );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// ---------- Specify what inputs affect the outputs ----------</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    ATTRIBUTE_AFFECTS( inputSurface, outputSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( inputSurface, worldSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( outputSurface, worldSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( inputSurface, bboxCorner1 );</div>
<div class="line">    ATTRIBUTE_AFFECTS( inputSurface, bboxCorner2 );</div>
<div class="line">    ATTRIBUTE_AFFECTS( cachedSurface, outputSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( cachedSurface, worldSurface );</div>
<div class="line"></div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlPoints, outputSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlValueX, outputSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlValueY, outputSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlValueZ, outputSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlPoints, cachedSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlValueX, cachedSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlValueY, cachedSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlValueZ, cachedSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlPoints, worldSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlValueX, worldSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlValueY, worldSurface );</div>
<div class="line">    ATTRIBUTE_AFFECTS( mControlValueZ, worldSurface );</div>
<div class="line"></div>
<div class="line">    return <a class="code" href="./class_m_status.html">MS</a>::kSuccess;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Node registry</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Registers/Deregisters apiMeshData geometry data,</span></div>
<div class="line"><span class="comment">// apiMeshCreator DG node, and apiMeshShape user defined shape.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment"></span><span class="comment">//</span></div>
<div class="line"><span class="comment">// Strings for registering vp2 draw overrides. Plugin includes implementations</span></div>
<div class="line"><span class="comment">// of MPxSubSceneOverride and MPxGeometryOverride, set the boolean flag below</span></div>
<div class="line"><span class="comment">// to choose which is used.</span></div>
<div class="line">static <span class="keywordtype">bool</span> sUseSubSceneOverride = (getenv("MAYA_APIMESHSHAPE_USE_SUBSCENEOVERRIDE") != NULL);</div>
<div class="line">static <span class="keywordtype">bool</span> sMakeGeometryOverridePointLight = (getenv("MAYA_APIMESHSHAPE_AS_POINTLIGHT") != NULL);</div>
<div class="line">static <a name="_a130"></a><a class="code" href="./class_m_string.html">MString</a> sDrawDbClassification(sUseSubSceneOverride</div>
<div class="line">    ? "drawdb/subscene/apiMesh"</div>
<div class="line">    : "drawdb/geometry/apiMesh");</div>
<div class="line">static <a class="code" href="./class_m_string.html">MString</a> sLightClass = "light:" + sDrawDbClassification + ":drawdb/light/pointLight";</div>
<div class="line">static <a class="code" href="./class_m_string.html">MString</a> sDrawRegistrantId("apiMeshPlugin");</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> initializePlugin( <a class="code" href="./class_m_object.html">MObject</a> obj )</div>
<div class="line">{</div>
<div class="line"> <a name="_a131"></a><a class="code" href="./class_m_fn_plugin.html">MFnPlugin</a> plugin( obj, PLUGIN_COMPANY, <span class="stringliteral">"3.0"</span>, <span class="stringliteral">"Any"</span>);</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat1, stat2, stat3, stat4;</div>
<div class="line"></div>
<div class="line">    stat1 = plugin.registerData( <span class="stringliteral">"apiMeshData"</span>, apiMeshData::id,</div>
<div class="line">                                  &amp;apiMeshData::creator,</div>
<div class="line"> <a name="a132"></a><a class="code" href="./class_m_px_data.html#a1d1cfd8ffb84e947f82999c682b666a7aa76b89a7cf1b1a256b49d1a64e4cffe3">MPxData::kGeometryData</a> );</div>
<div class="line"> <span class="keywordflow">if</span> ( ! stat1 ) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"Failed to register geometry data : apiMeshData \n"</span>;</div>
<div class="line"> <span class="keywordflow">return</span> stat1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    stat2 = plugin.registerShape( <span class="stringliteral">"apiMesh"</span>, apiMesh::id,</div>
<div class="line">                                    &amp;apiMesh::creator,</div>
<div class="line">                                    &amp;apiMesh::initialize,</div>
<div class="line">                                    &amp;apiMeshUI::creator,</div>
<div class="line">                                    sMakeGeometryOverridePointLight ? &amp;sLightClass : &amp;sDrawDbClassification ); </div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( ! stat2 ) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"Failed to register shape\n"</span>;</div>
<div class="line"> <span class="keywordflow">if</span> ( stat1) plugin.deregisterData( apiMeshData::id );</div>
<div class="line"> <span class="keywordflow">return</span> stat2;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    stat3 = plugin.registerNode( <span class="stringliteral">"apiMeshCreator"</span>, apiMeshCreator::id,</div>
<div class="line">                                 &amp;apiMeshCreator::creator,</div>
<div class="line">                                 &amp;apiMeshCreator::initialize  );</div>
<div class="line"> <span class="keywordflow">if</span> ( ! stat3 ) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"Failed to register creator\n"</span>;</div>
<div class="line"> <span class="keywordflow">if</span> ( stat2 ) {</div>
<div class="line">            plugin.deregisterNode( apiMesh::id );</div>
<div class="line">            plugin.deregisterData( apiMeshData::id );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (sUseSubSceneOverride)</div>
<div class="line">    {</div>
<div class="line">        stat4 = <a name="a133"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_registry.html#af075a48779d4514f296c42034f9298cb">MHWRender::MDrawRegistry::registerSubSceneOverrideCreator</a>(</div>
<div class="line">                    sDrawDbClassification,</div>
<div class="line">                    sDrawRegistrantId,</div>
<div class="line">                    apiMeshSubSceneOverride::Creator);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat4)</div>
<div class="line">        {</div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">"Failed to register Viewport 2.0 sub-scene override\n"</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">            stat4 = apiMeshSubSceneOverride::registerComponentConverters();</div>
<div class="line"> <span class="keywordflow">if</span> (!stat4)</div>
<div class="line">            {</div>
<div class="line">                cerr &lt;&lt; <span class="stringliteral">"Failed to register component converters\n"</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        stat4 = <a name="a134"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_registry.html#a36f6ac92077e5064d897187608c9e548">MHWRender::MDrawRegistry::registerGeometryOverrideCreator</a>(</div>
<div class="line">                    sDrawDbClassification,</div>
<div class="line">                    sDrawRegistrantId,</div>
<div class="line">                    apiMeshGeometryOverride::Creator);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat4)</div>
<div class="line">        {</div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">"Failed to register Viewport 2.0 geometry override\n"</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">            stat4 = apiMeshGeometryOverride::registerComponentConverters();</div>
<div class="line"> <span class="keywordflow">if</span> (!stat4)</div>
<div class="line">            {</div>
<div class="line">                cerr &lt;&lt; <span class="stringliteral">"Failed to register component converters\n"</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> stat3;</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> uninitializePlugin( <a class="code" href="./class_m_object.html">MObject</a> obj)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_fn_plugin.html">MFnPlugin</a> plugin( obj );</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (sUseSubSceneOverride)</div>
<div class="line">    {</div>
<div class="line">        stat = apiMeshSubSceneOverride::deregisterComponentConverters();</div>
<div class="line"> <span class="keywordflow">if</span> (!stat)</div>
<div class="line">        {</div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">"Failed to deregister component converters \n"</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        stat = <a name="a135"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_registry.html#aecdb63d6aa8b938e81dc3ce56ca42bcd">MHWRender::MDrawRegistry::deregisterSubSceneOverrideCreator</a>(</div>
<div class="line">                    sDrawDbClassification,</div>
<div class="line">                    sDrawRegistrantId);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat)</div>
<div class="line">        {</div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">"Failed to deregister sub-scene override : apiMeshSubSceneOverride \n"</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        stat = apiMeshGeometryOverride::deregisterComponentConverters();</div>
<div class="line"> <span class="keywordflow">if</span> (!stat)</div>
<div class="line">        {</div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">"Failed to deregister component converters \n"</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        stat = <a name="a136"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_registry.html#a24f600902d1e1a22ccd8985f9eee39a1">MHWRender::MDrawRegistry::deregisterGeometryOverrideCreator</a>(</div>
<div class="line">                    sDrawDbClassification,</div>
<div class="line">                    sDrawRegistrantId);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat)</div>
<div class="line">        {</div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">"Failed to deregister geometry override : apiMeshGeometryOverride \n"</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    stat = plugin.deregisterNode( apiMesh::id );</div>
<div class="line"> <span class="keywordflow">if</span> ( ! stat ) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"Failed to deregister shape : apiMeshShape \n"</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    stat = plugin.deregisterData( apiMeshData::id );</div>
<div class="line"> <span class="keywordflow">if</span> ( ! stat ) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"Failed to deregister geometry data : apiMeshData \n"</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    stat = plugin.deregisterNode( apiMeshCreator::id );</div>
<div class="line"> <span class="keywordflow">if</span> ( ! stat ) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">"Failed to deregister node : apiMeshCreator \n"</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> stat;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div><br/></div>
</link></link></link></link></div></body>
</html>

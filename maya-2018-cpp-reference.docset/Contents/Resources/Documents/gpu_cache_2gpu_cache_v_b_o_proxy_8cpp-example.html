<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="MAYAUL" name="product"><meta content="2018" name="release"><meta content="Developer" name="book"><meta content="2017-06-22" name="created"><meta content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887" name="topicid"><meta content="concept" name="topic-type">
<title>gpuCache/gpuCacheVBOProxy.cpp</title>
<meta content="C++" name="topic-subtype"/></meta></meta></meta></meta></meta></meta></meta></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2gpu_cache_v_b_o_proxy_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>gpuCache/gpuCacheVBOProxy.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">gpuCache/gpuCacheVBOProxy.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "gpuCacheVBOProxy.h"</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "gpuCacheConfig.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheGLFT.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheUnitBoundingBox.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheVramQuery.h"</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHardwareRenderer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MSceneMessage.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_set&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;tbb/tbb_thread.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tbb/mutex.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>GPUCache;</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// LOCAL FUNCTIONS</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> assertNoVertexArray() </div>
<div class="line">{</div>
<div class="line">    assert(!gGLFT-&gt;glIsEnabled(MGL_COLOR_ARRAY));</div>
<div class="line">    assert(!gGLFT-&gt;glIsEnabled(MGL_EDGE_FLAG_ARRAY));</div>
<div class="line">    assert(!gGLFT-&gt;glIsEnabled(MGL_FOG_COORDINATE_ARRAY_EXT));</div>
<div class="line">    assert(!gGLFT-&gt;glIsEnabled(MGL_INDEX_ARRAY));</div>
<div class="line">    assert(!gGLFT-&gt;glIsEnabled(MGL_NORMAL_ARRAY));</div>
<div class="line">    assert(!gGLFT-&gt;glIsEnabled(MGL_SECONDARY_COLOR_ARRAY_EXT));</div>
<div class="line">    assert(!gGLFT-&gt;glIsEnabled(MGL_TEXTURE_COORD_ARRAY));</div>
<div class="line">    assert(!gGLFT-&gt;glIsEnabled(MGL_VERTEX_ARRAY));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> assertNoVBOs()</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line">    MGLint buffer;</div>
<div class="line"></div>
<div class="line">    gGLFT-&gt;glGetIntegerv(MGL_ARRAY_BUFFER_BINDING_ARB, &amp;buffer);</div>
<div class="line">    assert(buffer == 0);</div>
<div class="line"> </div>
<div class="line">    gGLFT-&gt;glGetIntegerv(MGL_ELEMENT_ARRAY_BUFFER_BINDING_ARB, &amp;buffer);</div>
<div class="line">    assert(buffer == 0);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> BeginTransformFeedback(MGLenum primitiveMode)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glBeginTransformFeedbackNV(primitiveMode);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_EXT_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glBeginTransformFeedbackEXT(primitiveMode);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> EndTransformFeedback()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glEndTransformFeedbackNV();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_EXT_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glEndTransformFeedbackEXT();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> EnableRasterizerDiscard()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glEnable(MGL_RASTERIZER_DISCARD_NV);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_EXT_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glEnable(MGL_RASTERIZER_DISCARD_EXT);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> DisableRasterizerDiscard()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glDisable(MGL_RASTERIZER_DISCARD_NV);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_EXT_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glDisable(MGL_RASTERIZER_DISCARD_EXT);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> BindBufferBase(MGLuint index, MGLuint buffer)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glBindBufferBaseNV(MGL_TRANSFORM_FEEDBACK_BUFFER_NV, index, buffer);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_EXT_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glBindBufferBaseEXT(MGL_TRANSFORM_FEEDBACK_BUFFER_EXT, index, buffer);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// LOCAL CLASSES</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS FlipNormalsProgram</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Compute the flipped normals by transform feedback</span></div>
<div class="line"><span class="keyword">class </span>FlipNormalsProgram</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">static</span> std::shared_ptr&lt;FlipNormalsProgram&gt; getInstance();</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> resetInstance();</div>
<div class="line"></div>
<div class="line">    ~FlipNormalsProgram();</div>
<div class="line"> <span class="keywordtype">void</span> use();</div>
<div class="line"> <span class="keywordtype">void</span> beginQuery();</div>
<div class="line"> <span class="keywordtype">void</span> endQuery();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="comment">// Forbidden and not implemented.</span></div>
<div class="line">    FlipNormalsProgram(<span class="keyword">const</span> FlipNormalsProgram&amp;);</div>
<div class="line"> <span class="keyword">const</span> FlipNormalsProgram&amp; operator=(<span class="keyword">const</span> FlipNormalsProgram&amp;);</div>
<div class="line"></div>
<div class="line">    FlipNormalsProgram();</div>
<div class="line"> <span class="keywordtype">bool</span> validate();</div>
<div class="line"></div>
<div class="line">    MGLhandleARB fProgramObj;</div>
<div class="line">    MGLuint      fQuery;</div>
<div class="line"> <span class="keyword">static</span> std::shared_ptr&lt;FlipNormalsProgram&gt; fsFlipNormalsProgram;</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* fsFlipNormalsProgramText;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* FlipNormalsProgram::fsFlipNormalsProgramText = <span class="stringliteral">"#version 120\n"</span></div>
<div class="line"> <span class="stringliteral">"varying vec3 outNormal;\n"</span></div>
<div class="line"> <span class="stringliteral">"void main()\n"</span></div>
<div class="line"> <span class="stringliteral">"{\n"</span></div>
<div class="line"> <span class="stringliteral">"    outNormal = -gl_Vertex.xyz;\n"</span></div>
<div class="line"> <span class="stringliteral">"    gl_Position = gl_Vertex;\n"</span></div>
<div class="line"> <span class="stringliteral">"}\n\n"</span> ;</div>
<div class="line">std::shared_ptr&lt;FlipNormalsProgram&gt; FlipNormalsProgram::fsFlipNormalsProgram;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">std::shared_ptr&lt;FlipNormalsProgram&gt; FlipNormalsProgram::getInstance()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// return the transform feedback program cached in weak pointer</span></div>
<div class="line"> <span class="keywordflow">if</span> (fsFlipNormalsProgram) {</div>
<div class="line"> <span class="keywordflow">return</span> fsFlipNormalsProgram;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// check transform feedback extension</span></div>
<div class="line"> <span class="keywordflow">if</span> (!gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback) &amp;&amp;</div>
<div class="line">        !gGLFT-&gt;extensionExists(kMGLext_EXT_transform_feedback)) {</div>
<div class="line"> <span class="keywordflow">return</span> std::shared_ptr&lt;FlipNormalsProgram&gt;();;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// create a new transform feedback program</span></div>
<div class="line">    std::shared_ptr&lt;FlipNormalsProgram&gt; prog(<span class="keyword">new</span> FlipNormalsProgram());</div>
<div class="line"> <span class="keywordflow">if</span> (!prog-&gt;validate()) {</div>
<div class="line"> <span class="keywordflow">return</span> std::shared_ptr&lt;FlipNormalsProgram&gt;();</div>
<div class="line">    }</div>
<div class="line">    fsFlipNormalsProgram = prog;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> fsFlipNormalsProgram;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> FlipNormalsProgram::resetInstance()</div>
<div class="line">{</div>
<div class="line">    fsFlipNormalsProgram.reset();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">FlipNormalsProgram::~FlipNormalsProgram()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// delete the program and query</span></div>
<div class="line"> <span class="keywordflow">if</span> (fProgramObj != 0) {</div>
<div class="line">        gGLFT-&gt;glDeleteObjectARB(fProgramObj);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (fQuery != 0) {</div>
<div class="line">        gGLFT-&gt;glDeleteQueriesARB(1, &amp;fQuery);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> FlipNormalsProgram::use()</div>
<div class="line">{</div>
<div class="line">    assert(fProgramObj != 0);</div>
<div class="line">    gGLFT-&gt;glUseProgramObjectARB(fProgramObj);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> FlipNormalsProgram::beginQuery()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glBeginQueryARB(MGL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV, fQuery);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_EXT_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glBeginQueryARB(MGL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT, fQuery);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> FlipNormalsProgram::endQuery()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glEndQueryARB(MGL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_EXT_transform_feedback)) {</div>
<div class="line">        gGLFT-&gt;glEndQueryARB(MGL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">FlipNormalsProgram::FlipNormalsProgram()</div>
<div class="line">    : fProgramObj(0)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span>  success = <span class="keyword">true</span>;</div>
<div class="line">    MGLint status  = MGL_TRUE;</div>
<div class="line">    MGLhandleARB vertShaderObj = 0;</div>
<div class="line">    MGLhandleARB prog = 0;</div>
<div class="line">    MGLuint      query = 0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// create vertex shader</span></div>
<div class="line">    vertShaderObj = gGLFT-&gt;glCreateShaderObjectARB(MGL_VERTEX_SHADER_ARB);</div>
<div class="line">    assert(vertShaderObj != 0);</div>
<div class="line"> <span class="keywordflow">if</span> (vertShaderObj == 0) {</div>
<div class="line">        success = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// compile vertex shader</span></div>
<div class="line"> <span class="keywordflow">if</span> (success) {</div>
<div class="line">        gGLFT-&gt;glShaderSourceARB(vertShaderObj, 1, &amp;fsFlipNormalsProgramText, NULL);</div>
<div class="line">        gGLFT-&gt;glCompileShaderARB(vertShaderObj);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// check the compile result</span></div>
<div class="line">        gGLFT-&gt;glGetObjectParameterivARB(vertShaderObj, MGL_OBJECT_COMPILE_STATUS_ARB, &amp;status);</div>
<div class="line"> <span class="keywordflow">if</span> (status != MGL_TRUE) {</div>
<div class="line">            success = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">char</span> buffer[4096];</div>
<div class="line">            MGLsizei count = 0;</div>
<div class="line">            gGLFT-&gt;glGetInfoLogARB(vertShaderObj, 4096, &amp;count, buffer);</div>
<div class="line">            printf(<span class="stringliteral">"gpuCache: Failed to compile vertex shader.\nReason: %s\n"</span>, buffer);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// create transform feedback program</span></div>
<div class="line"> <span class="keywordflow">if</span> (success) {</div>
<div class="line">        prog = gGLFT-&gt;glCreateProgramObjectARB();</div>
<div class="line">        assert(prog != 0);</div>
<div class="line"> <span class="keywordflow">if</span> (prog == 0) {</div>
<div class="line">            success = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// set up and link program</span></div>
<div class="line"> <span class="keywordflow">if</span> (success) {</div>
<div class="line">        gGLFT-&gt;glAttachObjectARB(prog, vertShaderObj);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback)) {</div>
<div class="line"> <span class="comment">// do nothing. set NV_transform_feedback state post-link</span></div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_EXT_transform_feedback)) {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* outputs = <span class="stringliteral">"outNormal"</span>;</div>
<div class="line">            gGLFT-&gt;glTransformFeedbackVaryingsEXT((MGLuint)(<span class="keywordtype">size_t</span>)prog, 1, &amp;outputs, MGL_SEPARATE_ATTRIBS_EXT);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        gGLFT-&gt;glLinkProgramARB(prog);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (gGLFT-&gt;extensionExists(kMGLext_NV_transform_feedback)) {</div>
<div class="line"> <span class="keyword">const</span> MGLint output = gGLFT-&gt;glGetVaryingLocationNV((MGLuint)(<span class="keywordtype">size_t</span>)prog, <span class="stringliteral">"outNormal"</span>);</div>
<div class="line">            gGLFT-&gt;glTransformFeedbackVaryingsNV((MGLuint)(<span class="keywordtype">size_t</span>)prog, 1, &amp;output, MGL_SEPARATE_ATTRIBS_NV);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// check the link result</span></div>
<div class="line">        gGLFT-&gt;glGetObjectParameterivARB(prog, MGL_OBJECT_LINK_STATUS_ARB, &amp;status);</div>
<div class="line"> <span class="keywordflow">if</span> (status != MGL_TRUE) {</div>
<div class="line">            success = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">char</span> buffer[4096];</div>
<div class="line">            MGLsizei count = 0;</div>
<div class="line">            gGLFT-&gt;glGetInfoLogARB(prog, 4096, &amp;count, buffer);</div>
<div class="line">            printf(<span class="stringliteral">"gpuCache: Failed to link program.\nReason: %s\n"</span>, buffer);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// the vertex should be deleted along with the program</span></div>
<div class="line"> <span class="keywordflow">if</span> (vertShaderObj != 0) {</div>
<div class="line">        gGLFT-&gt;glDeleteObjectARB(vertShaderObj);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// generate the query object</span></div>
<div class="line">    gGLFT-&gt;glGenQueriesARB(1, &amp;query);</div>
<div class="line">    assert(query != 0);</div>
<div class="line"> <span class="keywordflow">if</span> (query == 0) {</div>
<div class="line">        success = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (success) {</div>
<div class="line"> <span class="comment">// success, we have the program to flip normals now</span></div>
<div class="line">        fProgramObj = prog;</div>
<div class="line">        fQuery      = query;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// failure, delete the program and query</span></div>
<div class="line"> <span class="keywordflow">if</span> (prog != 0) {</div>
<div class="line">            gGLFT-&gt;glDeleteObjectARB(prog);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">if</span> (query != 0) {</div>
<div class="line">            gGLFT-&gt;glDeleteQueriesARB(1, &amp;query);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> FlipNormalsProgram::validate()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> (fProgramObj != 0 &amp;&amp; fQuery != 0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==========================================================================</span></div>
<div class="line"><span class="comment">// CLASS FlipNormals</span></div>
<div class="line"><span class="comment">//==========================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>FlipNormals</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FlipNormals(<span class="keywordtype">size_t</span> numVerts, MGLuint normalName)</div>
<div class="line">        : fNumVerts(numVerts), fNormalName(normalName)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    MGLuint compute();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="comment">// Forbidden and not implemented.</span></div>
<div class="line">    FlipNormals(<span class="keyword">const</span> FlipNormals&amp;);</div>
<div class="line"> <span class="keyword">const</span> FlipNormals&amp; operator=(<span class="keyword">const</span> FlipNormals&amp;);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span>  fNumVerts;</div>
<div class="line">    MGLuint  fNormalName;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MGLuint FlipNormals::compute()</div>
<div class="line">{</div>
<div class="line">    std::shared_ptr&lt;FlipNormalsProgram&gt; prog = FlipNormalsProgram::getInstance();</div>
<div class="line"> <span class="keywordflow">if</span> (!prog) {</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// generate an empty buffer for flipped normals</span></div>
<div class="line">    MGLuint flippedNormalName = 0;</div>
<div class="line">    gGLFT-&gt;glGenBuffersARB(1, &amp;flippedNormalName);</div>
<div class="line">    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, flippedNormalName);</div>
<div class="line">    gGLFT-&gt;glBufferDataARB(MGL_ARRAY_BUFFER_ARB, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 3 * fNumVerts,</div>
<div class="line">                           NULL, MGL_STATIC_DRAW_ARB);</div>
<div class="line">    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, 0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// disable rasterization</span></div>
<div class="line">    EnableRasterizerDiscard();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// use flip normal program</span></div>
<div class="line">    prog-&gt;use();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// bind empty flipped normals buffer (#0:outNormal)</span></div>
<div class="line">    BindBufferBase(0, flippedNormalName);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// bind normals buffer</span></div>
<div class="line">    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, fNormalName);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// normals buffer is bounded to gl_Vertex</span></div>
<div class="line">    gGLFT-&gt;glEnableClientState(MGL_VERTEX_ARRAY);</div>
<div class="line">    gGLFT-&gt;glVertexPointer(3, MGL_FLOAT, 0, 0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// begin transform feedback</span></div>
<div class="line">    prog-&gt;beginQuery();</div>
<div class="line">    BeginTransformFeedback(MGL_POINTS);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// push the normals</span></div>
<div class="line">    gGLFT-&gt;glDrawArrays(MGL_POINTS, 0, MGLsizei(fNumVerts));</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// end transform feedback</span></div>
<div class="line">    EndTransformFeedback();</div>
<div class="line">    prog-&gt;endQuery();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// clean up</span></div>
<div class="line">    gGLFT-&gt;glDisableClientState(MGL_VERTEX_ARRAY);</div>
<div class="line">    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, 0);</div>
<div class="line">    BindBufferBase(0, 0);</div>
<div class="line">    gGLFT-&gt;glUseProgramObjectARB(0);</div>
<div class="line">    DisableRasterizerDiscard();</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> flippedNormalName;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS VBOBufferRegistry</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// VBO buffer registry is used to cache VBOs to keep them as much as</span></div>
<div class="line"><span class="comment">// possible on the graphic card from frame to frame. </span></div>
<div class="line"><span class="keyword">class </span>VBOBufferRegistry {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="comment">/*----- typedefs and enumerations -----*/</span></div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> VBOBuffer::BufferType BufferType;</div>
<div class="line"> <span class="keyword">typedef</span> VBOBuffer::Key        Key;</div>
<div class="line"> <span class="keyword">typedef</span> VBOBuffer::KeyHash    KeyHash;</div>
<div class="line"> <span class="keyword">typedef</span> VBOBuffer::KeyEqualTo KeyEqualTo;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">/*----- static member functions -----*/</span></div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> arrayDestructionCb(<span class="keyword">const</span> Key&amp; key);</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*----- member functions -----*/</span></div>
<div class="line"> </div>
<div class="line">    VBOBufferRegistry();</div>
<div class="line">    ~VBOBufferRegistry();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Returns the buffer matchng the given key if it exists. Returns</span></div>
<div class="line"> <span class="comment">// a null pointer otherwise.</span></div>
<div class="line">    std::shared_ptr&lt;const VBOBuffer&gt; find(</div>
<div class="line"> <span class="keyword">const</span> BufferType&amp; bufferType, <span class="keyword">const</span> Key&amp; key)</div>
<div class="line">    {</div>
<div class="line">        {</div>
<div class="line">            Map::const_iterator it = fActiveBuffers[bufferType].find(key);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fActiveBuffers[bufferType].end()) {</div>
<div class="line"> <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        {</div>
<div class="line">            Map::iterator it = fPreviousFrameBuffers[bufferType].find(key);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fPreviousFrameBuffers[bufferType].end()) {</div>
<div class="line"> <span class="comment">// The VBO was used while drawing the previous</span></div>
<div class="line"> <span class="comment">// frame. Moving it to the active list.</span></div>
<div class="line">                std::shared_ptr&lt;const VBOBuffer&gt; result = it-&gt;second;</div>
<div class="line">                fActiveBuffers[bufferType].insert(*it);</div>
<div class="line">                fPreviousFrameBuffers[bufferType].erase(it);</div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> std::shared_ptr&lt;const VBOBuffer&gt;();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Insert the given buffer in the registry.</span></div>
<div class="line"> <span class="keywordtype">void</span> insert(std::shared_ptr&lt;const VBOBuffer&gt;&amp; buffer)</div>
<div class="line">    {</div>
<div class="line">        fActiveBuffers[buffer-&gt;bufferType()].insert(</div>
<div class="line">            std::make_pair(buffer-&gt;key(), buffer));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> erase(<span class="keyword">const</span> Key&amp; key)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; VBOBuffer::kNbBufferType; ++i) {</div>
<div class="line">            fActiveBuffers[i].erase(key);</div>
<div class="line">            fPreviousFrameBuffers[i].erase(key);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> delayedErase(<span class="keyword">const</span> Key&amp; key)</div>
<div class="line">    {</div>
<div class="line">        tbb::mutex::scoped_lock lock(fBuffersToDeleteMutex);</div>
<div class="line">        fBuffersToDelete.insert(key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> doDelayedErase()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!fBuffersToDelete.empty()) {</div>
<div class="line">            tbb::mutex::scoped_lock lock(fBuffersToDeleteMutex);</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Key&amp; key : fBuffersToDelete) {</div>
<div class="line">                erase(key);</div>
<div class="line">            }</div>
<div class="line">            fBuffersToDelete.clear();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Randomly selects a random buffer from the previous frame and</span></div>
<div class="line"> <span class="comment">// erases it. Returns false if all allocated buffers are active. </span></div>
<div class="line"> <span class="keywordtype">bool</span> eraseRandomBuffer() </div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">size_t</span> nbCandidateBuffers = 0;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; VBOBuffer::kNbBufferType; ++i) {</div>
<div class="line">            nbCandidateBuffers += fPreviousFrameBuffers[i].size();</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">if</span> (nbCandidateBuffers == 0) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">size_t</span> candidate = fRandomEvictionIndex() % nbCandidateBuffers;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; VBOBuffer::kNbBufferType; ++i) {</div>
<div class="line"> <span class="keywordflow">if</span> (candidate &lt; fPreviousFrameBuffers[i].size()) {</div>
<div class="line">                fPreviousFrameBuffers[i].erase(</div>
<div class="line">                    fPreviousFrameBuffers[i].begin());</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            candidate -= fPreviousFrameBuffers[i].size();</div>
<div class="line">            assert(candidate &gt;= 0);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Should never get here...</span></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Tell the registry that we are about to start drawing a new</span></div>
<div class="line"> <span class="comment">// frame. This is used as hint to mark some VBOs as potential</span></div>
<div class="line"> <span class="comment">// candidates for eviction. </span></div>
<div class="line"> <span class="keywordtype">void</span> nextRefresh()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; VBOBuffer::kNbBufferType; ++i) {</div>
<div class="line">            fPreviousFrameBuffers[i].insert(</div>
<div class="line">                fActiveBuffers[i].begin(), fActiveBuffers[i].end());</div>
<div class="line">            fActiveBuffers[i].clear();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Flush all VBO buffers.</span></div>
<div class="line"> <span class="keywordtype">void</span> clear()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; VBOBuffer::kNbBufferType; ++i) {</div>
<div class="line">            fActiveBuffers[i].clear();</div>
<div class="line">            fPreviousFrameBuffers[i].clear();</div>
<div class="line">        }</div>
<div class="line">        FlipNormalsProgram::resetInstance();</div>
<div class="line"></div>
<div class="line">        assert(VBOBuffer::nbAllocatedBytes() == 0);</div>
<div class="line">        assert(VBOBuffer::nbAllocated()      == 0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Reserve spaces by deleting VBOs</span></div>
<div class="line"> <span class="keywordtype">bool</span> reserve(<span class="keywordtype">size_t</span> bytesNeeded, <span class="keywordtype">size_t</span> buffersNeeded);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Total size of all the index VBOs currently allocated</span></div>
<div class="line"> <span class="keywordtype">size_t</span> nbIndexAllocatedBytes()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordtype">size_t</span> bytes = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Map::value_type&amp; v :</div>
<div class="line">                      fActiveBuffers[VBOBuffer::kIndexBufferType]) {</div>
<div class="line">            bytes += v.second-&gt;key().fBytes;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Map::value_type&amp; v :</div>
<div class="line">                      fPreviousFrameBuffers[VBOBuffer::kIndexBufferType]) {</div>
<div class="line">            bytes += v.second-&gt;key().fBytes;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> bytes;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Total size of all the vertex VBOs currently allocated</span></div>
<div class="line"> <span class="keywordtype">size_t</span> nbVertexAllocatedBytes()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordtype">size_t</span> bytes = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Map::value_type&amp; v :</div>
<div class="line">                      fActiveBuffers[VBOBuffer::kVertexBufferType]) {</div>
<div class="line">            bytes += v.second-&gt;key().fBytes;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Map::value_type&amp; v :</div>
<div class="line">                      fPreviousFrameBuffers[VBOBuffer::kVertexBufferType]) {</div>
<div class="line">            bytes += v.second-&gt;key().fBytes;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Map::value_type&amp; v :</div>
<div class="line">                      fActiveBuffers[VBOBuffer::kFlippedNormalBufferType]) {</div>
<div class="line">            bytes += v.second-&gt;key().fBytes;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Map::value_type&amp; v :</div>
<div class="line">                      fPreviousFrameBuffers[VBOBuffer::kFlippedNormalBufferType]) {</div>
<div class="line">            bytes += v.second-&gt;key().fBytes;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> bytes;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Number of index VBOs currently allocated</span></div>
<div class="line"> <span class="keywordtype">size_t</span> nbIndexAllocated()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span></div>
<div class="line">            fActiveBuffers[        VBOBuffer::kIndexBufferType ].size() +</div>
<div class="line">            fPreviousFrameBuffers[ VBOBuffer::kIndexBufferType ].size();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Number of vertex VBOs currently allocated</span></div>
<div class="line"> <span class="keywordtype">size_t</span> nbVertexAllocated()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span></div>
<div class="line">            fActiveBuffers[        VBOBuffer::kVertexBufferType        ].size() +</div>
<div class="line">            fPreviousFrameBuffers[ VBOBuffer::kVertexBufferType        ].size() +</div>
<div class="line">            fActiveBuffers[        VBOBuffer::kFlippedNormalBufferType ].size() +</div>
<div class="line">            fPreviousFrameBuffers[ VBOBuffer::kFlippedNormalBufferType ].size();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> mayaExitCallback(<span class="keywordtype">void</span>* clientData);</div>
<div class="line"> <span class="keyword">static</span> MCallbackId fsMayaExitCallbackId;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> std::unordered_map&lt;</div>
<div class="line">        Key,</div>
<div class="line">        std::shared_ptr&lt;const VBOBuffer&gt;,</div>
<div class="line">        KeyHash,</div>
<div class="line">        KeyEqualTo</div>
<div class="line">        &gt; Map; </div>
<div class="line">    Map fActiveBuffers[VBOBuffer::kNbBufferType];</div>
<div class="line">    Map fPreviousFrameBuffers[VBOBuffer::kNbBufferType];</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This allow deleting a VBO from a non-main thread.</span></div>
<div class="line">    tbb::mutex fBuffersToDeleteMutex;</div>
<div class="line">    std::unordered_set&lt;Key, KeyHash, KeyEqualTo&gt; fBuffersToDelete;</div>
<div class="line"></div>
<div class="line">    std::mt19937_64 fRandomEvictionIndex;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">MCallbackId VBOBufferRegistry::fsMayaExitCallbackId;</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VBOBufferRegistry&amp; theBufferRegistry()</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">static</span> VBOBufferRegistry sRegistry;</div>
<div class="line"> <span class="keywordflow">return</span> sRegistry;</div>
<div class="line">} </div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">tbb::tbb_thread::id gsMainThreadId = tbb::this_tbb_thread::get_id();</div>
<div class="line"><span class="keywordtype">void</span> VBOBufferRegistry::arrayDestructionCb(<span class="keyword">const</span> Key&amp; key)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Array d'tor Callback might be called from a worker thread (background reading)</span></div>
<div class="line"> <span class="keywordflow">if</span> (tbb::this_tbb_thread::get_id() == gsMainThreadId) {</div>
<div class="line">        theBufferRegistry().erase(key);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">        theBufferRegistry().delayedErase(key);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> VBOBufferRegistry::mayaExitCallback(<span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line">    assert(clientData);</div>
<div class="line">    VBOBufferRegistry* registry = <span class="keyword">static_cast&lt;</span>VBOBufferRegistry*<span class="keyword">&gt;</span>(clientData);</div>
<div class="line">    registry-&gt;clear();</div>
<div class="line">    UnitBoundingBox::clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VBOBufferRegistry::VBOBufferRegistry()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// hook Maya exit callback to free VBOs</span></div>
<div class="line">    fsMayaExitCallbackId = <a name="a0"></a><a class="code" href="./class_m_scene_message.html#a44771b834e9a0ad7291ecdcc880106fe">MSceneMessage::addCallback</a>(</div>
<div class="line"> <a name="a1"></a><a class="code" href="./class_m_scene_message.html#a4f09127c805cc1f5ee20e67db7b45efaa1efff7ad75eeef5a2ac9e3c0e890dbd0">MSceneMessage::kMayaExiting</a>, mayaExitCallback, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get rid of the associated VBO as soon as possible</span></div>
<div class="line">    ArrayBase::registerDestructionCallback(arrayDestructionCb);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set hashmap load factor to 0.7 to decrease collision</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; VBOBuffer::kNbBufferType; ++i) {</div>
<div class="line">        fActiveBuffers[i].max_load_factor(0.7f);</div>
<div class="line">        fPreviousFrameBuffers[i].max_load_factor(0.7f);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VBOBufferRegistry::~VBOBufferRegistry()</div>
<div class="line">{</div>
<div class="line"> <a name="a2"></a><a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MSceneMessage::removeCallback</a>(fsMayaExitCallbackId);</div>
<div class="line">    ArrayBase::unregisterDestructionCallback(arrayDestructionCb);</div>
<div class="line"> </div>
<div class="line">    clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> VBOBufferRegistry::reserve(</div>
<div class="line"> <span class="keywordtype">size_t</span> bytesNeeded, <span class="keywordtype">size_t</span> buffersNeeded)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (Config::maxVBOSize()  &lt; bytesNeeded ||</div>
<div class="line">        Config::maxVBOCount() &lt; buffersNeeded)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span> targetBytes  = Config::maxVBOSize()  - bytesNeeded;</div>
<div class="line"> <span class="keywordtype">size_t</span> targetNumber = Config::maxVBOCount() - buffersNeeded;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">while</span> (</div>
<div class="line">        VBOBuffer::nbAllocatedBytes() &gt; targetBytes ||</div>
<div class="line">        VBOBuffer::nbAllocated()      &gt; targetNumber</div>
<div class="line">    ) {</div>
<div class="line"> <span class="comment">// keep deleting VBOs</span></div>
<div class="line"> <span class="keywordflow">if</span> (!eraseRandomBuffer()) {</div>
<div class="line"> <span class="comment">// no more VBOs to delete, fail</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">} <span class="comment">// unnamed namespace</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS VBOBuffer</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::fsTotalVBOSize = 0;</div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::fsNbAllocated  = 0;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::fsNbUploaded = 0;</div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::fsNbUploadedBytes = 0;</div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::fsNbEvicted = 0;</div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::fsNbEvictedBytes = 0;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// When switching from vp2 SubSceneOverride mode to the default viewport, we may</span></div>
<div class="line"><span class="comment">// want to convert the Maya buffers back into software buffers to free up the</span></div>
<div class="line"><span class="comment">// gpu memory.  However we don't have a clean way to delete the SubSceneOverride</span></div>
<div class="line"><span class="comment">// nodes from the vp2 scene since we can only update the MSubSceneContainer when</span></div>
<div class="line"><span class="comment">// vp2 renders.  Having switched viewport modes, vp2 doesn't render again.  This</span></div>
<div class="line"><span class="comment">// would take some extra gymnastics to avoid.  So the vp2 buffers will live on</span></div>
<div class="line"><span class="comment">// regardless.  In that case, we can just leave the data there.</span></div>
<div class="line"><span class="comment">//#define DOWNCONVERT_VP2SSO_TO_SOFTWARE</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">std::shared_ptr&lt;const VBOBuffer&gt;</div>
<div class="line">VBOBuffer::create(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; buffer,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> isTemporary)</div>
<div class="line">{</div>
<div class="line">    std::shared_ptr&lt;const VBOBuffer&gt; result =</div>
<div class="line">        theBufferRegistry().find(kIndexBufferType, buffer-&gt;array()-&gt;key());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!result) {</div>
<div class="line"><span class="preprocessor">#ifdef DOWNCONVERT_SSO_TO_SOFTWARE</span></div>
<div class="line">        std::shared_ptr&lt;ReadableArray&lt;unsigned int&gt; &gt; readable = buffer-&gt;array()-&gt;getReadableArray();</div>
<div class="line"> <span class="keywordflow">if</span> (!buffer-&gt;array()-&gt;isReadable()) {</div>
<div class="line"> <span class="comment">// We are converting from viewport 2.0 SubSceneOverride non-readable arrays back to VBOBuffers.</span></div>
<div class="line"> <span class="comment">// So graft the SharedArray copy of the data back into the VertexBuffer.  This happens when changing</span></div>
<div class="line"> <span class="comment">// the viewport mode from vp2.0 to the default viewport and allows the vp2.0 buffer to be freed.</span></div>
<div class="line">            std::shared_ptr&lt;Array&lt;unsigned int&gt; &gt; array(readable);</div>
<div class="line">            buffer-&gt;ReplaceArrayInstance(array);</div>
<div class="line">        }</div>
<div class="line"><span class="preprocessor">#else </span></div>
<div class="line">        IndexBuffer::ReadInterfacePtr readable = buffer-&gt;array()-&gt;getReadable();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> <span class="keyword">const</span> BufferType bufferType = kIndexBufferType;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">void</span>*      bufferData = readable-&gt;get();</div>
<div class="line">        result = std::make_shared&lt;VBOBuffer&gt;(</div>
<div class="line">            bufferType, buffer-&gt;array()-&gt;key(), bufferData);</div>
<div class="line"> <span class="keywordflow">if</span> (!isTemporary)</div>
<div class="line">            theBufferRegistry().insert(result);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">std::shared_ptr&lt;const VBOBuffer&gt;</div>
<div class="line">VBOBuffer::create(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; buffer,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> isTemporary)</div>
<div class="line">{</div>
<div class="line">    std::shared_ptr&lt;const VBOBuffer&gt; result =</div>
<div class="line">        theBufferRegistry().find(kVertexBufferType, buffer-&gt;array()-&gt;key());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!result) {</div>
<div class="line"><span class="preprocessor">#ifdef DOWNCONVERT_SSO_TO_SOFTWARE</span></div>
<div class="line">        std::shared_ptr&lt;ReadableArray&lt;float&gt; &gt; readable = buffer-&gt;array()-&gt;getReadableArray();</div>
<div class="line"> <span class="keywordflow">if</span> (!buffer-&gt;array()-&gt;isReadable()) {</div>
<div class="line"> <span class="comment">// We are converting from viewport 2.0 SubSceneOverride non-readable arrays back to VBOBuffers.</span></div>
<div class="line"> <span class="comment">// So graft the SharedArray copy of the data back into the VertexBuffer.  This happens when changing</span></div>
<div class="line"> <span class="comment">// the viewport mode from vp2.0 to the default viewport and allows the vp2.0 buffer to be freed.</span></div>
<div class="line">            std::shared_ptr&lt;Array&lt;float&gt; &gt; array(readableArray);</div>
<div class="line">            buffer-&gt;ReplaceArrayInstance(array);</div>
<div class="line">        }</div>
<div class="line"><span class="preprocessor">#else </span></div>
<div class="line">        VertexBuffer::ReadInterfacePtr readable = buffer-&gt;array()-&gt;getReadable();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> <span class="keyword">const</span> BufferType bufferType = kVertexBufferType;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">void</span>*      bufferData = readable-&gt;get();</div>
<div class="line">        result = std::make_shared&lt;VBOBuffer&gt;(</div>
<div class="line">            bufferType, buffer-&gt;array()-&gt;key(), bufferData);</div>
<div class="line"> <span class="keywordflow">if</span> (!isTemporary)</div>
<div class="line">            theBufferRegistry().insert(result);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">std::shared_ptr&lt;const VBOBuffer&gt;</div>
<div class="line">VBOBuffer::createFlippedNormals(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; buffer,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> isTemporary)</div>
<div class="line">{</div>
<div class="line">    std::shared_ptr&lt;const VBOBuffer&gt; flippedVBO =</div>
<div class="line">        theBufferRegistry().find(kFlippedNormalBufferType, buffer-&gt;array()-&gt;key());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!flippedVBO) {</div>
<div class="line">        std::shared_ptr&lt;const VBOBuffer&gt; unflippedVBO = create(buffer, isTemporary);</div>
<div class="line"></div>
<div class="line">        MGLuint flippedNormalName =</div>
<div class="line">            FlipNormals(buffer-&gt;numVerts(), unflippedVBO-&gt;name()).compute();</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (flippedNormalName !=0 ) {</div>
<div class="line"> <span class="keyword">const</span> BufferType bufferType = kFlippedNormalBufferType;</div>
<div class="line">            flippedVBO = std::make_shared&lt;VBOBuffer&gt;(</div>
<div class="line">                bufferType, buffer-&gt;array()-&gt;key(), flippedNormalName);</div>
<div class="line"> <span class="keywordflow">if</span> (!isTemporary)</div>
<div class="line">                theBufferRegistry().insert(flippedVBO);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> flippedVBO;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">std::shared_ptr&lt;const VBOBuffer&gt;</div>
<div class="line">VBOBuffer::lookup(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; buffer)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> theBufferRegistry().find(</div>
<div class="line">        kIndexBufferType, buffer-&gt;array()-&gt;key());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">std::shared_ptr&lt;const VBOBuffer&gt;</div>
<div class="line">VBOBuffer::lookup(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; buffer)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> theBufferRegistry().find(</div>
<div class="line">        kVertexBufferType, buffer-&gt;array()-&gt;key());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">std::shared_ptr&lt;const VBOBuffer&gt;</div>
<div class="line">VBOBuffer::lookupFlippedNormals(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; buffer)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> theBufferRegistry().find(</div>
<div class="line">        kFlippedNormalBufferType, buffer-&gt;array()-&gt;key());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbAllocatedBytes()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fsTotalVBOSize;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbAllocated()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fsNbAllocated;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbIndexAllocatedBytes()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> theBufferRegistry().nbIndexAllocatedBytes();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbIndexAllocated()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> theBufferRegistry().nbIndexAllocated();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbVertexAllocatedBytes()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> theBufferRegistry().nbVertexAllocatedBytes();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbVertexAllocated()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> theBufferRegistry().nbVertexAllocated();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbUploaded()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fsNbUploaded;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbUploadedBytes()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fsNbUploadedBytes;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbEvicted()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fsNbEvicted;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">size_t</span> VBOBuffer::nbEvictedBytes()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fsNbEvictedBytes;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> VBOBuffer::clear()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> theBufferRegistry().clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> VBOBuffer::nextRefresh()</div>
<div class="line">{</div>
<div class="line">    theBufferRegistry().nextRefresh();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VBOBuffer::VBOBuffer(BufferType bufferType, <span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> <span class="keywordtype">void</span>* buffer)</div>
<div class="line">    : fKey(key), fBufferType(bufferType), fVBOName(0)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Create an VBO and copy data to it.</span></div>
<div class="line">    gGLFT-&gt;glGenBuffersARB(1, &amp;fVBOName);</div>
<div class="line">    assert(fVBOName != 0);</div>
<div class="line">    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, fVBOName);</div>
<div class="line">    gGLFT-&gt;glBufferDataARB(MGL_ARRAY_BUFFER_ARB, fKey.fBytes, buffer, MGL_STATIC_DRAW_ARB);</div>
<div class="line">    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, 0);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// accumulate VBO size counter</span></div>
<div class="line">    fsTotalVBOSize += fKey.fBytes;</div>
<div class="line">    ++fsNbAllocated;</div>
<div class="line"></div>
<div class="line">    fsNbUploadedBytes += fKey.fBytes;</div>
<div class="line">    ++fsNbUploaded;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VBOBuffer::VBOBuffer(BufferType bufferType, <span class="keyword">const</span> Key&amp; key, MGLuint vboName)</div>
<div class="line">    : fKey(key), fBufferType(bufferType), fVBOName(vboName)</div>
<div class="line">{</div>
<div class="line">    assert(fVBOName != 0);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// accumulate VBO size counter</span></div>
<div class="line">    fsTotalVBOSize += fKey.fBytes;</div>
<div class="line">    ++fsNbAllocated;</div>
<div class="line"></div>
<div class="line">    fsNbUploadedBytes += fKey.fBytes;</div>
<div class="line">    ++fsNbUploaded;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VBOBuffer::~VBOBuffer()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// free the VBO</span></div>
<div class="line">    assert(gGLFT-&gt;glIsBufferARB(fVBOName));</div>
<div class="line">    gGLFT-&gt;glDeleteBuffersARB(1, &amp;fVBOName);</div>
<div class="line">    fVBOName = 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// reduce VBO size counter</span></div>
<div class="line">    fsTotalVBOSize -= fKey.fBytes;</div>
<div class="line">    --fsNbAllocated;</div>
<div class="line"></div>
<div class="line">    assert(fsTotalVBOSize &gt;= 0);</div>
<div class="line">    assert(fsNbAllocated  &gt;= 0);</div>
<div class="line"></div>
<div class="line">    fsNbEvictedBytes += fKey.fBytes;</div>
<div class="line">    ++fsNbEvicted;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS VBOProxy</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VBOProxy::VBOProxy()</div>
<div class="line">    : fLastBindingType(kPrimitives),</div>
<div class="line">      fAreNormalsFlipped(false)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Just double check that no vertex array or VBO is in use when</span></div>
<div class="line"> <span class="comment">// the VBOProxy object takes control of the OpenGL client state.</span></div>
<div class="line">    assertNoVertexArray();</div>
<div class="line">    assertNoVBOs();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// For extra safety...</span></div>
<div class="line">    gGLFT-&gt;glTexCoord2f(0.0f, 0.0f);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VBOProxy::~VBOProxy()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">switch</span> (fLastBindingType) {</div>
<div class="line"> <span class="keywordflow">case</span> kPrimitives: {</div>
<div class="line">            fIndices.reset();</div>
<div class="line">            fPositions.reset();</div>
<div class="line">            fNormals.reset();</div>
<div class="line">            fUVs.reset();</div>
<div class="line">        } <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVertexArrays: {</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// We should always have indices</span></div>
<div class="line">                assert(fIndices);</div>
<div class="line">                fIndices.reset();</div>
<div class="line">            }</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// We should always have positions!</span></div>
<div class="line">                assert(fPositions);</div>
<div class="line"> </div>
<div class="line">                gGLFT-&gt;glDisableClientState(MGL_VERTEX_ARRAY);</div>
<div class="line">                fPositions.reset();</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">if</span> (fNormals) {</div>
<div class="line">                gGLFT-&gt;glDisableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                fNormals.reset();</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">if</span> (fUVs) {</div>
<div class="line">                gGLFT-&gt;glDisableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                fUVs.reset();</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">case</span> kVBOs: {</div>
<div class="line">            gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, 0);</div>
<div class="line">            gGLFT-&gt;glBindBufferARB(MGL_ELEMENT_ARRAY_BUFFER_ARB, 0);</div>
<div class="line"> </div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// We should always have indices</span></div>
<div class="line">                assert(fIndices);</div>
<div class="line">                assert(fVBOIndices);</div>
<div class="line"> </div>
<div class="line">                fIndices.reset();</div>
<div class="line">                fVBOIndices.reset();</div>
<div class="line">            }</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// We should always have positions!</span></div>
<div class="line">                assert(fPositions);</div>
<div class="line">                assert(fVBOPositions);</div>
<div class="line"></div>
<div class="line">                gGLFT-&gt;glDisableClientState(MGL_VERTEX_ARRAY);</div>
<div class="line"> </div>
<div class="line">                fPositions.reset();</div>
<div class="line">                fVBOPositions.reset();</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">if</span> (fVBONormals) {</div>
<div class="line">                assert(fNormals);</div>
<div class="line"></div>
<div class="line">                gGLFT-&gt;glDisableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                fNormals.reset();</div>
<div class="line">                fVBONormals.reset();</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">if</span> (fVBOUVs) {</div>
<div class="line">                assert(fUVs);</div>
<div class="line"> </div>
<div class="line">                gGLFT-&gt;glDisableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                fUVs.reset();</div>
<div class="line">                fVBOUVs.reset();</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">default</span>: {</div>
<div class="line">            assert(0);</div>
<div class="line">        } <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    assertNoVertexArray();</div>
<div class="line">    assertNoVBOs();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VBOProxy::BindingType VBOProxy::updateBuffers(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  indices,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; positions,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; normals,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; uvs,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span>                                   areNormalsFlipped,</div>
<div class="line"> <span class="keyword">const</span> VBOMode                                vboMode,</div>
<div class="line">    VertexBuffer::ReadInterfacePtr&amp;              positionsRead,</div>
<div class="line">    VertexBuffer::ReadInterfacePtr&amp;              normalsRead,</div>
<div class="line">    VertexBuffer::ReadInterfacePtr&amp;              uvsRead</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    assert(indices);</div>
<div class="line">    assert(positions);</div>
<div class="line"></div>
<div class="line">    theBufferRegistry().doDelayedErase();</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;const VBOBuffer&gt; vboIndices;</div>
<div class="line">    std::shared_ptr&lt;const VBOBuffer&gt; vboPositions;</div>
<div class="line">    std::shared_ptr&lt;const VBOBuffer&gt; vboNormals;</div>
<div class="line">    std::shared_ptr&lt;const VBOBuffer&gt; vboUVs;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Attempt to use VBOs as much as possible since this is the</span></div>
<div class="line"> <span class="comment">// highest performance API.</span></div>
<div class="line">    BindingType bindingType = kVBOs;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (vboMode == kDontUseVBO || positions-&gt;numVerts() &lt; Config::minVertsForVBOs()) {</div>
<div class="line"> <span class="comment">// We only use VBOs for elements above a certain threshold to</span></div>
<div class="line"> <span class="comment">// avoid using too many VBOs.</span></div>
<div class="line">        bindingType = kVertexArrays;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// Estimate the VBO buffer size to allocate. </span></div>
<div class="line"> <span class="keywordtype">size_t</span> bytesNeeded = 0;</div>
<div class="line"> <span class="keywordtype">size_t</span> buffersNeeded = 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (indices == fIndices) {</div>
<div class="line">            vboIndices = fVBOIndices;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">            vboIndices = theBufferRegistry().find(</div>
<div class="line">                VBOBuffer::kIndexBufferType, indices-&gt;array()-&gt;key());</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (!vboIndices) {</div>
<div class="line">                bytesNeeded += indices-&gt;array()-&gt;bytes();</div>
<div class="line">                ++buffersNeeded;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positions == fPositions) {</div>
<div class="line">            vboPositions = fVBOPositions;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">            vboPositions = theBufferRegistry().find(</div>
<div class="line">                VBOBuffer::kVertexBufferType, positions-&gt;array()-&gt;key());</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (!vboPositions) {</div>
<div class="line">                bytesNeeded += positions-&gt;array()-&gt;bytes();</div>
<div class="line">                ++buffersNeeded;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (normals == fNormals &amp;&amp; areNormalsFlipped == fAreNormalsFlipped) {</div>
<div class="line">            vboNormals = fVBONormals;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordflow">if</span> (areNormalsFlipped) {</div>
<div class="line">                vboNormals = theBufferRegistry().find(</div>
<div class="line">                    VBOBuffer::kFlippedNormalBufferType, normals-&gt;array()-&gt;key());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!vboNormals) {</div>
<div class="line">                    bytesNeeded += normals-&gt;array()-&gt;bytes();</div>
<div class="line">                    ++buffersNeeded;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The unflipped normals buffer will also be</span></div>
<div class="line"> <span class="comment">// necessary to compute the flipped buffer ones..</span></div>
<div class="line">                    std::shared_ptr&lt;const VBOBuffer&gt; unflippedNormals =</div>
<div class="line">                        theBufferRegistry().find(</div>
<div class="line">                            VBOBuffer::kVertexBufferType, normals-&gt;array()-&gt;key());</div>
<div class="line"> <span class="keywordflow">if</span> (!unflippedNormals) {</div>
<div class="line">                        bytesNeeded += normals-&gt;array()-&gt;bytes();</div>
<div class="line">                        ++buffersNeeded;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                vboNormals = theBufferRegistry().find(</div>
<div class="line">                    VBOBuffer::kVertexBufferType, normals-&gt;array()-&gt;key());</div>
<div class="line"> <span class="keywordflow">if</span> (!vboNormals) {</div>
<div class="line">                    bytesNeeded += normals-&gt;array()-&gt;bytes();</div>
<div class="line">                    ++buffersNeeded;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (uvs == fUVs) {</div>
<div class="line">            vboUVs = fVBOUVs;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">            vboUVs = theBufferRegistry().find(</div>
<div class="line">                VBOBuffer::kVertexBufferType, uvs-&gt;array()-&gt;key());</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (!vboUVs) {</div>
<div class="line">                bytesNeeded += uvs-&gt;array()-&gt;bytes();</div>
<div class="line">                ++buffersNeeded;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Stop using VBOs if we have exceeded the limit</span></div>
<div class="line"> <span class="keywordflow">if</span> (theBufferRegistry().reserve(bytesNeeded, buffersNeeded)) {</div>
<div class="line"> <span class="keywordflow">if</span> (!vboIndices) {</div>
<div class="line">                vboIndices = VBOBuffer::create(indices);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">if</span> (!vboPositions) {</div>
<div class="line">                vboPositions = VBOBuffer::create(positions);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">if</span> (normals &amp;&amp; !vboNormals) {</div>
<div class="line"> <span class="keywordflow">if</span> (areNormalsFlipped) {</div>
<div class="line">                    vboNormals = VBOBuffer::createFlippedNormals(normals);</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                    vboNormals = VBOBuffer::create(normals);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">if</span> (uvs &amp;&amp; !vboUVs) {</div>
<div class="line">                vboUVs = VBOBuffer::create(uvs);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordflow">if</span> (Config::useVertexArrayWhenVRAMIsLow()) {</div>
<div class="line"> <span class="comment">// All VBOs are in use, no more space for new VBOs. Use</span></div>
<div class="line"> <span class="comment">// vertex arrays instead.</span></div>
<div class="line">                bindingType = kVertexArrays;</div>
<div class="line"> </div>
<div class="line">                vboIndices.reset();</div>
<div class="line">                vboPositions.reset();</div>
<div class="line">                vboNormals.reset();</div>
<div class="line">                vboUVs.reset();</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// There is not enough VRAM available to keep VBOs around</span></div>
<div class="line"> <span class="comment">// from frame to frame. Draw using temporary VBOs instead.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!vboIndices) {</div>
<div class="line">                    vboIndices = VBOBuffer::create(indices, <span class="keyword">true</span>);</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">if</span> (!vboPositions) {</div>
<div class="line">                    vboPositions = VBOBuffer::create(positions, <span class="keyword">true</span>);</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">if</span> (normals &amp;&amp; !vboNormals) {</div>
<div class="line"> <span class="keywordflow">if</span> (areNormalsFlipped) {</div>
<div class="line">                        vboNormals = VBOBuffer::createFlippedNormals(normals, <span class="keyword">true</span>);</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                        vboNormals = VBOBuffer::create(normals, <span class="keyword">true</span>);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">if</span> (uvs &amp;&amp; !vboUVs) {</div>
<div class="line">                    vboUVs = VBOBuffer::create(uvs, <span class="keyword">true</span>);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Extra checks to see if vertex arrays can be safely used.</span></div>
<div class="line"> <span class="keywordflow">if</span> (bindingType == kVertexArrays) {</div>
<div class="line"> <span class="keywordflow">if</span> (Config::useGLPrimitivesInsteadOfVA()) {</div>
<div class="line"> <span class="comment">// For some reason, using vertex arrays on Windows/nVidia</span></div>
<div class="line"> <span class="comment">// Quadro gfx leads to memory corruption. Using primitive</span></div>
<div class="line"> <span class="comment">// OpenGL calls instead as a workaround.</span></div>
<div class="line">            bindingType = kPrimitives;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (areNormalsFlipped) {</div>
<div class="line"> <span class="comment">// FIXME: We should probably implement a faster way to</span></div>
<div class="line"> <span class="comment">// flip normals than reverting to glBegin()/glEnd()</span></div>
<div class="line"> <span class="comment">// primitives...</span></div>
<div class="line">            bindingType = kPrimitives;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (fLastBindingType) {</div>
<div class="line"> <span class="keywordflow">case</span> kPrimitives: </div>
<div class="line"> <span class="keywordflow">switch</span> (bindingType) {</div>
<div class="line"> <span class="keywordflow">case</span> kPrimitives:</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVertexArrays:</div>
<div class="line">                    {</div>
<div class="line">                        gGLFT-&gt;glEnableClientState(MGL_VERTEX_ARRAY);</div>
<div class="line">                        positionsRead = positions-&gt;readableInterface();</div>
<div class="line">                        gGLFT-&gt;glVertexPointer(3, MGL_FLOAT, 0, positionsRead-&gt;get());</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (normals) {</div>
<div class="line">                        gGLFT-&gt;glEnableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                        normalsRead = normals-&gt;readableInterface();</div>
<div class="line">                        gGLFT-&gt;glNormalPointer(MGL_FLOAT, 0, normalsRead-&gt;get());</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (uvs) {</div>
<div class="line">                        gGLFT-&gt;glEnableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                        uvsRead = uvs-&gt;readableInterface();</div>
<div class="line">                        gGLFT-&gt;glTexCoordPointer(2, MGL_FLOAT, 0, uvsRead-&gt;get());</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVBOs:</div>
<div class="line">                    gGLFT-&gt;glEnableClientState(MGL_VERTEX_ARRAY);</div>
<div class="line">                    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, vboPositions-&gt;name());</div>
<div class="line">                    gGLFT-&gt;glVertexPointer(3, MGL_FLOAT, 0, 0);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (vboNormals) {</div>
<div class="line">                        gGLFT-&gt;glEnableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                        gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, vboNormals-&gt;name());</div>
<div class="line">                        gGLFT-&gt;glNormalPointer(MGL_FLOAT, 0, 0);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (vboUVs) {</div>
<div class="line">                        gGLFT-&gt;glEnableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                        gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, vboUVs-&gt;name());</div>
<div class="line">                        gGLFT-&gt;glTexCoordPointer(2, MGL_FLOAT, 0, 0);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    gGLFT-&gt;glBindBufferARB(MGL_ELEMENT_ARRAY_BUFFER_ARB, vboIndices-&gt;name());</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVertexArrays: </div>
<div class="line"> <span class="keywordflow">switch</span> (bindingType) {</div>
<div class="line"> <span class="keywordflow">case</span> kPrimitives:</div>
<div class="line">                    gGLFT-&gt;glDisableClientState(MGL_VERTEX_ARRAY);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (fNormals) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fUVs) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVertexArrays:</div>
<div class="line"> <span class="keywordflow">if</span> (positions != fPositions || !positions-&gt;array()-&gt;isReadable()) {</div>
<div class="line">                        positionsRead = positions-&gt;readableInterface();</div>
<div class="line">                        gGLFT-&gt;glVertexPointer(3, MGL_FLOAT, 0, positionsRead-&gt;get());</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (normals) {</div>
<div class="line"> <span class="keywordflow">if</span> (!fNormals)</div>
<div class="line">                            gGLFT-&gt;glEnableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line"> <span class="keywordflow">if</span> (normals != fNormals || !normals-&gt;array()-&gt;isReadable()) {</div>
<div class="line">                            normalsRead = normals-&gt;readableInterface();</div>
<div class="line">                            gGLFT-&gt;glNormalPointer(MGL_FLOAT, 0, normalsRead-&gt;get());</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fNormals) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (uvs) {</div>
<div class="line"> <span class="keywordflow">if</span> (!fUVs)</div>
<div class="line">                            gGLFT-&gt;glEnableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line"> <span class="keywordflow">if</span> (uvs != fUVs || !uvs-&gt;array()-&gt;isReadable()) {</div>
<div class="line">                            uvsRead = uvs-&gt;readableInterface();</div>
<div class="line">                            gGLFT-&gt;glTexCoordPointer(2, MGL_FLOAT, 0, uvsRead-&gt;get());</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fUVs) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVBOs:</div>
<div class="line">                    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, vboPositions-&gt;name());</div>
<div class="line">                    gGLFT-&gt;glVertexPointer(3, MGL_FLOAT, 0, 0);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (vboNormals) {</div>
<div class="line"> <span class="keywordflow">if</span> (!fNormals)</div>
<div class="line">                            gGLFT-&gt;glEnableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                        gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, vboNormals-&gt;name());</div>
<div class="line">                        gGLFT-&gt;glNormalPointer(MGL_FLOAT, 0, 0);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (vboUVs) {</div>
<div class="line"> <span class="keywordflow">if</span> (!fUVs)</div>
<div class="line">                            gGLFT-&gt;glEnableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                        gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, vboUVs-&gt;name());</div>
<div class="line">                        gGLFT-&gt;glTexCoordPointer(2, MGL_FLOAT, 0, 0);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    gGLFT-&gt;glBindBufferARB(MGL_ELEMENT_ARRAY_BUFFER_ARB, vboIndices-&gt;name());</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVBOs: </div>
<div class="line"> <span class="keywordflow">switch</span> (bindingType) {</div>
<div class="line"> <span class="keywordflow">case</span> kPrimitives:</div>
<div class="line">                    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, 0);</div>
<div class="line">                    gGLFT-&gt;glBindBufferARB(MGL_ELEMENT_ARRAY_BUFFER_ARB, 0);</div>
<div class="line"></div>
<div class="line">                    gGLFT-&gt;glDisableClientState(MGL_VERTEX_ARRAY);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (fVBONormals) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fVBOUVs) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVertexArrays:</div>
<div class="line">                    gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, 0);</div>
<div class="line">                    gGLFT-&gt;glBindBufferARB(MGL_ELEMENT_ARRAY_BUFFER_ARB, 0);</div>
<div class="line"></div>
<div class="line">                    {</div>
<div class="line">                        positionsRead = positions-&gt;readableInterface();</div>
<div class="line">                        gGLFT-&gt;glVertexPointer(3, MGL_FLOAT, 0, positionsRead-&gt;get());</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (normals) {</div>
<div class="line"> <span class="keywordflow">if</span> (!fVBONormals)</div>
<div class="line">                            gGLFT-&gt;glEnableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                        normalsRead = normals-&gt;readableInterface();</div>
<div class="line">                        gGLFT-&gt;glNormalPointer(MGL_FLOAT, 0, normalsRead-&gt;get());</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fVBONormals) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (uvs) {</div>
<div class="line"> <span class="keywordflow">if</span> (!fVBOUVs)</div>
<div class="line">                            gGLFT-&gt;glEnableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                        uvsRead = uvs-&gt;readableInterface();</div>
<div class="line">                        gGLFT-&gt;glTexCoordPointer(2, MGL_FLOAT, 0, uvsRead-&gt;get());</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fUVs) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVBOs:</div>
<div class="line"> <span class="keywordflow">if</span> (vboPositions != fVBOPositions) {</div>
<div class="line">                        gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, vboPositions-&gt;name());</div>
<div class="line">                        gGLFT-&gt;glVertexPointer(3, MGL_FLOAT, 0, 0);</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (vboNormals) {</div>
<div class="line"> <span class="keywordflow">if</span> (!fVBONormals)</div>
<div class="line">                            gGLFT-&gt;glEnableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line"> <span class="keywordflow">if</span> (vboNormals != fVBONormals) {</div>
<div class="line">                            gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, vboNormals-&gt;name());</div>
<div class="line">                            gGLFT-&gt;glNormalPointer(MGL_FLOAT, 0, 0);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fVBONormals) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_NORMAL_ARRAY);</div>
<div class="line">                        gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, 0);</div>
<div class="line">                        gGLFT-&gt;glNormalPointer(MGL_FLOAT, 0, 0);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (vboUVs) {</div>
<div class="line"> <span class="keywordflow">if</span> (!fVBOUVs)</div>
<div class="line">                            gGLFT-&gt;glEnableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line"> <span class="keywordflow">if</span> (vboUVs != fVBOUVs) {</div>
<div class="line">                            gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, vboUVs-&gt;name());</div>
<div class="line">                            gGLFT-&gt;glTexCoordPointer(2, MGL_FLOAT, 0, 0);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fUVs) {</div>
<div class="line">                        gGLFT-&gt;glDisableClientState(MGL_TEXTURE_COORD_ARRAY);</div>
<div class="line">                        gGLFT-&gt;glBindBufferARB(MGL_ARRAY_BUFFER_ARB, 0);</div>
<div class="line">                        gGLFT-&gt;glTexCoordPointer(2, MGL_FLOAT, 0, 0);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    gGLFT-&gt;glBindBufferARB(MGL_ELEMENT_ARRAY_BUFFER_ARB, vboIndices-&gt;name());</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fIndices           = indices;</div>
<div class="line">    fPositions         = positions;</div>
<div class="line">    fNormals           = normals;</div>
<div class="line">    fUVs               = uvs;</div>
<div class="line"> </div>
<div class="line">    fVBOIndices        = vboIndices;</div>
<div class="line">    fVBOPositions      = vboPositions;</div>
<div class="line">    fVBONormals        = vboNormals;</div>
<div class="line">    fVBOUVs            = vboUVs;</div>
<div class="line">    fAreNormalsFlipped = areNormalsFlipped;</div>
<div class="line"></div>
<div class="line">    fLastBindingType = bindingType;</div>
<div class="line"> <span class="keywordflow">return</span> fLastBindingType;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> VBOProxy::drawVertices(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample,</div>
<div class="line"> <span class="keyword">const</span> VBOMode                               vboMode)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// We may need to read from the buffers in this function and also in</span></div>
<div class="line"> <span class="comment">// updateBuffers.  So to avoid possibly converting the buffers twice, we</span></div>
<div class="line"> <span class="comment">// put the ReadInterfacePtrs in this scope and share them with updateBuffers.</span></div>
<div class="line">    IndexBuffer::ReadInterfacePtr indicesRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr positionsRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr normalsRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr uvsRead;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This draws some vertices multiple times. Unfortunately, there</span></div>
<div class="line"> <span class="comment">// is no easy way to draw each vertices only once without</span></div>
<div class="line"> <span class="comment">// generating a sorted list of the vertices. This is therefore</span></div>
<div class="line"> <span class="comment">// probably the most efficient way to draw the wireframe vertices</span></div>
<div class="line"> <span class="comment">// on the fly.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// A more efficient solution would be to store an index array of</span></div>
<div class="line"> <span class="comment">// the wireframe vertices in the ShapeSample object. We might</span></div>
<div class="line"> <span class="comment">// implement this at a later time if it proved necessary.</span></div>
<div class="line">    BindingType bindingType = updateBuffers(</div>
<div class="line">        sample-&gt;wireVertIndices(),</div>
<div class="line">        sample-&gt;positions(),</div>
<div class="line">        std::shared_ptr&lt;VertexBuffer&gt;(),</div>
<div class="line">        std::shared_ptr&lt;VertexBuffer&gt;(),</div>
<div class="line"> <span class="keyword">false</span>,</div>
<div class="line">        vboMode,</div>
<div class="line">        positionsRead,</div>
<div class="line">        normalsRead,</div>
<div class="line">        uvsRead</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (bindingType) {</div>
<div class="line"> <span class="keywordflow">case</span> kPrimitives:</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span> numPoints = fIndices-&gt;numIndices();</div>
<div class="line">                indicesRead = fIndices-&gt;readableInterface();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> indices = indicesRead-&gt;get();</div>
<div class="line"> <span class="keywordflow">if</span> (!positionsRead)</div>
<div class="line">                    positionsRead = fPositions-&gt;readableInterface();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> verts = positionsRead-&gt;get();</div>
<div class="line"></div>
<div class="line">                gGLFT-&gt;glBegin(MGL_POINTS);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numPoints; ++i) {</div>
<div class="line">                    gGLFT-&gt;glVertex3f(verts[indices[i]*3 + 0],</div>
<div class="line">                                      verts[indices[i]*3 + 1],</div>
<div class="line">                                      verts[indices[i]*3 + 2]);</div>
<div class="line">                }</div>
<div class="line">                gGLFT-&gt;glEnd();</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVertexArrays:</div>
<div class="line">            {</div>
<div class="line">                indicesRead = fIndices-&gt;readableInterface();</div>
<div class="line">                gGLFT-&gt;glDrawElements(</div>
<div class="line">                    MGL_POINTS,</div>
<div class="line">                    MGLsizei(fIndices-&gt;numIndices()),</div>
<div class="line">                    MGL_UNSIGNED_INT,</div>
<div class="line">                    indicesRead-&gt;get());</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVBOs:</div>
<div class="line">            gGLFT-&gt;glDrawElements(</div>
<div class="line">                MGL_POINTS,</div>
<div class="line">                MGLsizei(fIndices-&gt;numIndices()),</div>
<div class="line">                MGL_UNSIGNED_INT,</div>
<div class="line">                (<span class="keywordtype">void</span>*)(fIndices-&gt;beginIdx() * <span class="keyword">sizeof</span>(index_t)));</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> VBOProxy::drawWireframe(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample,</div>
<div class="line"> <span class="keyword">const</span> VBOMode                               vboMode)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// We may need to read from the buffers in this function and also in</span></div>
<div class="line"> <span class="comment">// updateBuffers.  So to avoid possibly converting the buffers twice, we</span></div>
<div class="line"> <span class="comment">// put the ReadInterfacePtrs in this scope and share them with updateBuffers.</span></div>
<div class="line">    IndexBuffer::ReadInterfacePtr indicesRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr positionsRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr normalsRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr uvsRead;</div>
<div class="line"></div>
<div class="line">    BindingType bindingType = updateBuffers(</div>
<div class="line">        sample-&gt;wireVertIndices(),</div>
<div class="line">        sample-&gt;positions(),</div>
<div class="line">        std::shared_ptr&lt;VertexBuffer&gt;(),</div>
<div class="line">        std::shared_ptr&lt;VertexBuffer&gt;(),</div>
<div class="line"> <span class="keyword">false</span>,</div>
<div class="line">        vboMode,</div>
<div class="line">        positionsRead,</div>
<div class="line">        normalsRead,</div>
<div class="line">        uvsRead</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (bindingType) {</div>
<div class="line"> <span class="keywordflow">case</span> kPrimitives:</div>
<div class="line">            {</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span> numWires = fIndices-&gt;numIndices() / 2;</div>
<div class="line">                indicesRead = fIndices-&gt;readableInterface();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> indices = indicesRead-&gt;get();</div>
<div class="line"> <span class="keywordflow">if</span> (!positionsRead)</div>
<div class="line">                    positionsRead = fPositions-&gt;readableInterface();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> verts = positionsRead-&gt;get();</div>
<div class="line"></div>
<div class="line">                gGLFT-&gt;glBegin(MGL_LINES);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numWires; ++i) {</div>
<div class="line">                    gGLFT-&gt;glVertex3f(verts[indices[2*i + 0]*3 + 0],</div>
<div class="line">                                      verts[indices[2*i + 0]*3 + 1],</div>
<div class="line">                                      verts[indices[2*i + 0]*3 + 2]);</div>
<div class="line">                    gGLFT-&gt;glVertex3f(verts[indices[2*i + 1]*3 + 0],</div>
<div class="line">                                      verts[indices[2*i + 1]*3 + 1],</div>
<div class="line">                                      verts[indices[2*i + 1]*3 + 2]);</div>
<div class="line">                }</div>
<div class="line">                gGLFT-&gt;glEnd();</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVertexArrays:</div>
<div class="line">            {</div>
<div class="line">                indicesRead = fIndices-&gt;readableInterface();</div>
<div class="line">                gGLFT-&gt;glDrawElements(</div>
<div class="line">                    MGL_LINES,</div>
<div class="line">                    MGLsizei(fIndices-&gt;numIndices()),</div>
<div class="line">                    MGL_UNSIGNED_INT,</div>
<div class="line">                    indicesRead-&gt;get());</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVBOs:</div>
<div class="line">            gGLFT-&gt;glDrawElements(</div>
<div class="line">                MGL_LINES,</div>
<div class="line">                MGLsizei(fIndices-&gt;numIndices()),</div>
<div class="line">                MGL_UNSIGNED_INT,</div>
<div class="line">                (<span class="keywordtype">void</span>*)(fIndices-&gt;beginIdx() * <span class="keyword">sizeof</span>(index_t)));</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> VBOProxy::drawTriangles(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span>                                groupId,</div>
<div class="line"> <span class="keyword">const</span> NormalsMode                           normalsMode,</div>
<div class="line"> <span class="keyword">const</span> UVsMode                               uvsMode,</div>
<div class="line"> <span class="keyword">const</span> VBOMode                               vboMode)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// We may need to read from the buffers in this function and also in</span></div>
<div class="line"> <span class="comment">// updateBuffers.  So to avoid possibly converting the buffers twice, we</span></div>
<div class="line"> <span class="comment">// put the ReadInterfacePtrs in this scope and share them with updateBuffers.</span></div>
<div class="line">    IndexBuffer::ReadInterfacePtr indicesRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr positionsRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr normalsRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr uvsRead;</div>
<div class="line"></div>
<div class="line">    BindingType bindingType = updateBuffers(</div>
<div class="line">        sample-&gt;triangleVertIndices(groupId),</div>
<div class="line">        sample-&gt;positions(),</div>
<div class="line">        normalsMode != kNoNormals ? sample-&gt;normals() : std::shared_ptr&lt;VertexBuffer&gt;(),</div>
<div class="line">        uvsMode != kNoUVs         ? sample-&gt;uvs()     : std::shared_ptr&lt;VertexBuffer&gt;(),</div>
<div class="line">        normalsMode == kBackNormals,</div>
<div class="line">        vboMode,</div>
<div class="line">        positionsRead,</div>
<div class="line">        normalsRead,</div>
<div class="line">        uvsRead</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (bindingType) {</div>
<div class="line"> <span class="keywordflow">case</span> kPrimitives:</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span> numTriangles = fIndices-&gt;numIndices() / 3;</div>
<div class="line">                indicesRead = fIndices-&gt;readableInterface();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> indices = indicesRead-&gt;get();</div>
<div class="line"> <span class="keywordflow">if</span> (!positionsRead)</div>
<div class="line">                    positionsRead = fPositions-&gt;readableInterface();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> verts = positionsRead-&gt;get();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* norms = NULL;</div>
<div class="line"> <span class="keywordflow">if</span> (fNormals) {</div>
<div class="line"> <span class="keywordflow">if</span> (!normalsRead)</div>
<div class="line">                        normalsRead = fNormals-&gt;readableInterface();</div>
<div class="line">                    norms = normalsRead-&gt;get();</div>
<div class="line">                }</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* uvs = NULL;</div>
<div class="line"> <span class="keywordflow">if</span> (fUVs) {</div>
<div class="line"> <span class="keywordflow">if</span> (!uvsRead)</div>
<div class="line">                        uvsRead = fUVs-&gt;readableInterface();</div>
<div class="line">                    uvs = uvsRead-&gt;get();</div>
<div class="line">                }</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> areNormalsFlipped = fAreNormalsFlipped;</div>
<div class="line"> </div>
<div class="line">                gGLFT-&gt;glBegin(MGL_TRIANGLES);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numTriangles; ++i) {</div>
<div class="line"> <span class="keyword">const</span> index_t idx0 = indices[3*i + 0]*3;</div>
<div class="line"> <span class="keyword">const</span> index_t idx1 = indices[3*i + 1]*3;</div>
<div class="line"> <span class="keyword">const</span> index_t idx2 = indices[3*i + 2]*3;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Index 0</span></div>
<div class="line"> <span class="keywordflow">if</span> (norms) {</div>
<div class="line"> <span class="keywordflow">if</span> (areNormalsFlipped) {</div>
<div class="line">                            gGLFT-&gt;glNormal3f(</div>
<div class="line">                                -norms[idx0 + 0], -norms[idx0 + 1], -norms[idx0 + 2]);</div>
<div class="line">                        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                            gGLFT-&gt;glNormal3f(</div>
<div class="line">                                +norms[idx0 + 0], +norms[idx0 + 1], +norms[idx0 + 2]);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">if</span> (uvs) {</div>
<div class="line">                        gGLFT-&gt;glTexCoord2f(</div>
<div class="line">                            uvs[idx0 + 0], uvs[idx0 + 1]);</div>
<div class="line">                    }</div>
<div class="line">                    gGLFT-&gt;glVertex3f(</div>
<div class="line">                        verts[idx0 + 0], verts[idx0 + 1], verts[idx0 + 2]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Index 1</span></div>
<div class="line"> <span class="keywordflow">if</span> (norms) {</div>
<div class="line"> <span class="keywordflow">if</span> (areNormalsFlipped) {</div>
<div class="line">                            gGLFT-&gt;glNormal3f(</div>
<div class="line">                                -norms[idx1 + 0], -norms[idx1 + 1], -norms[idx1 + 2]);</div>
<div class="line">                        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                            gGLFT-&gt;glNormal3f(</div>
<div class="line">                                +norms[idx1 + 0], +norms[idx1 + 1], +norms[idx1 + 2]);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">if</span> (uvs) {</div>
<div class="line">                        gGLFT-&gt;glTexCoord2f(</div>
<div class="line">                            uvs[idx1 + 0], uvs[idx1 + 1]);</div>
<div class="line">                    }</div>
<div class="line">                    gGLFT-&gt;glVertex3f(</div>
<div class="line">                        verts[idx1 + 0], verts[idx1 + 1], verts[idx1 + 2]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Index 2</span></div>
<div class="line"> <span class="keywordflow">if</span> (norms) {</div>
<div class="line"> <span class="keywordflow">if</span> (areNormalsFlipped) {</div>
<div class="line">                            gGLFT-&gt;glNormal3f(</div>
<div class="line">                                -norms[idx2 + 0], -norms[idx2 + 1], -norms[idx2 + 2]);</div>
<div class="line">                        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                            gGLFT-&gt;glNormal3f(</div>
<div class="line">                                +norms[idx2 + 0], +norms[idx2 + 1], +norms[idx2 + 2]);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">if</span> (uvs) {</div>
<div class="line">                        gGLFT-&gt;glTexCoord2f(</div>
<div class="line">                            uvs[idx2 + 0], uvs[idx2 + 1]);</div>
<div class="line">                    }</div>
<div class="line">                    gGLFT-&gt;glVertex3f(</div>
<div class="line">                        verts[idx2 + 0], verts[idx2 + 1], verts[idx2 + 2]);</div>
<div class="line">                }</div>
<div class="line">                gGLFT-&gt;glEnd();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// For safety...</span></div>
<div class="line">                gGLFT-&gt;glTexCoord2f(0.0f, 0.0f);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVertexArrays:</div>
<div class="line">            {</div>
<div class="line">                indicesRead = fIndices-&gt;readableInterface();</div>
<div class="line">                gGLFT-&gt;glDrawElements(</div>
<div class="line">                    MGL_TRIANGLES,</div>
<div class="line">                    MGLsizei(fIndices-&gt;numIndices()),</div>
<div class="line">                    MGL_UNSIGNED_INT,</div>
<div class="line">                    indicesRead-&gt;get());</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVBOs:</div>
<div class="line">            gGLFT-&gt;glDrawElements(</div>
<div class="line">                MGL_TRIANGLES,</div>
<div class="line">                MGLsizei(fIndices-&gt;numIndices()),</div>
<div class="line">                MGL_UNSIGNED_INT,</div>
<div class="line">                (<span class="keywordtype">void</span>*)(fIndices-&gt;beginIdx() * <span class="keyword">sizeof</span>(index_t)));</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> VBOProxy::drawBoundingBox(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample, </div>
<div class="line"> <span class="keywordtype">bool</span> overrideShadedState  <span class="comment">/* = false */</span></div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    drawBoundingBox(sample-&gt;boundingBox(), overrideShadedState);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> VBOProxy::drawBoundingBox(</div>
<div class="line"> <span class="keyword">const</span> <a name="_a3"></a><a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>&amp; boundingBox,</div>
<div class="line"> <span class="keywordtype">bool</span> overrideShadedState  <span class="comment">/* = false */</span></div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// We may need to read from the buffers in this function and also in</span></div>
<div class="line"> <span class="comment">// updateBuffers.  So to avoid possibly converting the buffers twice, we</span></div>
<div class="line"> <span class="comment">// put the ReadInterfacePtrs in this scope and share them with updateBuffers.</span></div>
<div class="line">    IndexBuffer::ReadInterfacePtr indicesRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr positionsRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr normalsRead;</div>
<div class="line">    VertexBuffer::ReadInterfacePtr uvsRead;</div>
<div class="line"></div>
<div class="line">    BindingType bindingType = updateBuffers(</div>
<div class="line">        UnitBoundingBox::indices(),</div>
<div class="line">        UnitBoundingBox::positions(),</div>
<div class="line">        std::shared_ptr&lt;VertexBuffer&gt;(),</div>
<div class="line">        std::shared_ptr&lt;VertexBuffer&gt;(),</div>
<div class="line"> <span class="keyword">false</span>,</div>
<div class="line">        kDontUseVBO,</div>
<div class="line">        positionsRead,</div>
<div class="line">        normalsRead,</div>
<div class="line">        uvsRead</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// A little hack. We have to draw bounding box in shaded mode.</span></div>
<div class="line"> <span class="comment">// Override OpenGL Shaded state for bounding box drawing</span></div>
<div class="line"> <span class="keywordtype">bool</span> lightingWasOn = <span class="keyword">false</span>, depthMaskWasOn = <span class="keyword">false</span>, stippleWasOn = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">float</span> prevColor[4];</div>
<div class="line"> <span class="keywordflow">if</span> (overrideShadedState) {</div>
<div class="line"> <span class="comment">// Turn off lighting</span></div>
<div class="line">        lightingWasOn = gGLFT-&gt;glIsEnabled(MGL_LIGHTING) == MGL_TRUE;</div>
<div class="line"> <span class="keywordflow">if</span> (lightingWasOn) {</div>
<div class="line">            gGLFT-&gt;glDisable(MGL_LIGHTING);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Turn on depth write</span></div>
<div class="line">        MGLboolean depthWriteMask = MGL_TRUE;</div>
<div class="line">        gGLFT-&gt;glGetBooleanv(MGL_DEPTH_WRITEMASK, &amp;depthWriteMask);</div>
<div class="line">        depthMaskWasOn = depthWriteMask == MGL_TRUE;</div>
<div class="line"> <span class="keywordflow">if</span> (!depthMaskWasOn) {</div>
<div class="line">            gGLFT-&gt;glDepthMask(MGL_TRUE);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Turn on line stipple</span></div>
<div class="line">        stippleWasOn = gGLFT-&gt;glIsEnabled(MGL_LINE_STIPPLE) == MGL_TRUE;</div>
<div class="line"> <span class="keywordflow">if</span> (!stippleWasOn) {</div>
<div class="line">            gGLFT-&gt;glEnable(MGL_LINE_STIPPLE);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set default wireframe color</span></div>
<div class="line">        gGLFT-&gt;glGetFloatv(MGL_CURRENT_COLOR, prevColor);</div>
<div class="line">        gGLFT-&gt;glColor4f(0.0f, 0.016f, 0.376f, 1.0f);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (bindingType) {</div>
<div class="line"> <span class="keywordflow">case</span> kPrimitives:</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// We are using primitives</span></div>
<div class="line"> <span class="keywordtype">float</span> w = (float) boundingBox.<a name="a4"></a><a class="code" href="./class_m_bounding_box.html#a6cddcbf72c80144aa2e6501abb150c30">width</a>();</div>
<div class="line"> <span class="keywordtype">float</span> h = (float) boundingBox.<a name="a5"></a><a class="code" href="./class_m_bounding_box.html#afa7750092d5dcf402c83fb5adba91453">height</a>();</div>
<div class="line"> <span class="keywordtype">float</span> d = (float) boundingBox.<a name="a6"></a><a class="code" href="./class_m_bounding_box.html#a65c72a51aba9fc4233b58751dd712e43">depth</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Below we just two sides and then connect</span></div>
<div class="line"> <span class="comment">// the edges together</span></div>
<div class="line"> <a name="_a7"></a><a class="code" href="./class_m_point.html">MPoint</a> minVertex = boundingBox.<a name="a8"></a><a class="code" href="./class_m_bounding_box.html#afb3213b98f3a6b4bda9759511e9b79a1">min</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Draw first side</span></div>
<div class="line">            gGLFT-&gt;glBegin( MGL_LINE_LOOP );</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> vertex = minVertex;</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex[0],   (<span class="keywordtype">float</span>)vertex[1],   (<span class="keywordtype">float</span>)vertex[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex[0]+w, (<span class="keywordtype">float</span>)vertex[1],   (<span class="keywordtype">float</span>)vertex[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex[0]+w, (<span class="keywordtype">float</span>)vertex[1]+h, (<span class="keywordtype">float</span>)vertex[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex[0],   (<span class="keywordtype">float</span>)vertex[1]+h, (<span class="keywordtype">float</span>)vertex[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex[0],   (<span class="keywordtype">float</span>)vertex[1],   (<span class="keywordtype">float</span>)vertex[2] );</div>
<div class="line">            gGLFT-&gt;glEnd();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Draw second side</span></div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> sideFactor(0,0,d);</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> vertex2 = minVertex + sideFactor;</div>
<div class="line">            gGLFT-&gt;glBegin( MGL_LINE_LOOP );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex2[0],   (<span class="keywordtype">float</span>)vertex2[1],   (<span class="keywordtype">float</span>)vertex2[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex2[0]+w, (<span class="keywordtype">float</span>)vertex2[1],   (<span class="keywordtype">float</span>)vertex2[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex2[0]+w, (<span class="keywordtype">float</span>)vertex2[1]+h, (<span class="keywordtype">float</span>)vertex2[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex2[0],   (<span class="keywordtype">float</span>)vertex2[1]+h, (<span class="keywordtype">float</span>)vertex2[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex2[0],   (<span class="keywordtype">float</span>)vertex2[1],   (<span class="keywordtype">float</span>)vertex2[2] );</div>
<div class="line">            gGLFT-&gt;glEnd();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Connect the edges together</span></div>
<div class="line">            gGLFT-&gt;glBegin( MGL_LINES );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex2[0],  (<span class="keywordtype">float</span>)vertex2[1],  (<span class="keywordtype">float</span>)vertex2[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex[0],   (<span class="keywordtype">float</span>)vertex[1],   (<span class="keywordtype">float</span>)vertex[2]  );</div>
<div class="line"></div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex2[0]+w,  (<span class="keywordtype">float</span>)vertex2[1],  (<span class="keywordtype">float</span>)vertex2[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex[0]+w,   (<span class="keywordtype">float</span>)vertex[1],   (<span class="keywordtype">float</span>)vertex[2]  );</div>
<div class="line"></div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex2[0]+w,  (<span class="keywordtype">float</span>)vertex2[1]+h,  (<span class="keywordtype">float</span>)vertex2[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex[0]+w,   (<span class="keywordtype">float</span>)vertex[1]+h,   (<span class="keywordtype">float</span>)vertex[2]  );</div>
<div class="line"></div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex2[0],  (<span class="keywordtype">float</span>)vertex2[1]+h,  (<span class="keywordtype">float</span>)vertex2[2] );</div>
<div class="line">                gGLFT-&gt;glVertex3f( (<span class="keywordtype">float</span>)vertex[0],   (<span class="keywordtype">float</span>)vertex[1]+h,   (<span class="keywordtype">float</span>)vertex[2]  );</div>
<div class="line">            gGLFT-&gt;glEnd();</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVertexArrays:</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// We are using vertex arrays</span></div>
<div class="line">            gGLFT-&gt;glPushMatrix();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Prepare the matrix for the unit bounding box</span></div>
<div class="line"> <span class="keyword">const</span> <a name="_a9"></a><a class="code" href="./class_m_matrix.html">MMatrix</a> boundingBoxMatrix = </div>
<div class="line">                UnitBoundingBox::boundingBoxMatrix(boundingBox);</div>
<div class="line">            gGLFT-&gt;glMultMatrixd(boundingBoxMatrix.<a name="a10"></a><a class="code" href="./class_m_matrix.html#a527b102f4eb0951cf4f391f828d3ca34">matrix</a>[0]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Draw the bounding box</span></div>
<div class="line">            indicesRead = fIndices-&gt;readableInterface();</div>
<div class="line">            gGLFT-&gt;glDrawElements(MGL_LINES, 24, MGL_UNSIGNED_INT, indicesRead-&gt;get());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Restore the matrix</span></div>
<div class="line">            gGLFT-&gt;glPopMatrix();</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> kVBOs:</div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line"> <span class="comment">// should not get here</span></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Restore the OpenGL state to draw shaded</span></div>
<div class="line"> <span class="keywordflow">if</span> (overrideShadedState) {</div>
<div class="line"> <span class="comment">// Lighting</span></div>
<div class="line"> <span class="keywordflow">if</span> (lightingWasOn) {</div>
<div class="line">            gGLFT-&gt;glEnable(MGL_LIGHTING);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Depth write</span></div>
<div class="line"> <span class="keywordflow">if</span> (!depthMaskWasOn) {</div>
<div class="line">            gGLFT-&gt;glDepthMask(MGL_FALSE);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Line stipple</span></div>
<div class="line"> <span class="keywordflow">if</span> (!stippleWasOn) {</div>
<div class="line">            gGLFT-&gt;glDisable(MGL_LINE_STIPPLE);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Color</span></div>
<div class="line">        gGLFT-&gt;glColor4fv(prevColor);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace GPUCache</span></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</link></link></link></link></div></body>
</html>

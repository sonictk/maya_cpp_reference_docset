var topic = "<!-- saved from url=(0024)http://docs.autodesk.com -->\n\
<html>\n\
   <head><script src=\"../scripts/yepnope.1.5.4-min.js\" type=\"text/javascript\"></script><script src=\"../scripts/lib/jquery-1.11.1.min.js\" type=\"text/javascript\"></script><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><meta name=\"product\" content=\"MAYAUL\"><meta name=\"release\" content=\"2018\"><meta name=\"book\" content=\"Developer\"><meta name=\"created\" content=\"2017-06-22\"><meta name=\"topicid\" content=\"GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887\"><meta name=\"topic-type\" content=\"concept\">\n\
      <title>gpuCache/gpuCacheSubSceneOverride.cpp</title>\n\
   \n\
\n\
<meta name=\"topic-subtype\" content=\"C++\"></head>\n\
   <body height=\"100%\"><div class=\"body_content\" id=\"body-content\"><link rel=\"stylesheet\" type=\"text/css\" href=\"cpp_ref/navtree.css\"><link rel=\"stylesheet\" type=\"text/css\" href=\"cpp_ref/doxygen.css\"><link rel=\"stylesheet\" type=\"text/css\" href=\"cpp_ref/tabs.css\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style/adsk.cpm.css\"><script language=\"javascript\">var index = \'index.html\';</script><script>$(document).ready(function() { yepnope.injectJs(\"./scripts/ac_common.js\"); });</script><script type=\"text/javascript\">\n\
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == \'undefined\';\n\
var weAreIn21 = $(\'div#main.view-active\').length;\n\
var tocPrefix = \'\';\n\
if (weAreIn21)\n\
{ tocPrefix = \'cpp_ref/\'; }\n\
function cpp_ref_initializeToc(forceTrigger) {\n\
    cpp_ref_adsk_ref_toc.initResizable();\n\
    cpp_ref_adsk_ref_toc.initNavTree(\'gpu_cache_2gpu_cache_sub_scene_override_8cpp-example.html\', tocPrefix);\n\
    dQuery(document).trigger(\'toc_initialized\');\n\
}\n\
if (tocSystemNeedsToBeLoaded)\n\
{\n\
	yepnope([{\n\
	load:[tocPrefix + \'json3.min.js\', tocPrefix + \'jquery.js\', tocPrefix + \'ref-toc-controller.js\', tocPrefix + \'dynsections.js\'],\n\
	complete: function() {\n\
	  if (typeof(dQuery) == \'undefined\')\n\
	  {\n\
	    dQuery = jQuery.noConflict(true);\n\
	  }\n\
	  else { jQuery.noConflict(true); }\n\
	  $(document).ready(cpp_ref_initializeToc);\n\
	}\n\
 	}])\n\
}\n\
if (!weAreIn21) { // if in AKN...\n\
$(window).load( function() {\n\
    setTimeout( function() {\n\
        var content = $(\'body > div\').not(\'#body-content\');     // take any divs under body that are not id=body-content\n\
        content.each( function() { \n\
            $(this).css( { \'padding-left\': $(this).css(\'margin-left\') } );       // and if they have any padding-left already, move it to margin-left.\n\
        } );\n\
        var width = cpp_ref_adsk_ref_toc.readFromStorage(\'width\');\n\
        content.css({marginLeft:parseInt(width)+6+\"px\"});\n\
    }, 100);\n\
} ); \n\
}\n\
</script><script>$(\"div#WidgetFloaterPanels,link[href*=\'microsofttranslator.com\'],script[src*=\'microsofttranslator.com\'],script[src*=\'bing.com\']\").remove();</script><script type=\'text/javascript\'>$(\"div#navigation,div#breadcrumbs,div#banner\").attr(\"translate\",\"no\"); var mtLocation = ((location && location.href && location.href.indexOf(\'https\') == 0)?\'https://ssl.microsofttranslator.com\':\'http://www.microsofttranslator.com\')+\'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages=\'; yepnope.injectJs(mtLocation, function() {}, { charset:\'utf-8\', type:\'text/javascript\' } );</script><script>\n\
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }\n\
 </script><!-- begin MT -->\n\
            \n\
            <div id=\'MicrosoftTranslatorWidget\' class=\'Dark\' style=\'float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden\'></div>\n\
      <div>\n\
         <div class=\"head\">\n\
            <h1>gpuCache/gpuCacheSubSceneOverride.cpp</h1>\n\
         </div>\n\
\n\
    <div id=\"top\"><!-- Generated by Doxygen 1.8.10 -->\n\
  <div id=\"navrow1\" class=\"tabs\">\n\
    <ul class=\"tablist\">\n\
      <li><a href=\"#!/url=./cpp_ref/index.html\"><span>Main&#160;Page</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/pages.html\"><span>Topics</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/modules.html\"><span>Modules</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/namespaces.html\"><span>Namespaces</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/annotated.html\"><span>Classes</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/examples.html\"><span>Examples</span></a></li>\n\
    </ul>\n\
  </div>\n\
</div><!-- top -->\n\
<div id=\"side-nav\" class=\"ui-resizable side-nav-resizable\">\n\
  <div id=\"nav-tree\">\n\
    <div id=\"nav-tree-contents\">\n\
      <div id=\"nav-sync\" class=\"sync\"></div>\n\
    </div>\n\
  </div>\n\
  <div id=\"splitbar\" style=\"-moz-user-select:none;\" class=\"ui-resizable-handle\">\n\
  </div>\n\
</div>\n\
\n\
<div id=\"doc-content\">\n\
<div class=\"header\">\n\
  <div class=\"headertitle\">\n\
<div class=\"title\">gpuCache/gpuCacheSubSceneOverride.cpp</div>  </div>\n\
</div><!--header-->\n\
<div class=\"contents\">\n\
<div class=\"fragment\"><div class=\"line\"><span class=\"comment\">//-</span></div>\n\
<div class=\"line\"><span class=\"comment\">//**************************************************************************/</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>\n\
<div class=\"line\"><span class=\"comment\">//</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Use of this software is subject to the terms of the Autodesk</span></div>\n\
<div class=\"line\"><span class=\"comment\">// license agreement provided at the time of installation or download,</span></div>\n\
<div class=\"line\"><span class=\"comment\">// or which otherwise accompanies this software in either electronic</span></div>\n\
<div class=\"line\"><span class=\"comment\">// or hard copy form.</span></div>\n\
<div class=\"line\"><span class=\"comment\">//**************************************************************************/</span></div>\n\
<div class=\"line\"><span class=\"comment\">//+</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &quot;gpuCacheSubSceneOverride.h&quot;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &quot;gpuCacheShapeNode.h&quot;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &quot;gpuCacheUnitBoundingBox.h&quot;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &quot;gpuCacheFrustum.h&quot;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &quot;gpuCacheUtil.h&quot;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &quot;CacheReader.h&quot;</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;unordered_set&gt;</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;boost/multi_index_container.hpp&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;boost/multi_index/member.hpp&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;boost/multi_index/mem_fun.hpp&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;boost/multi_index/hashed_index.hpp&gt;</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;tbb/tbb_thread.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;tbb/mutex.h&gt;</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MDagMessage.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MDGMessage.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MModelMessage.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MNodeMessage.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MSceneMessage.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MEventMessage.h&gt;</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MHWGeometryUtilities.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MAnimControl.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MDrawContext.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MFnAttribute.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MFnDagNode.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MGlobal.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MItDag.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MSelectionContext.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MSelectionList.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MShaderManager.h&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;maya/MUserData.h&gt;</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">namespace </span>{</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// LOCAL FUNCTIONS and CLASSES</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Guard pattern.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>ScopedGuard : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    ScopedGuard(T&amp; value)</div>\n\
<div class=\"line\">        : fValueRef(value), fValueBackup(value)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~ScopedGuard()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fValueRef = fValueBackup;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    T&amp; fValueRef;</div>\n\
<div class=\"line\">    T  fValueBackup;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// The thread id of the main thread.</span></div>\n\
<div class=\"line\">tbb::tbb_thread::id gsMainThreadId = tbb::this_tbb_thread::get_id();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Helper functions for MayaBufferArray to fetch the buffer sizes.  Results are in numbers </span></div>\n\
<div class=\"line\"><span class=\"comment\">// of 4-byte words.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">size_t</span> MayaBufferSizeHelper(<a name=\"_a0\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html\">MHWRender::MIndexBuffer</a>* mayaBuffer)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> mayaBuffer-&gt;<a name=\"a1\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a90ca964ebcc1b02bbcde225edd49e812\">size</a>();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">size_t</span> MayaBufferSizeHelper(<a name=\"_a2\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html\">MHWRender::MVertexBuffer</a>* mayaBuffer)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> mayaBuffer-&gt;<a name=\"a3\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html#a331cfb987f5f4d632a747e7fbbbe4a43\">descriptor</a>().<a name=\"a4\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#ae5acbe47d704ceb866e3717e2ac9422f\">dimension</a>() * mayaBuffer-&gt;<a name=\"a5\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html#a42db940e8d3c623487a4e2c34024751c\">vertexCount</a>();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">namespace </span>GPUCache {</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">using namespace </span><a class=\"code\" href=\"#!/url=./cpp_ref/namespace_m_h_w_render.html\">MHWRender</a>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// An implementation of the Array interface which wraps a Maya-owned data buffer.  This</span></div>\n\
<div class=\"line\"><span class=\"comment\">// buffer may reside on the GPU, so we do not provide direct read access.  Read access</span></div>\n\
<div class=\"line\"><span class=\"comment\">// can be granted, but this is only safe to do from the main thread.  Readback won&#39;t be</span></div>\n\
<div class=\"line\"><span class=\"comment\">// as fast as from a raw memory buffer, but it will typically be fast enough to be useful.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// With huge scenes we can&#39;t afford to store two entire copies of the scene geometry.  So</span></div>\n\
<div class=\"line\"><span class=\"comment\">// we can convert our arrays to this type and depend solely on the Maya copy.  We leave</span></div>\n\
<div class=\"line\"><span class=\"comment\">// memory management of the buffers to Maya, so they may be paged out to system memory or</span></div>\n\
<div class=\"line\"><span class=\"comment\">// to disk as needed.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// T - the raw datatype of the array, float or unsigned int.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// C - the maya buffer class containing the data, MVertexBuffer or MIndexBuffer.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">template</span> &lt; <span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> C &gt;</div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>MayaBufferArray : <span class=\"keyword\">public</span> Array&lt;T&gt;</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Some places only need temporary read-access to the contents of a Maya buffer.  So</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// instead of creating a full SharedArray which goes in the ArrayRegistry, we can provide</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// an alternate implementation of ArrayReadInterface which provides a bare-bones temporary</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// memory buffer.  This is useful for selection, which is the most common case of readback</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// from renderable buffers.  Less common use cases are when gpuCache exports a copy of itself</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// into a new alembic cache file or when the viewport mode switches to the default viewport.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">class </span>TempCopyReadableInterface : <span class=\"keyword\">public</span> ArrayReadInterface&lt;T&gt;</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">         boost::shared_array&lt;T&gt; fLocalArray;</div>\n\
<div class=\"line\">    <span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">        TempCopyReadableInterface(boost::shared_array&lt;T&gt; localArray) : fLocalArray(localArray) {}</div>\n\
<div class=\"line\">        ~TempCopyReadableInterface()<span class=\"keyword\"> override </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> T* <span class=\"keyword\">get</span>() <span class=\"keyword\">const</span> <span class=\"keyword\">override</span> { <span class=\"keywordflow\">return</span> fLocalArray.get(); }</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> Array&lt;T&gt;::Digest Digest;</div>\n\
<div class=\"line\">    </div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> std::shared_ptr&lt;Array&lt;T&gt; &gt; create(<span class=\"keyword\">const</span> std::shared_ptr&lt;C&gt;&amp; mayaBuffer, Digest digest)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// The Digest is pre-calculated.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> size = MayaBufferSizeHelper(mayaBuffer.get());</div>\n\
<div class=\"line\">       </div>\n\
<div class=\"line\">        <span class=\"comment\">// We first look if a similar array already exists in the</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// cache. If so, we return the cached array to promote sharing as</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// much as possible.</span></div>\n\
<div class=\"line\">        std::shared_ptr&lt;Array&lt;T&gt; &gt; ret;</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            tbb::mutex::scoped_lock lock(ArrayRegistry&lt;T&gt;::mutex());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            ret = ArrayRegistry&lt;T&gt;::lookupNonReadable(digest, size);</div>\n\
<div class=\"line\">        </div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (!ret) {</div>\n\
<div class=\"line\">                ret = std::make_shared&lt;MayaBufferArray&lt;T, C&gt; &gt;(</div>\n\
<div class=\"line\">                    mayaBuffer, digest);</div>\n\
<div class=\"line\">                ArrayRegistry&lt;T&gt;::insert(ret);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ret;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~MayaBufferArray()<span class=\"keyword\"> override </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::shared_ptr&lt;const ArrayReadInterface&lt;T&gt; &gt; getReadable()<span class=\"keyword\"> const override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Get a temporary readable copy of the buffer contents.  Nothing new</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// will be registered with the ArrayRegistry.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// This function can only be called from the main thread.</span></div>\n\
<div class=\"line\">        std::shared_ptr&lt;const TempCopyReadableInterface&gt; ret(std::make_shared&lt;const TempCopyReadableInterface&gt;(GetTempArrayCopy()));</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ret;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; getReadableArray()<span class=\"keyword\"> const override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Get a full-fledged SharedArray version of the buffer contents.  This</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// SharedArray will be registered with the ArrayRegistry.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// This function can only be called from the main thread.</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"comment\">// If the readable version already exists in the registry, return that one.</span></div>\n\
<div class=\"line\">            tbb::mutex::scoped_lock lock(ArrayRegistry&lt;T&gt;::mutex());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; ret;</div>\n\
<div class=\"line\">            <span class=\"comment\">// Linux gcc complains about these base class functions unless they are explicitly </span></div>\n\
<div class=\"line\">            <span class=\"comment\">// disambiguated by proving this-&gt;</span></div>\n\
<div class=\"line\">            ret = ArrayRegistry&lt;T&gt;::lookupReadable(this-&gt;digest(), this-&gt;bytes());</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (ret)</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">return</span> ret;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// If the readable version doesn&#39;t exist in the registry, then create one.</span></div>\n\
<div class=\"line\">        boost::shared_array&lt;T&gt; rawData(GetTempArrayCopy());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> SharedArray&lt;T&gt;::create(rawData, this-&gt;digest(), this-&gt;bytes()/<span class=\"keyword\">sizeof</span>(T));</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::shared_ptr&lt;C&gt; getMBuffer()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fMayaBuffer;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    MayaBufferArray(<span class=\"keyword\">const</span> std::shared_ptr&lt;C&gt;&amp; mayaBuffer, Digest digest)  <span class=\"comment\">// private constructor.  use create() instead.</span></div>\n\
<div class=\"line\">        : Array&lt;T&gt;(MayaBufferSizeHelper(mayaBuffer.get()), digest, false)</div>\n\
<div class=\"line\">        , fMayaBuffer(mayaBuffer)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    MayaBufferArray(<span class=\"keyword\">const</span> MayaBufferArray&amp; other);  <span class=\"comment\">//private and unimplemented</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    boost::shared_array&lt;T&gt; GetTempArrayCopy()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Read the buffer contents back out of the Maya buffer and store it in a</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// temporary system memory buffer.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// If the Maya buffer is resident in GPU ram, then the graphics API calls to </span></div>\n\
<div class=\"line\">        <span class=\"comment\">// access it can only be performed from the main thread.  gpuCache uses a</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// worker thread for file reading, so that code in CacheReaderAlembic has</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// to avoid converting Arrays into ReadableArrays.  It is possible that the</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// file reader thread may create an array which duplicates the contents of</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// a MayaBufferArray, but that situation should clean itself up when the array</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// is eventually converted into a BufferEntry for rendering.</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// We copy the data into a temporary buffer instead of just holding the mapped</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// pointer because the selection code intermixes buffer readback with it&#39;s own</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// OpenGL calls. That conflicts with leaving the buffer bound for mapping in vp2.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// The unmap() API function guarantees that it resets the GL buffer binding to 0</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// so this will behave predictably mixed with other GL code.</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(gsMainThreadId == tbb::this_tbb_thread::get_id());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (gsMainThreadId != tbb::this_tbb_thread::get_id())</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> boost::shared_array&lt;T&gt;();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> T* src = (<span class=\"keyword\">const</span> T *)fMayaBuffer-&gt;map();</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> numBytes = this-&gt;bytes();</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> numValues = numBytes / <span class=\"keyword\">sizeof</span>(T);</div>\n\
<div class=\"line\">        boost::shared_array&lt;T&gt; rawData(<span class=\"keyword\">new</span> T[numValues]);</div>\n\
<div class=\"line\">        memcpy(rawData.get(), src, numBytes);</div>\n\
<div class=\"line\">        fMayaBuffer-&gt;unmap();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> rawData;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    </div>\n\
<div class=\"line\">    GPUCACHE_DECLARE_MAKE_SHARED_FRIEND;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> std::shared_ptr&lt;C&gt; fMayaBuffer;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Explicitly instantiate the two versions we need.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">template</span> <span class=\"keyword\">class </span>MayaBufferArray&lt;unsigned int, MHWRender::MIndexBuffer&gt;;</div>\n\
<div class=\"line\"><span class=\"keyword\">template</span> <span class=\"keyword\">class </span>MayaBufferArray&lt;float, MHWRender::MVertexBuffer&gt;;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">typedef</span> MayaBufferArray&lt;unsigned int, MHWRender::MIndexBuffer&gt; MayaIndexBufferWrapper;</div>\n\
<div class=\"line\"><span class=\"keyword\">typedef</span> MayaBufferArray&lt;float, MHWRender::MVertexBuffer&gt; MayaVertexBufferWrapper;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS BuffersCache</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class manages all Viewport 2.0 buffers.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// When VRAM is hitting the threshold, the cache will delete free buffers to get </span></div>\n\
<div class=\"line\"><span class=\"comment\">// more room for the new buffers.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Allocating and evicting are done between frames.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>BuffersCache : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> BuffersCache&amp; getInstance()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Singleton</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">static</span> BuffersCache sSingleton;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> sSingleton;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Set Viewport 2.0 buffers to the render item and add these buffers</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// to this cache. This means that these buffers are going to be used</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// in the render item.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setBuffers(</div>\n\
<div class=\"line\">        SubSceneOverride&amp;                            subSceneOverride,</div>\n\
<div class=\"line\">        <a name=\"_a6\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html\">MRenderItem</a>*                                 renderItem,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  indices,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; positions,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; normals,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; uvs,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a name=\"_a7\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_bounding_box.html\">MBoundingBox</a>&amp;                          boundingBox</div>\n\
<div class=\"line\">    )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(positions);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!positions) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Unloaded render item! Just count the reference.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!renderItem) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (indices) {</div>\n\
<div class=\"line\">                acquireIndexBuffer(indices);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            acquireVertexBuffer(positions);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (normals) {</div>\n\
<div class=\"line\">                acquireVertexBuffer(normals);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (uvs) {</div>\n\
<div class=\"line\">                acquireVertexBuffer(uvs);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Semantic Constants</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <a name=\"_a8\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> sPositions(<span class=\"stringliteral\">&quot;positions&quot;</span>);</div>\n\
<div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> sNormals(<span class=\"stringliteral\">&quot;normals&quot;</span>);</div>\n\
<div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> sUVs(<span class=\"stringliteral\">&quot;uvs&quot;</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <a name=\"_a9\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_array.html\">MVertexBufferArray</a> buffers;</div>\n\
<div class=\"line\">        buffers.<a name=\"a10\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_array.html#acd36fdd49c7d45faff08163ae776c5b2\">addBuffer</a>(sPositions, acquireVertexBuffer(positions));</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (normals) {</div>\n\
<div class=\"line\">            buffers.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_array.html#acd36fdd49c7d45faff08163ae776c5b2\">addBuffer</a>(sNormals, acquireVertexBuffer(normals));</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (uvs) {</div>\n\
<div class=\"line\">            buffers.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_array.html#acd36fdd49c7d45faff08163ae776c5b2\">addBuffer</a>(sUVs, acquireVertexBuffer(uvs));</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// It the geometry does not require an index buffer, then use an empty one.</span></div>\n\
<div class=\"line\">        subSceneOverride.setGeometryForRenderItem(</div>\n\
<div class=\"line\">            *renderItem,</div>\n\
<div class=\"line\">            buffers,</div>\n\
<div class=\"line\">            indices ? *acquireIndexBuffer(indices) : <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html\">MIndexBuffer</a>(MGeometry::kUnsignedInt32),</div>\n\
<div class=\"line\">            &amp;boundingBox</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Remove Viewport 2.0 buffers from this cache. This means that these</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// buffers is no longer used (and might become free buffers and then deleted).</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> removeBuffers(</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  indices,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; positions,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; normals = std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; uvs     = std::shared_ptr&lt;const VertexBuffer&gt;()</div>\n\
<div class=\"line\">    )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (indices) {</div>\n\
<div class=\"line\">            removeBufferFromCache(indices);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (positions) {</div>\n\
<div class=\"line\">            removeBufferFromCache(positions);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (normals) {</div>\n\
<div class=\"line\">            removeBufferFromCache(normals);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (uvs) {</div>\n\
<div class=\"line\">            removeBufferFromCache(uvs);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Shorthand method to do removeBuffers() and setBuffers()</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateBuffers(</div>\n\
<div class=\"line\">        SubSceneOverride&amp;                            subSceneOverride,</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html\">MRenderItem</a>*                                 renderItem,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  indices,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; positions,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; normals,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; uvs,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_bounding_box.html\">MBoundingBox</a>&amp;                          boundingBox,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  prevIndices,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; prevPositions,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; prevNormals = std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; prevUVs     = std::shared_ptr&lt;const VertexBuffer&gt;()</div>\n\
<div class=\"line\">    )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        removeBuffers(prevIndices, prevPositions, prevNormals, prevUVs);</div>\n\
<div class=\"line\">        setBuffers(subSceneOverride, renderItem, indices, positions, normals, uvs, boundingBox);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Find the Viewport 2.0 index buffer in the cache. Returns NULL if not found.</span></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html\">MIndexBuffer</a>* lookup(<span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html\">MIndexBuffer</a>* buffer = NULL;</div>\n\
<div class=\"line\">        lookup(indices, buffer);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> buffer;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Find the Viewport 2.0 vertex buffer in the cache. Returns NULL if not found.</span></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html\">MVertexBuffer</a>* lookup(<span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html\">MVertexBuffer</a>* buffer = NULL;</div>\n\
<div class=\"line\">        lookup(vertices, buffer);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> buffer;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Shrink the cache if the total size of buffers is hitting the threshold.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// Buffers with 0 reference count will be deleted.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> shrink()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Delete Viewport 2.0 buffers that are queued for deletion.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// Their IndexBuffer/VertexBuffer arrays have already been deleted.</span></div>\n\
<div class=\"line\">        doDeleteQueuedBuffers();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">while</span> (fTotalBufferSize &gt; Config::maxVBOSize()) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// No more free buffers can be deleted.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// All active buffers are already used by render items.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fFreeBuffers.empty()) <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Delete a random free buffer.</span></div>\n\
<div class=\"line\">            BufferSet::iterator it = fFreeBuffers.begin();</div>\n\
<div class=\"line\">            fTotalBufferSize -= (*it).bytes();</div>\n\
<div class=\"line\">            fFreeBuffers.erase(it);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Clear and delete all buffers.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> clear()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fTotalBufferSize = 0;</div>\n\
<div class=\"line\">        fActiveBuffers.clear();</div>\n\
<div class=\"line\">        fFreeBuffers.clear();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            tbb::mutex::scoped_lock lock(fBuffersToDeleteMutex);</div>\n\
<div class=\"line\">            fBuffersToDelete.clear();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">class </span>BufferEntry;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    BuffersCache()</div>\n\
<div class=\"line\">        : fTotalBufferSize(0)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        ArrayBase::registerDestructionCallback(sArrayDestructionCb);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~BuffersCache()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        ArrayBase::unregisterDestructionCallback(sArrayDestructionCb);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Allocate an index buffer or return the existing index buffer.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// This will add the reference count by 1.</span></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html\">MIndexBuffer</a>* acquireIndexBuffer(<span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(indices);</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html\">MIndexBuffer</a>* buffer = NULL;</div>\n\
<div class=\"line\">        addBufferToCache(indices).getBuffer(buffer);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> buffer;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Allocate a vertex buffer or return the existing vertex buffer.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// This will add the reference count by 1.</span></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html\">MVertexBuffer</a>* acquireVertexBuffer(<span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(vertices);</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html\">MVertexBuffer</a>* buffer = NULL;</div>\n\
<div class=\"line\">        addBufferToCache(vertices).getBuffer(buffer);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> buffer;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Add the buffer to the cache. If the buffer already exists</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// in the cache, the reference count will be added by 1.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> BufferEntry&amp; addBufferToCache(<span class=\"keyword\">const</span> T&amp; buffer)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Already a buffer in use?</span></div>\n\
<div class=\"line\">        BufferSet::iterator it = fActiveBuffers.find(buffer);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fActiveBuffers.end()) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// The buffer is already used by a render item.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// Just increase the reference count.</span></div>\n\
<div class=\"line\">            assert((*it).refCount() &gt; 0);</div>\n\
<div class=\"line\">            (*it).ref();</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> *it;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// A free buffer?</span></div>\n\
<div class=\"line\">        it = fFreeBuffers.find(buffer);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fFreeBuffers.end()) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// The buffer is not used by any render items.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// Move it to active buffer set and increase the reference count.</span></div>\n\
<div class=\"line\">            assert((*it).refCount() == 0);</div>\n\
<div class=\"line\">            BufferSet::iterator newIt = fActiveBuffers.insert(*it).first;</div>\n\
<div class=\"line\">            fFreeBuffers.erase(it);</div>\n\
<div class=\"line\">            (*newIt).ref();</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> *newIt;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Allocate a new buffer.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// This will construct a new MIndexBuffer or MVertexBuffer.</span></div>\n\
<div class=\"line\">        BufferSet::iterator newIt = fActiveBuffers.insert(buffer).first;</div>\n\
<div class=\"line\">        (*newIt).ref();</div>\n\
<div class=\"line\">        fTotalBufferSize += (*newIt).bytes();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> *newIt;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Declaim that the buffer is not used by a render item.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// The reference count will be decreased by 1.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// If the reference count reaches 0, the buffer has the </span></div>\n\
<div class=\"line\">    <span class=\"comment\">// possibility to be deleted in shrink().</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> removeBufferFromCache(<span class=\"keyword\">const</span> T&amp; buffer)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// This must be a buffer in use.</span></div>\n\
<div class=\"line\">        BufferSet::iterator it = fActiveBuffers.find(buffer);</div>\n\
<div class=\"line\">        assert(fFreeBuffers.find(buffer) == fFreeBuffers.end());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fActiveBuffers.end()) {</div>\n\
<div class=\"line\">            assert((*it).refCount() &gt; 0);</div>\n\
<div class=\"line\">            (*it).unref();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// This buffer is no longer used by any render items.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// Move it to free buffer set.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> ((*it).refCount() == 0) {</div>\n\
<div class=\"line\">                fFreeBuffers.insert(*it);</div>\n\
<div class=\"line\">                fActiveBuffers.erase(it);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Find the buffer in the cache.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// This will not allocate any new buffers.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> R&gt;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> lookup(<span class=\"keyword\">const</span> T&amp; buffer, R&amp; pointer)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// In active buffer set?</span></div>\n\
<div class=\"line\">        BufferSet::iterator it = fActiveBuffers.find(buffer);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fActiveBuffers.end()) {</div>\n\
<div class=\"line\">            assert((*it).refCount() &gt; 0);</div>\n\
<div class=\"line\">            (*it).getBuffer(pointer);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// In free buffer set?</span></div>\n\
<div class=\"line\">        it = fFreeBuffers.find(buffer);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fFreeBuffers.end()) {</div>\n\
<div class=\"line\">            assert((*it).refCount() == 0);</div>\n\
<div class=\"line\">            (*it).getBuffer(pointer);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        pointer = NULL;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Queue the buffer for deletion. This method is thread-safe.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// Sometimes, a buffer might be deleted in a worker thread.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> queueBufferForDelete(<span class=\"keyword\">const</span> ArrayBase::Key&amp; key)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        tbb::mutex::scoped_lock lock(fBuffersToDeleteMutex);</div>\n\
<div class=\"line\">        fBuffersToDelete.insert(key);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Delete all queued buffers. This method must be called from the main thread.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> doDeleteQueuedBuffers()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fBuffersToDelete.empty()) {</div>\n\
<div class=\"line\">            tbb::mutex::scoped_lock lock(fBuffersToDeleteMutex);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keyword\">typedef</span> BufferSet::nth_index&lt;1&gt;::type::iterator KeyIterator;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> ArrayBase::Key&amp; key : fBuffersToDelete) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// Find all the buffers that have the same key.</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// It&#39;s possible that the array is used for both position and normal.</span></div>\n\
<div class=\"line\">                std::pair&lt;KeyIterator,KeyIterator&gt; range = </div>\n\
<div class=\"line\">                    fFreeBuffers.get&lt;1&gt;().equal_range(key);</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span> (KeyIterator it = range.first; it != range.second; it++) {</div>\n\
<div class=\"line\">                    assert((*it).refCount() == 0);</div>\n\
<div class=\"line\">                    fTotalBufferSize -= (*it).bytes();</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                fFreeBuffers.get&lt;1&gt;().erase(key);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Done.</span></div>\n\
<div class=\"line\">            fBuffersToDelete.clear();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keywordtype\">void</span> sArrayDestructionCb(<span class=\"keyword\">const</span> ArrayBase::Key&amp; key)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Queue the buffers for deletion.</span></div>\n\
<div class=\"line\">        BuffersCache::getInstance().queueBufferForDelete(key);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Delete the buffers immediately if we are in the main thread.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (tbb::this_tbb_thread::get_id() == gsMainThreadId) {</div>\n\
<div class=\"line\">            BuffersCache::getInstance().doDeleteQueuedBuffers();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This class provides a common interface for vertex/index buffers.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">class </span>BufferEntry</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">    <span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">        <span class=\"comment\">// The unique key for index/vertex buffers.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">struct </span>BufferKey</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">enum</span> BufferType { kIndex, kVertex };</div>\n\
<div class=\"line\">            BufferType          type;</div>\n\
<div class=\"line\">            ArrayBase::Key      arrayKey;</div>\n\
<div class=\"line\">            <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6\">MGeometry::DataType</a> dataType;</div>\n\
<div class=\"line\">            <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4\">MGeometry::Semantic</a> semantic;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            BufferKey(<span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>\n\
<div class=\"line\">                : type(kIndex),</div>\n\
<div class=\"line\">                  arrayKey(indices-&gt;array()-&gt;key()),</div>\n\
<div class=\"line\">                  dataType(<a name=\"_a11\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html\">MGeometry</a>::kUnsignedInt32),</div>\n\
<div class=\"line\">                  semantic(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html\">MGeometry</a>::kInvalidSemantic)</div>\n\
<div class=\"line\">            {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            BufferKey(<span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>\n\
<div class=\"line\">                : type(kVertex),</div>\n\
<div class=\"line\">                  arrayKey(vertices-&gt;array()-&gt;key()),</div>\n\
<div class=\"line\">                  dataType(vertices-&gt;descriptor().dataType()),</div>\n\
<div class=\"line\">                  semantic(vertices-&gt;descriptor().semantic())</div>\n\
<div class=\"line\">            {}</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keyword\">struct </span>BufferKeyHash : std::unary_function&lt;BufferKey, std::size_t&gt;</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            std::size_t operator()(<span class=\"keyword\">const</span> BufferKey&amp; key)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">            </span>{</div>\n\
<div class=\"line\">                std::size_t hashCode = 0;</div>\n\
<div class=\"line\">                boost::hash_combine(hashCode, key.type);</div>\n\
<div class=\"line\">                boost::hash_combine(hashCode, ArrayBase::KeyHash()(key.arrayKey));</div>\n\
<div class=\"line\">                boost::hash_combine(hashCode, key.dataType);</div>\n\
<div class=\"line\">                boost::hash_combine(hashCode, key.semantic);</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">return</span> hashCode;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keyword\">struct </span>BufferKeyEqualTo : std::binary_function&lt;BufferKey, BufferKey, bool&gt;</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keywordtype\">bool</span> operator()(<span class=\"keyword\">const</span> BufferKey&amp; x, <span class=\"keyword\">const</span> BufferKey&amp; y)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">            </span>{</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">return</span> x.type == y.type &amp;&amp;</div>\n\
<div class=\"line\">                        ArrayBase::KeyEqualTo()(x.arrayKey, y.arrayKey) &amp;&amp;</div>\n\
<div class=\"line\">                        x.dataType == y.dataType &amp;&amp;</div>\n\
<div class=\"line\">                        x.semantic == y.semantic;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        BufferEntry(<span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>\n\
<div class=\"line\">            : fKey(indices),</div>\n\
<div class=\"line\">              fRefCount(0)</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Allocate the index buffer and initialize the contents.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (indices-&gt;numIndices() &gt; 0) {</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (!indices-&gt;array()-&gt;isReadable())</div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// The IndexBuffer has already been converted to a Maya buffer so we can reuse it.  This can</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// happen if the BufferEntry has been deleted but the IndexBuffer that it converted remains</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// and is being reused.  We want to avoid an expensive readback and creation of a duplicate buffer.</span></div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> MayaIndexBufferWrapper* mbufferWrapper = <span class=\"keyword\">dynamic_cast&lt;</span><span class=\"keyword\">const </span>MayaIndexBufferWrapper*<span class=\"keyword\">&gt;</span>(indices-&gt;array().get());</div>\n\
<div class=\"line\">                    assert(mbufferWrapper);</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (mbufferWrapper) {</div>\n\
<div class=\"line\">                        std::shared_ptr&lt;MIndexBuffer&gt; mbuffer = mbufferWrapper-&gt;getMBuffer();</div>\n\
<div class=\"line\">                        assert(mbuffer);</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">if</span> (mbuffer) {</div>\n\
<div class=\"line\">                            fIndexBuffer = mbuffer;</div>\n\
<div class=\"line\">                            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">                        }</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                fIndexBuffer.reset(<span class=\"keyword\">new</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html\">MIndexBuffer</a>(MGeometry::kUnsignedInt32));</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    IndexBuffer::ReadInterfacePtr readable = indices-&gt;readableInterface();</div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> IndexBuffer::index_t* data = readable-&gt;get();</div>\n\
<div class=\"line\">                    fIndexBuffer-&gt;update(data, 0, (<span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span>)indices-&gt;numIndices(), <span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// We want to avoid storing two copies of all the scene geometry.  One copy of the scene</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// goes into the Maya SubSceneOverride interface.  The other copy of the scene stored in</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// ReadableArrays is now mostly redundant.  If we want to load huge scenes close to the limit</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// of our system ram, then we can&#39;t keep the local ReadableArray copy.</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// So after creating the Maya MIndexBuffer, we graft a non-readable version of the Array</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// back into the IndexBuffer.  The readable version that it previously held can then be freed.</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (indices-&gt;array()-&gt;isReadable()) {</div>\n\
<div class=\"line\">                    std::shared_ptr&lt;Array&lt;IndexBuffer::index_t&gt; &gt; mayaArray = MayaIndexBufferWrapper::create(fIndexBuffer, indices-&gt;array()-&gt;digest());</div>\n\
<div class=\"line\">                    indices-&gt;ReplaceArrayInstance(mayaArray);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        BufferEntry(<span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>\n\
<div class=\"line\">            : fKey(vertices),</div>\n\
<div class=\"line\">              fRefCount(0)</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Allocate the vertex buffer and initialize the contents.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (vertices-&gt;numVerts() &gt; 0) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// FIXME: Assumes 32-bit float data.</span></div>\n\
<div class=\"line\">                assert(fKey.dataType == MGeometry::kFloat);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"keywordtype\">bool</span> allowReplaceBufferArray = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (!vertices-&gt;array()-&gt;isReadable())</div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// The VertexBuffer has already been converted to a Maya buffer.  We can reuse it if the</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// semantic matches.  This can happen if the BufferEntry has been deleted but the VertexBuffer</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// that it converted remains and is being reused.  We want to avoid an expensive readback and</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// creation of a duplicate buffer.</span></div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> MayaVertexBufferWrapper* mbufferWrapper = <span class=\"keyword\">dynamic_cast&lt;</span><span class=\"keyword\">const </span>MayaVertexBufferWrapper*<span class=\"keyword\">&gt;</span>(vertices-&gt;array().get());</div>\n\
<div class=\"line\">                    assert(mbufferWrapper);</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (mbufferWrapper) {</div>\n\
<div class=\"line\">                        std::shared_ptr&lt;MVertexBuffer&gt; mbuffer = mbufferWrapper-&gt;getMBuffer();</div>\n\
<div class=\"line\">                        assert(mbuffer);</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">if</span> (mbuffer) {</div>\n\
<div class=\"line\">                            <span class=\"keywordflow\">if</span> (mbuffer-&gt;descriptor().semantic() == vertices-&gt;descriptor().semantic()) {</div>\n\
<div class=\"line\">                                <span class=\"comment\">// The semantic matches.  Simply reuse the buffer and we are finished.</span></div>\n\
<div class=\"line\">                                fVertexBuffer = mbuffer;</div>\n\
<div class=\"line\">                                <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                            } <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                                <span class=\"comment\">// The semantic doesn&#39;t match, so we can&#39;t reuse the buffer.  An example is a normal</span></div>\n\
<div class=\"line\">                                <span class=\"comment\">// and position buffer that happen to match their contents.  The unique key rules mean</span></div>\n\
<div class=\"line\">                                <span class=\"comment\">// that we can&#39;t make a duplicate MayaVertexBufferWrapper, so make a new MBuffer backed</span></div>\n\
<div class=\"line\">                                <span class=\"comment\">// by a plain software buffer.  Graft the software buffer back into the VertexBuffer so</span></div>\n\
<div class=\"line\">                                <span class=\"comment\">// that we store both.</span></div>\n\
<div class=\"line\">                                std::shared_ptr&lt;Array&lt;float&gt; &gt; softwareArray = vertices-&gt;array()-&gt;getReadableArray();</div>\n\
<div class=\"line\">                                vertices-&gt;ReplaceArrayInstance(softwareArray);</div>\n\
<div class=\"line\">                                allowReplaceBufferArray = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">                                <span class=\"comment\">// Now proceed with normal MBuffer creation, but skip the final step of converting the</span></div>\n\
<div class=\"line\">                                <span class=\"comment\">// VertexBuffer back.</span></div>\n\
<div class=\"line\">                            }</div>\n\
<div class=\"line\">                        }</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                fVertexBuffer.reset(<span class=\"keyword\">new</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html\">MVertexBuffer</a>(vertices-&gt;descriptor()));</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    VertexBuffer::ReadInterfacePtr readable = vertices-&gt;readableInterface();</div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span>* data = readable-&gt;get();</div>\n\
<div class=\"line\">                    fVertexBuffer-&gt;update(data, 0, (<span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span>)vertices-&gt;numVerts(), <span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                </div>\n\
<div class=\"line\">                <span class=\"comment\">// We want to avoid storing two copies of all the scene geometry.  One copy of the scene</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// goes into the Maya SubSceneOverride interface.  The other copy of the scene stored in</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// ReadableArrays is now mostly redundant.  If we want to load huge scenes close to the limit</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// of our system ram, then we can&#39;t keep the local ReadableArray copy.</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// So after creating the Maya MVertexBuffer, we graft a non-readable version of the Array</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// back into the VertexBuffer.  The readable version that it previously held can then be freed.</span></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (allowReplaceBufferArray &amp;&amp; vertices-&gt;array()-&gt;isReadable()) {</div>\n\
<div class=\"line\">                    std::shared_ptr&lt;Array&lt;float&gt; &gt; mayaArray = MayaVertexBufferWrapper::create(fVertexBuffer, vertices-&gt;array()-&gt;digest());</div>\n\
<div class=\"line\">                    vertices-&gt;ReplaceArrayInstance(mayaArray);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// The unique key of this buffer.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> BufferKey&amp;      key()<span class=\"keyword\"> const      </span>{ <span class=\"keywordflow\">return</span> fKey; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// The array key of this buffer. (without type and semantic)</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> ArrayBase::Key&amp; arrayKey()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fKey.arrayKey; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// The size of this buffer.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> bytes()<span class=\"keyword\"> const    </span>{ <span class=\"keywordflow\">return</span> fKey.arrayKey.fBytes; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Get the index buffer pointer.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">void</span> getBuffer(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html\">MIndexBuffer</a>*&amp; buffer)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">        </span>{</div>\n\
<div class=\"line\">            assert(fIndexBuffer);</div>\n\
<div class=\"line\">            buffer = fIndexBuffer.get();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Get the vertex buffer pointer.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">void</span> getBuffer(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html\">MVertexBuffer</a>*&amp; buffer)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">        </span>{</div>\n\
<div class=\"line\">            assert(fVertexBuffer);</div>\n\
<div class=\"line\">            buffer = fVertexBuffer.get();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">void</span>   ref()<span class=\"keyword\"> const      </span>{ fRefCount++; }</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">void</span>   unref()<span class=\"keyword\"> const    </span>{ fRefCount--; }</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> refCount()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fRefCount; }</div>\n\
<div class=\"line\">        </div>\n\
<div class=\"line\">    <span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">        BufferKey                           fKey;</div>\n\
<div class=\"line\">        std::shared_ptr&lt;MIndexBuffer&gt;     fIndexBuffer;</div>\n\
<div class=\"line\">        std::shared_ptr&lt;MVertexBuffer&gt;    fVertexBuffer;</div>\n\
<div class=\"line\">        <span class=\"keyword\">mutable</span> <span class=\"keywordtype\">size_t</span>                      fRefCount;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> boost::multi_index_container&lt;</div>\n\
<div class=\"line\">        BufferEntry,</div>\n\
<div class=\"line\">        boost::multi_index::indexed_by&lt;</div>\n\
<div class=\"line\">            <span class=\"comment\">// Index 0: The unique index for each Viewport 2.0 buffer.</span></div>\n\
<div class=\"line\">            boost::multi_index::hashed_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_CONST_MEM_FUN(BufferEntry,<span class=\"keyword\">const</span> BufferEntry::BufferKey&amp;,key),</div>\n\
<div class=\"line\">                BufferEntry::BufferKeyHash,</div>\n\
<div class=\"line\">                BufferEntry::BufferKeyEqualTo</div>\n\
<div class=\"line\">            &gt;,</div>\n\
<div class=\"line\">            <span class=\"comment\">// Index 1: The index for each array murmur3 key.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">//          Note: The same key might be used for different semantic.</span></div>\n\
<div class=\"line\">            boost::multi_index::hashed_non_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_CONST_MEM_FUN(BufferEntry,<span class=\"keyword\">const</span> ArrayBase::Key&amp;,arrayKey),</div>\n\
<div class=\"line\">                ArrayBase::KeyHash,</div>\n\
<div class=\"line\">                ArrayBase::KeyEqualTo</div>\n\
<div class=\"line\">            &gt;</div>\n\
<div class=\"line\">        &gt;</div>\n\
<div class=\"line\">    &gt; BufferSet;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> std::unordered_set&lt;</div>\n\
<div class=\"line\">        ArrayBase::Key,</div>\n\
<div class=\"line\">        ArrayBase::KeyHash,</div>\n\
<div class=\"line\">        ArrayBase::KeyEqualTo</div>\n\
<div class=\"line\">    &gt; KeySet;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">size_t</span>          fTotalBufferSize;</div>\n\
<div class=\"line\">    BufferSet       fActiveBuffers;</div>\n\
<div class=\"line\">    BufferSet       fFreeBuffers;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    tbb::mutex      fBuffersToDeleteMutex;</div>\n\
<div class=\"line\">    KeySet          fBuffersToDelete;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// The user data is attached on bounding box place holder render items.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// When the bounding box place holder is drawn, a post draw callback is</span></div>\n\
<div class=\"line\"><span class=\"comment\">// triggered to hint the shape should be read in priority.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubNodeUserData : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    SubNodeUserData(<span class=\"keyword\">const</span> SubNode&amp; subNode)</div>\n\
<div class=\"line\">        : fSubNode(subNode)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">virtual</span> ~SubNodeUserData()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> hintShapeReadOrder()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Hint the shape read order.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// The shape will be loaded in priority.</span></div>\n\
<div class=\"line\">        GlobalReaderCache::theCache().hintShapeReadOrder(fSubNode);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> SubNode&amp; fSubNode;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// The deletion order of MRenderItem and MPxSubSceneOverride is not consistent.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// We let Maya/VP2 delete the delegate and decrease the reference counter.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubNodeUserDataDelegate : <span class=\"keyword\">public</span> <a name=\"_a12\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_user_data.html\">MUserData</a></div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    SubNodeUserDataDelegate(<span class=\"keyword\">const</span> std::shared_ptr&lt;SubNodeUserData&gt;&amp; userData)</div>\n\
<div class=\"line\">        : <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_user_data.html\">MUserData</a>(true <span class=\"comment\">/*deleteAfterUse*/</span>),</div>\n\
<div class=\"line\">          fUserData(userData)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~SubNodeUserDataDelegate()<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> hintShapeReadOrder()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fUserData)</div>\n\
<div class=\"line\">            fUserData-&gt;hintShapeReadOrder();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    std::shared_ptr&lt;SubNodeUserData&gt;  fUserData;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// For GPUCache OGS draw, make sure the pattern has its first bit == 1</span></div>\n\
<div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keywordtype\">void</span> SetDashLinePattern(<a name=\"_a13\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader, <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">short</span> pattern)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> sDashPattern = <span class=\"stringliteral\">&quot;dashPattern&quot;</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">short</span> newPattern = pattern;</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (newPattern != 0) {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">while</span> ((newPattern &amp; 0x8000) == 0) {</div>\n\
<div class=\"line\">            newPattern &lt;&lt;= 1;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    shader-&gt;<a name=\"a14\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef\">setParameter</a>(sDashPattern, newPattern);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> BoundingBoxPlaceHolderDrawCallback(<a name=\"_a15\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html\">MDrawContext</a>&amp; context,</div>\n\
<div class=\"line\">                                        <span class=\"keyword\">const</span> <a name=\"_a16\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html\">MRenderItemList</a>&amp; renderItemList,</div>\n\
<div class=\"line\">                                        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">int</span> numRenderItems = renderItemList.<a name=\"a17\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a57b988236ee6a3a5e572d126d3fbccc1\">length</a>();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">int</span> i = 0; i &lt; numRenderItems; i++) {</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html\">MRenderItem</a>* renderItem = renderItemList.<a name=\"a18\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0\">itemAt</a>(i);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (renderItem) {</div>\n\
<div class=\"line\">            SubNodeUserDataDelegate* userData =</div>\n\
<div class=\"line\">                <span class=\"keyword\">dynamic_cast&lt;</span>SubNodeUserDataDelegate*<span class=\"keyword\">&gt;</span>(renderItem-&gt;<a name=\"a19\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#afd8b782f19e9508747c851a990d8f5db\">customData</a>());</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (userData) {</div>\n\
<div class=\"line\">                userData-&gt;hintShapeReadOrder();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> WireframePreDrawCallback(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html\">MDrawContext</a>&amp; context,</div>\n\
<div class=\"line\">                              <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html\">MRenderItemList</a>&amp; renderItemList,</div>\n\
<div class=\"line\">                              <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Wireframe on Shaded: Full / Reduced / None</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> DisplayPref::WireframeOnShadedMode wireOnShadedMode =</div>\n\
<div class=\"line\">        DisplayPref::wireframeOnShadedMode();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Early out if we are not drawing Reduced/None wireframe.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (wireOnShadedMode == DisplayPref::kWireframeOnShadedFull) {</div>\n\
<div class=\"line\">        assert(0);  <span class=\"comment\">// Only Reduced/None mode has callbacks.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Wireframe on shaded.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> displayStyle = context.<a name=\"a20\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#acd5ce60bbd3d03181b1ad681023ff44d\">getDisplayStyle</a>();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (displayStyle &amp; (MDrawContext::kGouraudShaded | MDrawContext::kTextured)) {</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">short</span> pattern =</div>\n\
<div class=\"line\">            (wireOnShadedMode == DisplayPref::kWireframeOnShadedReduced)</div>\n\
<div class=\"line\">            ? Config::kLineStippleDotted  <span class=\"comment\">// Reduce: dotted line</span></div>\n\
<div class=\"line\">            : 0;                          <span class=\"comment\">// None: no wire</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> sDashPattern = <span class=\"stringliteral\">&quot;dashPattern&quot;</span>;        </div>\n\
<div class=\"line\">        SetDashLinePattern(shader, pattern);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> WireframePostDrawCallback(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html\">MDrawContext</a>&amp; context,</div>\n\
<div class=\"line\">                               <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html\">MRenderItemList</a>&amp; renderItemList,</div>\n\
<div class=\"line\">                               <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Wireframe on Shaded: Full / Reduced / None</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> DisplayPref::WireframeOnShadedMode wireOnShadedMode =</div>\n\
<div class=\"line\">        DisplayPref::wireframeOnShadedMode();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Early out if we are not drawing reduced wireframe.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (wireOnShadedMode == DisplayPref::kWireframeOnShadedFull) {</div>\n\
<div class=\"line\">        assert(0);  <span class=\"comment\">// Only Reduced/None mode has callbacks.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Restore the default pattern.</span></div>\n\
<div class=\"line\">    SetDashLinePattern(shader, Config::kLineStippleShortDashed);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* getPointShaderInstance()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <a name=\"_a21\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html\">MRenderer</a>* renderer = MRenderer::theRenderer();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!renderer) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a name=\"_a22\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html\">MShaderManager</a>* shaderMgr = renderer-&gt;<a name=\"a23\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125\">getShaderManager</a>();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!shaderMgr) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> shaderMgr-&gt;<a name=\"a24\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a8e4ad27d691969622af2b05d8c6213d9\">getStockShader</a>(MShaderManager::k3dFatPointShader);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* getWireShaderInstance()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html\">MRenderer</a>* renderer = MRenderer::theRenderer();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!renderer) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html\">MShaderManager</a>* shaderMgr = renderer-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125\">getShaderManager</a>();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!shaderMgr) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> shaderMgr-&gt;<a name=\"a25\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44\">getFragmentShader</a>(<span class=\"stringliteral\">&quot;mayaDashLineShader&quot;</span>, <span class=\"stringliteral\">&quot;&quot;</span>, <span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* getWireShaderInstanceWithCB()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html\">MRenderer</a>* renderer = MRenderer::theRenderer();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!renderer) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html\">MShaderManager</a>* shaderMgr = renderer-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125\">getShaderManager</a>();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!shaderMgr) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> shaderMgr-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44\">getFragmentShader</a>(<span class=\"stringliteral\">&quot;mayaDashLineShader&quot;</span>, <span class=\"stringliteral\">&quot;&quot;</span>, <span class=\"keyword\">false</span>,</div>\n\
<div class=\"line\">        WireframePreDrawCallback, WireframePostDrawCallback);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* getBoundingBoxPlaceHolderShaderInstance()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html\">MRenderer</a>* renderer = MRenderer::theRenderer();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!renderer) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html\">MShaderManager</a>* shaderMgr = renderer-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125\">getShaderManager</a>();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!shaderMgr) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> shaderMgr-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44\">getFragmentShader</a>(<span class=\"stringliteral\">&quot;mayaDashLineShader&quot;</span>, <span class=\"stringliteral\">&quot;&quot;</span>, <span class=\"keyword\">false</span>,</div>\n\
<div class=\"line\">        NULL, BoundingBoxPlaceHolderDrawCallback);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* getDiffuseColorShaderInstance()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html\">MRenderer</a>* renderer = MRenderer::theRenderer();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!renderer) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html\">MShaderManager</a>* shaderMgr = renderer-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125\">getShaderManager</a>();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!shaderMgr) <span class=\"keywordflow\">return</span> NULL;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> shaderMgr-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44\">getFragmentShader</a>(<span class=\"stringliteral\">&quot;mayaLambertSurface&quot;</span>, <span class=\"stringliteral\">&quot;outSurfaceFinal&quot;</span>, <span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> releaseShaderInstance(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*&amp; shader)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html\">MRenderer</a>* renderer = MRenderer::theRenderer();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!renderer) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html\">MShaderManager</a>* shaderMgr = renderer-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125\">getShaderManager</a>();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!shaderMgr) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">        shaderMgr-&gt;<a name=\"a26\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a0c7deb55edc231cbb2365b271ecd55f8\">releaseShader</a>(shader);</div>\n\
<div class=\"line\">        shader = NULL;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> setDiffuseColor(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader, <span class=\"keyword\">const</span> <a name=\"_a27\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp; diffuseColor)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Color</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> color[3] = {diffuseColor.<a name=\"a28\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, diffuseColor.<a name=\"a29\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, diffuseColor.<a name=\"a30\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>};</div>\n\
<div class=\"line\">        shader-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef\">setParameter</a>(<span class=\"stringliteral\">&quot;color&quot;</span>, color);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Transparency</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (diffuseColor.<a name=\"a31\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e\">a</a> &lt; 1.0f) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> oneMinusAlpha =</div>\n\
<div class=\"line\">                (diffuseColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e\">a</a> &gt;= 0.0f) ? 1.0f - diffuseColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e\">a</a> : 1.0f;</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> transparency[3] = {oneMinusAlpha, oneMinusAlpha, oneMinusAlpha};</div>\n\
<div class=\"line\">            shader-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef\">setParameter</a>(<span class=\"stringliteral\">&quot;transparency&quot;</span>, transparency);</div>\n\
<div class=\"line\">            shader-&gt;<a name=\"a32\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a6b65d9b284fc376f7f3458b36c29d8a0\">setIsTransparent</a>(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">            shader-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a6b65d9b284fc376f7f3458b36c29d8a0\">setIsTransparent</a>(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Diffuse</span></div>\n\
<div class=\"line\">        shader-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef\">setParameter</a>(<span class=\"stringliteral\">&quot;diffuse&quot;</span>, 1.0f);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">bool</span> useHardwareInstancing()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// hardwareRenderingGlobals is a default node so we assume</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// that it will never be deleted.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> <a name=\"_a33\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_plug.html\">MPlug</a> sHwInstancingPlug;</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (sHwInstancingPlug.<a name=\"a34\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9\">isNull</a>()) {</div>\n\
<div class=\"line\">        <a name=\"_a35\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_list.html\">MSelectionList</a> sl;</div>\n\
<div class=\"line\">        sl.<a name=\"a36\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_list.html#a23929aeafb29672f2652128eac9c4dec\">add</a>(<span class=\"stringliteral\">&quot;hardwareRenderingGlobals.hwInstancing&quot;</span>);</div>\n\
<div class=\"line\">        <a name=\"_a37\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_status.html\">MStatus</a> stat = sl.<a name=\"a38\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_list.html#a4cdb668fdd6feafe9b296a80cfca26f0\">getPlug</a>(0, sHwInstancingPlug);</div>\n\
<div class=\"line\">        MStatAssert(stat);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> sHwInstancingPlug.<a name=\"a39\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_plug.html#a69b4092a85b4edf58b7d50f331cc38cf\">asBool</a>() &amp;&amp; Config::useHardwareInstancing();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS ShaderInstancePtr</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class wraps a MShaderInstance* and its template shader.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>ShaderInstancePtr</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"comment\">// Invalid shader instance.</span></div>\n\
<div class=\"line\">    ShaderInstancePtr()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Wraps a MShaderInstance* and its template MShaderInstance*.</span></div>\n\
<div class=\"line\">    ShaderInstancePtr(std::shared_ptr&lt;MShaderInstance&gt; shader,</div>\n\
<div class=\"line\">                      std::shared_ptr&lt;MShaderInstance&gt; source)</div>\n\
<div class=\"line\">        : fShader(shader), fTemplate(source)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~ShaderInstancePtr()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">operator</span> bool ()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fShader &amp;&amp; fTemplate;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* operator-&gt;()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        assert(fShader);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fShader.get();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* <span class=\"keyword\">get</span>() <span class=\"keyword\">const</span></div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(fShader);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fShader.get();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::shared_ptr&lt;MShaderInstance&gt; getShader()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        assert(fShader);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fShader;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::shared_ptr&lt;MShaderInstance&gt; getTemplate()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        assert(fTemplate);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fTemplate;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> reset()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fShader.reset();</div>\n\
<div class=\"line\">        fTemplate.reset();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> operator==(<span class=\"keyword\">const</span> ShaderInstancePtr&amp; rv)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fShader == rv.fShader &amp;&amp; fTemplate == rv.fTemplate;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> operator!=(<span class=\"keyword\">const</span> ShaderInstancePtr&amp; rv)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> !(operator==(rv));</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    std::shared_ptr&lt;MShaderInstance&gt; fShader;</div>\n\
<div class=\"line\">    std::shared_ptr&lt;MShaderInstance&gt; fTemplate;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS ShaderTemplatePtr</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class wraps a MShaderInstance* as a template.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>ShaderTemplatePtr</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"comment\">// Invalid shader template.</span></div>\n\
<div class=\"line\">    ShaderTemplatePtr()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Wrap a shader instance to be used as a template.</span></div>\n\
<div class=\"line\">    ShaderTemplatePtr(std::shared_ptr&lt;MShaderInstance&gt; source)</div>\n\
<div class=\"line\">        : fTemplate(source)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~ShaderTemplatePtr()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">operator</span> bool ()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> (fTemplate.get() != NULL);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* <span class=\"keyword\">get</span>() <span class=\"keyword\">const</span></div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(fTemplate);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fTemplate.get();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::shared_ptr&lt;MShaderInstance&gt; getTemplate()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        assert(fTemplate);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fTemplate;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> void (*Deleter)(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*);</div>\n\
<div class=\"line\">    ShaderInstancePtr newShaderInstance(Deleter deleter)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        assert(fTemplate);</div>\n\
<div class=\"line\">        std::shared_ptr&lt;MShaderInstance&gt; newShader;</div>\n\
<div class=\"line\">        newShader.reset(fTemplate-&gt;clone(), std::ptr_fun(deleter));</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr(newShader, fTemplate);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    std::shared_ptr&lt;MShaderInstance&gt; fTemplate;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS ShaderCache</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class manages the shader templates. A shader template can be used to create</span></div>\n\
<div class=\"line\"><span class=\"comment\">// shader instances with different parameters.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>ShaderCache : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> ShaderCache&amp; getInstance()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Singleton</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">static</span> ShaderCache sSingleton;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> sSingleton;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> void (*Deleter)(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr newPointShader(Deleter deleter)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for a cached shader.</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> key = <span class=\"stringliteral\">&quot;_reserved_point_shader_&quot;</span>;</div>\n\
<div class=\"line\">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fFragmentCache.get&lt;0&gt;().find(key);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(templateShader);  <span class=\"comment\">// no staled pointer</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new shader.</span></div>\n\
<div class=\"line\">        ShaderTemplatePtr templateShader =</div>\n\
<div class=\"line\">            wrapShaderTemplate(getPointShaderInstance());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (templateShader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            FragmentAndShaderTemplate entry;</div>\n\
<div class=\"line\">            entry.fragmentAndOutput = key;</div>\n\
<div class=\"line\">            entry.shader            = templateShader.get();</div>\n\
<div class=\"line\">            entry.ptr               = templateShader.getTemplate();</div>\n\
<div class=\"line\">            fFragmentCache.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr newWireShader(Deleter deleter)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for a cached shader.</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> key = <span class=\"stringliteral\">&quot;_reserved_wire_shader_&quot;</span>;</div>\n\
<div class=\"line\">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fFragmentCache.get&lt;0&gt;().find(key);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(templateShader);  <span class=\"comment\">// no staled pointer</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new shader.</span></div>\n\
<div class=\"line\">        ShaderTemplatePtr templateShader =</div>\n\
<div class=\"line\">            wrapShaderTemplate(getWireShaderInstance());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (templateShader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            FragmentAndShaderTemplate entry;</div>\n\
<div class=\"line\">            entry.fragmentAndOutput = key;</div>\n\
<div class=\"line\">            entry.shader            = templateShader.get();</div>\n\
<div class=\"line\">            entry.ptr               = templateShader.getTemplate();</div>\n\
<div class=\"line\">            fFragmentCache.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr newWireShaderWithCB(Deleter deleter)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for a cached shader.</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> key = <span class=\"stringliteral\">&quot;_reserved_wire_shader_with_cb_&quot;</span>;</div>\n\
<div class=\"line\">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fFragmentCache.get&lt;0&gt;().find(key);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(templateShader);  <span class=\"comment\">// no staled pointer</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new shader.</span></div>\n\
<div class=\"line\">        ShaderTemplatePtr templateShader =</div>\n\
<div class=\"line\">            wrapShaderTemplate(getWireShaderInstanceWithCB());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (templateShader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            FragmentAndShaderTemplate entry;</div>\n\
<div class=\"line\">            entry.fragmentAndOutput = key;</div>\n\
<div class=\"line\">            entry.shader            = templateShader.get();</div>\n\
<div class=\"line\">            entry.ptr               = templateShader.getTemplate();</div>\n\
<div class=\"line\">            fFragmentCache.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr newBoundingBoxPlaceHolderShader(Deleter deleter)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for a cached shader.</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> key = <span class=\"stringliteral\">&quot;_reserved_bounding_box_place_holder_shader_&quot;</span>;</div>\n\
<div class=\"line\">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fFragmentCache.get&lt;0&gt;().find(key);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(templateShader);  <span class=\"comment\">// no staled pointer</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new shader.</span></div>\n\
<div class=\"line\">        ShaderTemplatePtr templateShader =</div>\n\
<div class=\"line\">            wrapShaderTemplate(getBoundingBoxPlaceHolderShaderInstance());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (templateShader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            FragmentAndShaderTemplate entry;</div>\n\
<div class=\"line\">            entry.fragmentAndOutput = key;</div>\n\
<div class=\"line\">            entry.shader            = templateShader.get();</div>\n\
<div class=\"line\">            entry.ptr               = templateShader.getTemplate();</div>\n\
<div class=\"line\">            fFragmentCache.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr newDiffuseColorShader(Deleter deleter)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for a cached shader.</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> key = <span class=\"stringliteral\">&quot;_reserved_diffuse_color_shader_&quot;</span>;</div>\n\
<div class=\"line\">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fFragmentCache.get&lt;0&gt;().find(key);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(templateShader);  <span class=\"comment\">// no staled pointer</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new shader.</span></div>\n\
<div class=\"line\">        ShaderTemplatePtr templateShader =</div>\n\
<div class=\"line\">            wrapShaderTemplate(getDiffuseColorShaderInstance());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (templateShader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            FragmentAndShaderTemplate entry;</div>\n\
<div class=\"line\">            entry.fragmentAndOutput = key;</div>\n\
<div class=\"line\">            entry.shader            = templateShader.get();</div>\n\
<div class=\"line\">            entry.ptr               = templateShader.getTemplate();</div>\n\
<div class=\"line\">            fFragmentCache.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr newFragmentShader(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp; fragmentName,</div>\n\
<div class=\"line\">                                        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp; outputStructName,</div>\n\
<div class=\"line\">                                        Deleter        deleter)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for a cached shader.</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> key = fragmentName + <span class=\"stringliteral\">&quot;:&quot;</span> + outputStructName;</div>\n\
<div class=\"line\">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fFragmentCache.get&lt;0&gt;().find(key);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(templateShader);  <span class=\"comment\">// no staled pointer</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new shader.</span></div>\n\
<div class=\"line\">        ShaderTemplatePtr templateShader =</div>\n\
<div class=\"line\">            createFragmentShader(fragmentName, outputStructName);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (templateShader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            FragmentAndShaderTemplate entry;</div>\n\
<div class=\"line\">            entry.fragmentAndOutput = key;</div>\n\
<div class=\"line\">            entry.shader            = templateShader.get();</div>\n\
<div class=\"line\">            entry.ptr               = templateShader.getTemplate();</div>\n\
<div class=\"line\">            fFragmentCache.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> templateShader.newShaderInstance(deleter);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    ShaderCache()  {}</div>\n\
<div class=\"line\">    ~ShaderCache() {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Release the MShaderInstance and remove the pointer from the cache.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keywordtype\">void</span> shaderTemplateDeleter(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(shader);</div>\n\
<div class=\"line\">        getInstance().removeShaderTemplateFromCache(shader);</div>\n\
<div class=\"line\">        releaseShaderInstance(shader);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Remove the pointer from the cache.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> removeShaderTemplateFromCache(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(shader);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!shader) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Remove the MShaderInstance* from the cache.</span></div>\n\
<div class=\"line\">        fFragmentCache.get&lt;1&gt;().erase(shader);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Wrap the MShaderInstance* as template.</span></div>\n\
<div class=\"line\">    ShaderTemplatePtr wrapShaderTemplate(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(shader);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!shader) <span class=\"keywordflow\">return</span> ShaderTemplatePtr();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        std::shared_ptr&lt;MShaderInstance&gt; ptr;</div>\n\
<div class=\"line\">        ptr.reset(shader, std::ptr_fun(shaderTemplateDeleter));</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderTemplatePtr(ptr);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Create a shader template from a Maya fragment.</span></div>\n\
<div class=\"line\">    ShaderTemplatePtr createFragmentShader(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp; fragmentName,</div>\n\
<div class=\"line\">                                           <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp; outputStructName)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html\">MRenderer</a>* renderer = MRenderer::theRenderer();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!renderer) <span class=\"keywordflow\">return</span> ShaderTemplatePtr();</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html\">MShaderManager</a>* shaderMgr = renderer-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125\">getShaderManager</a>();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!shaderMgr) <span class=\"keywordflow\">return</span> ShaderTemplatePtr();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> wrapShaderTemplate(</div>\n\
<div class=\"line\">            shaderMgr-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44\">getFragmentShader</a>(fragmentName, outputStructName, <span class=\"keyword\">true</span>));</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">struct </span>FragmentAndShaderTemplate {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>                          fragmentAndOutput;</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*                 shader;</div>\n\
<div class=\"line\">        std::weak_ptr&lt;MShaderInstance&gt; ptr;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> boost::multi_index_container&lt;</div>\n\
<div class=\"line\">        FragmentAndShaderTemplate,</div>\n\
<div class=\"line\">        boost::multi_index::indexed_by&lt;</div>\n\
<div class=\"line\">            boost::multi_index::hashed_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_MEMBER(FragmentAndShaderTemplate,<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>,fragmentAndOutput),</div>\n\
<div class=\"line\">                MStringHash</div>\n\
<div class=\"line\">            &gt;,</div>\n\
<div class=\"line\">            boost::multi_index::hashed_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_MEMBER(FragmentAndShaderTemplate,<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*,shader)</div>\n\
<div class=\"line\">            &gt;</div>\n\
<div class=\"line\">        &gt;</div>\n\
<div class=\"line\">    &gt; FragmentAndShaderTemplateCache;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    FragmentAndShaderTemplateCache  fFragmentCache;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS MaterialGraphTranslatorShaded</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class translates a MaterialGraph to a MShaderInstance*</span></div>\n\
<div class=\"line\"><span class=\"comment\">// that can be used in VP2.0.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>MaterialGraphTranslatorShaded : <span class=\"keyword\">public</span> ConcreteMaterialNodeVisitor</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"comment\">// Create a new shader instance.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> void (*Deleter)(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*);</div>\n\
<div class=\"line\">    MaterialGraphTranslatorShaded(Deleter deleter, <span class=\"keywordtype\">double</span> timeInSeconds)</div>\n\
<div class=\"line\">        : fShader(), fDeleter(deleter), fTimeInSeconds(timeInSeconds)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update an existing shader instance.</span></div>\n\
<div class=\"line\">    MaterialGraphTranslatorShaded(ShaderInstancePtr&amp; shader, <span class=\"keywordtype\">double</span> timeInSeconds)</div>\n\
<div class=\"line\">        : fShader(shader), fDeleter(NULL), fTimeInSeconds(timeInSeconds)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~MaterialGraphTranslatorShaded()<span class=\"keyword\"> override </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr getShader()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{ <span class=\"keywordflow\">return</span> fShader; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> LambertMaterial&amp; node)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fShader) {</div>\n\
<div class=\"line\">            createShader(<span class=\"stringliteral\">&quot;mayaLambertSurface&quot;</span>, <span class=\"stringliteral\">&quot;outSurfaceFinal&quot;</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        setupLambert(node);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> PhongMaterial&amp; node)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fShader) {</div>\n\
<div class=\"line\">            createShader(<span class=\"stringliteral\">&quot;mayaPhongSurface&quot;</span>, <span class=\"stringliteral\">&quot;outSurfaceFinal&quot;</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        setupPhong(node);</div>\n\
<div class=\"line\">        setupLambert(node);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> BlinnMaterial&amp; node)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fShader) {</div>\n\
<div class=\"line\">            createShader(<span class=\"stringliteral\">&quot;mayaBlinnSurface&quot;</span>, <span class=\"stringliteral\">&quot;outSurfaceFinal&quot;</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        setupBlinn(node);</div>\n\
<div class=\"line\">        setupLambert(node);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Nodes that can&#39;t be used as root material node.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> SurfaceMaterial&amp; node)<span class=\"keyword\"> override </span>{}</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> Texture2d&amp; node)<span class=\"keyword\"> override </span>{}</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> FileTexture&amp; node)<span class=\"keyword\"> override </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> createShader(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp; fragmentName,</div>\n\
<div class=\"line\">                      <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp; structOutputName)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(fDeleter);</div>\n\
<div class=\"line\">        fShader = ShaderCache::getInstance().newFragmentShader(</div>\n\
<div class=\"line\">            fragmentName, structOutputName, fDeleter);</div>\n\
<div class=\"line\">        assert(fShader);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setupLambert(<span class=\"keyword\">const</span> LambertMaterial&amp; lambert)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fShader) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Color</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> color =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateDefaultColor(lambert.Color, fTimeInSeconds);</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> buffer[3] = {color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>};</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;color&quot;</span>, buffer);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Transparency</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> transparency =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateColor(lambert.Transparency, fTimeInSeconds);</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> buffer[3] = {transparency.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, transparency.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, transparency.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>};</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;transparency&quot;</span>, buffer);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (transparency.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a> &gt; 0 || transparency.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a> &gt; 0 || transparency.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a> &gt; 0) {</div>\n\
<div class=\"line\">                fShader-&gt;setIsTransparent(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                fShader-&gt;setIsTransparent(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Ambient Color</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> ambientColor =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateColor(lambert.AmbientColor, fTimeInSeconds);</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> buffer[3] = {ambientColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, ambientColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, ambientColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>};</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;ambientColor&quot;</span>, buffer);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Incandescence</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> incandescence =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateColor(lambert.Incandescence, fTimeInSeconds);</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> buffer[3] = {incandescence.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, incandescence.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, incandescence.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>};</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;incandescence&quot;</span>, buffer);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Diffuse</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> diffuse =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(lambert.Diffuse, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;diffuse&quot;</span>, diffuse);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Translucence</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> translucence =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(lambert.Translucence, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;translucence&quot;</span>, translucence);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Translucence Depth</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> translucenceDepth =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(lambert.TranslucenceDepth, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;translucenceDepth&quot;</span>, translucenceDepth);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Translucence Focus</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> translucenceFocus =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(lambert.TranslucenceFocus, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;translucenceFocus&quot;</span>, translucenceFocus);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Hide Source</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span> hideSource =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateBool(lambert.HideSource, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;hideSource&quot;</span>, hideSource);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Glow Intensity</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> glowIntensity =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(lambert.GlowIntensity, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;glowIntensity&quot;</span>, glowIntensity);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setupPhong(<span class=\"keyword\">const</span> PhongMaterial&amp; phong)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fShader) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Cosine Power</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> cosinePower =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(phong.CosinePower, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;cosinePower&quot;</span>, cosinePower);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Specular Color</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> specularColor =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateColor(phong.SpecularColor, fTimeInSeconds);</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> buffer[3] = {specularColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, specularColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, specularColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>};</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;specularColor&quot;</span>, buffer);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Reflectivity</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> reflectivity =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(phong.Reflectivity, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;reflectivity&quot;</span>, reflectivity);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Reflected Color</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> reflectedColor =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateColor(phong.ReflectedColor, fTimeInSeconds);</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> buffer[3] = {reflectedColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, reflectedColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, reflectedColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>};</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;reflectedColor&quot;</span>, buffer);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setupBlinn(<span class=\"keyword\">const</span> BlinnMaterial&amp; blinn)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fShader) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Eccentricity</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> eccentricity =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(blinn.Eccentricity, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;eccentricity&quot;</span>, eccentricity);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// SpecularRollOff</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> specularRollOff =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(blinn.SpecularRollOff, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;specularRollOff&quot;</span>, specularRollOff);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Specular Color</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> specularColor =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateColor(blinn.SpecularColor, fTimeInSeconds);</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> buffer[3] = {specularColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, specularColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, specularColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>};</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;specularColor&quot;</span>, buffer);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Reflectivity</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> reflectivity =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateFloat(blinn.Reflectivity, fTimeInSeconds);</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;reflectivity&quot;</span>, reflectivity);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Reflected Color</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> reflectedColor =</div>\n\
<div class=\"line\">                ShadedModeColor::evaluateColor(blinn.ReflectedColor, fTimeInSeconds);</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> buffer[3] = {reflectedColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, reflectedColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, reflectedColor.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>};</div>\n\
<div class=\"line\">            fShader-&gt;setParameter(<span class=\"stringliteral\">&quot;reflectedColor&quot;</span>, buffer);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr fShader;</div>\n\
<div class=\"line\">    Deleter           fDeleter;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keywordtype\">double</span>      fTimeInSeconds;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS ShaderInstanceCache</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class manages MShaderInstance across multiple gpuCache nodes.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// The cache returns a shared pointer to the requested MShaderInstance.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// The caller shouldn&#39;t modify the MShaderInstance* that is returned from</span></div>\n\
<div class=\"line\"><span class=\"comment\">// getSharedXXXShader() because the shader instance might be shared</span></div>\n\
<div class=\"line\"><span class=\"comment\">// with other render items.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// The caller is responsible to hold the pointer.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// If the reference counter goes 0, the MShaderInstance is released.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>ShaderInstanceCache : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> ShaderInstanceCache&amp; getInstance()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Singleton</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">static</span> ShaderInstanceCache sSingleton;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> sSingleton;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr getSharedPointShader()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Not visible in view, so color is not relevant:</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> color(1.0, 0.0, 1.0);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for the cached MShaderInstance.</span></div>\n\
<div class=\"line\">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fPointShaders.get&lt;0&gt;().find(color);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fPointShaders.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(shader);  <span class=\"comment\">// no staled pointer.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new MShaderInstance.</span></div>\n\
<div class=\"line\">        ShaderInstancePtr shader =</div>\n\
<div class=\"line\">            ShaderCache::getInstance().newPointShader(shaderInstanceDeleter);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Fat point color.</span></div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> solidColor[4] = {color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>, 1.0f};</div>\n\
<div class=\"line\">            shader-&gt;setParameter(<span class=\"stringliteral\">&quot;solidColor&quot;</span>, solidColor);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            ColorAndShaderInstance entry;</div>\n\
<div class=\"line\">            entry.color  = color;</div>\n\
<div class=\"line\">            entry.shader = shader.get();</div>\n\
<div class=\"line\">            entry.ptr    = shader.getShader();</div>\n\
<div class=\"line\">            entry.source = shader.getTemplate();</div>\n\
<div class=\"line\">            fPointShaders.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> shader;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr getSharedWireShader(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp; color)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for the cached MShaderInstance.</span></div>\n\
<div class=\"line\">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fWireShaders.get&lt;0&gt;().find(color);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fWireShaders.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(shader);  <span class=\"comment\">// no staled pointer.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new MShaderInstance.</span></div>\n\
<div class=\"line\">        ShaderInstancePtr shader =</div>\n\
<div class=\"line\">            ShaderCache::getInstance().newWireShader(shaderInstanceDeleter);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Wireframe dash-line pattern.</span></div>\n\
<div class=\"line\">           SetDashLinePattern(shader.get(), Config::kLineStippleShortDashed);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Wireframe color.</span></div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> solidColor[4] = {color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>, 1.0f};</div>\n\
<div class=\"line\">            shader-&gt;setParameter(<span class=\"stringliteral\">&quot;solidColor&quot;</span>, solidColor);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            ColorAndShaderInstance entry;</div>\n\
<div class=\"line\">            entry.color  = color;</div>\n\
<div class=\"line\">            entry.shader = shader.get();</div>\n\
<div class=\"line\">            entry.ptr    = shader.getShader();</div>\n\
<div class=\"line\">            entry.source = shader.getTemplate();</div>\n\
<div class=\"line\">            fWireShaders.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> shader;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr getSharedWireShaderWithCB(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp; color)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for the cached MShaderInstance.</span></div>\n\
<div class=\"line\">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fWireShadersWithCB.get&lt;0&gt;().find(color);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fWireShadersWithCB.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(shader);  <span class=\"comment\">// no staled pointer.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new MShaderInstance.</span></div>\n\
<div class=\"line\">        ShaderInstancePtr shader =</div>\n\
<div class=\"line\">            ShaderCache::getInstance().newWireShaderWithCB(shaderInstanceDeleter);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Wireframe dash-line pattern.</span></div>\n\
<div class=\"line\">            SetDashLinePattern(shader.get(), Config::kLineStippleShortDashed);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Wireframe color.</span></div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> solidColor[4] = {color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>, 1.0f};</div>\n\
<div class=\"line\">            shader-&gt;setParameter(<span class=\"stringliteral\">&quot;solidColor&quot;</span>, solidColor);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            ColorAndShaderInstance entry;</div>\n\
<div class=\"line\">            entry.color  = color;</div>\n\
<div class=\"line\">            entry.shader = shader.get();</div>\n\
<div class=\"line\">            entry.ptr    = shader.getShader();</div>\n\
<div class=\"line\">            entry.source = shader.getTemplate();</div>\n\
<div class=\"line\">            fWireShadersWithCB.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> shader;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr getSharedBoundingBoxPlaceHolderShader(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp; color)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for the cached MShaderInstance.</span></div>\n\
<div class=\"line\">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fBoundingBoxPlaceHolderShaders.get&lt;0&gt;().find(color);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fBoundingBoxPlaceHolderShaders.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(shader);  <span class=\"comment\">// no staled pointer.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new MShaderInstance.</span></div>\n\
<div class=\"line\">        ShaderInstancePtr shader =</div>\n\
<div class=\"line\">            ShaderCache::getInstance().newBoundingBoxPlaceHolderShader(shaderInstanceDeleter);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Wireframe dash-line pattern.</span></div>\n\
<div class=\"line\">            SetDashLinePattern(shader.get(), Config::kLineStippleShortDashed);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Wireframe color.</span></div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keywordtype\">float</span> solidColor[4] = {color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>, color.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>, 1.0f};</div>\n\
<div class=\"line\">            shader-&gt;setParameter(<span class=\"stringliteral\">&quot;solidColor&quot;</span>, solidColor);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            ColorAndShaderInstance entry;</div>\n\
<div class=\"line\">            entry.color  = color;</div>\n\
<div class=\"line\">            entry.shader = shader.get();</div>\n\
<div class=\"line\">            entry.ptr    = shader.getShader();</div>\n\
<div class=\"line\">            entry.source = shader.getTemplate();</div>\n\
<div class=\"line\">            fBoundingBoxPlaceHolderShaders.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> shader;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr getSharedDiffuseColorShader(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp; color)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for the cached MShaderInstance.</span></div>\n\
<div class=\"line\">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fDiffuseColorShaders.get&lt;0&gt;().find(color);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fDiffuseColorShaders.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(shader);  <span class=\"comment\">// no staled pointer.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new MShaderInstance.</span></div>\n\
<div class=\"line\">        ShaderInstancePtr shader =</div>\n\
<div class=\"line\">            ShaderCache::getInstance().newDiffuseColorShader(shaderInstanceDeleter);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Set the diffuse color.</span></div>\n\
<div class=\"line\">            setDiffuseColor(shader.get(), color);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            ColorAndShaderInstance entry;</div>\n\
<div class=\"line\">            entry.color  = color;</div>\n\
<div class=\"line\">            entry.shader = shader.get();</div>\n\
<div class=\"line\">            entry.ptr    = shader.getShader();</div>\n\
<div class=\"line\">            entry.source = shader.getTemplate();</div>\n\
<div class=\"line\">            fDiffuseColorShaders.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> shader;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Create a unique lambert shader for diffuse color.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// The caller can change the shader parameters for material animation.</span></div>\n\
<div class=\"line\">    ShaderInstancePtr getUniqueDiffuseColorShader(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp; color)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        ShaderInstancePtr shader =</div>\n\
<div class=\"line\">            ShaderCache::getInstance().newDiffuseColorShader(shaderInstanceDeleter);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Set the diffuse color.</span></div>\n\
<div class=\"line\">            setDiffuseColor(shader.get(), color);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> shader;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This method will get a cached MShaderInstance for the given material.</span></div>\n\
<div class=\"line\">    ShaderInstancePtr getSharedShadedMaterialShader(</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> MaterialGraph::Ptr&amp; material,</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">double</span>                    timeInSeconds</div>\n\
<div class=\"line\">    )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(material);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!material) <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Look for the cached MShaderInstance.</span></div>\n\
<div class=\"line\">        MaterialAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>\n\
<div class=\"line\">            fShadedMaterialShaders.get&lt;0&gt;().find(material);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Found in cache.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it != fShadedMaterialShaders.get&lt;0&gt;().end()) {</div>\n\
<div class=\"line\">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>\n\
<div class=\"line\">            assert(shader);  <span class=\"comment\">// no staled pointer.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Not found. Get a new MShaderInstance.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> MaterialNode::Ptr&amp; rootNode = material-&gt;rootNode();</div>\n\
<div class=\"line\">        assert(rootNode);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        ShaderInstancePtr shader;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (rootNode) {</div>\n\
<div class=\"line\">            MaterialGraphTranslatorShaded shadedTranslator(shaderInstanceDeleter, timeInSeconds);</div>\n\
<div class=\"line\">            rootNode-&gt;accept(shadedTranslator);</div>\n\
<div class=\"line\">            shader = shadedTranslator.getShader();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Insert into cache.</span></div>\n\
<div class=\"line\">            MaterialAndShaderInstance entry;</div>\n\
<div class=\"line\">            entry.material      = material;</div>\n\
<div class=\"line\">            entry.shader        = shader.get();</div>\n\
<div class=\"line\">            entry.ptr           = shader.getShader();</div>\n\
<div class=\"line\">            entry.source        = shader.getTemplate();</div>\n\
<div class=\"line\">            entry.isAnimated    = material-&gt;isAnimated();</div>\n\
<div class=\"line\">            entry.timeInSeconds = timeInSeconds;</div>\n\
<div class=\"line\">            fShadedMaterialShaders.insert(entry);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> shader;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> ShaderInstancePtr();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateCachedShadedShaders(<span class=\"keywordtype\">double</span> timeInSeconds)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Update all cached MShaderInstance* for shaded mode to the current time.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> MaterialAndShaderInstance&amp; entry : fShadedMaterialShaders) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Not animated. Skipping.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (!entry.isAnimated) <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Already up-to-date. Skipping.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (entry.timeInSeconds == timeInSeconds) <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Update the MShaderInstance*</span></div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> MaterialNode::Ptr&amp; rootNode = entry.material-&gt;rootNode();</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (rootNode) {</div>\n\
<div class=\"line\">                ShaderInstancePtr shader(entry.ptr.lock(), entry.source);</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">                    MaterialGraphTranslatorShaded shadedTranslator(shader, timeInSeconds);</div>\n\
<div class=\"line\">                    rootNode-&gt;accept(shadedTranslator);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Remember the last update time.</span></div>\n\
<div class=\"line\">            entry.timeInSeconds = timeInSeconds;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"comment\">// Release the MShaderInstance and remove the pointer from the cache.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keywordtype\">void</span> shaderInstanceDeleter(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(shader);</div>\n\
<div class=\"line\">        getInstance().removeShaderInstanceFromCache(shader);</div>\n\
<div class=\"line\">        releaseShaderInstance(shader);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Remove the pointer from the cache.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> removeShaderInstanceFromCache(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>* shader)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(shader);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!shader) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Remove the MShaderInstance* from the cache.</span></div>\n\
<div class=\"line\">        fPointShaders.get&lt;1&gt;().erase(shader);</div>\n\
<div class=\"line\">        fWireShaders.get&lt;1&gt;().erase(shader);</div>\n\
<div class=\"line\">        fWireShadersWithCB.get&lt;1&gt;().erase(shader);</div>\n\
<div class=\"line\">        fBoundingBoxPlaceHolderShaders.get&lt;1&gt;().erase(shader);</div>\n\
<div class=\"line\">        fDiffuseColorShaders.get&lt;1&gt;().erase(shader);</div>\n\
<div class=\"line\">        fShadedMaterialShaders.get&lt;1&gt;().erase(shader);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    ShaderInstanceCache()  {}</div>\n\
<div class=\"line\">    ~ShaderInstanceCache() {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// MColor as hash key.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">struct </span>MColorHash : std::unary_function&lt;MColor, std::size_t&gt;</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        std::size_t operator()(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp; key)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">        </span>{</div>\n\
<div class=\"line\">            std::size_t seed = 0;</div>\n\
<div class=\"line\">            boost::hash_combine(seed, key.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b\">r</a>);</div>\n\
<div class=\"line\">            boost::hash_combine(seed, key.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd\">g</a>);</div>\n\
<div class=\"line\">            boost::hash_combine(seed, key.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d\">b</a>);</div>\n\
<div class=\"line\">            boost::hash_combine(seed, key.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e\">a</a>);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> seed;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// MaterialGraph as hash key.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">struct </span>MaterialGraphHash : std::unary_function&lt;MaterialGraph::Ptr, std::size_t&gt;</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        std::size_t operator()(<span class=\"keyword\">const</span> MaterialGraph::Ptr&amp; key)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">        </span>{</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> boost::hash_value(key.get());</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// MShaderInstance* cached by MColor as hash key.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">struct </span>ColorAndShaderInstance {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>                             color;</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*                   shader;</div>\n\
<div class=\"line\">        std::weak_ptr&lt;MShaderInstance&gt;   ptr;</div>\n\
<div class=\"line\">        std::shared_ptr&lt;MShaderInstance&gt; source;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> boost::multi_index_container&lt;</div>\n\
<div class=\"line\">        ColorAndShaderInstance,</div>\n\
<div class=\"line\">        boost::multi_index::indexed_by&lt;</div>\n\
<div class=\"line\">            boost::multi_index::hashed_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_MEMBER(ColorAndShaderInstance,<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>,color),</div>\n\
<div class=\"line\">                MColorHash</div>\n\
<div class=\"line\">            &gt;,</div>\n\
<div class=\"line\">            boost::multi_index::hashed_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_MEMBER(ColorAndShaderInstance,<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*,shader)</div>\n\
<div class=\"line\">            &gt;</div>\n\
<div class=\"line\">        &gt;</div>\n\
<div class=\"line\">    &gt; ColorAndShaderInstanceCache;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// MShaderInstance* cached by MaterialGraph as hash key.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">struct </span>MaterialAndShaderInstance {</div>\n\
<div class=\"line\">        MaterialGraph::Ptr                 material;</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*                   shader;</div>\n\
<div class=\"line\">        std::weak_ptr&lt;MShaderInstance&gt;   ptr;</div>\n\
<div class=\"line\">        std::shared_ptr&lt;MShaderInstance&gt; source;</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span>                               isAnimated;</div>\n\
<div class=\"line\">        <span class=\"keyword\">mutable</span> <span class=\"keywordtype\">double</span>                     timeInSeconds;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> boost::multi_index_container&lt;</div>\n\
<div class=\"line\">        MaterialAndShaderInstance,</div>\n\
<div class=\"line\">        boost::multi_index::indexed_by&lt;</div>\n\
<div class=\"line\">            boost::multi_index::hashed_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_MEMBER(MaterialAndShaderInstance,MaterialGraph::Ptr,material),</div>\n\
<div class=\"line\">                MaterialGraphHash</div>\n\
<div class=\"line\">            &gt;,</div>\n\
<div class=\"line\">            boost::multi_index::hashed_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_MEMBER(MaterialAndShaderInstance,<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html\">MShaderInstance</a>*,shader)</div>\n\
<div class=\"line\">            &gt;</div>\n\
<div class=\"line\">        &gt;</div>\n\
<div class=\"line\">    &gt; MaterialAndShaderInstanceCache;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ColorAndShaderInstanceCache    fPointShaders;</div>\n\
<div class=\"line\">    ColorAndShaderInstanceCache    fWireShaders;</div>\n\
<div class=\"line\">    ColorAndShaderInstanceCache    fWireShadersWithCB;</div>\n\
<div class=\"line\">    ColorAndShaderInstanceCache    fBoundingBoxPlaceHolderShaders;</div>\n\
<div class=\"line\">    ColorAndShaderInstanceCache    fDiffuseColorShaders;</div>\n\
<div class=\"line\">    MaterialAndShaderInstanceCache fShadedMaterialShaders;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS HardwareInstanceData</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>RenderItemWrapper;</div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>HardwareInstanceManagerImpl;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class contains the hardware instancing information for a render item.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Each RenderItemWrapper object has the ownership of this object.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// If a RenderItemWrapper holds an instance of this class, the render item is</span></div>\n\
<div class=\"line\"><span class=\"comment\">// already instanced or is an instance candidate (not-yet-instanced).</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>HardwareInstanceData : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    HardwareInstanceData(HardwareInstanceManagerImpl* manager,</div>\n\
<div class=\"line\">                         RenderItemWrapper*           renderItem)</div>\n\
<div class=\"line\">        : fMasterData(NULL),</div>\n\
<div class=\"line\">          fInstanceId(0),</div>\n\
<div class=\"line\">          fRenderItem(renderItem),</div>\n\
<div class=\"line\">          fManager(manager)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~HardwareInstanceData()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Returns the master render item.</span></div>\n\
<div class=\"line\">    HardwareInstanceData* masterData()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fMasterData; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Returns the instance id.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> instanceId()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fInstanceId; }</div>\n\
<div class=\"line\">    </div>\n\
<div class=\"line\">    <span class=\"comment\">// Returns the owner render item.</span></div>\n\
<div class=\"line\">    RenderItemWrapper* renderItem()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fRenderItem; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Returns true if this render item is hardware instanced.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> isInstanced()<span class=\"keyword\"> const  </span>{ <span class=\"keywordflow\">return</span> fInstanceId &gt; 0; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Returns true if this render item is a mater instance item.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> isMasterItem()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fMasterData == <span class=\"keyword\">this</span>; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Set up to be an instance candidate.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setupCandidate(HardwareInstanceData* master)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(master);</div>\n\
<div class=\"line\">        fMasterData = master;</div>\n\
<div class=\"line\">        fInstanceId = 0;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Set up to be an instance.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setupInstance(HardwareInstanceData* master, <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> instanceId)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(master);</div>\n\
<div class=\"line\">        assert(instanceId &gt; 0);</div>\n\
<div class=\"line\">        fMasterData = master;</div>\n\
<div class=\"line\">        fInstanceId = instanceId;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Clear the instance data.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> clearInstanceData()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fMasterData = NULL;</div>\n\
<div class=\"line\">        fInstanceId = 0;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Notify that the render item has been changed so its instancing</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// should be recomputed.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyInstancingChange();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Notify that the render item has been changed but the change is</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// destructive (shader or geometry change).</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyInstancingClear();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Notify that the render item&#39;s world matrix has been changed.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyWorldMatrixChange();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Notify that the render item is going to be destroyed.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyDestroy();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    HardwareInstanceData* fMasterData;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span>          fInstanceId;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    RenderItemWrapper*           fRenderItem;</div>\n\
<div class=\"line\">    HardwareInstanceManagerImpl* fManager;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS RenderItemWrapper</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class wraps a MRenderItem* object. This will make us easier to track</span></div>\n\
<div class=\"line\"><span class=\"comment\">// the state of a render item.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>RenderItemWrapper : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> std::shared_ptr&lt;RenderItemWrapper&gt; Ptr;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    RenderItemWrapper(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;                     name,</div>\n\
<div class=\"line\">                      <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49e\">MRenderItem::RenderItemType</a>  type,</div>\n\
<div class=\"line\">                      <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e\">MGeometry::Primitive</a>         primitive)</div>\n\
<div class=\"line\">        : fName(name),</div>\n\
<div class=\"line\">          fType(type),</div>\n\
<div class=\"line\">          fPrimitive(primitive),</div>\n\
<div class=\"line\">          fRenderItem(NULL),</div>\n\
<div class=\"line\">          fEnabled(true),</div>\n\
<div class=\"line\">          fDrawMode((<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html\">MGeometry</a>::DrawMode)0),</div>\n\
<div class=\"line\">          fDepthPriority(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html\">MRenderItem</a>::sDormantFilledDepthPriority),</div>\n\
<div class=\"line\">          fIsPointSnapping(false),</div>\n\
<div class=\"line\">          fExcludedFromPostEffects(true),</div>\n\
<div class=\"line\">          fCastsShadows(false),</div>\n\
<div class=\"line\">          fReceivesShadows(false)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(name.<a name=\"a40\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e\">length</a>() &gt; 0);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Create the render item.</span></div>\n\
<div class=\"line\">        fRenderItem = MRenderItem::Create(</div>\n\
<div class=\"line\">            name,</div>\n\
<div class=\"line\">            type,</div>\n\
<div class=\"line\">            primitive</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">        assert(fRenderItem);</div>\n\
<div class=\"line\">        <a name=\"_a41\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_mask.html\">MSelectionMask</a> gpuCacheMask(ShapeNode::selectionMaskName);</div>\n\
<div class=\"line\">        fRenderItem-&gt;setSelectionMask(gpuCacheMask);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~RenderItemWrapper()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// The buffers are no longer used by this render item.</span></div>\n\
<div class=\"line\">        BuffersCache::getInstance().removeBuffers(</div>\n\
<div class=\"line\">            fIndices,</div>\n\
<div class=\"line\">            fPositions,</div>\n\
<div class=\"line\">            fNormals,</div>\n\
<div class=\"line\">            fUVs</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Notify that the render item is destroyed or already destroyed.</span></div>\n\
<div class=\"line\">        notifyDestroy();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> addToContainer(<a name=\"_a42\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(fRenderItem);</div>\n\
<div class=\"line\">        container.<a name=\"a43\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html#a3868473990e1902a2929a48acd2746d8\">add</a>(fRenderItem);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> removeFromContainer(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">            assert(fName == fRenderItem-&gt;name());</div>\n\
<div class=\"line\">            fRenderItem-&gt;setCustomData(NULL);</div>\n\
<div class=\"line\">            container.<a name=\"a44\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html#ab8634382a216e26abb0b47c55d5eb4b6\">remove</a>(fName);</div>\n\
<div class=\"line\">            fRenderItem = NULL;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setEnabled(<span class=\"keywordtype\">bool</span> enabled)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fEnabled != enabled) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Enable/disable the render item.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                fRenderItem-&gt;enable(enabled);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Cache the enable flag.</span></div>\n\
<div class=\"line\">            fEnabled = enabled;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Visibility changed. We need to recompute shadow map.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fType == MRenderItem::MaterialSceneItem) {</div>\n\
<div class=\"line\">                MRenderer::setLightsAndShadowsDirty();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            notifyInstancingChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setWorldMatrix(<span class=\"keyword\">const</span> <a name=\"_a45\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a>&amp; worldMatrix)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fWorldMatrix != worldMatrix) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Set the world matrix to the render item.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                fRenderItem-&gt;setMatrix(&amp;worldMatrix);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Cache the world matrix.</span></div>\n\
<div class=\"line\">            fWorldMatrix = worldMatrix;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// World matrix changed. We need to recompute shadow map.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fType == MRenderItem::MaterialSceneItem) {</div>\n\
<div class=\"line\">                MRenderer::setLightsAndShadowsDirty();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            notifyWorldMatrixChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setBuffers(SubSceneOverride&amp;                               subSceneOverride,</div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;     indices,</div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp;    positions,</div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp;    normals,</div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp;    uvs,</div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_bounding_box.html\">MBoundingBox</a>&amp;                             boundingBox)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span> buffersChanged =</div>\n\
<div class=\"line\">            fIndices    !=  indices     ||</div>\n\
<div class=\"line\">            fPositions  !=  positions   ||</div>\n\
<div class=\"line\">            fNormals    !=  normals     ||</div>\n\
<div class=\"line\">            fUVs        !=  uvs;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (buffersChanged) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Update the geometry on the render item.</span></div>\n\
<div class=\"line\">            BuffersCache::getInstance().updateBuffers(</div>\n\
<div class=\"line\">                subSceneOverride,</div>\n\
<div class=\"line\">                fRenderItem,</div>\n\
<div class=\"line\">                indices,</div>\n\
<div class=\"line\">                positions,</div>\n\
<div class=\"line\">                normals,</div>\n\
<div class=\"line\">                uvs,</div>\n\
<div class=\"line\">                boundingBox,</div>\n\
<div class=\"line\">                fIndices,</div>\n\
<div class=\"line\">                fPositions,</div>\n\
<div class=\"line\">                fNormals,</div>\n\
<div class=\"line\">                fUVs</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Cache the buffers.</span></div>\n\
<div class=\"line\">            fIndices        =   indices;</div>\n\
<div class=\"line\">            fPositions      =   positions;</div>\n\
<div class=\"line\">            fNormals        =   normals;</div>\n\
<div class=\"line\">            fUVs            =   uvs;</div>\n\
<div class=\"line\">            fBoundingBox    =   boundingBox;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// World matrix changed. We need to recompute shadow map.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fType == MRenderItem::MaterialSceneItem) {</div>\n\
<div class=\"line\">                MRenderer::setLightsAndShadowsDirty();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Setting the geometry is destructive.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// Viewport 2.0 will override the geometry for hardware instancing.</span></div>\n\
<div class=\"line\">            notifyInstancingClear();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setShader(<span class=\"keyword\">const</span> ShaderInstancePtr&amp; shader)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fShader != shader) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Set the new shader to the render item.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                fRenderItem-&gt;setShader(shader.get());</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Cache the shader pointer.</span></div>\n\
<div class=\"line\">            fShader = shader;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Setting the shader is destructive.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// Viewport 2.0 will override the shader for hardware instancing.</span></div>\n\
<div class=\"line\">            notifyInstancingClear();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setCustomData(<span class=\"keyword\">const</span> std::shared_ptr&lt;SubNodeUserData&gt;&amp; userData)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fUserData != userData) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                fRenderItem-&gt;setCustomData(<span class=\"keyword\">new</span> SubNodeUserDataDelegate(userData));</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            fUserData = userData;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            notifyInstancingChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setDrawMode(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3\">MGeometry::DrawMode</a> drawMode)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fDrawMode != drawMode) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                fRenderItem-&gt;setDrawMode(drawMode);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            fDrawMode = drawMode;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            notifyInstancingChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setSnappingSelectionMask()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fIsPointSnapping) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_mask.html\">MSelectionMask</a> pointsForGravityMask(<a name=\"a46\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da973e7813e5ba338103dc014a3037bc7a\">MSelectionMask::kSelectPointsForGravity</a>);</div>\n\
<div class=\"line\">                fRenderItem-&gt;setSelectionMask(pointsForGravityMask);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            fIsPointSnapping = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            notifyInstancingChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setDepthPriority(<span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> depthPriority)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fDepthPriority != depthPriority) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                fRenderItem-&gt;depthPriority(depthPriority);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            fDepthPriority = depthPriority;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            notifyInstancingChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setExcludedFromPostEffects(<span class=\"keywordtype\">bool</span> exclude)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fExcludedFromPostEffects != exclude) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                fRenderItem-&gt;setExcludedFromPostEffects(exclude);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            fExcludedFromPostEffects = exclude;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            notifyInstancingChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setCastsShadows(<span class=\"keywordtype\">bool</span> cast)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fCastsShadows != cast) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Set whether the render item will cast shadows on other objects.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                fRenderItem-&gt;castsShadows(cast);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Cache the cast shadow flag.</span></div>\n\
<div class=\"line\">            fCastsShadows = cast;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Recompute shadow map if cast shadow flag changes</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fType == MRenderItem::MaterialSceneItem) {</div>\n\
<div class=\"line\">                MRenderer::setLightsAndShadowsDirty();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            notifyInstancingChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setReceivesShadows(<span class=\"keywordtype\">bool</span> receive)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fReceivesShadows != receive) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Set whether the render item will receive shadows from other objects.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                fRenderItem-&gt;receivesShadows(receive);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Cache the receive shadow flag.</span></div>\n\
<div class=\"line\">            fReceivesShadows = receive;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            notifyInstancingChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setCompatibleWithMayaInstancer(<span class=\"keywordtype\">bool</span> state)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fRenderItem &amp;&amp; fRenderItem-&gt;isCompatibleWithMayaInstancer() != state)</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            fRenderItem-&gt;setCompatibleWithMayaInstancer(state);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Set up for hardware instancing. </span></div>\n\
<div class=\"line\">    <span class=\"comment\">// If the hardware instance data is NULL, the render item will never be instanced.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// This method must be called from HardwareInstanceManager.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> installHardwareInstanceData(<span class=\"keyword\">const</span> std::shared_ptr&lt;HardwareInstanceData&gt;&amp; data)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fHardwareInstanceData = data;</div>\n\
<div class=\"line\">        notifyInstancingChange();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Remove hardware instancing data. This render item will never be instanced.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// This method must be called from HardwareInstanceManager.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> removeHardwareInstanceData(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                                    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fHardwareInstanceData) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fHardwareInstanceData-&gt;isInstanced()) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// Get rid of the render item that is set up hardware instancing.</span></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (fRenderItem) {</div>\n\
<div class=\"line\">                    unloadItem(container);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                assert(!fRenderItem);</div>\n\
<div class=\"line\">                loadItem(subSceneOverride, container);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Delete the hardware instancing data.</span></div>\n\
<div class=\"line\">            fHardwareInstanceData.reset();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Returns true if the render item is already instaned or not-yet-instanced.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> hasHardwareInstanceData()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fHardwareInstanceData.get() != NULL;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Unload the render item. This will delete the actual MRenderItem.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> unloadItem(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Already unloaded?</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fRenderItem) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Remove the render item from the container. The container claims</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// a strong ownership so the render item is actually deleted.</span></div>\n\
<div class=\"line\">        removeFromContainer(container);</div>\n\
<div class=\"line\">        fRenderItem = NULL;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Load the render item. This will create a new identical MRenderItem.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> loadItem(SubSceneOverride&amp; subSceneOverride,</div>\n\
<div class=\"line\">                  <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Already loaded?</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fRenderItem) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Create the render item.</span></div>\n\
<div class=\"line\">        fRenderItem = MRenderItem::Create(</div>\n\
<div class=\"line\">            fName,</div>\n\
<div class=\"line\">            fType,</div>\n\
<div class=\"line\">            fPrimitive</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">        assert(fRenderItem);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Add back to container.</span></div>\n\
<div class=\"line\">        addToContainer(container);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Restore parameters.</span></div>\n\
<div class=\"line\">        fRenderItem-&gt;setCustomData(<span class=\"keyword\">new</span> SubNodeUserDataDelegate(fUserData));</div>\n\
<div class=\"line\">        fRenderItem-&gt;enable(fEnabled);</div>\n\
<div class=\"line\">        fRenderItem-&gt;setMatrix(&amp;fWorldMatrix);</div>\n\
<div class=\"line\">        fRenderItem-&gt;setDrawMode(fDrawMode);</div>\n\
<div class=\"line\">        fRenderItem-&gt;depthPriority(fDepthPriority);</div>\n\
<div class=\"line\">        fRenderItem-&gt;setExcludedFromPostEffects(fExcludedFromPostEffects);</div>\n\
<div class=\"line\">        fRenderItem-&gt;castsShadows(fCastsShadows);</div>\n\
<div class=\"line\">        fRenderItem-&gt;receivesShadows(fReceivesShadows);</div>\n\
<div class=\"line\">        fRenderItem-&gt;setShader(fShader.get());</div>\n\
<div class=\"line\">        fRenderItem-&gt;setCompatibleWithMayaInstancer(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fIsPointSnapping)</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_mask.html\">MSelectionMask</a> pointsForGravityMask(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da973e7813e5ba338103dc014a3037bc7a\">MSelectionMask::kSelectPointsForGravity</a>);</div>\n\
<div class=\"line\">            fRenderItem-&gt;setSelectionMask(pointsForGravityMask);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_mask.html\">MSelectionMask</a> gpuCacheMask(ShapeNode::selectionMaskName);</div>\n\
<div class=\"line\">            fRenderItem-&gt;setSelectionMask(gpuCacheMask);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Restore buffers.</span></div>\n\
<div class=\"line\">        BuffersCache::getInstance().updateBuffers(</div>\n\
<div class=\"line\">            subSceneOverride,</div>\n\
<div class=\"line\">            fRenderItem,</div>\n\
<div class=\"line\">            fIndices,</div>\n\
<div class=\"line\">            fPositions,</div>\n\
<div class=\"line\">            fNormals,</div>\n\
<div class=\"line\">            fUVs,</div>\n\
<div class=\"line\">            fBoundingBox,</div>\n\
<div class=\"line\">            fIndices,</div>\n\
<div class=\"line\">            fPositions,</div>\n\
<div class=\"line\">            fNormals,</div>\n\
<div class=\"line\">            fUVs</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Query methods</span></div>\n\
<div class=\"line\">    <span class=\"comment\">//</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;                      name()<span class=\"keyword\"> const      </span>{ <span class=\"keywordflow\">return</span> fName; }</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49e\">MRenderItem::RenderItemType</a>   type()<span class=\"keyword\"> const      </span>{ <span class=\"keywordflow\">return</span> fType; }</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e\">MGeometry::Primitive</a>          primitive()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fPrimitive; }</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> std::shared_ptr&lt;SubNodeUserData&gt;&amp; userData()<span class=\"keyword\"> const  </span>{ <span class=\"keywordflow\">return</span> fUserData; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  indices()<span class=\"keyword\"> const    </span>{ <span class=\"keywordflow\">return</span> fIndices; }</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; positions()<span class=\"keyword\"> const  </span>{ <span class=\"keywordflow\">return</span> fPositions; }</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; normals()<span class=\"keyword\"> const    </span>{ <span class=\"keywordflow\">return</span> fNormals; }</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; uvs()<span class=\"keyword\"> const        </span>{ <span class=\"keywordflow\">return</span> fUVs; }</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_bounding_box.html\">MBoundingBox</a>&amp; boundingBox()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fBoundingBox; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                enabled()<span class=\"keyword\"> const                 </span>{ <span class=\"keywordflow\">return</span> fEnabled; }</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a>&amp;      worldMatrix()<span class=\"keyword\"> const             </span>{ <span class=\"keywordflow\">return</span> fWorldMatrix; }</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3\">MGeometry::DrawMode</a> drawMode()<span class=\"keyword\"> const                </span>{ <span class=\"keywordflow\">return</span> fDrawMode; }</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span>        depthPriority()<span class=\"keyword\"> const           </span>{ <span class=\"keywordflow\">return</span> fDepthPriority; }</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                excludedFromPostEffects()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fExcludedFromPostEffects; }</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                castsShadows()<span class=\"keyword\"> const            </span>{ <span class=\"keywordflow\">return</span> fCastsShadows; }</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                receivesShadows()<span class=\"keyword\"> const         </span>{ <span class=\"keywordflow\">return</span> fReceivesShadows; }</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                isCompatibleWithMayaInstancer()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fRenderItem ? fRenderItem-&gt;isCompatibleWithMayaInstancer() : <span class=\"keyword\">false</span>; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> ShaderInstancePtr&amp; shader()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fShader; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Extract the wrapped render item.</span></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html\">MRenderItem</a>* wrappedItem()<span class=\"keyword\"> const </span>{ <span class=\"keywordflow\">return</span> fRenderItem; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"comment\">// Hardware instancing notification methods.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">//</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// Slight change that we can reuse existing instancing.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyInstancingChange()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fHardwareInstanceData) {</div>\n\
<div class=\"line\">            fHardwareInstanceData-&gt;notifyInstancingChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Destructive change that we have to clear instancing.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyInstancingClear()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fHardwareInstanceData) {</div>\n\
<div class=\"line\">            fHardwareInstanceData-&gt;notifyInstancingClear();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// World matrix change. We need to update instance transform.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyWorldMatrixChange()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fHardwareInstanceData) {</div>\n\
<div class=\"line\">            fHardwareInstanceData-&gt;notifyWorldMatrixChange();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Destructor is being called.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyDestroy()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fHardwareInstanceData) {</div>\n\
<div class=\"line\">            fHardwareInstanceData-&gt;notifyDestroy();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>                           fName;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49e\">MRenderItem::RenderItemType</a>       fType;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e\">MGeometry::Primitive</a>              fPrimitive;</div>\n\
<div class=\"line\">    std::shared_ptr&lt;SubNodeUserData&gt;      fUserData;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html\">MRenderItem</a>*                            fRenderItem;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::shared_ptr&lt;const IndexBuffer&gt;    fIndices;</div>\n\
<div class=\"line\">    std::shared_ptr&lt;const VertexBuffer&gt;   fPositions;</div>\n\
<div class=\"line\">    std::shared_ptr&lt;const VertexBuffer&gt;   fNormals;</div>\n\
<div class=\"line\">    std::shared_ptr&lt;const VertexBuffer&gt;   fUVs;</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_bounding_box.html\">MBoundingBox</a>                            fBoundingBox;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                                    fEnabled;</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a>                                 fWorldMatrix;</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3\">MGeometry::DrawMode</a>                     fDrawMode;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span>                            fDepthPriority;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                                    fIsPointSnapping;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                                    fExcludedFromPostEffects;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                                    fCastsShadows;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                                    fReceivesShadows;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShaderInstancePtr                       fShader;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::shared_ptr&lt;HardwareInstanceData&gt; fHardwareInstanceData;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS HardwareInstanceManagerImpl</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class is expected to manage all hardware instances inside a single</span></div>\n\
<div class=\"line\"><span class=\"comment\">// subscene. Currently, we don&#39;t support hardware instances between gpuCache nodes.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Each SubSceneOverride owns a HardwareInstanceManager.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// The manager tracks the render item changes. At the end of update() method,</span></div>\n\
<div class=\"line\"><span class=\"comment\">// processInstances() is called to set up instances.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// There are 3 places that hold instancing information:</span></div>\n\
<div class=\"line\"><span class=\"comment\">//   1) HardwareInstanceManagerImpl: This class holds all instancing info.</span></div>\n\
<div class=\"line\"><span class=\"comment\">//   2) HardwareInstanceData: This class is attached to each render item to</span></div>\n\
<div class=\"line\"><span class=\"comment\">//                            keep track of the per-renderItem info.</span></div>\n\
<div class=\"line\"><span class=\"comment\">//   3) MRenderItem: An instance render item is set up by calling MPxSubSceneOverride</span></div>\n\
<div class=\"line\"><span class=\"comment\">//                   hardware instancing methods.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>HardwareInstanceManagerImpl : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    HardwareInstanceManagerImpl(SubSceneOverride&amp; subSceneOverride)</div>\n\
<div class=\"line\">        : fSubSceneOverride(subSceneOverride)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~HardwareInstanceManagerImpl()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This method is called at the end of the subscene&#39;s update() method.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// We have collected all changed/destroyed render items.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// In this method, we can choose the render items to form hardware</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// instances. Or remove a render item from an existing instance.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> processInstances(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Clean up removed instances.</span></div>\n\
<div class=\"line\">        removePendingInstances(container);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update all instance world matrices.</span></div>\n\
<div class=\"line\">        updateInstanceTransforms();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Extract dirty source render items.</span></div>\n\
<div class=\"line\">        std::unordered_set&lt;HardwareInstanceData*&gt; dirtySourceItems;</div>\n\
<div class=\"line\">        extractDirtySourceItems(container, dirtySourceItems);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Process all dirty source render items.</span></div>\n\
<div class=\"line\">        std::unordered_set&lt;HardwareInstanceData*&gt; dirtyCandidates;</div>\n\
<div class=\"line\">        processDirtySourceItems(container, dirtySourceItems, dirtyCandidates);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Process all dirty candidates.</span></div>\n\
<div class=\"line\">        processCandidates(container, dirtyCandidates);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Load the render items back if they are still not instances.</span></div>\n\
<div class=\"line\">        loadPendingItems(container);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This method is called at the beginning of the subscene&#39;s update method().</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// In this method, we delete everything related to hardware instancing.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> resetInstances(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// This method must be called before the update() method.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// So there are no dirty render items.</span></div>\n\
<div class=\"line\">        assert(fInstancingChangeItems.empty());</div>\n\
<div class=\"line\">        assert(fWorldMatrixChangeItems.empty());</div>\n\
<div class=\"line\">        assert(fItemsPendingLoad.empty());</div>\n\
<div class=\"line\">        assert(fItemsPendingRemove.empty());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Collect all render items.</span></div>\n\
<div class=\"line\">        std::unordered_set&lt;RenderItemWrapper*&gt; renderItems;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> HardwareInstance&amp; hwInstance : fInstances) {</div>\n\
<div class=\"line\">            renderItems.insert(hwInstance.master-&gt;renderItem());</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span>(HardwareInstanceData* data : hwInstance.sources) {</div>\n\
<div class=\"line\">                renderItems.insert(data-&gt;renderItem());</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Throw away all the instancing information.</span></div>\n\
<div class=\"line\">        fInstancingChangeItems.clear();</div>\n\
<div class=\"line\">        fWorldMatrixChangeItems.clear();</div>\n\
<div class=\"line\">        fItemsPendingLoad.clear();</div>\n\
<div class=\"line\">        fItemsPendingRemove.clear();</div>\n\
<div class=\"line\">        fInstances.clear();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Delete the attached hardware instance data on the render item.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// If the render item is already instanced, it will be re-created to</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// get rid of the instancing.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(RenderItemWrapper* renderItem : renderItems) {</div>\n\
<div class=\"line\">            renderItem-&gt;removeHardwareInstanceData(fSubSceneOverride, container);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Callback that a render item has been changed. We need to look at</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// the render item in processInstances() method later.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyInstancingChange(HardwareInstanceData* data)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(data &amp;&amp; data-&gt;renderItem());</div>\n\
<div class=\"line\">        fInstancingChangeItems.insert(data);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Callback that a render item&#39;s world matrix has been changed.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// We need to update the instance transform in the master render item.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyWorldMatrixChange(HardwareInstanceData* data)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(data &amp;&amp; data-&gt;renderItem() &amp;&amp; data-&gt;isInstanced());</div>\n\
<div class=\"line\">        fWorldMatrixChangeItems.insert(data);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Callback that a render item has been changed but the change is</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// destructive. The render item should no longer be an instance.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// e.g. shader change and/or geometry change are destructive.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyInstancingClear(HardwareInstanceData* data, <span class=\"keywordtype\">bool</span> destroy = <span class=\"keyword\">false</span>)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(data &amp;&amp; data-&gt;renderItem());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Dirty the render item so it will get processed again later.</span></div>\n\
<div class=\"line\">        fInstancingChangeItems.insert(data);</div>\n\
<div class=\"line\">        fWorldMatrixChangeItems.erase(data);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// All instanced source render items are pending reloading because</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// the master render item has gone.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// But we don&#39;t reload them immediately for performance.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (data-&gt;isInstanced()) {</div>\n\
<div class=\"line\">            fItemsPendingLoad.insert(data);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update hardware instance set.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (data-&gt;isMasterItem()) {</div>\n\
<div class=\"line\">            HardwareInstanceSet::iterator it = fInstances.find(data);</div>\n\
<div class=\"line\">            assert(it != fInstances.end() &amp;&amp; it-&gt;master == data);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// This is a master render item. We dismiss this hardware instance or</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// instance candidate.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span>(HardwareInstanceData* sourceData : it-&gt;sources) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// Dirty the source item so it will get processed again later.</span></div>\n\
<div class=\"line\">                fInstancingChangeItems.insert(sourceData);</div>\n\
<div class=\"line\">                fWorldMatrixChangeItems.erase(sourceData);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// All instanced source render items are pending reloading because</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// the master render item has gone.</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// But we don&#39;t reload them immediately for performance.</span></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (sourceData-&gt;isInstanced()) {</div>\n\
<div class=\"line\">                    fItemsPendingLoad.insert(sourceData);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// The source render item is no longer instanced.</span></div>\n\
<div class=\"line\">                sourceData-&gt;clearInstanceData();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Clear the master render item&#39;s instancing.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (data-&gt;isInstanced()) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// If the render item is going to be destroyed, we don&#39;t need</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// to call removeAllInstances() ..</span></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (!destroy) {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// Master render item is gone. No survivals..</span></div>\n\
<div class=\"line\">                    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_status.html\">MStatus</a> stat = fSubSceneOverride.removeAllInstances(</div>\n\
<div class=\"line\">                        *data-&gt;renderItem()-&gt;wrappedItem()</div>\n\
<div class=\"line\">                    );</div>\n\
<div class=\"line\">                    MStatAssert(stat);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// Schedule for reloading the master render item to</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// totally get rid of the instancing set up.</span></div>\n\
<div class=\"line\">                fItemsPendingRemove.insert(data);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            fInstances.erase(it);</div>\n\
<div class=\"line\">            data-&gt;clearInstanceData();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">            HardwareInstanceData* master = data-&gt;masterData();</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (master) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// This is a source render item. Find the master render item first.</span></div>\n\
<div class=\"line\">                HardwareInstanceSet::iterator it = fInstances.find(master);</div>\n\
<div class=\"line\">                assert(it != fInstances.end());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// Remove this source render item from the set.</span></div>\n\
<div class=\"line\">                assert(it-&gt;sources.find(data) != it-&gt;sources.end());</div>\n\
<div class=\"line\">                it-&gt;sources.erase(data);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// Remove the instance from the master render item.</span></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (!it-&gt;candidate) {</div>\n\
<div class=\"line\">                    assert(master-&gt;isInstanced() &amp;&amp; data-&gt;isInstanced());</div>\n\
<div class=\"line\">                    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_status.html\">MStatus</a> stat = fSubSceneOverride.removeInstance(</div>\n\
<div class=\"line\">                        *master-&gt;renderItem()-&gt;wrappedItem(),</div>\n\
<div class=\"line\">                        data-&gt;instanceId()</div>\n\
<div class=\"line\">                    );</div>\n\
<div class=\"line\">                    MStatAssert(stat);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// The source render item is no longer instanced.</span></div>\n\
<div class=\"line\">                data-&gt;clearInstanceData();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Callback that a render item is going to be destroyed.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// This is similar to a destructive change but we will remove the</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// render item permanently.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> notifyDestroy(HardwareInstanceData* data)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(data &amp;&amp; data-&gt;renderItem());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Same as a destructive change.</span></div>\n\
<div class=\"line\">        notifyInstancingClear(data, <span class=\"keyword\">true</span> <span class=\"comment\">/* destroy */</span> );</div>\n\
<div class=\"line\">        </div>\n\
<div class=\"line\">        <span class=\"comment\">// The render item is going to be destroyed. We don&#39;t want to</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// deal with it any more.</span></div>\n\
<div class=\"line\">        fInstancingChangeItems.erase(data);</div>\n\
<div class=\"line\">        fWorldMatrixChangeItems.erase(data);</div>\n\
<div class=\"line\">        fItemsPendingLoad.erase(data);</div>\n\
<div class=\"line\">        fItemsPendingRemove.erase(data);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> instancePathIndex(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html\">MHWRender::MRenderItem</a>&amp; renderItem, <span class=\"keywordtype\">int</span> hardwareInstanceIndex)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> hardwareInstanceID(hardwareInstanceIndex);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> HardwareInstance&amp; hwInstance : fInstances) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (hwInstance.master-&gt;renderItem()-&gt;name() == renderItem.<a name=\"a47\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#aca2cba4630391c78dcf1a828986160da\">name</a>())</div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> renderItemName;</div>\n\
<div class=\"line\">                <span class=\"keywordtype\">bool</span> found = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (hwInstance.master-&gt;instanceId() == hardwareInstanceID)</div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    renderItemName = hwInstance.master-&gt;renderItem()-&gt;name();</div>\n\
<div class=\"line\">                    found = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">for</span>(HardwareInstanceData* sourceData : hwInstance.sources) {</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">if</span> (sourceData-&gt;instanceId() == hardwareInstanceID)</div>\n\
<div class=\"line\">                        {</div>\n\
<div class=\"line\">                            renderItemName = sourceData-&gt;renderItem()-&gt;name();</div>\n\
<div class=\"line\">                            found = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">                            <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\">                        }</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (found)</div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    <a name=\"_a48\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string_array.html\">MStringArray</a> renderItemParts;</div>\n\
<div class=\"line\">                    renderItemName.<a name=\"a49\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html#ac914d138fc96d7065c687a4f8b40c263\">split</a>(<span class=\"charliteral\">&#39;:&#39;</span>, renderItemParts);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (renderItemParts.<a name=\"a50\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e\">length</a>() &gt; 1 &amp;&amp; renderItemParts[0].isUnsigned())</div>\n\
<div class=\"line\">                    {</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">return</span> renderItemParts[0].asUnsigned();</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> -1;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> dump()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keyword\">using namespace </span>std;</div>\n\
<div class=\"line\">        ostringstream tmp;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> hwInstCounter = 0;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> HardwareInstance&amp; hwInstance : fInstances) {</div>\n\
<div class=\"line\">            tmp &lt;&lt; <span class=\"stringliteral\">&quot;HW Instance #&quot;</span> &lt;&lt; (hwInstCounter++) &lt;&lt; endl;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            tmp &lt;&lt; <span class=\"charliteral\">&#39;\\t&#39;</span> &lt;&lt; <span class=\"stringliteral\">&quot;Master: &quot;</span> </div>\n\
<div class=\"line\">                &lt;&lt; hwInstance.master-&gt;renderItem()-&gt;name().asChar()</div>\n\
<div class=\"line\">                &lt;&lt; endl;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            tmp &lt;&lt; <span class=\"charliteral\">&#39;\\t&#39;</span> &lt;&lt; <span class=\"stringliteral\">&quot;Candidate: &quot;</span></div>\n\
<div class=\"line\">                &lt;&lt; (hwInstance.candidate ? <span class=\"stringliteral\">&quot;true&quot;</span> : <span class=\"stringliteral\">&quot;false&quot;</span>)</div>\n\
<div class=\"line\">                &lt;&lt; endl;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            tmp &lt;&lt; <span class=\"charliteral\">&#39;\\t&#39;</span> &lt;&lt; <span class=\"stringliteral\">&quot;Sources: &quot;</span></div>\n\
<div class=\"line\">                &lt;&lt; hwInstance.sources.size()</div>\n\
<div class=\"line\">                &lt;&lt; endl;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordtype\">size_t</span> sourceCounter = 0;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span>(HardwareInstanceData* sourceData : hwInstance.sources) {</div>\n\
<div class=\"line\">                tmp &lt;&lt; <span class=\"charliteral\">&#39;\\t&#39;</span> &lt;&lt; <span class=\"charliteral\">&#39;\\t&#39;</span> &lt;&lt; <span class=\"stringliteral\">&quot;Source #&quot;</span> &lt;&lt; (sourceCounter++)</div>\n\
<div class=\"line\">                    &lt;&lt; <span class=\"stringliteral\">&quot; &quot;</span> &lt;&lt; sourceData-&gt;renderItem()-&gt;name().asChar()</div>\n\
<div class=\"line\">                    &lt;&lt; <span class=\"stringliteral\">&quot; instance ID: &quot;</span> &lt;&lt; sourceData-&gt;instanceId()</div>\n\
<div class=\"line\">                    &lt;&lt; endl;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        printf(<span class=\"stringliteral\">&quot;%s\\n&quot;</span>, tmp.str().c_str());</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"comment\">// Some render items are destroyed or have destructive changes.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// This is the final step to update the underlying MRenderItem.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> removePendingInstances(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(HardwareInstanceData* data : fItemsPendingRemove) {</div>\n\
<div class=\"line\">            data-&gt;renderItem()-&gt;unloadItem(container);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        fItemsPendingRemove.clear();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Some render items are no longer instances. We need to re-create</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// the underlying MRenderItem. But we do this lazily because the render</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// item might become instance again.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> loadPendingItems(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(HardwareInstanceData* data : fItemsPendingLoad) {</div>\n\
<div class=\"line\">            assert(data);</div>\n\
<div class=\"line\">            data-&gt;renderItem()-&gt;loadItem(fSubSceneOverride, container);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        fItemsPendingLoad.clear();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Some render items&#39; world matrices have been changed. We need to</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// update the corresponding instance matrix in the master render item.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateInstanceTransforms()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(HardwareInstanceData* data : fWorldMatrixChangeItems) {</div>\n\
<div class=\"line\">            assert(data &amp;&amp; data-&gt;isInstanced());</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (!data || !data-&gt;isInstanced()) <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Note that if this is a master item, master equals to data.</span></div>\n\
<div class=\"line\">            HardwareInstanceData* master = data-&gt;masterData();</div>\n\
<div class=\"line\">            assert(master &amp;&amp; master-&gt;isInstanced());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Render items.</span></div>\n\
<div class=\"line\">            RenderItemWrapper* masterItem = master-&gt;renderItem();</div>\n\
<div class=\"line\">            assert(masterItem);</div>\n\
<div class=\"line\">            RenderItemWrapper* thisItem = data-&gt;renderItem();</div>\n\
<div class=\"line\">            assert(thisItem);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Set instance transform.</span></div>\n\
<div class=\"line\">            <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_status.html\">MStatus</a> stat = fSubSceneOverride.updateInstanceTransform(</div>\n\
<div class=\"line\">                *masterItem-&gt;wrappedItem(),</div>\n\
<div class=\"line\">                data-&gt;instanceId(),</div>\n\
<div class=\"line\">                thisItem-&gt;worldMatrix()</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\">            MStatAssert(stat);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        fWorldMatrixChangeItems.clear();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This method will find all dirty source render items based on the current</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// dirty render items (master + source). If a master render item is dirty,</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// we consider all its source render items are dirty as well.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> extractDirtySourceItems(</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;                          container,</div>\n\
<div class=\"line\">        std::unordered_set&lt;HardwareInstanceData*&gt;&amp; dirtySourceItems)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(HardwareInstanceData* data : fInstancingChangeItems) {</div>\n\
<div class=\"line\">            assert(data);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// This is a source item. Skip it.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (!data-&gt;isMasterItem()) {</div>\n\
<div class=\"line\">                assert(fInstances.find(data) == fInstances.end());</div>\n\
<div class=\"line\">                dirtySourceItems.insert(data);</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// We only deal with master render items.</span></div>\n\
<div class=\"line\">            HardwareInstanceSet::iterator it = fInstances.find(data);</div>\n\
<div class=\"line\">            assert(it != fInstances.end());</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (it == fInstances.end()) <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\">            assert(it-&gt;master == data);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (it-&gt;master != data) <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Search the source items. If the source item is different from</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// the changed master item, mark it as dirty.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span>(HardwareInstanceData* sourceData : it-&gt;sources) {</div>\n\
<div class=\"line\">                assert(sourceData);</div>\n\
<div class=\"line\">                dirtySourceItems.insert(sourceData);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Re-hash the master render item since it&#39;s changed.</span></div>\n\
<div class=\"line\">            HardwareInstance hwInstance = *it;</div>\n\
<div class=\"line\">            fInstances.erase(it);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fInstances.get&lt;1&gt;().find(hwInstance.master) == fInstances.get&lt;1&gt;().end()) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// Insert back..</span></div>\n\
<div class=\"line\">                fInstances.insert(hwInstance);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                <span class=\"comment\">// We already have a hardware instance that has the same look..</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// Dismiss this instance.</span></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span>(HardwareInstanceData* sourceData : hwInstance.sources) {</div>\n\
<div class=\"line\">                    dirtySourceItems.insert(sourceData);</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (sourceData-&gt;isInstanced()) {</div>\n\
<div class=\"line\">                        sourceData-&gt;renderItem()-&gt;unloadItem(container);</div>\n\
<div class=\"line\">                        fItemsPendingLoad.insert(sourceData);</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                    sourceData-&gt;clearInstanceData();</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                dirtySourceItems.insert(data);</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (data-&gt;isInstanced()) {</div>\n\
<div class=\"line\">                    data-&gt;renderItem()-&gt;unloadItem(container);</div>\n\
<div class=\"line\">                    fItemsPendingLoad.insert(data);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                data-&gt;clearInstanceData();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        fInstancingChangeItems.clear();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This method goes through all dirty source render items and put them</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// to the correct instance group.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> processDirtySourceItems(</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;                                container,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::unordered_set&lt;HardwareInstanceData*&gt;&amp; dirtySourceItems,</div>\n\
<div class=\"line\">        std::unordered_set&lt;HardwareInstanceData*&gt;&amp;       dirtyCandidates)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Process all dirty source items.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(HardwareInstanceData* data : dirtySourceItems) {</div>\n\
<div class=\"line\">            assert(data &amp;&amp; !data-&gt;isMasterItem());</div>\n\
<div class=\"line\">            assert(fInstances.find(data) == fInstances.end());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Remove the dirty item since its hash (look) is changed.</span></div>\n\
<div class=\"line\">            HardwareInstanceData* master = data-&gt;masterData();</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (master) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// Remove the source item from its master&#39;s source set.</span></div>\n\
<div class=\"line\">                HardwareInstanceSet::iterator it = fInstances.find(master);</div>\n\
<div class=\"line\">                assert(it != fInstances.end());</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (it != fInstances.end()) {</div>\n\
<div class=\"line\">                    assert(it-&gt;sources.find(data) != it-&gt;sources.end());</div>\n\
<div class=\"line\">                    it-&gt;sources.erase(data);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Process this dirty render item.</span></div>\n\
<div class=\"line\">            <span class=\"keywordtype\">bool</span> skipThisItem = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">            HardwareInstanceSet::nth_index&lt;1&gt;::type::iterator it = </div>\n\
<div class=\"line\">                fInstances.get&lt;1&gt;().find(data);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (data-&gt;isInstanced()) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// This render item is already instanced.</span></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (it != fInstances.get&lt;1&gt;().end()) {</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (data-&gt;masterData() == it-&gt;master) {</div>\n\
<div class=\"line\">                        <span class=\"comment\">// Both the render item and its master item are changed,</span></div>\n\
<div class=\"line\">                        <span class=\"comment\">// but they finally have the same look again...</span></div>\n\
<div class=\"line\">                        <span class=\"comment\">// Simply add the render item back and skip.</span></div>\n\
<div class=\"line\">                        it-&gt;sources.insert(data);</div>\n\
<div class=\"line\">                        skipThisItem = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                        <span class=\"comment\">// The instanced render item is changed. We need to</span></div>\n\
<div class=\"line\">                        <span class=\"comment\">// remove it from its master.</span></div>\n\
<div class=\"line\">                        leaveInstance(data, container);</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// The instanced render item is changed. We need to</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// remove it from its master.</span></div>\n\
<div class=\"line\">                    leaveInstance(data, container);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (!skipThisItem) {</div>\n\
<div class=\"line\">                assert(!data-&gt;isInstanced());</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (it != fInstances.get&lt;1&gt;().end()) {</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (it-&gt;candidate) {</div>\n\
<div class=\"line\">                        <span class=\"comment\">// There is a candidate hardware instance. Join</span></div>\n\
<div class=\"line\">                        <span class=\"comment\">// the candidate.</span></div>\n\
<div class=\"line\">                        joinCandidate(it-&gt;master, data);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                        <span class=\"comment\">// We will review the candidate later.</span></div>\n\
<div class=\"line\">                        dirtyCandidates.insert(it-&gt;master);</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                        <span class=\"comment\">// There is already a master render item that has the</span></div>\n\
<div class=\"line\">                        <span class=\"comment\">// same look.</span></div>\n\
<div class=\"line\">                        joinInstance(it-&gt;master, data, container);</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// There are no instances or candidates that have the</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// same look. We create a new candidate.</span></div>\n\
<div class=\"line\">                    newCandidate(data);</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This method goes through all instance candidates and make them instances if</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// the number of source render items meets the threshold requirement.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> processCandidates(</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;                                container,</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::unordered_set&lt;HardwareInstanceData*&gt;&amp; dirtyCandidates)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(HardwareInstanceData* data : dirtyCandidates) {</div>\n\
<div class=\"line\">            assert(data);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            HardwareInstanceSet::iterator it = fInstances.find(data);</div>\n\
<div class=\"line\">            assert(it != fInstances.end());</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (it == fInstances.end()) <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\">            assert(it-&gt;candidate &amp;&amp; data == it-&gt;master);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (!it-&gt;candidate || data != it-&gt;master) <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// If the number of master and source items in the candidate does</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// not meet the threshold requirement, skip this candidate.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (it-&gt;sources.size() + 1 &lt; Config::hardwareInstancingThreshold()) {</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Remove the candidate.</span></div>\n\
<div class=\"line\">            HardwareInstance hwInstance = *it;</div>\n\
<div class=\"line\">            fInstances.erase(it);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Create a new hardware instance.</span></div>\n\
<div class=\"line\">            assert(hwInstance.master &amp;&amp; !hwInstance.master-&gt;isInstanced());</div>\n\
<div class=\"line\">            hwInstance.master-&gt;clearInstanceData();</div>\n\
<div class=\"line\">            newInstance(hwInstance.master, container);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Join the remaining instances.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span>(HardwareInstanceData* data : hwInstance.sources) {</div>\n\
<div class=\"line\">                assert(data &amp;&amp; !data-&gt;isInstanced() &amp;&amp; !data-&gt;isMasterItem());</div>\n\
<div class=\"line\">                data-&gt;clearInstanceData();</div>\n\
<div class=\"line\">                joinInstance(hwInstance.master, data, container);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> newCandidate(HardwareInstanceData* source)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// source must be a not-yet-instanced item.</span></div>\n\
<div class=\"line\">        assert(source);</div>\n\
<div class=\"line\">        assert(!source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// The master of the candidate is the source.</span></div>\n\
<div class=\"line\">        source-&gt;setupCandidate(source);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Create a new candidate.</span></div>\n\
<div class=\"line\">        HardwareInstance hwInstance;</div>\n\
<div class=\"line\">        hwInstance.master    = source;</div>\n\
<div class=\"line\">        hwInstance.candidate = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">        fInstances.insert(hwInstance);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> joinCandidate(HardwareInstanceData* master,</div>\n\
<div class=\"line\">                       HardwareInstanceData* source)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// master must be an not instanced master render item.</span></div>\n\
<div class=\"line\">        assert(master);</div>\n\
<div class=\"line\">        assert(!master-&gt;isInstanced() &amp;&amp; master-&gt;isMasterItem());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (master-&gt;isInstanced() || !master-&gt;isMasterItem()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// We should know the master render item.</span></div>\n\
<div class=\"line\">        HardwareInstanceSet::iterator it = fInstances.find(master);</div>\n\
<div class=\"line\">        assert(it != fInstances.end());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it == fInstances.end()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        assert(it-&gt;master == master &amp;&amp; it-&gt;candidate);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it-&gt;master != master || !it-&gt;candidate) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        assert(it-&gt;sources.find(source) == it-&gt;sources.end());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// source must be a not-yet-instanced item.</span></div>\n\
<div class=\"line\">        assert(source);</div>\n\
<div class=\"line\">        assert(!source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Set up the remaining data.</span></div>\n\
<div class=\"line\">        source-&gt;setupCandidate(master);</div>\n\
<div class=\"line\">        it-&gt;sources.insert(source);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> newInstance(HardwareInstanceData* source,</div>\n\
<div class=\"line\">                     <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;   container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// source must be a not-yet-instanced item.</span></div>\n\
<div class=\"line\">        assert(source);</div>\n\
<div class=\"line\">        assert(!source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Render items.</span></div>\n\
<div class=\"line\">        RenderItemWrapper* sourceItem = source-&gt;renderItem();</div>\n\
<div class=\"line\">        assert(sourceItem);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Make sure the master render item is loaded.</span></div>\n\
<div class=\"line\">        sourceItem-&gt;loadItem(fSubSceneOverride, container);</div>\n\
<div class=\"line\">        fItemsPendingLoad.erase(source);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Make the source render item as a master item.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> instanceId = fSubSceneOverride.addInstanceTransform(</div>\n\
<div class=\"line\">            *sourceItem-&gt;wrappedItem(),</div>\n\
<div class=\"line\">            sourceItem-&gt;worldMatrix()</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">        assert(instanceId &gt; 0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (instanceId == 0) <span class=\"keywordflow\">return</span>;    <span class=\"comment\">// failure?</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// The master of the candidate is the source.</span></div>\n\
<div class=\"line\">        source-&gt;setupInstance(source, instanceId);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Create a new instance.</span></div>\n\
<div class=\"line\">        HardwareInstance hwInstance;</div>\n\
<div class=\"line\">        hwInstance.master    = source;</div>\n\
<div class=\"line\">        hwInstance.candidate = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">        fInstances.insert(hwInstance);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> joinInstance(HardwareInstanceData* master, </div>\n\
<div class=\"line\">                      HardwareInstanceData* source,</div>\n\
<div class=\"line\">                      <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;   container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// master must be an instanced master render item.</span></div>\n\
<div class=\"line\">        assert(master);</div>\n\
<div class=\"line\">        assert(master-&gt;isInstanced() &amp;&amp; master-&gt;isMasterItem());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!master-&gt;isInstanced() || !master-&gt;isMasterItem()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// We should know the master render item.</span></div>\n\
<div class=\"line\">        HardwareInstanceSet::iterator it = fInstances.find(master);</div>\n\
<div class=\"line\">        assert(it != fInstances.end());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it == fInstances.end()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        assert(it-&gt;master == master &amp;&amp; !it-&gt;candidate);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (it-&gt;master != master || it-&gt;candidate) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        assert(it-&gt;sources.find(source) == it-&gt;sources.end());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// source must be a not-yet-instanced item.</span></div>\n\
<div class=\"line\">        assert(source);</div>\n\
<div class=\"line\">        assert(!source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Render items.</span></div>\n\
<div class=\"line\">        RenderItemWrapper* masterItem = master-&gt;renderItem();</div>\n\
<div class=\"line\">        assert(masterItem);</div>\n\
<div class=\"line\">        RenderItemWrapper* sourceItem = source-&gt;renderItem();</div>\n\
<div class=\"line\">        assert(sourceItem);</div>\n\
<div class=\"line\">        </div>\n\
<div class=\"line\">        <span class=\"comment\">// Add a new hardware instance to the master render item.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> instanceId = fSubSceneOverride.addInstanceTransform(</div>\n\
<div class=\"line\">            *masterItem-&gt;wrappedItem(),</div>\n\
<div class=\"line\">            sourceItem-&gt;worldMatrix()</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">        assert(instanceId &gt; 0);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (instanceId == 0) <span class=\"keywordflow\">return</span>;    <span class=\"comment\">// failure?</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Delete the source render item. </span></div>\n\
<div class=\"line\">        sourceItem-&gt;unloadItem(container);</div>\n\
<div class=\"line\">        fItemsPendingLoad.erase(source);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Set up the remaining data.</span></div>\n\
<div class=\"line\">        source-&gt;setupInstance(master, instanceId);</div>\n\
<div class=\"line\">        it-&gt;sources.insert(source);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> leaveInstance(HardwareInstanceData* source,</div>\n\
<div class=\"line\">                       <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;   container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// source must be an instanced item but not a master.</span></div>\n\
<div class=\"line\">        assert(source);</div>\n\
<div class=\"line\">        assert(source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        HardwareInstanceData* master = source-&gt;masterData();</div>\n\
<div class=\"line\">        assert(master);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Render items.</span></div>\n\
<div class=\"line\">        RenderItemWrapper* masterItem = master-&gt;renderItem();</div>\n\
<div class=\"line\">        assert(masterItem);</div>\n\
<div class=\"line\">        RenderItemWrapper* sourceItem = source-&gt;renderItem();</div>\n\
<div class=\"line\">        assert(sourceItem);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Remove the hardware instance from the master render item.</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_status.html\">MStatus</a> stat = fSubSceneOverride.removeInstance(</div>\n\
<div class=\"line\">            *masterItem-&gt;wrappedItem(),</div>\n\
<div class=\"line\">            source-&gt;instanceId()</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">        assert(stat == MS::kSuccess);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!stat) <span class=\"keywordflow\">return</span>;  <span class=\"comment\">// failure?</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Reload the source render item.</span></div>\n\
<div class=\"line\">        sourceItem-&gt;loadItem(fSubSceneOverride, container);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Set up the remaining data.</span></div>\n\
<div class=\"line\">        source-&gt;clearInstanceData();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This function object returns the same hash code for</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// render items that have identical look.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// We ignore the render item&#39;s name and its world matrix.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">struct </span>VisHash : std::unary_function&lt;HardwareInstanceData*, std::size_t&gt;</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        std::size_t operator()(<span class=\"keyword\">const</span> HardwareInstanceData* <span class=\"keyword\">const</span>&amp; data)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">        </span>{</div>\n\
<div class=\"line\">            std::size_t seed = 0;</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> RenderItemWrapper* w = data-&gt;renderItem();</div>\n\
<div class=\"line\">            assert(w);</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;type());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;primitive());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;userData().get());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;indices().get());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;positions().get());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;normals().get());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;uvs().get());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;enabled());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;drawMode());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;depthPriority());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;excludedFromPostEffects());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;castsShadows());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;receivesShadows());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;shader().get());</div>\n\
<div class=\"line\">            boost::hash_combine(seed, w-&gt;isCompatibleWithMayaInstancer());</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> seed;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This function object returns true if two render items have</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// identical look.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// We ignore the render item&#39;s name and its world matrix.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">struct </span>VisEqualTo : std::binary_function&lt;HardwareInstanceData*, HardwareInstanceData*, bool&gt;</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span> operator()(<span class=\"keyword\">const</span> HardwareInstanceData* <span class=\"keyword\">const</span>&amp; xData,</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> HardwareInstanceData* <span class=\"keyword\">const</span>&amp; yData)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">        </span>{</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> RenderItemWrapper* x = xData-&gt;renderItem();</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> RenderItemWrapper* y = yData-&gt;renderItem();</div>\n\
<div class=\"line\">            assert(x &amp;&amp; y);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> x-&gt;type()                   == y-&gt;type() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;primitive()                 == y-&gt;primitive() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;userData().get()            == y-&gt;userData().get() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;indices().get()             == y-&gt;indices().get() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;positions().get()           == y-&gt;positions().get() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;normals().get()             == y-&gt;normals().get() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;uvs().get()                 == y-&gt;uvs().get() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;enabled()                   == y-&gt;enabled() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;drawMode()                  == y-&gt;drawMode() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;depthPriority()             == y-&gt;depthPriority() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;excludedFromPostEffects()   == y-&gt;excludedFromPostEffects() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;castsShadows()              == y-&gt;castsShadows() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;receivesShadows()           == y-&gt;receivesShadows() &amp;&amp;</div>\n\
<div class=\"line\">                x-&gt;shader().get()              == y-&gt;shader().get();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Each HardwareInstance stands for a group of render items that</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// have the same appearance.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// If the group is instanced, only the master render item has the</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// actual MRenderItem. Other render items have no MRenderItems.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// Otherwise, the group is an instance candidate. The master and </span></div>\n\
<div class=\"line\">    <span class=\"comment\">// other render items behave normal.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">struct </span>HardwareInstance</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// The master render item.</span></div>\n\
<div class=\"line\">        HardwareInstanceData* master;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// True if this group is an instance candidate (not-yet-instanced).</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// Otherwise, this group is hardware instanced.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">mutable</span> <span class=\"keywordtype\">bool</span> candidate;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Other render items that have the same appearance as the</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// master render item.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">mutable</span> std::unordered_set&lt;HardwareInstanceData*&gt; sources;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> boost::multi_index_container&lt;</div>\n\
<div class=\"line\">        HardwareInstance,</div>\n\
<div class=\"line\">        boost::multi_index::indexed_by&lt;</div>\n\
<div class=\"line\">            <span class=\"comment\">// Index 0: The pointer of hardware instance data.</span></div>\n\
<div class=\"line\">            boost::multi_index::hashed_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_MEMBER(HardwareInstance,HardwareInstanceData*,master)</div>\n\
<div class=\"line\">            &gt;,</div>\n\
<div class=\"line\">            <span class=\"comment\">// Index 1: The render item visual hash.</span></div>\n\
<div class=\"line\">            boost::multi_index::hashed_non_unique&lt;</div>\n\
<div class=\"line\">                BOOST_MULTI_INDEX_MEMBER(HardwareInstance,HardwareInstanceData*,master),</div>\n\
<div class=\"line\">                VisHash,</div>\n\
<div class=\"line\">                VisEqualTo</div>\n\
<div class=\"line\">            &gt;</div>\n\
<div class=\"line\">        &gt;</div>\n\
<div class=\"line\">    &gt; HardwareInstanceSet;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// The associated subscene.</span></div>\n\
<div class=\"line\">    SubSceneOverride&amp;   fSubSceneOverride;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Keeps all hardware instancing information.</span></div>\n\
<div class=\"line\">    HardwareInstanceSet fInstances;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Helper structures to track render item changes.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// They should be empty after processInstances() method.</span></div>\n\
<div class=\"line\">    std::unordered_set&lt;HardwareInstanceData*&gt; fInstancingChangeItems;</div>\n\
<div class=\"line\">    std::unordered_set&lt;HardwareInstanceData*&gt; fWorldMatrixChangeItems;</div>\n\
<div class=\"line\">    std::unordered_set&lt;HardwareInstanceData*&gt; fItemsPendingLoad;</div>\n\
<div class=\"line\">    std::unordered_set&lt;HardwareInstanceData*&gt; fItemsPendingRemove;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// The following methods have dependency on HardwareInstanceManagerImpl.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> HardwareInstanceData::notifyInstancingChange()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    fManager-&gt;notifyInstancingChange(<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> HardwareInstanceData::notifyInstancingClear()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    fManager-&gt;notifyInstancingClear(<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> HardwareInstanceData::notifyWorldMatrixChange()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Only need to update instance transform.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (isInstanced()) {</div>\n\
<div class=\"line\">        fManager-&gt;notifyWorldMatrixChange(<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> HardwareInstanceData::notifyDestroy()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    fManager-&gt;notifyDestroy(<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS ModelCallbacks</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class manages model-level callbacks.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// gpuCache node-level callbacks are registered in GPUCache::SubSceneOverride.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>ModelCallbacks : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> ModelCallbacks&amp; getInstance()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Singleton</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">static</span> ModelCallbacks sSingleton;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> sSingleton;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ModelCallbacks()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Initialize DAG object attributes that affect display appearance</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// of their descendant shapes.</span></div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;visibility&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;lodVisibility&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;intermediateObject&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;template&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;renderLayerInfo&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;renderLayerId&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;renderLayerRenderable&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;renderLayerColor&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;drawOverride&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;overrideDisplayType&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;overrideLevelOfDetail&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;overrideShading&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;overrideTexturing&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;overridePlayback&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;overrideEnabled&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;overrideVisibility&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;overrideColor&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;useObjectColor&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;objectColor&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;ghosting&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;castsShadows&quot;</span>);</div>\n\
<div class=\"line\">        fAttrsAffectAppearance.insert(<span class=\"stringliteral\">&quot;receiveShadows&quot;</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Hook model/scene/DG/event callbacks.</span></div>\n\
<div class=\"line\">        fMayaExitingCallback = <a name=\"a51\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_scene_message.html#a44771b834e9a0ad7291ecdcc880106fe\">MSceneMessage::addCallback</a>(</div>\n\
<div class=\"line\">            <a name=\"a52\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_scene_message.html#a4f09127c805cc1f5ee20e67db7b45efaa1efff7ad75eeef5a2ac9e3c0e890dbd0\">MSceneMessage::kMayaExiting</a>, MayaExitingCallback, NULL);</div>\n\
<div class=\"line\">        fSelectionChangedCallback = <a name=\"a53\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_model_message.html#ac4dd423a333cf2a97157987532b36675\">MModelMessage::addCallback</a>(</div>\n\
<div class=\"line\">            <a name=\"a54\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_model_message.html#a4f09127c805cc1f5ee20e67db7b45efaa256632550aa8e279dac1d41927c59d84\">MModelMessage::kActiveListModified</a>, SelectionChangedCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">        fTimeChangeCallback = <a name=\"a55\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_d_g_message.html#a0cf2d487672abd947a5abc89ac788789\">MDGMessage::addTimeChangeCallback</a>(</div>\n\
<div class=\"line\">            TimeChangeCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">        fRenderLayerChangeCallback = <a name=\"a56\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_event_message.html#a8d22c58b90484867755273c2f7ffc6ec\">MEventMessage::addEventCallback</a>(</div>\n\
<div class=\"line\">            <span class=\"stringliteral\">&quot;renderLayerChange&quot;</span>, RenderLayerChangeCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">        fRenderLayerManagerChangeCallback = <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_event_message.html#a8d22c58b90484867755273c2f7ffc6ec\">MEventMessage::addEventCallback</a>(</div>\n\
<div class=\"line\">            <span class=\"stringliteral\">&quot;renderLayerManagerChange&quot;</span>, RenderLayerChangeCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Trigger the callback to initialize the selection list.</span></div>\n\
<div class=\"line\">        selectionChanged();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~ModelCallbacks()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <a name=\"a57\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09\">MMessage::removeCallback</a>(fMayaExitingCallback);</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09\">MMessage::removeCallback</a>(fSelectionChangedCallback);</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09\">MMessage::removeCallback</a>(fTimeChangeCallback);</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09\">MMessage::removeCallback</a>(fRenderLayerChangeCallback);</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09\">MMessage::removeCallback</a>(fRenderLayerManagerChangeCallback);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> registerSubSceneOverride(<span class=\"keyword\">const</span> ShapeNode* shapeNode, SubSceneOverride* subSceneOverride)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(shapeNode);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!shapeNode) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        assert(subSceneOverride);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!subSceneOverride) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Register the MPxSubSceneOverride to receive callbacks.</span></div>\n\
<div class=\"line\">        fShapeNodes.insert(std::make_pair(shapeNode, subSceneOverride));</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> deregisterSubSceneOverride(<span class=\"keyword\">const</span> ShapeNode* shapeNode)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(shapeNode);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!shapeNode) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Deregister the MPxSubSceneOverride.</span></div>\n\
<div class=\"line\">        fShapeNodes.erase(shapeNode);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Detect selection change and dirty SubSceneOverride.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> selectionChanged()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Retrieve the current selection list.</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_list.html\">MSelectionList</a> list;</div>\n\
<div class=\"line\">        <a name=\"a58\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_global.html#a6d81d38246555884897fb153c93aaf42\">MGlobal::getActiveSelectionList</a>(list);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Find all selected gpuCache nodes.</span></div>\n\
<div class=\"line\">        ShapeNodeNameMap currentSelection;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <a name=\"_a59\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a>   dagPath;</div>\n\
<div class=\"line\">        <a name=\"_a60\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_it_dag.html\">MItDag</a>     dagIt;</div>\n\
<div class=\"line\">        <a name=\"_a61\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn_dag_node.html\">MFnDagNode</a> dagNode;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0, size = list.<a name=\"a62\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_list.html#a99dd6a54b909ede1d11702fe58977e2a\">length</a>(); i &lt; size; i++) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (list.<a name=\"a63\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_selection_list.html#a16dda1a34d5f10be257d8421ac6deabd\">getDagPath</a>(i, dagPath) &amp;&amp; dagPath.<a name=\"a64\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#a095ae34296e81703965265a42ee783ca\">isValid</a>()) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// Iterate the DAG to find descendant gpuCache nodes.</span></div>\n\
<div class=\"line\">                dagIt.<a name=\"a65\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_it_dag.html#ac734f26ff1c92ecec3572a31f5e4435c\">reset</a>(dagPath, <a name=\"a66\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_it_dag.html#a1545968b4f810358b53ae9844bce6bd1a6e92a8757afce03be51397f0b518f4c5\">MItDag::kDepthFirst</a>, <a name=\"a67\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ad409ef3c9033402174590389a6ce18ea\">MFn::kPluginShape</a>);</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span> (; !dagIt.<a name=\"a68\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_it_dag.html#a8b6dbf6fbab6f4e7bf50a309124cbf4c\">isDone</a>(); dagIt.<a name=\"a69\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_it_dag.html#a73616f002814b8abe6d921db72d7a496\">next</a>()) {</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (dagNode.<a name=\"a70\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn_dag_node.html#a6b2301b53683a8e8f56dd0b9cb088b0f\">setObject</a>(dagIt.<a name=\"a71\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_it_dag.html#afc1c0d71245e763fc566fc1d67ab06ae\">currentItem</a>()) &amp;&amp; dagNode.<a name=\"a72\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn_dependency_node.html#a1d0bbd4d50dae591f8e003c0aedc8135\">typeId</a>() == ShapeNode::id) {</div>\n\
<div class=\"line\">                        <span class=\"keyword\">const</span> ShapeNode* shapeNode = (<span class=\"keyword\">const</span> ShapeNode*)dagNode.<a name=\"a73\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn_dependency_node.html#a4f2c53c9d1dcf25a6462c70fb25aead1\">userNode</a>();</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">if</span> (shapeNode) {</div>\n\
<div class=\"line\">                            currentSelection.insert(std::make_pair(dagIt.<a name=\"a74\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_it_dag.html#ac4b316731c4019c927aa63731d4749e8\">fullPathName</a>(), shapeNode));</div>\n\
<div class=\"line\">                        }</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Check Active -&gt; Dormant</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> ShapeNodeNameMap::value_type&amp; val : fLastSelection) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (currentSelection.find(val.first) == currentSelection.end()) {</div>\n\
<div class=\"line\">                ShapeNodeSubSceneMap::iterator it = fShapeNodes.find(val.second);</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (it != fShapeNodes.end() &amp;&amp; it-&gt;second) {</div>\n\
<div class=\"line\">                    it-&gt;second-&gt;dirtyEverything();</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Check Dormant -&gt; Active</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> ShapeNodeNameMap::value_type&amp; val : currentSelection) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fLastSelection.find(val.first) == fLastSelection.end()) {</div>\n\
<div class=\"line\">                ShapeNodeSubSceneMap::iterator it = fShapeNodes.find(val.second);</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (it != fShapeNodes.end() &amp;&amp; it-&gt;second) {</div>\n\
<div class=\"line\">                    it-&gt;second-&gt;dirtyEverything();</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        fLastSelection.swap(currentSelection);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Detect time change and dirty SubSceneOverride.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> timeChanged()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(ShapeNodeSubSceneMap::value_type&amp; val : fShapeNodes) {</div>\n\
<div class=\"line\">            val.second-&gt;dirtyVisibility();   <span class=\"comment\">// visibility animation</span></div>\n\
<div class=\"line\">            val.second-&gt;dirtyWorldMatrix();  <span class=\"comment\">// xform animation</span></div>\n\
<div class=\"line\">            val.second-&gt;dirtyStreams();      <span class=\"comment\">// vertex animation</span></div>\n\
<div class=\"line\">            val.second-&gt;dirtyMaterials();    <span class=\"comment\">// material animation</span></div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Detect render layer change and dirty SubSceneOverride.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> renderLayerChanged()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(ShapeNodeSubSceneMap::value_type&amp; val : fShapeNodes) {</div>\n\
<div class=\"line\">            val.second-&gt;dirtyEverything();   <span class=\"comment\">// render layer change is destructive</span></div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> affectAppearance(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp; attr)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> (fAttrsAffectAppearance.find(attr) != fAttrsAffectAppearance.cend());</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keywordtype\">void</span> MayaExitingCallback(<span class=\"keywordtype\">void</span>* clientData)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Free VP2.0 buffers on exit.</span></div>\n\
<div class=\"line\">        BuffersCache::getInstance().clear();</div>\n\
<div class=\"line\">        UnitBoundingBox::clear();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keywordtype\">void</span> SelectionChangedCallback(<span class=\"keywordtype\">void</span>* clientData)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(clientData);</div>\n\
<div class=\"line\">        <span class=\"keyword\">static_cast&lt;</span>ModelCallbacks*<span class=\"keyword\">&gt;</span>(clientData)-&gt;selectionChanged();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keywordtype\">void</span> TimeChangeCallback(<a name=\"_a75\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_time.html\">MTime</a>&amp; time, <span class=\"keywordtype\">void</span>* clientData)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(clientData);</div>\n\
<div class=\"line\">        <span class=\"keyword\">static_cast&lt;</span>ModelCallbacks*<span class=\"keyword\">&gt;</span>(clientData)-&gt;timeChanged();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keywordtype\">void</span> RenderLayerChangeCallback(<span class=\"keywordtype\">void</span>* clientData)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(clientData);</div>\n\
<div class=\"line\">        <span class=\"keyword\">static_cast&lt;</span>ModelCallbacks*<span class=\"keyword\">&gt;</span>(clientData)-&gt;renderLayerChanged();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    MCallbackId fMayaExitingCallback;</div>\n\
<div class=\"line\">    MCallbackId fSelectionChangedCallback;</div>\n\
<div class=\"line\">    MCallbackId fTimeChangeCallback;</div>\n\
<div class=\"line\">    MCallbackId fRenderLayerChangeCallback;</div>\n\
<div class=\"line\">    MCallbackId fRenderLayerManagerChangeCallback;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> std::unordered_map&lt;MString,const ShapeNode*,MStringHash&gt; ShapeNodeNameMap;</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> std::unordered_map&lt;const ShapeNode*,SubSceneOverride*&gt;   ShapeNodeSubSceneMap;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ShapeNodeNameMap     fLastSelection;</div>\n\
<div class=\"line\">    ShapeNodeSubSceneMap fShapeNodes;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::unordered_set&lt;MString, MStringHash&gt; fAttrsAffectAppearance;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Callbacks</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Instance Changed Callback</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> InstanceChangedCallback(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a>&amp; child, <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a>&amp; parent, <span class=\"keywordtype\">void</span>* clientData)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    assert(clientData);</div>\n\
<div class=\"line\">    <span class=\"keyword\">static_cast&lt;</span>SubSceneOverride*<span class=\"keyword\">&gt;</span>(clientData)-&gt;dirtyEverything();</div>\n\
<div class=\"line\">    <span class=\"keyword\">static_cast&lt;</span>SubSceneOverride*<span class=\"keyword\">&gt;</span>(clientData)-&gt;resetDagPaths();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// World Matrix Changed Callback</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> WorldMatrixChangedCallback(<a name=\"_a76\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_object.html\">MObject</a>&amp; transformNode,</div>\n\
<div class=\"line\">    MDagMessage::MatrixModifiedFlags&amp; modified,</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span>* clientData)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    assert(clientData);</div>\n\
<div class=\"line\">    <span class=\"keyword\">static_cast&lt;</span>SubSceneOverride*<span class=\"keyword\">&gt;</span>(clientData)-&gt;dirtyWorldMatrix();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Parent Add/Remove Callback</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> ParentChangedCallback(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a>&amp; child, <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a>&amp; parent, <span class=\"keywordtype\">void</span>* clientData)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// We register node dirty callbacks on all transform parents/ancestors.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// If the parent is changed, we will have to re-register all callbacks.</span></div>\n\
<div class=\"line\">    assert(clientData);</div>\n\
<div class=\"line\">    <span class=\"comment\">// Clear the callbacks on parents.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">static_cast&lt;</span>SubSceneOverride*<span class=\"keyword\">&gt;</span>(clientData)-&gt;clearNodeDirtyCallbacks();</div>\n\
<div class=\"line\">    <span class=\"comment\">// Dirty the render items so we re-register callbacks again in update().</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">static_cast&lt;</span>SubSceneOverride*<span class=\"keyword\">&gt;</span>(clientData)-&gt;dirtyEverything();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Node Dirty Callback</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> NodeDirtyCallback(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_object.html\">MObject</a>&amp; node, <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_plug.html\">MPlug</a>&amp; plug, <span class=\"keywordtype\">void</span>* clientData)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// One of the parent/ancestor has changed.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// Dirty the SubSceneOverride if the attribute will affect</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// the appearance of the gpuCache shape.</span></div>\n\
<div class=\"line\">    assert(clientData);</div>\n\
<div class=\"line\">    <a name=\"_a77\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn_attribute.html\">MFnAttribute</a> attr(plug.<a name=\"a78\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_plug.html#a240c26abf3ba7645371553cb130691fa\">attribute</a>());</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (ModelCallbacks::getInstance().affectAppearance(attr.name())) {</div>\n\
<div class=\"line\">        <span class=\"keyword\">static_cast&lt;</span>SubSceneOverride*<span class=\"keyword\">&gt;</span>(clientData)-&gt;dirtyEverything();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">namespace </span>GPUCache {</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">using namespace </span><a class=\"code\" href=\"#!/url=./cpp_ref/namespace_m_h_w_render.html\">MHWRender</a>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::HardwareInstanceManager</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class resolve the dependency problem between RenderItemWrapper and</span></div>\n\
<div class=\"line\"><span class=\"comment\">// GPUCache::SubSceneOverride.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::HardwareInstanceManager : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    HardwareInstanceManager(SubSceneOverride&amp; subSceneOverride)</div>\n\
<div class=\"line\">        : fImpl(new HardwareInstanceManagerImpl(subSceneOverride))</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~HardwareInstanceManager()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> processInstances(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fImpl-&gt;processInstances(container);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> resetInstances(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fImpl-&gt;resetInstances(container);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> installHardwareInstanceData(RenderItemWrapper::Ptr&amp; renderItem)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!renderItem-&gt;hasHardwareInstanceData()) {</div>\n\
<div class=\"line\">            std::shared_ptr&lt;HardwareInstanceData&gt; data(</div>\n\
<div class=\"line\">                <span class=\"keyword\">new</span> HardwareInstanceData(fImpl.get(), renderItem.get())</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\">            renderItem-&gt;installHardwareInstanceData(data);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> instancePathIndex(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html\">MHWRender::MRenderItem</a>&amp; renderItem, <span class=\"keywordtype\">int</span> hardwareInstanceIndex)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> fImpl-&gt;instancePathIndex(renderItem, hardwareInstanceIndex);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    std::shared_ptr&lt;HardwareInstanceManagerImpl&gt; fImpl;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::HierarchyStat</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class contains the analysis result of the sub-node hierarchy.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::HierarchyStat : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> std::shared_ptr&lt;const HierarchyStat&gt; Ptr;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// This is the status of a sub-node and its descendants.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">struct </span>SubNodeStat</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// False if the sub-node and all its descendants have no visibility animation.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span>   isVisibilityAnimated;</div>\n\
<div class=\"line\">        <span class=\"comment\">// False if the sub-node and all its descendants have no xform animation.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span>   isXformAnimated;</div>\n\
<div class=\"line\">        <span class=\"comment\">// False if the sub-node and all its descendants have no vertices animation.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span>   isShapeAnimated;</div>\n\
<div class=\"line\">        <span class=\"comment\">// False if the sub-node and all its descendants have no diffuse color animation.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span>   isDiffuseColorAnimated;</div>\n\
<div class=\"line\">        <span class=\"comment\">// The next sub-node id if we prune at this sub-node. (depth first, preorder)</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> nextSubNodeIndex;</div>\n\
<div class=\"line\">        <span class=\"comment\">// The next shape sub-node id if we prune at this sub-node. (depth first, preorder)</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> nextShapeSubNodeIndex;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        SubNodeStat()</div>\n\
<div class=\"line\">            : isVisibilityAnimated(false),</div>\n\
<div class=\"line\">              isXformAnimated(false),</div>\n\
<div class=\"line\">              isShapeAnimated(false),</div>\n\
<div class=\"line\">              isDiffuseColorAnimated(false),</div>\n\
<div class=\"line\">              nextSubNodeIndex(0),</div>\n\
<div class=\"line\">              nextShapeSubNodeIndex(0)</div>\n\
<div class=\"line\">        {}</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~HierarchyStat() {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setStat(<span class=\"keywordtype\">size_t</span> subNodeIndex, SubNodeStat&amp; stat)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (subNodeIndex &gt;= fStats.size()) {</div>\n\
<div class=\"line\">            fStats.resize(subNodeIndex+1);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        fStats[subNodeIndex] = stat;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> SubNodeStat&amp; stat(<span class=\"keywordtype\">size_t</span> subNodeIndex)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{ <span class=\"keywordflow\">return</span> fStats[subNodeIndex]; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    HierarchyStat() {}</div>\n\
<div class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class </span>HierarchyStatVisitor;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::vector&lt;SubNodeStat&gt; fStats;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::HierarchyStatVisitor</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class analyzes the sub-node hierarchy to help pruning non-animated sub-hierarchy.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::HierarchyStatVisitor : <span class=\"keyword\">public</span> SubNodeVisitor</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    HierarchyStatVisitor(<span class=\"keyword\">const</span> SubNode::Ptr&amp; geometry)</div>\n\
<div class=\"line\">        : fGeometry(geometry),</div>\n\
<div class=\"line\">          fIsParentVisibilityAnimated(false),</div>\n\
<div class=\"line\">          fIsVisibilityAnimated(false),</div>\n\
<div class=\"line\">          fIsParentXformAnimated(false),</div>\n\
<div class=\"line\">          fIsXformAnimated(false),</div>\n\
<div class=\"line\">          fIsShapeAnimated(false),</div>\n\
<div class=\"line\">          fIsDiffuseColorAnimated(false),</div>\n\
<div class=\"line\">          fSubNodeIndex(0),</div>\n\
<div class=\"line\">          fShapeSubNodeIndex(0)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fHierarchyStat.reset(<span class=\"keyword\">new</span> HierarchyStat());</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~HierarchyStatVisitor()<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> HierarchyStat::Ptr getStat()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{ <span class=\"keywordflow\">return</span> fHierarchyStat; }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> XformData&amp;   xform,</div>\n\
<div class=\"line\">                       <span class=\"keyword\">const</span> SubNode&amp;     subNode)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Increase the sub-node counter.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> thisSubNodeIndex = fSubNodeIndex;</div>\n\
<div class=\"line\">        fSubNodeIndex++;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Is the visibility animated?</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span> isVisibilityAnimated = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (xform.getSamples().size() &gt; 1) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>\n\
<div class=\"line\">                xform.getSamples().begin()-&gt;second;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (sample) {</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span> oneVisibility = sample-&gt;visibility();</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> XformData::SampleMap::value_type&amp; val : xform.getSamples()) {</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (val.second &amp;&amp; val.second-&gt;visibility() != oneVisibility) {</div>\n\
<div class=\"line\">                        isVisibilityAnimated = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Is the xform animated?</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span> isXformAnimated = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (xform.getSamples().size() &gt; 1) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>\n\
<div class=\"line\">                xform.getSamples().begin()-&gt;second;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (sample) {</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a>&amp; oneMatrix = sample-&gt;xform();</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> XformData::SampleMap::value_type&amp; val : xform.getSamples()) {</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (val.second &amp;&amp; val.second-&gt;xform() != oneMatrix) {</div>\n\
<div class=\"line\">                        isXformAnimated = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Push the xform/visibility animated flag down the hierarchy.</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            ScopedGuard&lt;bool&gt; parentVisibilityGuard(fIsParentVisibilityAnimated);</div>\n\
<div class=\"line\">            fIsParentVisibilityAnimated = fIsParentVisibilityAnimated || isVisibilityAnimated;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            ScopedGuard&lt;bool&gt; parentXformGuard(fIsParentXformAnimated);</div>\n\
<div class=\"line\">            fIsParentXformAnimated = fIsParentXformAnimated || isXformAnimated;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Shape animated flags for all descendant shapes.</span></div>\n\
<div class=\"line\">            <span class=\"keywordtype\">bool</span> isShapeAnimated        = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">            <span class=\"keywordtype\">bool</span> isDiffuseColorAnimated = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Recursive calls into children</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> SubNode::Ptr&amp; child : subNode.getChildren()) {</div>\n\
<div class=\"line\">                child-&gt;accept(*<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// Merge shape animated flags.</span></div>\n\
<div class=\"line\">                isVisibilityAnimated   = isVisibilityAnimated   || fIsVisibilityAnimated;</div>\n\
<div class=\"line\">                isXformAnimated        = isXformAnimated        || fIsXformAnimated;</div>\n\
<div class=\"line\">                isShapeAnimated        = isShapeAnimated        || fIsShapeAnimated;</div>\n\
<div class=\"line\">                isDiffuseColorAnimated = isDiffuseColorAnimated || fIsDiffuseColorAnimated;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Pull shape animated flags up the hierarchy.</span></div>\n\
<div class=\"line\">            fIsVisibilityAnimated   = isVisibilityAnimated;</div>\n\
<div class=\"line\">            fIsXformAnimated        = isXformAnimated;</div>\n\
<div class=\"line\">            fIsShapeAnimated        = isShapeAnimated;</div>\n\
<div class=\"line\">            fIsDiffuseColorAnimated = isDiffuseColorAnimated;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        appendStat(thisSubNodeIndex);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> ShapeData&amp;   shape,</div>\n\
<div class=\"line\">                       <span class=\"keyword\">const</span> SubNode&amp;     subNode)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Increase the sub-node counter.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">size_t</span> thisSubNodeIndex = fSubNodeIndex;</div>\n\
<div class=\"line\">        fSubNodeIndex++;</div>\n\
<div class=\"line\">        fShapeSubNodeIndex++;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Is the shape animated ?</span></div>\n\
<div class=\"line\">        fIsShapeAnimated = shape.getSamples().size() &gt; 1;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Is the diffuse color animated?</span></div>\n\
<div class=\"line\">        fIsDiffuseColorAnimated = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fIsShapeAnimated) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>\n\
<div class=\"line\">                shape.getSamples().begin()-&gt;second;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (sample) {</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp; oneColor = sample-&gt;diffuseColor();</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> ShapeData::SampleMap::value_type&amp; val : shape.getSamples()) {</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (val.second &amp;&amp; val.second-&gt;diffuseColor() != oneColor) {</div>\n\
<div class=\"line\">                        fIsDiffuseColorAnimated = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Is the visibility animated?</span></div>\n\
<div class=\"line\">        fIsVisibilityAnimated = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fIsShapeAnimated) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>\n\
<div class=\"line\">                shape.getSamples().begin()-&gt;second;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (sample) {</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span> oneVisibility = sample-&gt;visibility();</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> ShapeData::SampleMap::value_type&amp; val : shape.getSamples()) {</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (val.second &amp;&amp; val.second-&gt;visibility() != oneVisibility) {</div>\n\
<div class=\"line\">                        fIsVisibilityAnimated = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Shape&#39;s xform is not animated..</span></div>\n\
<div class=\"line\">        fIsXformAnimated = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        appendStat(thisSubNodeIndex);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> appendStat(<span class=\"keywordtype\">size_t</span> subNodeIndex)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Record the stat of this sub-node.</span></div>\n\
<div class=\"line\">        HierarchyStat::SubNodeStat stat;</div>\n\
<div class=\"line\">        stat.isVisibilityAnimated   = fIsVisibilityAnimated || fIsParentVisibilityAnimated;</div>\n\
<div class=\"line\">        stat.isXformAnimated        = fIsXformAnimated || fIsParentXformAnimated;</div>\n\
<div class=\"line\">        stat.isShapeAnimated        = fIsShapeAnimated;</div>\n\
<div class=\"line\">        stat.isDiffuseColorAnimated = fIsDiffuseColorAnimated;</div>\n\
<div class=\"line\">        stat.nextSubNodeIndex       = fSubNodeIndex;</div>\n\
<div class=\"line\">        stat.nextShapeSubNodeIndex  = fShapeSubNodeIndex;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        fHierarchyStat-&gt;setStat(subNodeIndex, stat);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> SubNode::Ptr fGeometry;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>               fIsParentVisibilityAnimated;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>               fIsVisibilityAnimated;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>               fIsParentXformAnimated;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>               fIsXformAnimated;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>               fIsShapeAnimated;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>               fIsDiffuseColorAnimated;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">size_t</span>             fSubNodeIndex;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">size_t</span>             fShapeSubNodeIndex;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    std::shared_ptr&lt;HierarchyStat&gt; fHierarchyStat;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::SubNodeRenderItems</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class contains the render items for each sub node.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::SubNodeRenderItems : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> std::shared_ptr&lt;SubNodeRenderItems&gt; Ptr;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    SubNodeRenderItems()</div>\n\
<div class=\"line\">        : fIsBoundingBoxPlaceHolder(false),</div>\n\
<div class=\"line\">          fIsSelected(false),</div>\n\
<div class=\"line\">          fVisibility(true),</div>\n\
<div class=\"line\">          fValidPoly(true)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~SubNodeRenderItems()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateRenderItems(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                           <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;      subNodePrefix,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp;       wireColor,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> ShapeData&amp;    shape,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> SubNode&amp;      subNode,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span>          isSelected)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Get the current shape sample.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>\n\
<div class=\"line\">            shape.getSample(subSceneOverride.getTime());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!sample) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Cache flags</span></div>\n\
<div class=\"line\">        fIsBoundingBoxPlaceHolder = sample-&gt;isBoundingBoxPlaceHolder();</div>\n\
<div class=\"line\">        fIsSelected               = isSelected;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Bounding box place holder.</span></div>\n\
<div class=\"line\">        updateBoundingBoxItems(subSceneOverride, container, subNodePrefix, wireColor, subNode);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Snap points</span></div>\n\
<div class=\"line\">        updateSnappingItems(subSceneOverride, container, subNodePrefix);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Dormant Wireframe</span></div>\n\
<div class=\"line\">        updateDormantWireItems(subSceneOverride, container, subNodePrefix, wireColor);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Active Wireframe</span></div>\n\
<div class=\"line\">        updateActiveWireItems(subSceneOverride, container, subNodePrefix, wireColor);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Shaded</span></div>\n\
<div class=\"line\">        updateShadedItems(subSceneOverride, container, subNodePrefix, shape,</div>\n\
<div class=\"line\">            sample-&gt;diffuseColor(), sample-&gt;numIndexGroups());</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateVisibility(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                          <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                          <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span>          visibility,</div>\n\
<div class=\"line\">                          <span class=\"keyword\">const</span> ShapeData&amp;    shape)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Cache the sub-node visibility flag.</span></div>\n\
<div class=\"line\">        fVisibility = visibility;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Enable or disable render items.</span></div>\n\
<div class=\"line\">        toggleBoundingBoxItem();</div>\n\
<div class=\"line\">        toggleSnappingItem();</div>\n\
<div class=\"line\">        toggleDormantWireItem();</div>\n\
<div class=\"line\">        toggleActiveWireItem();</div>\n\
<div class=\"line\">        toggleShadedItems();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateWorldMatrix(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                           <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a>&amp;      matrix,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> ShapeData&amp;    shape)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Set the world matrix.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fBoundingBoxItem) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>\n\
<div class=\"line\">                shape.getSample(subSceneOverride.getTime());</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (sample) {</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_bounding_box.html\">MBoundingBox</a>&amp; boundingBox = sample-&gt;boundingBox();</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a> worldMatrix =</div>\n\
<div class=\"line\">                    UnitBoundingBox::boundingBoxMatrix(boundingBox) * matrix;</div>\n\
<div class=\"line\">                fBoundingBoxItem-&gt;setWorldMatrix(worldMatrix);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fSnappingItem) {</div>\n\
<div class=\"line\">            fSnappingItem-&gt;setWorldMatrix(matrix);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fDormantWireItem) {</div>\n\
<div class=\"line\">            fDormantWireItem-&gt;setWorldMatrix(matrix);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fActiveWireItem) {</div>\n\
<div class=\"line\">            fActiveWireItem-&gt;setWorldMatrix(matrix);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(RenderItemWrapper::Ptr&amp; shadedItem : fShadedItems) {</div>\n\
<div class=\"line\">            shadedItem-&gt;setWorldMatrix(matrix);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateStreams(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                       <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                       <span class=\"keyword\">const</span> ShapeData&amp;    shape)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>\n\
<div class=\"line\">            shape.getSample(subSceneOverride.getTime());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!sample) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// If this sample is an empty poly, we disable all render items and return.</span></div>\n\
<div class=\"line\">        fValidPoly = sample-&gt;numVerts() &gt; 0 &amp;&amp;</div>\n\
<div class=\"line\">                     sample-&gt;numWires() &gt; 0 &amp;&amp;</div>\n\
<div class=\"line\">                     sample-&gt;numTriangles() &gt; 0 &amp;&amp;</div>\n\
<div class=\"line\">                     sample-&gt;positions();</div>\n\
<div class=\"line\">        <span class=\"comment\">// Enable or disable render items.</span></div>\n\
<div class=\"line\">        toggleBoundingBoxItem();</div>\n\
<div class=\"line\">        toggleSnappingItem();</div>\n\
<div class=\"line\">        toggleDormantWireItem();</div>\n\
<div class=\"line\">        toggleActiveWireItem();</div>\n\
<div class=\"line\">        toggleShadedItems();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fValidPoly) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Nothing to do. Render items are disabled.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fSnappingItem) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// The snapping item is fully sequential and does not</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// require an index buffer.</span></div>\n\
<div class=\"line\">            fSnappingItem-&gt;setBuffers(</div>\n\
<div class=\"line\">                subSceneOverride,</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const IndexBuffer&gt;(),</div>\n\
<div class=\"line\">                sample-&gt;positions(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                sample-&gt;boundingBox()</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the wireframe streams.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fDormantWireItem) {</div>\n\
<div class=\"line\">            fDormantWireItem-&gt;setBuffers(</div>\n\
<div class=\"line\">                subSceneOverride,</div>\n\
<div class=\"line\">                sample-&gt;wireVertIndices(),</div>\n\
<div class=\"line\">                sample-&gt;positions(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                sample-&gt;boundingBox()</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fActiveWireItem) {</div>\n\
<div class=\"line\">            fActiveWireItem-&gt;setBuffers(</div>\n\
<div class=\"line\">                subSceneOverride,</div>\n\
<div class=\"line\">                sample-&gt;wireVertIndices(),</div>\n\
<div class=\"line\">                sample-&gt;positions(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                sample-&gt;boundingBox()</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the shaded streams.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">size_t</span> groupId = 0; groupId &lt; sample-&gt;numIndexGroups(); groupId++) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (groupId &gt;= fShadedItems.size()) <span class=\"keywordflow\">break</span>;  <span class=\"comment\">// background loading</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            assert(fShadedItems[groupId]);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (!fShadedItems[groupId]) <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            fShadedItems[groupId]-&gt;setBuffers(</div>\n\
<div class=\"line\">                subSceneOverride,</div>\n\
<div class=\"line\">                sample-&gt;triangleVertIndices(groupId),</div>\n\
<div class=\"line\">                sample-&gt;positions(),</div>\n\
<div class=\"line\">                sample-&gt;normals(),</div>\n\
<div class=\"line\">                sample-&gt;uvs(),</div>\n\
<div class=\"line\">                sample-&gt;boundingBox()</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateMaterials(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                         <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                         <span class=\"keyword\">const</span> ShapeData&amp;    shape)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>\n\
<div class=\"line\">            shape.getSample(subSceneOverride.getTime());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!sample) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">size_t</span> groupId = 0; groupId &lt; sample-&gt;numIndexGroups(); groupId++) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (groupId &gt;= fShadedItems.size()) <span class=\"keywordflow\">break</span>;  <span class=\"comment\">// background loading</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (groupId &gt;= fSharedDiffuseColorShaders.size()) <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (groupId &gt;= fUniqueDiffuseColorShaders.size()) <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (groupId &gt;= fMaterialShaders.size()) <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            assert(fShadedItems[groupId]);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (!fShadedItems[groupId]) <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// First, check if the shader instance is created from a MaterialGraph.</span></div>\n\
<div class=\"line\">            ShaderInstancePtr shader = fMaterialShaders[groupId];</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// Nothing to do.</span></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Then, check if the shader instance is already unique to the render item.</span></div>\n\
<div class=\"line\">            shader = fUniqueDiffuseColorShaders[groupId];</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">                <span class=\"comment\">// Unique shader instance belongs to this render item.</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// Set the diffuse color directly.</span></div>\n\
<div class=\"line\">                setDiffuseColor(shader.get(), sample-&gt;diffuseColor());</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Then, get a shared shader instance from cache.</span></div>\n\
<div class=\"line\">            shader = ShaderInstanceCache::getInstance().getSharedDiffuseColorShader(</div>\n\
<div class=\"line\">                sample-&gt;diffuseColor());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// If the shared shader instance is different from the existing one,</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// there is diffuse color animation.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// We promote the shared shader instance to a unique shader instance.</span></div>\n\
<div class=\"line\">            assert(fSharedDiffuseColorShaders[groupId]);  <span class=\"comment\">// set in updateRenderItems()</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (shader != fSharedDiffuseColorShaders[groupId]) {</div>\n\
<div class=\"line\">                shader = ShaderInstanceCache::getInstance().getUniqueDiffuseColorShader(</div>\n\
<div class=\"line\">                    sample-&gt;diffuseColor());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                fSharedDiffuseColorShaders[groupId].reset();</div>\n\
<div class=\"line\">                fUniqueDiffuseColorShaders[groupId] = shader;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                fShadedItems[groupId]-&gt;setShader(shader);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateBoundingBoxItems(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                                <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;      subNodePrefix,</div>\n\
<div class=\"line\">                                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp;       wireColor,</div>\n\
<div class=\"line\">                                <span class=\"keyword\">const</span> SubNode&amp;      subNode)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// This shape is no longer a bounding box place holder.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fBoundingBoxItem) {</div>\n\
<div class=\"line\">                fBoundingBoxItem-&gt;removeFromContainer(container);</div>\n\
<div class=\"line\">                fBoundingBoxItem.reset();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Bounding box place holder render item.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fBoundingBoxItem) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Create the bounding box render item.</span></div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> boundingBoxItemName = subNodePrefix + <span class=\"stringliteral\">&quot;:boundingBox&quot;</span>;</div>\n\
<div class=\"line\">            fBoundingBoxItem.reset(<span class=\"keyword\">new</span> RenderItemWrapper(</div>\n\
<div class=\"line\">                boundingBoxItemName,</div>\n\
<div class=\"line\">                MRenderItem::NonMaterialSceneItem,</div>\n\
<div class=\"line\">                MGeometry::kLines</div>\n\
<div class=\"line\">            ));</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setDrawMode((<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3\">MGeometry::DrawMode</a>)(MGeometry::kWireframe | MGeometry::kShaded | MGeometry::kTextured));</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setDepthPriority(MRenderItem::sDormantWireDepthPriority);</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setCompatibleWithMayaInstancer(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Set the shader so that we can fill the geometry data.</span></div>\n\
<div class=\"line\">            ShaderInstancePtr boundingBoxShader = </div>\n\
<div class=\"line\">                ShaderInstanceCache::getInstance().getSharedBoundingBoxPlaceHolderShader(wireColor);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (boundingBoxShader) {</div>\n\
<div class=\"line\">                fBoundingBoxItem-&gt;setShader(boundingBoxShader);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Add to the container.</span></div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;addToContainer(container);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Set unit bounding box buffer.</span></div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setBuffers(</div>\n\
<div class=\"line\">                subSceneOverride,</div>\n\
<div class=\"line\">                UnitBoundingBox::indices(),</div>\n\
<div class=\"line\">                UnitBoundingBox::positions(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                UnitBoundingBox::boundingBox()</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Add a custom data to indicate the sub-node.</span></div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setCustomData(</div>\n\
<div class=\"line\">                std::make_shared&lt;SubNodeUserData&gt;(subNode)</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update shader color.</span></div>\n\
<div class=\"line\">        ShaderInstancePtr boundingBoxShader = </div>\n\
<div class=\"line\">            ShaderInstanceCache::getInstance().getSharedBoundingBoxPlaceHolderShader(wireColor);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (boundingBoxShader) {</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setShader(boundingBoxShader);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        toggleBoundingBoxItem();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateSnappingItems(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                                <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;      subNodePrefix)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// This shape is a bounding box place holder.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fSnappingItem) fSnappingItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update snapping item.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fSnappingItem) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Create the snapping render item.</span></div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> snappingItemName = subNodePrefix + <span class=\"stringliteral\">&quot;:snapping&quot;</span>;</div>\n\
<div class=\"line\">            fSnappingItem.reset(<span class=\"keyword\">new</span> RenderItemWrapper(</div>\n\
<div class=\"line\">                snappingItemName,</div>\n\
<div class=\"line\">                MRenderItem::DecorationItem,</div>\n\
<div class=\"line\">                MGeometry::kPoints</div>\n\
<div class=\"line\">            ));</div>\n\
<div class=\"line\">            fSnappingItem-&gt;setDrawMode(<a name=\"a79\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a3b28d66a728ec358f3aae323b2c24fa9\">MHWRender::MGeometry::kSelectionOnly</a>);</div>\n\
<div class=\"line\">            fSnappingItem-&gt;setDepthPriority(MRenderItem::sSelectionDepthPriority);</div>\n\
<div class=\"line\">            fSnappingItem-&gt;setSnappingSelectionMask();</div>\n\
<div class=\"line\">            fSnappingItem-&gt;setCompatibleWithMayaInstancer(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Add to the container</span></div>\n\
<div class=\"line\">            fSnappingItem-&gt;addToContainer(container);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Hardware instancing.</span></div>\n\
<div class=\"line\">        std::shared_ptr&lt;HardwareInstanceManager&gt;&amp; hwInstanceManager = </div>\n\
<div class=\"line\">            subSceneOverride.hardwareInstanceManager();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (hwInstanceManager) {</div>\n\
<div class=\"line\">            hwInstanceManager-&gt;installHardwareInstanceData(fSnappingItem);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        toggleSnappingItem();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Snapping item is never displayed.</span></div>\n\
<div class=\"line\">        ShaderInstancePtr snappingShader = ShaderInstanceCache::getInstance().getSharedPointShader();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (snappingShader) {</div>\n\
<div class=\"line\">            fSnappingItem-&gt;setShader(snappingShader);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateDormantWireItems(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                                <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;      subNodePrefix,</div>\n\
<div class=\"line\">                                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp;       wireColor)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// This shape is a bounding box place holder.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fDormantWireItem) fDormantWireItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update dormant wireframe item.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fDormantWireItem) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Create the dormant wireframe render item.</span></div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> dormantWireItemName = subNodePrefix + <span class=\"stringliteral\">&quot;:dormantWire&quot;</span>;</div>\n\
<div class=\"line\">            fDormantWireItem.reset(<span class=\"keyword\">new</span> RenderItemWrapper(</div>\n\
<div class=\"line\">                dormantWireItemName,</div>\n\
<div class=\"line\">                MRenderItem::DecorationItem,</div>\n\
<div class=\"line\">                MGeometry::kLines</div>\n\
<div class=\"line\">            ));</div>\n\
<div class=\"line\">            fDormantWireItem-&gt;setDrawMode(MGeometry::kWireframe);</div>\n\
<div class=\"line\">            fDormantWireItem-&gt;setDepthPriority(MRenderItem::sDormantWireDepthPriority);</div>\n\
<div class=\"line\">            fDormantWireItem-&gt;setCompatibleWithMayaInstancer(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Add to the container</span></div>\n\
<div class=\"line\">            fDormantWireItem-&gt;addToContainer(container);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Hardware instancing.</span></div>\n\
<div class=\"line\">        std::shared_ptr&lt;HardwareInstanceManager&gt;&amp; hwInstanceManager = </div>\n\
<div class=\"line\">            subSceneOverride.hardwareInstanceManager();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (hwInstanceManager) {</div>\n\
<div class=\"line\">            hwInstanceManager-&gt;installHardwareInstanceData(fDormantWireItem);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        toggleDormantWireItem();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Dormant wireframe color.</span></div>\n\
<div class=\"line\">        ShaderInstancePtr dormantWireShader =</div>\n\
<div class=\"line\">            (DisplayPref::wireframeOnShadedMode() == DisplayPref::kWireframeOnShadedFull)</div>\n\
<div class=\"line\">            ? ShaderInstanceCache::getInstance().getSharedWireShader(wireColor)</div>\n\
<div class=\"line\">            : ShaderInstanceCache::getInstance().getSharedWireShaderWithCB(wireColor);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (dormantWireShader) {</div>\n\
<div class=\"line\">            fDormantWireItem-&gt;setShader(dormantWireShader);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateActiveWireItems(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                               <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                               <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;      subNodePrefix,</div>\n\
<div class=\"line\">                               <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp;       wireColor)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// This shape is a bounding box place holder or unselected.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fActiveWireItem)  fActiveWireItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fActiveWireItem) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Create the active wireframe render item.</span></div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> activeWireItemName = subNodePrefix + <span class=\"stringliteral\">&quot;:activeWire&quot;</span>;</div>\n\
<div class=\"line\">            fActiveWireItem.reset(<span class=\"keyword\">new</span> RenderItemWrapper(</div>\n\
<div class=\"line\">                activeWireItemName,</div>\n\
<div class=\"line\">                MRenderItem::DecorationItem,</div>\n\
<div class=\"line\">                MGeometry::kLines</div>\n\
<div class=\"line\">            ));</div>\n\
<div class=\"line\">            fActiveWireItem-&gt;setDrawMode((<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3\">MGeometry::DrawMode</a>)(MGeometry::kWireframe | MGeometry::kShaded | MGeometry::kTextured));</div>\n\
<div class=\"line\">            fActiveWireItem-&gt;setDepthPriority(MRenderItem::sActiveWireDepthPriority);</div>\n\
<div class=\"line\">            fActiveWireItem-&gt;setCompatibleWithMayaInstancer(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Add to the container.</span></div>\n\
<div class=\"line\">            fActiveWireItem-&gt;addToContainer(container);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Hardware instancing.</span></div>\n\
<div class=\"line\">        std::shared_ptr&lt;HardwareInstanceManager&gt;&amp; hwInstanceManager = </div>\n\
<div class=\"line\">            subSceneOverride.hardwareInstanceManager();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (hwInstanceManager) {</div>\n\
<div class=\"line\">            hwInstanceManager-&gt;installHardwareInstanceData(fActiveWireItem);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        toggleActiveWireItem();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Active wireframe color.</span></div>\n\
<div class=\"line\">        ShaderInstancePtr activeWireShader =</div>\n\
<div class=\"line\">            (DisplayPref::wireframeOnShadedMode() == DisplayPref::kWireframeOnShadedFull)</div>\n\
<div class=\"line\">            ? ShaderInstanceCache::getInstance().getSharedWireShader(wireColor)</div>\n\
<div class=\"line\">            : ShaderInstanceCache::getInstance().getSharedWireShaderWithCB(wireColor);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (activeWireShader) {</div>\n\
<div class=\"line\">            fActiveWireItem-&gt;setShader(activeWireShader);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateShadedItems(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                           <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;      subNodePrefix,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> ShapeData&amp;    shape,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp;       diffuseColor,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> <span class=\"keywordtype\">size_t</span>        nbIndexGroups)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Shaded render items.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// This shape is a bounding box place holder.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span>(RenderItemWrapper::Ptr&amp; item : fShadedItems) {</div>\n\
<div class=\"line\">                item-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fShadedItems.empty()) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Create a render item for each index group.</span></div>\n\
<div class=\"line\">            fShadedItems.reserve(nbIndexGroups);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Each render item has an associated MShaderInstance.</span></div>\n\
<div class=\"line\">            fSharedDiffuseColorShaders.reserve(nbIndexGroups);</div>\n\
<div class=\"line\">            fUniqueDiffuseColorShaders.reserve(nbIndexGroups);</div>\n\
<div class=\"line\">            fMaterialShaders.reserve(nbIndexGroups);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">size_t</span> groupId = 0; groupId &lt; nbIndexGroups; groupId++) {</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> shadedItemName = subNodePrefix + <span class=\"stringliteral\">&quot;:shaded&quot;</span> + (int)groupId;</div>\n\
<div class=\"line\">                RenderItemWrapper::Ptr renderItem(<span class=\"keyword\">new</span> RenderItemWrapper(</div>\n\
<div class=\"line\">                    shadedItemName,</div>\n\
<div class=\"line\">                    MRenderItem::MaterialSceneItem,</div>\n\
<div class=\"line\">                    MGeometry::kTriangles</div>\n\
<div class=\"line\">                ));</div>\n\
<div class=\"line\">                renderItem-&gt;setDrawMode((<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3\">MGeometry::DrawMode</a>)(MGeometry::kShaded | MGeometry::kTextured));</div>\n\
<div class=\"line\">                renderItem-&gt;setExcludedFromPostEffects(<span class=\"keyword\">false</span>);  <span class=\"comment\">// SSAO, etc..</span></div>\n\
<div class=\"line\">                renderItem-&gt;setCompatibleWithMayaInstancer(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\">                fShadedItems.push_back(renderItem);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// Check if we have any material that is assigned to this index group.</span></div>\n\
<div class=\"line\">                ShaderInstancePtr shader;</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> std::vector&lt;MString&gt;&amp;  materialsAssignment = shape.getMaterials();</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> MaterialGraphMap::Ptr&amp; materials = subSceneOverride.getMaterial();</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (materials &amp;&amp; groupId &lt; materialsAssignment.size()) {</div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> MaterialGraph::Ptr graph = materials-&gt;find(materialsAssignment[groupId]);</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (graph) {</div>\n\
<div class=\"line\">                        shader = ShaderInstanceCache::getInstance().getSharedShadedMaterialShader(</div>\n\
<div class=\"line\">                            graph, subSceneOverride.getTime()</div>\n\
<div class=\"line\">                        );</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (shader) {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// We have successfully created a material shader.</span></div>\n\
<div class=\"line\">                    renderItem-&gt;setShader(shader);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                    fMaterialShaders.push_back(shader);</div>\n\
<div class=\"line\">                    fSharedDiffuseColorShaders.push_back(ShaderInstancePtr());</div>\n\
<div class=\"line\">                    fUniqueDiffuseColorShaders.push_back(ShaderInstancePtr());</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// There is no materials. Fallback to diffuse color.</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                    <span class=\"comment\">// Let&#39;s assume that the diffuse color is not animated at beginning.</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// If the diffuse color changes, we will promote the shared shader to</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// a unique shader.</span></div>\n\
<div class=\"line\">                    ShaderInstancePtr sharedShader =</div>\n\
<div class=\"line\">                        ShaderInstanceCache::getInstance().getSharedDiffuseColorShader(diffuseColor);</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (sharedShader) {</div>\n\
<div class=\"line\">                        renderItem-&gt;setShader(sharedShader);</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                    fMaterialShaders.push_back(ShaderInstancePtr());</div>\n\
<div class=\"line\">                    fSharedDiffuseColorShaders.push_back(sharedShader);</div>\n\
<div class=\"line\">                    fUniqueDiffuseColorShaders.push_back(ShaderInstancePtr());</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// Add to the container.</span></div>\n\
<div class=\"line\">                renderItem-&gt;addToContainer(container);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Check if we can cast/receive shadows and hardware instancing.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span> castsShadows   = subSceneOverride.castsShadows();</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span> receiveShadows = subSceneOverride.receiveShadows();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(RenderItemWrapper::Ptr&amp; renderItem : fShadedItems) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Set Casts Shadows and Receives Shadows.</span></div>\n\
<div class=\"line\">            renderItem-&gt;setCastsShadows(castsShadows);</div>\n\
<div class=\"line\">            renderItem-&gt;setReceivesShadows(receiveShadows);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Hardware instancing.</span></div>\n\
<div class=\"line\">            std::shared_ptr&lt;HardwareInstanceManager&gt;&amp; hwInstanceManager = </div>\n\
<div class=\"line\">                subSceneOverride.hardwareInstanceManager();</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (hwInstanceManager &amp;&amp; renderItem-&gt;shader() &amp;&amp; !renderItem-&gt;shader()-&gt;isTransparent()) {</div>\n\
<div class=\"line\">                hwInstanceManager-&gt;installHardwareInstanceData(renderItem);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        toggleShadedItems();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Enable or disable bounding box place holder item.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> toggleBoundingBoxItem()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fBoundingBoxItem) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">                fBoundingBoxItem-&gt;setEnabled(fVisibility);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                fBoundingBoxItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Enable or disable snapping item.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> toggleSnappingItem()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fSnappingItem) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">                fSnappingItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                fSnappingItem-&gt;setEnabled(fVisibility &amp;&amp; fValidPoly);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Enable or disable dormant wireframe item.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> toggleDormantWireItem()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fDormantWireItem) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">                fDormantWireItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                fDormantWireItem-&gt;setEnabled(fVisibility &amp;&amp; fValidPoly &amp;&amp; !fIsSelected);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Enable or disable active wireframe item.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> toggleActiveWireItem()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fActiveWireItem) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">                fActiveWireItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                fActiveWireItem-&gt;setEnabled(fVisibility &amp;&amp; fValidPoly &amp;&amp; fIsSelected);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Enable or disable shaded items.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> toggleShadedItems()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(RenderItemWrapper::Ptr&amp; shadedItem : fShadedItems) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fIsBoundingBoxPlaceHolder) {</div>\n\
<div class=\"line\">                shadedItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">                shadedItem-&gt;setEnabled(fVisibility &amp;&amp; fValidPoly);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> hideRenderItems()</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Simply disable all render items.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fActiveWireItem) {</div>\n\
<div class=\"line\">            fActiveWireItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fDormantWireItem) {</div>\n\
<div class=\"line\">            fDormantWireItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fSnappingItem) {</div>\n\
<div class=\"line\">            fSnappingItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fBoundingBoxItem) {</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(RenderItemWrapper::Ptr&amp; item : fShadedItems) {</div>\n\
<div class=\"line\">            item-&gt;setEnabled(<span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> destroyRenderItems(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Destroy all render items.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fActiveWireItem) {</div>\n\
<div class=\"line\">            fActiveWireItem-&gt;removeFromContainer(container);</div>\n\
<div class=\"line\">            fActiveWireItem.reset();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fDormantWireItem) {</div>\n\
<div class=\"line\">            fDormantWireItem-&gt;removeFromContainer(container);</div>\n\
<div class=\"line\">            fDormantWireItem.reset();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fSnappingItem) {</div>\n\
<div class=\"line\">            fSnappingItem-&gt;removeFromContainer(container);</div>\n\
<div class=\"line\">            fSnappingItem.reset();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fBoundingBoxItem) {</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;removeFromContainer(container);</div>\n\
<div class=\"line\">            fBoundingBoxItem.reset();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(RenderItemWrapper::Ptr&amp; item : fShadedItems) {</div>\n\
<div class=\"line\">            item-&gt;removeFromContainer(container);</div>\n\
<div class=\"line\">            item.reset();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        fShadedItems.clear();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"comment\">// Render items for this sub-node.</span></div>\n\
<div class=\"line\">    RenderItemWrapper::Ptr               fBoundingBoxItem;</div>\n\
<div class=\"line\">    RenderItemWrapper::Ptr               fActiveWireItem;</div>\n\
<div class=\"line\">    RenderItemWrapper::Ptr               fDormantWireItem;</div>\n\
<div class=\"line\">    RenderItemWrapper::Ptr               fSnappingItem;</div>\n\
<div class=\"line\">    std::vector&lt;RenderItemWrapper::Ptr&gt;  fShadedItems;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// The following flags control the enable/disable state of render items.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> fIsBoundingBoxPlaceHolder; <span class=\"comment\">// The sub-node has not been loaded.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> fIsSelected;               <span class=\"comment\">// Selection state for this sub-node.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> fVisibility;               <span class=\"comment\">// Visibility for this sub-node.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> fValidPoly;                <span class=\"comment\">// False if the poly has 0 vertices.</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Shader instances for shaded render items.</span></div>\n\
<div class=\"line\">    std::vector&lt;ShaderInstancePtr&gt;  fSharedDiffuseColorShaders;</div>\n\
<div class=\"line\">    std::vector&lt;ShaderInstancePtr&gt;  fUniqueDiffuseColorShaders;</div>\n\
<div class=\"line\">    std::vector&lt;ShaderInstancePtr&gt;  fMaterialShaders;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::UpdateRenderItemsVisitor</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Update the render items.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::UpdateRenderItemsVisitor : <span class=\"keyword\">public</span> SubNodeVisitor</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    UpdateRenderItemsVisitor(SubSceneOverride&amp;      subSceneOverride,</div>\n\
<div class=\"line\">                             <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;    container,</div>\n\
<div class=\"line\">                             <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;         instancePrefix,</div>\n\
<div class=\"line\">                             <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp;          wireColor,</div>\n\
<div class=\"line\">                             <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span>             isSelected,</div>\n\
<div class=\"line\">                             SubNodeRenderItemList&amp; subNodeItems)</div>\n\
<div class=\"line\">        : fSubSceneOverride(subSceneOverride),</div>\n\
<div class=\"line\">          fContainer(container),</div>\n\
<div class=\"line\">          fWireColor(wireColor),</div>\n\
<div class=\"line\">          fIsSelected(isSelected),</div>\n\
<div class=\"line\">          fSubNodeItems(subNodeItems),</div>\n\
<div class=\"line\">          fLongName(instancePrefix),</div>\n\
<div class=\"line\">          fSubNodeIndex(0)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~UpdateRenderItemsVisitor()<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> XformData&amp;   xform,</div>\n\
<div class=\"line\">                       <span class=\"keyword\">const</span> SubNode&amp;     subNode)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// We use the hierarchical name to represent the unique render item name.</span></div>\n\
<div class=\"line\">        ScopedGuard&lt;MString&gt; longNameGuard(fLongName);</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span> isTop = subNode.getParents().empty() &amp;&amp; subNode.getName() == <span class=\"stringliteral\">&quot;|&quot;</span>;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!isTop) {</div>\n\
<div class=\"line\">            fLongName += <span class=\"stringliteral\">&quot;|&quot;</span>;</div>\n\
<div class=\"line\">            fLongName += subNode.getName();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Recursive calls into children</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> SubNode::Ptr&amp; child : subNode.getChildren()) {</div>\n\
<div class=\"line\">            child-&gt;accept(*<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> ShapeData&amp;   shape,</div>\n\
<div class=\"line\">                       <span class=\"keyword\">const</span> SubNode&amp;     subNode)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// We use the hierarchical name to represent the unique render item name.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> prevName = fLongName;</div>\n\
<div class=\"line\">        fLongName += <span class=\"stringliteral\">&quot;|&quot;</span>;</div>\n\
<div class=\"line\">        fLongName += subNode.getName();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update render items for this sub-node.</span></div>\n\
<div class=\"line\">        updateRenderItems(shape, subNode);</div>\n\
<div class=\"line\">        fSubNodeIndex++;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Restore to the previous name.</span></div>\n\
<div class=\"line\">        fLongName = prevName;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateRenderItems(<span class=\"keyword\">const</span> ShapeData&amp; shape, <span class=\"keyword\">const</span> SubNode&amp; subNode)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Create new sub-node render items.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fSubNodeIndex &gt;= fSubNodeItems.size()) {</div>\n\
<div class=\"line\">            fSubNodeItems.push_back(std::make_shared&lt;SubNodeRenderItems&gt;());</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the render items for this sub-node.</span></div>\n\
<div class=\"line\">        fSubNodeItems[fSubNodeIndex]-&gt;updateRenderItems(</div>\n\
<div class=\"line\">            fSubSceneOverride,</div>\n\
<div class=\"line\">            fContainer,</div>\n\
<div class=\"line\">            fLongName,</div>\n\
<div class=\"line\">            fWireColor,</div>\n\
<div class=\"line\">            shape,</div>\n\
<div class=\"line\">            subNode,</div>\n\
<div class=\"line\">            fIsSelected</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    SubSceneOverride&amp;      fSubSceneOverride;</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;    fContainer;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a>&amp;          fWireColor;</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span>             fIsSelected;</div>\n\
<div class=\"line\">    SubNodeRenderItemList&amp; fSubNodeItems;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> fLongName;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">size_t</span>  fSubNodeIndex;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::UpdateVisitorWithPrune</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class is a visitor for the sub-node hierarchy and allowing to prune</span></div>\n\
<div class=\"line\"><span class=\"comment\">// a sub part of it.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Curiously recurring template pattern.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// The derived class should implement the following two methods:</span></div>\n\
<div class=\"line\"><span class=\"comment\">//</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Test if this sub-node and its descendants can be pruned.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// bool canPrune(const HierarchyStat::SubNodeStat&amp; stat);</span></div>\n\
<div class=\"line\"><span class=\"comment\">//</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Update the shape sub-node.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// void update(const ShapeData&amp;         shape,</span></div>\n\
<div class=\"line\"><span class=\"comment\">//             const SubNode&amp;           subNode,</span></div>\n\
<div class=\"line\"><span class=\"comment\">//             SubNodeRenderItems::Ptr&amp; subNodeItems);</span></div>\n\
<div class=\"line\"><span class=\"comment\">//</span></div>\n\
<div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DERIVED&gt;</div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::UpdateVisitorWithPrune : <span class=\"keyword\">public</span> SubNodeVisitor</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    UpdateVisitorWithPrune(SubSceneOverride&amp;      subSceneOverride,</div>\n\
<div class=\"line\">                           <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;    container,</div>\n\
<div class=\"line\">                           SubNodeRenderItemList&amp; subNodeItems)</div>\n\
<div class=\"line\">        : fSubSceneOverride(subSceneOverride),</div>\n\
<div class=\"line\">          fContainer(container),</div>\n\
<div class=\"line\">          fSubNodeItems(subNodeItems),</div>\n\
<div class=\"line\">          fDontPrune(false),</div>\n\
<div class=\"line\">          fTraverseInvisible(false),</div>\n\
<div class=\"line\">          fSubNodeIndex(0),</div>\n\
<div class=\"line\">          fShapeSubNodeIndex(0)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~UpdateVisitorWithPrune()<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Disable prune.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setDontPrune(<span class=\"keywordtype\">bool</span> dontPrune)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fDontPrune = dontPrune;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Traverse invisible sub-nodes.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> setTraverseInvisible(<span class=\"keywordtype\">bool</span> traverseInvisible)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        fTraverseInvisible = traverseInvisible;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> XformData&amp;   xform,</div>\n\
<div class=\"line\">                       <span class=\"keyword\">const</span> SubNode&amp;     subNode)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Try to prune this sub-hierarchy.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> HierarchyStat::Ptr&amp; hierarchyStat = fSubSceneOverride.getHierarchyStat();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (hierarchyStat) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> HierarchyStat::SubNodeStat&amp; stat = hierarchyStat-&gt;stat(fSubNodeIndex);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (!fDontPrune) {</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (static_cast&lt;DERIVED*&gt;(<span class=\"keyword\">this</span>)-&gt;canPrune(stat)) {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// Prune this sub-hierarchy.</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// Fast-forward to the next sub-node.</span></div>\n\
<div class=\"line\">                    fSubNodeIndex      = stat.nextSubNodeIndex;</div>\n\
<div class=\"line\">                    fShapeSubNodeIndex = stat.nextShapeSubNodeIndex;</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> (!fTraverseInvisible) {</div>\n\
<div class=\"line\">                    <span class=\"keyword\">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>\n\
<div class=\"line\">                        xform.getSample(fSubSceneOverride.getTime());</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> (sample &amp;&amp; !sample-&gt;visibility()) {</div>\n\
<div class=\"line\">                        <span class=\"comment\">// Invisible sub-node. Prune this sub-hierarchy.</span></div>\n\
<div class=\"line\">                        <span class=\"comment\">// Fast-forward to the next sub-node.</span></div>\n\
<div class=\"line\">                        fSubNodeIndex      = stat.nextSubNodeIndex;</div>\n\
<div class=\"line\">                        fShapeSubNodeIndex = stat.nextShapeSubNodeIndex;</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        fSubNodeIndex++;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Recursive calls into children.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(<span class=\"keyword\">const</span> SubNode::Ptr&amp; child : subNode.getChildren()) {</div>\n\
<div class=\"line\">            child-&gt;accept(*<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> ShapeData&amp;   shape,</div>\n\
<div class=\"line\">                       <span class=\"keyword\">const</span> SubNode&amp;     subNode)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the sub-node.</span></div>\n\
<div class=\"line\">        assert(fShapeSubNodeIndex &lt; fSubNodeItems.size());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fShapeSubNodeIndex &lt; fSubNodeItems.size()) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">static_cast&lt;</span>DERIVED*<span class=\"keyword\">&gt;</span>(<span class=\"keyword\">this</span>)-&gt;update(shape, subNode, fSubNodeItems[fShapeSubNodeIndex]);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        fSubNodeIndex++;</div>\n\
<div class=\"line\">        fShapeSubNodeIndex++;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">protected</span>:</div>\n\
<div class=\"line\">    SubSceneOverride&amp;      fSubSceneOverride;</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;    fContainer;</div>\n\
<div class=\"line\">    SubNodeRenderItemList&amp; fSubNodeItems;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                   fDontPrune;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                   fTraverseInvisible;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">size_t</span>  fSubNodeIndex;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">size_t</span>  fShapeSubNodeIndex;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::UpdateVisibilityVisitor</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Update the visibility.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::UpdateVisibilityVisitor :</div>\n\
<div class=\"line\">    <span class=\"keyword\">public</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateVisibilityVisitor&gt;</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateVisibilityVisitor&gt; ParentClass;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    UpdateVisibilityVisitor(SubSceneOverride&amp;      subSceneOverride,</div>\n\
<div class=\"line\">                            <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;    container,</div>\n\
<div class=\"line\">                            SubNodeRenderItemList&amp; subNodeItems,</div>\n\
<div class=\"line\">                            <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span>             outOfViewFrustum)</div>\n\
<div class=\"line\">        : ParentClass(subSceneOverride, container, subNodeItems),</div>\n\
<div class=\"line\">          fVisibility(!outOfViewFrustum)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// The visibility visitor should always traverse into invisible sub-nodes</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// because we have to disable the render items for these invisible sub-nodes.</span></div>\n\
<div class=\"line\">        setTraverseInvisible(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~UpdateVisibilityVisitor()<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> canPrune(<span class=\"keyword\">const</span> HierarchyStat::SubNodeStat&amp; stat)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> !stat.isVisibilityAnimated;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> update(<span class=\"keyword\">const</span> ShapeData&amp;         shape,</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> SubNode&amp;           subNode,</div>\n\
<div class=\"line\">                SubNodeRenderItems::Ptr&amp; subNodeItems)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Get the shape sample.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>\n\
<div class=\"line\">            shape.getSample(fSubSceneOverride.getTime());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!sample) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Shape visibility.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span> visibility = fVisibility &amp;&amp; sample-&gt;visibility();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        subNodeItems-&gt;updateVisibility(</div>\n\
<div class=\"line\">            fSubSceneOverride,</div>\n\
<div class=\"line\">            fContainer,</div>\n\
<div class=\"line\">            visibility,</div>\n\
<div class=\"line\">            shape</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> XformData&amp;   xform,</div>\n\
<div class=\"line\">                       <span class=\"keyword\">const</span> SubNode&amp;     subNode)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Get the xform sample.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>\n\
<div class=\"line\">            xform.getSample(fSubSceneOverride.getTime());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!sample) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Push visibility.</span></div>\n\
<div class=\"line\">        ScopedGuard&lt;bool&gt; guard(fVisibility);</div>\n\
<div class=\"line\">        fVisibility = fVisibility &amp;&amp; sample-&gt;visibility();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        ParentClass::visit(xform, subNode);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> fVisibility;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::UpdateWorldMatrixVisitor</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Update the world matrices.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::UpdateWorldMatrixVisitor :</div>\n\
<div class=\"line\">    <span class=\"keyword\">public</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateWorldMatrixVisitor&gt;</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateWorldMatrixVisitor&gt; ParentClass;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    UpdateWorldMatrixVisitor(SubSceneOverride&amp;      subSceneOverride,</div>\n\
<div class=\"line\">                             <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;    container,</div>\n\
<div class=\"line\">                             <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a>&amp;         dagMatrix,</div>\n\
<div class=\"line\">                             SubNodeRenderItemList&amp; subNodeItems)</div>\n\
<div class=\"line\">        : ParentClass(subSceneOverride, container, subNodeItems),</div>\n\
<div class=\"line\">          fMatrix(dagMatrix)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~UpdateWorldMatrixVisitor()<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> canPrune(<span class=\"keyword\">const</span> HierarchyStat::SubNodeStat&amp; stat)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> !stat.isXformAnimated;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> update(<span class=\"keyword\">const</span> ShapeData&amp;         shape,</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> SubNode&amp;           subNode,</div>\n\
<div class=\"line\">                SubNodeRenderItems::Ptr&amp; subNodeItems)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        subNodeItems-&gt;updateWorldMatrix(</div>\n\
<div class=\"line\">            fSubSceneOverride,</div>\n\
<div class=\"line\">            fContainer,</div>\n\
<div class=\"line\">            fMatrix,</div>\n\
<div class=\"line\">            shape</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> visit(<span class=\"keyword\">const</span> XformData&amp;   xform,</div>\n\
<div class=\"line\">                       <span class=\"keyword\">const</span> SubNode&amp;     subNode)<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{</div>\n\
<div class=\"line\">        <span class=\"comment\">// Get the xform sample.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>\n\
<div class=\"line\">            xform.getSample(fSubSceneOverride.getTime());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!sample) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Push matrix.</span></div>\n\
<div class=\"line\">        ScopedGuard&lt;MMatrix&gt; guard(fMatrix);</div>\n\
<div class=\"line\">        fMatrix = sample-&gt;xform() * fMatrix;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        ParentClass::visit(xform, subNode);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a> fMatrix;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::UpdateStreamsVisitor</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Update the streams.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::UpdateStreamsVisitor :</div>\n\
<div class=\"line\">    <span class=\"keyword\">public</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateStreamsVisitor&gt;</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateStreamsVisitor&gt; ParentClass;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    UpdateStreamsVisitor(SubSceneOverride&amp;      subSceneOverride,</div>\n\
<div class=\"line\">                         <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;    container,</div>\n\
<div class=\"line\">                         SubNodeRenderItemList&amp; subNodeItems)</div>\n\
<div class=\"line\">        : ParentClass(subSceneOverride, container, subNodeItems)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~UpdateStreamsVisitor()<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> canPrune(<span class=\"keyword\">const</span> HierarchyStat::SubNodeStat&amp; stat)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> !stat.isShapeAnimated;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> update(<span class=\"keyword\">const</span> ShapeData&amp;         shape,</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> SubNode&amp;           subNode,</div>\n\
<div class=\"line\">                SubNodeRenderItems::Ptr&amp; subNodeItems)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        subNodeItems-&gt;updateStreams(</div>\n\
<div class=\"line\">            fSubSceneOverride,</div>\n\
<div class=\"line\">            fContainer,</div>\n\
<div class=\"line\">            shape</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::UpdateDiffuseColorVisitor</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Update the streams.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::UpdateDiffuseColorVisitor :</div>\n\
<div class=\"line\">    <span class=\"keyword\">public</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateDiffuseColorVisitor&gt;</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateDiffuseColorVisitor&gt; ParentClass;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    UpdateDiffuseColorVisitor(SubSceneOverride&amp;      subSceneOverride,</div>\n\
<div class=\"line\">                              <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;    container,</div>\n\
<div class=\"line\">                              SubNodeRenderItemList&amp; subNodeItems)</div>\n\
<div class=\"line\">        : ParentClass(subSceneOverride, container, subNodeItems)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~UpdateDiffuseColorVisitor()<span class=\"keyword\"> override</span></div>\n\
<div class=\"line\"><span class=\"keyword\">    </span>{}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> canPrune(<span class=\"keyword\">const</span> HierarchyStat::SubNodeStat&amp; stat)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> !stat.isDiffuseColorAnimated;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> update(<span class=\"keyword\">const</span> ShapeData&amp;         shape,</div>\n\
<div class=\"line\">                <span class=\"keyword\">const</span> SubNode&amp;           subNode,</div>\n\
<div class=\"line\">                SubNodeRenderItems::Ptr&amp; subNodeItems)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        subNodeItems-&gt;updateMaterials(</div>\n\
<div class=\"line\">            fSubSceneOverride,</div>\n\
<div class=\"line\">            fContainer,</div>\n\
<div class=\"line\">            shape</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride::InstanceRenderItems</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This class contains the render items for an instance of gpuCache node.</span></div>\n\
<div class=\"line\"><span class=\"keyword\">class </span>SubSceneOverride::InstanceRenderItems : boost::noncopyable</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\"><span class=\"keyword\">public</span>:</div>\n\
<div class=\"line\">    <span class=\"keyword\">typedef</span> std::shared_ptr&lt;InstanceRenderItems&gt; Ptr;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    InstanceRenderItems()</div>\n\
<div class=\"line\">        : fVisibility(true),</div>\n\
<div class=\"line\">          fVisibilityValid(false),</div>\n\
<div class=\"line\">          fWorldMatrixValid(false),</div>\n\
<div class=\"line\">          fStreamsValid(false),</div>\n\
<div class=\"line\">          fMaterialsValid(false)</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    ~InstanceRenderItems()</div>\n\
<div class=\"line\">    {}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update the bounding box render item.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateRenderItems(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                           <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a>&amp;     dagPath,</div>\n\
<div class=\"line\">                           <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>&amp;      instancePrefix)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(dagPath.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#a095ae34296e81703965265a42ee783ca\">isValid</a>());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!dagPath.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#a095ae34296e81703965265a42ee783ca\">isValid</a>()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Set the path of this instance.</span></div>\n\
<div class=\"line\">        fDagPath = dagPath;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Check if we can see the DAG node.</span></div>\n\
<div class=\"line\">        fVisibility = dagPath.<a name=\"a80\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#a27f324b7f2643119a7542e39101601d1\">isVisible</a>();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Early out if we can&#39;t see this instance.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fVisibility) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Disable all render items that belong to this instance.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span>(SubNodeRenderItemList::value_type&amp; items : fSubNodeItems) {</div>\n\
<div class=\"line\">                items-&gt;hideRenderItems();</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// We have disabled all render items that belong to this instance.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// When the DAG object is visible again, we need to restore visibility.</span></div>\n\
<div class=\"line\">            fVisibilityValid = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Check if this instance is selected.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bca\">DisplayStatus</a> displayStatus =</div>\n\
<div class=\"line\">            MGeometryUtilities::displayStatus(dagPath);</div>\n\
<div class=\"line\">        fIsSelected = (displayStatus == <a class=\"code\" href=\"#!/url=./cpp_ref/namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bcaab6a8784b4cf96692e0d71d19c44ce732\">kActive</a>) ||</div>\n\
<div class=\"line\">                      (displayStatus == kLead)   ||</div>\n\
<div class=\"line\">                      (displayStatus == <a class=\"code\" href=\"#!/url=./cpp_ref/namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bcaa88694d85749c9c85738c56c4912c385a\">kHilite</a>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Get the wireframe color for the whole gpuCache node.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_color.html\">MColor</a> wireColor = MGeometryUtilities::wireframeColor(dagPath);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the bounding box render item.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fBoundingBoxItem) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> boundingBoxName = instancePrefix + <span class=\"stringliteral\">&quot;BoundingBox&quot;</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Create the bounding box render item.</span></div>\n\
<div class=\"line\">            fBoundingBoxItem.reset(<span class=\"keyword\">new</span> RenderItemWrapper(</div>\n\
<div class=\"line\">                boundingBoxName,</div>\n\
<div class=\"line\">                MRenderItem::NonMaterialSceneItem,</div>\n\
<div class=\"line\">                MGeometry::kLines</div>\n\
<div class=\"line\">            ));</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setDrawMode(MGeometry::kBoundingBox);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Set the shader so that we can fill geometry data.</span></div>\n\
<div class=\"line\">            fBoundingBoxShader =</div>\n\
<div class=\"line\">                ShaderInstanceCache::getInstance().getSharedWireShader(wireColor);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fBoundingBoxShader) {</div>\n\
<div class=\"line\">                fBoundingBoxItem-&gt;setShader(fBoundingBoxShader);</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Add to the container.</span></div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;addToContainer(container);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Set unit bounding box buffer.</span></div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setBuffers(</div>\n\
<div class=\"line\">                subSceneOverride,</div>\n\
<div class=\"line\">                UnitBoundingBox::indices(),</div>\n\
<div class=\"line\">                UnitBoundingBox::positions(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>\n\
<div class=\"line\">                UnitBoundingBox::boundingBox()</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Bounding box color</span></div>\n\
<div class=\"line\">        fBoundingBoxShader =</div>\n\
<div class=\"line\">            ShaderInstanceCache::getInstance().getSharedWireShader(wireColor);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fBoundingBoxShader) {</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setShader(fBoundingBoxShader);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Bounding box depth priority</span></div>\n\
<div class=\"line\">        fBoundingBoxItem-&gt;setDepthPriority(</div>\n\
<div class=\"line\">            fIsSelected ?</div>\n\
<div class=\"line\">                MRenderItem::sActiveWireDepthPriority :</div>\n\
<div class=\"line\">                MRenderItem::sDormantWireDepthPriority</div>\n\
<div class=\"line\">        );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        fBoundingBoxItem-&gt;setEnabled(<span class=\"keyword\">true</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the sub-node render items.</span></div>\n\
<div class=\"line\">        UpdateRenderItemsVisitor visitor(subSceneOverride, container,</div>\n\
<div class=\"line\">            instancePrefix, wireColor, fIsSelected, fSubNodeItems);</div>\n\
<div class=\"line\">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateVisibility(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                          <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                          <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span>          outOfViewFrustum)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(fDagPath.isValid());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fDagPath.isValid()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Early out if we can&#39;t see this instance.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fVisibility) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Disable visibility animation checks so that we turn off all render</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// items when the geometry goes out of the view frustum. Otherwise,</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// only visibility-animated render items are updated..</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// Visibility is updated once when the geometry moves out of the view</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// frustum. requiresUpdate() should return false for the following</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// frames so disable the check won&#39;t affect performance when the</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// render items are view-frustum-culled.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (outOfViewFrustum) {</div>\n\
<div class=\"line\">            fVisibilityValid = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the sub-node visibility.</span></div>\n\
<div class=\"line\">        UpdateVisibilityVisitor visitor(subSceneOverride, container, fSubNodeItems, outOfViewFrustum);</div>\n\
<div class=\"line\">        visitor.setDontPrune(!fVisibilityValid);</div>\n\
<div class=\"line\">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>\n\
<div class=\"line\">        fVisibilityValid = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Keep the visibility animation checks off so the visibility will be</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// updated again when the geometry moves into the view frustum.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (outOfViewFrustum) {</div>\n\
<div class=\"line\">            fVisibilityValid = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateWorldMatrix(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                           <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(fDagPath.isValid());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fDagPath.isValid()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Early out if we can&#39;t see this instance.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fVisibility) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// The DAG node&#39;s world matrix.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a> pathMatrix = fDagPath.inclusiveMatrix();</div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span> pathMatrixChanged = fMatrix != pathMatrix;</div>\n\
<div class=\"line\">        fMatrix = pathMatrix;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the bounding box render item&#39;s world matrix.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fBoundingBoxItem) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_bounding_box.html\">MBoundingBox</a> boundingBox = BoundingBoxVisitor::boundingBox(</div>\n\
<div class=\"line\">                subSceneOverride.getGeometry(),</div>\n\
<div class=\"line\">                subSceneOverride.getTime()</div>\n\
<div class=\"line\">            );</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a> worldMatrix =</div>\n\
<div class=\"line\">                UnitBoundingBox::boundingBoxMatrix(boundingBox) * fMatrix;</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;setWorldMatrix(worldMatrix);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the sub-node world matrices</span></div>\n\
<div class=\"line\">        UpdateWorldMatrixVisitor visitor(subSceneOverride, container,</div>\n\
<div class=\"line\">            fMatrix, fSubNodeItems);</div>\n\
<div class=\"line\">        visitor.setDontPrune(pathMatrixChanged || !fWorldMatrixValid);  <span class=\"comment\">// The DAG object&#39;s matrix has changed.</span></div>\n\
<div class=\"line\">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>\n\
<div class=\"line\">        fWorldMatrixValid = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateStreams(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                       <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(fDagPath.isValid());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fDagPath.isValid()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Early out if we can&#39;t see this instance.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fVisibility) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the sub-node streams.</span></div>\n\
<div class=\"line\">        UpdateStreamsVisitor visitor(subSceneOverride, container, fSubNodeItems);</div>\n\
<div class=\"line\">        visitor.setDontPrune(!fStreamsValid);</div>\n\
<div class=\"line\">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>\n\
<div class=\"line\">        fStreamsValid = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> updateMaterials(SubSceneOverride&amp;   subSceneOverride,</div>\n\
<div class=\"line\">                         <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        assert(fDagPath.isValid());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fDagPath.isValid()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Early out if we can&#39;t see this instance.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (!fVisibility) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the sub-node diffuse color materials.</span></div>\n\
<div class=\"line\">        UpdateDiffuseColorVisitor visitor(subSceneOverride, container, fSubNodeItems);</div>\n\
<div class=\"line\">        visitor.setDontPrune(!fMaterialsValid);</div>\n\
<div class=\"line\">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>\n\
<div class=\"line\">        fMaterialsValid = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">void</span> destroyRenderItems(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Destroy the bounding box render item for this instance.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fBoundingBoxItem) {</div>\n\
<div class=\"line\">            fBoundingBoxItem-&gt;removeFromContainer(container);</div>\n\
<div class=\"line\">            fBoundingBoxItem.reset();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Destroy the sub node render items.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span>(SubNodeRenderItems::Ptr&amp; subNodeItem : fSubNodeItems) {</div>\n\
<div class=\"line\">            subNodeItem-&gt;destroyRenderItems(container);</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keyword\">private</span>:</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a>               fDagPath;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                   fIsSelected;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span>                   fVisibility;</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a>                fMatrix;</div>\n\
<div class=\"line\">    RenderItemWrapper::Ptr fBoundingBoxItem;</div>\n\
<div class=\"line\">    ShaderInstancePtr      fBoundingBoxShader;</div>\n\
<div class=\"line\">    SubNodeRenderItemList  fSubNodeItems;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> fVisibilityValid;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> fWorldMatrixValid;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> fStreamsValid;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> fMaterialsValid;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CLASS SubSceneOverride</span></div>\n\
<div class=\"line\"><span class=\"comment\">//==============================================================================</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><a name=\"_a81\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html\">MPxSubSceneOverride</a>* SubSceneOverride::creator(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_object.html\">MObject</a>&amp; <span class=\"keywordtype\">object</span>)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> <span class=\"keyword\">new</span> SubSceneOverride(<span class=\"keywordtype\">object</span>);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::clear()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Delete the buffers in the cache.</span></div>\n\
<div class=\"line\">    BuffersCache::getInstance().clear();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html\">MIndexBuffer</a>* SubSceneOverride::lookup(<span class=\"keyword\">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Find the corresponding index buffer.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> BuffersCache::getInstance().lookup(indices);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html\">MVertexBuffer</a>* SubSceneOverride::lookup(<span class=\"keyword\">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Find the corresponding vertex buffer.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> BuffersCache::getInstance().lookup(vertices);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">SubSceneOverride::SubSceneOverride(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_object.html\">MObject</a>&amp; <span class=\"keywordtype\">object</span>)</div>\n\
<div class=\"line\">    : <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html\">MPxSubSceneOverride</a>(object),</div>\n\
<div class=\"line\">      fObject(object),</div>\n\
<div class=\"line\">      fShapeNode(NULL),</div>\n\
<div class=\"line\">      fUpdateRenderItemsRequired(true),</div>\n\
<div class=\"line\">      fUpdateVisibilityRequired(true),</div>\n\
<div class=\"line\">      fUpdateWorldMatrixRequired(true),</div>\n\
<div class=\"line\">      fUpdateStreamsRequired(true),</div>\n\
<div class=\"line\">      fUpdateMaterialsRequired(true),</div>\n\
<div class=\"line\">      fOutOfViewFrustum(false),</div>\n\
<div class=\"line\">      fOutOfViewFrustumUpdated(false),</div>\n\
<div class=\"line\">      fWireOnShadedMode(DisplayPref::kWireframeOnShadedFull)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Extract the ShapeNode pointer.</span></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn_dag_node.html\">MFnDagNode</a> dagNode(<span class=\"keywordtype\">object</span>);</div>\n\
<div class=\"line\">    fShapeNode = (<span class=\"keyword\">const</span> ShapeNode*)dagNode.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn_dependency_node.html#a4f2c53c9d1dcf25a6462c70fb25aead1\">userNode</a>();</div>\n\
<div class=\"line\">    assert(fShapeNode);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Get all DAG paths.</span></div>\n\
<div class=\"line\">    resetDagPaths();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Cache the non-networked plugs.</span></div>\n\
<div class=\"line\">    fCastsShadowsPlug   = dagNode.<a name=\"a82\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153\">findPlug</a>(<span class=\"stringliteral\">&quot;castsShadows&quot;</span>, <span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\">    fReceiveShadowsPlug = dagNode.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153\">findPlug</a>(<span class=\"stringliteral\">&quot;receiveShadows&quot;</span>, <span class=\"keyword\">false</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Register callbacks</span></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a> dagPath = <a name=\"a83\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#a422aa5ec02565f757c13fe2873ed25d7\">MDagPath::getAPathTo</a>(<span class=\"keywordtype\">object</span>);  <span class=\"comment\">// any path</span></div>\n\
<div class=\"line\">    fInstanceAddedCallback = <a name=\"a84\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_message.html#a9c301d5a30d9424eea522166b283a98d\">MDagMessage::addInstanceAddedDagPathCallback</a>(</div>\n\
<div class=\"line\">        dagPath, InstanceChangedCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">    fInstanceRemovedCallback = <a name=\"a85\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_message.html#aafe921878a14c3ae07f6a453773c59e2\">MDagMessage::addInstanceRemovedDagPathCallback</a>(</div>\n\
<div class=\"line\">        dagPath, InstanceChangedCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">    fWorldMatrixChangedCallback = <a name=\"a86\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_message.html#a33a28fd9c6b6fbaa4fefe2c849f76636\">MDagMessage::addWorldMatrixModifiedCallback</a>(</div>\n\
<div class=\"line\">        dagPath, WorldMatrixChangedCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">    registerNodeDirtyCallbacks();</div>\n\
<div class=\"line\">    ModelCallbacks::getInstance().registerSubSceneOverride(fShapeNode, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    fUpdateTime = boost::date_time::microsec_clock&lt;boost::posix_time::ptime&gt;::local_time();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">SubSceneOverride::~SubSceneOverride()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Deregister callbacks</span></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09\">MMessage::removeCallback</a>(fInstanceAddedCallback);</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09\">MMessage::removeCallback</a>(fInstanceRemovedCallback);</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09\">MMessage::removeCallback</a>(fWorldMatrixChangedCallback);</div>\n\
<div class=\"line\">    <a name=\"a87\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#ac637287cc26b707b9e1a175a32f44e29\">MMessage::removeCallbacks</a>(fNodeDirtyCallbacks);</div>\n\
<div class=\"line\">    ModelCallbacks::getInstance().deregisterSubSceneOverride(fShapeNode);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Destroy render items.</span></div>\n\
<div class=\"line\">    fInstanceRenderItems.clear();</div>\n\
<div class=\"line\">    fHardwareInstanceManager.reset();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><a class=\"code\" href=\"#!/url=./cpp_ref/namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49\">MHWRender::DrawAPI</a> SubSceneOverride::supportedDrawAPIs()<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\"></span>{</div>\n\
<div class=\"line\">    <span class=\"comment\">// We support both OpenGL and DX11 in VP2.0!</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> <a name=\"a88\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49a98fc59e3a63859014185d6ff7f574a3b\">MHWRender::kAllDevices</a>;</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">bool</span> SubSceneOverride::requiresUpdate(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp; container,</div>\n\
<div class=\"line\">                                      <span class=\"keyword\">const</span> <a name=\"_a89\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html\">MFrameContext</a>&amp;      frameContext)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\"></span>{</div>\n\
<div class=\"line\">    assert(fShapeNode);</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!fShapeNode) <span class=\"keywordflow\">return</span> <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html\">MRenderer</a>* renderer = MRenderer::theRenderer();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!renderer) <span class=\"keywordflow\">return</span> <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Cache the DAG paths for all instances.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fInstanceDagPaths.length() == 0) {</div>\n\
<div class=\"line\">        SubSceneOverride* nonConstThis = <span class=\"keyword\">const_cast&lt;</span>SubSceneOverride*<span class=\"keyword\">&gt;</span>(<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">        <a name=\"a90\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#a6e4195497a9d3f031d159ddb60f94e74\">MDagPath::getAllPathsTo</a>(fObject, nonConstThis-&gt;fInstanceDagPaths);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Turn on/off hardware instancing.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span> hwInstancing = useHardwareInstancing();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ((hwInstancing &amp;&amp; !fHardwareInstanceManager) ||</div>\n\
<div class=\"line\">            (!hwInstancing &amp;&amp; fHardwareInstanceManager)) {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Get the cached geometry and materials.</span></div>\n\
<div class=\"line\">    SubNode::Ptr          geometry = fShapeNode-&gt;getCachedGeometry();</div>\n\
<div class=\"line\">    MaterialGraphMap::Ptr material = fShapeNode-&gt;getCachedMaterial();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Check if the cached geometry or materials have been changed.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (geometry != fGeometry || material != fMaterial) {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Check if the Wireframe on Shaded mode has been changed.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fWireOnShadedMode != DisplayPref::wireframeOnShadedMode()) {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Skip update if all instances are out of view frustum.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// Only cull when we are using default lights.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// Shadow map generation requires the update() even if the whole</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// DAG object is out of the camera view frustum.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (geometry &amp;&amp; frameContext.<a name=\"a91\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#a376f1eeaa26e24a893afacff7db169bc\">getLightingMode</a>() == MFrameContext::kLightDefault) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// The world view proj inv matrix.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a> viewProjInv = frameContext.<a name=\"a92\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#a71cbe2a3f2dfa967ebc43b5e97456ccb\">getMatrix</a>(MFrameContext::kViewProjInverseMtx);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// The bounding box in local DAG transform space.</span></div>\n\
<div class=\"line\">        BoundingBoxVisitor visitor(<a name=\"a93\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060\">MAnimControl::currentTime</a>().as(<a name=\"a94\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7\">MTime::kSeconds</a>));</div>\n\
<div class=\"line\">        geometry-&gt;accept(visitor);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">bool</span> outOfViewFrustum = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0; i &lt; fInstanceDagPaths.length(); i++) {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_matrix.html\">MMatrix</a> worldInv = fInstanceDagPaths[i].inclusiveMatrixInverse();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Test view frustum.</span></div>\n\
<div class=\"line\">            Frustum frustum(viewProjInv * worldInv,</div>\n\
<div class=\"line\">                renderer-&gt;<a name=\"a95\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#aac2a5827e6a0ce3333e62ffa7751ba5e\">drawAPIIsOpenGL</a>() ? Frustum::kOpenGL : Frustum::kDirectX);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (frustum.test(visitor.boundingBox()) != Frustum::kOutside) {</div>\n\
<div class=\"line\">                outOfViewFrustum = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">break</span>;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// We know all the render items are going to be culled so skip update them.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (outOfViewFrustum) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// It&#39;s important to call update() once after the shape is out of the view frustum.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// This will make sure all render items are going to be culled.</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// If the render items are still going to be culled in this frame,</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// we can then skip calling update().</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (fOutOfViewFrustum &amp;&amp; fOutOfViewFrustumUpdated) {</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">return</span> <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        SubSceneOverride* nonConstThis = <span class=\"keyword\">const_cast&lt;</span>SubSceneOverride*<span class=\"keyword\">&gt;</span>(<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fOutOfViewFrustum ^ outOfViewFrustum) {</div>\n\
<div class=\"line\">            <span class=\"comment\">// Update the visibility of render items when the geometry moves</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// into the view frustum or when it goes out of the view frustum.</span></div>\n\
<div class=\"line\">            nonConstThis-&gt;dirtyVisibility();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        nonConstThis-&gt;fOutOfViewFrustum        = outOfViewFrustum;</div>\n\
<div class=\"line\">        nonConstThis-&gt;fOutOfViewFrustumUpdated = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">else</span> {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Reset view frustum culling flags</span></div>\n\
<div class=\"line\">        SubSceneOverride* nonConstThis = <span class=\"keyword\">const_cast&lt;</span>SubSceneOverride*<span class=\"keyword\">&gt;</span>(<span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (fOutOfViewFrustum) {</div>\n\
<div class=\"line\">            nonConstThis-&gt;dirtyVisibility();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        nonConstThis-&gt;fOutOfViewFrustum        = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">        nonConstThis-&gt;fOutOfViewFrustumUpdated = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Check if we are loading geometry in background.</span></div>\n\
<div class=\"line\">    CacheFileEntry::BackgroundReadingState readingState = fShapeNode-&gt;backgroundReadingState();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (readingState != fReadingState) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Force an update when reading is done.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (readingState != CacheFileEntry::kReadingDone) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Don&#39;t update too frequently.</span></div>\n\
<div class=\"line\">        boost::posix_time::ptime currentTime =</div>\n\
<div class=\"line\">            boost::date_time::microsec_clock&lt;boost::posix_time::ptime&gt;::local_time();</div>\n\
<div class=\"line\">        boost::posix_time::time_duration interval = currentTime - fUpdateTime;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (interval.total_milliseconds() &gt;= (int)(Config::backgroundReadingRefresh() / 2)) {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> fUpdateRenderItemsRequired ||</div>\n\
<div class=\"line\">            fUpdateVisibilityRequired ||</div>\n\
<div class=\"line\">            fUpdateWorldMatrixRequired ||</div>\n\
<div class=\"line\">            fUpdateStreamsRequired ||</div>\n\
<div class=\"line\">            fUpdateMaterialsRequired;</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::update(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MSubSceneContainer</a>&amp;  container,</div>\n\
<div class=\"line\">                              <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html\">MFrameContext</a>&amp; frameContext)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    assert(fShapeNode);</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!fShapeNode) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Register node dirty callbacks if necessary.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fNodeDirtyCallbacks.length() == 0) {</div>\n\
<div class=\"line\">        registerNodeDirtyCallbacks();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update hardware instances.</span></div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keywordtype\">bool</span> hwInstancing = useHardwareInstancing();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (hwInstancing &amp;&amp; !fHardwareInstanceManager) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Turn on hardware instancing.</span></div>\n\
<div class=\"line\">        dirtyRenderItems();     <span class=\"comment\">// force updating</span></div>\n\
<div class=\"line\">        fHardwareInstanceManager.reset(<span class=\"keyword\">new</span> HardwareInstanceManager(*<span class=\"keyword\">this</span>));</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">else</span> <span class=\"keywordflow\">if</span> (!hwInstancing &amp;&amp; fHardwareInstanceManager) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Turn off hardware instancing.</span></div>\n\
<div class=\"line\">        fHardwareInstanceManager-&gt;resetInstances(container);</div>\n\
<div class=\"line\">        fHardwareInstanceManager.reset();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Shrink the buffer cache to make room for new buffers.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// When the total size of the buffers is hitting the threshold,</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// buffers that are not used by any render items will be evicted.</span></div>\n\
<div class=\"line\">    BuffersCache::getInstance().shrink();</div>\n\
<div class=\"line\">    </div>\n\
<div class=\"line\">    <span class=\"comment\">// Get the cached geometry and materials.</span></div>\n\
<div class=\"line\">    SubNode::Ptr          geometry = fShapeNode-&gt;getCachedGeometry();</div>\n\
<div class=\"line\">    MaterialGraphMap::Ptr material = fShapeNode-&gt;getCachedMaterial();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Remember the current time.</span></div>\n\
<div class=\"line\">    fUpdateTime = boost::date_time::microsec_clock&lt;boost::posix_time::ptime&gt;::local_time();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Check if the cached geometry or materials have been changed.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (geometry != fGeometry || material != fMaterial) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Set the cached geometry and materials.</span></div>\n\
<div class=\"line\">        fGeometry = geometry;</div>\n\
<div class=\"line\">        fMaterial = material;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Rebuild render items.</span></div>\n\
<div class=\"line\">        fInstanceRenderItems.clear();</div>\n\
<div class=\"line\">        container.<a name=\"a96\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html#ac8bb3912a3ce86b15842e79d0b421204\">clear</a>();</div>\n\
<div class=\"line\">        fHierarchyStat.reset();</div>\n\
<div class=\"line\">        dirtyEverything();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Check if we are loading geometry in background.</span></div>\n\
<div class=\"line\">    CacheFileEntry::BackgroundReadingState readingState = fShapeNode-&gt;backgroundReadingState();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (readingState != fReadingState || readingState != CacheFileEntry::kReadingDone) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Background reading has not finished. Update all render items.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// (Remove bounding box render items and add shaded/wire render items.)</span></div>\n\
<div class=\"line\">        fReadingState = readingState;</div>\n\
<div class=\"line\">        dirtyEverything();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update the render items to match the Wireframe on Shaded mode.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fWireOnShadedMode != DisplayPref::wireframeOnShadedMode()) {</div>\n\
<div class=\"line\">        fWireOnShadedMode = DisplayPref::wireframeOnShadedMode();</div>\n\
<div class=\"line\">        dirtyRenderItems();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Current time in seconds</span></div>\n\
<div class=\"line\">    fTimeInSeconds = <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060\">MAnimControl::currentTime</a>().<a name=\"a97\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_time.html#a105d41236561f4d4be6383ced757a429\">as</a>(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7\">MTime::kSeconds</a>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update the render items.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fUpdateRenderItemsRequired) {</div>\n\
<div class=\"line\">        updateRenderItems(container, frameContext);</div>\n\
<div class=\"line\">        fUpdateRenderItemsRequired = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update the visibility.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fUpdateVisibilityRequired) {</div>\n\
<div class=\"line\">        updateVisibility(container, frameContext);</div>\n\
<div class=\"line\">        fUpdateVisibilityRequired = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update the world matrices.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fUpdateWorldMatrixRequired) {</div>\n\
<div class=\"line\">        updateWorldMatrix(container, frameContext);</div>\n\
<div class=\"line\">        fUpdateWorldMatrixRequired = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update streams.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fUpdateStreamsRequired) {</div>\n\
<div class=\"line\">        updateStreams(container, frameContext);</div>\n\
<div class=\"line\">        fUpdateStreamsRequired = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update materials.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fUpdateMaterialsRequired) {</div>\n\
<div class=\"line\">        updateMaterials(container, frameContext);</div>\n\
<div class=\"line\">        fUpdateMaterialsRequired = <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Analysis the sub-node hierarchy so that we can prune it.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!fHierarchyStat &amp;&amp; fReadingState == CacheFileEntry::kReadingDone &amp;&amp; fGeometry) {</div>\n\
<div class=\"line\">        HierarchyStatVisitor visitor(fGeometry);</div>\n\
<div class=\"line\">        fGeometry-&gt;accept(visitor);</div>\n\
<div class=\"line\">        fHierarchyStat = visitor.getStat();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// The geometry is fully loaded. Recompute the shadow map.</span></div>\n\
<div class=\"line\">        MRenderer::setLightsAndShadowsDirty();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update hardware instancing.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fHardwareInstanceManager) {</div>\n\
<div class=\"line\">        fHardwareInstanceManager-&gt;processInstances(container);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// We have done update() when the shape is out of view frustum.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fOutOfViewFrustum) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// There is a situation that both the render items and the camera are</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// animated and the render items are out-of-view-frustum for frames.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// We skip update() for performance so we don&#39;t have chances to update</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// the matrix or geometry of the render item. We need to turn off the</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// render items until the render items appear in the view frustum again.</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// MRenderItem::enable(false) is called in updateVisibility() method.</span></div>\n\
<div class=\"line\">        fOutOfViewFrustumUpdated = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">bool</span> SubSceneOverride::getInstancedSelectionPath(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html\">MHWRender::MRenderItem</a>&amp; renderItem, <span class=\"keyword\">const</span> <a name=\"_a98\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_intersection.html\">MHWRender::MIntersection</a>&amp; intersection, <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a>&amp; dagPath)<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\"></span>{</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> pathIndex = -1;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// When using hardware accelerated instancing, the InstanceID</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// information will be found in the intersection:</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">int</span> hardwareInstanceIndex = intersection.<a name=\"a99\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_intersection.html#a35ab9f5cd2b7e3c46d5c661d9cd73571\">instanceID</a>();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (hardwareInstanceIndex &gt;= 0)</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        pathIndex = fHardwareInstanceManager-&gt;instancePathIndex(renderItem, hardwareInstanceIndex);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// The path to the instance is encoded in the render item name:</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string_array.html\">MStringArray</a> renderItemParts;</div>\n\
<div class=\"line\">        renderItem.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#aca2cba4630391c78dcf1a828986160da\">name</a>().<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html#ac914d138fc96d7065c687a4f8b40c263\">split</a>(<span class=\"charliteral\">&#39;:&#39;</span>, renderItemParts);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> (renderItemParts.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e\">length</a>() &gt; 1 &amp;&amp; renderItemParts[0].isUnsigned())</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            pathIndex = renderItemParts[0].asUnsigned();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (pathIndex &lt; fInstanceDagPaths.length())</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">            dagPath.<a name=\"a100\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#a0803071a27de28ea0eee7fdc7812de95\">set</a>(fInstanceDagPaths[pathIndex]);</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> (dagPath.<a name=\"a101\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#af321be336f1f2d96ac2273a87cb3c8ab\">length</a>() &gt; 1)</div>\n\
<div class=\"line\">                dagPath.<a name=\"a102\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#ac71eca2b78b8cfc088adc9af6f851dfd\">pop</a>(); <span class=\"comment\">// from shape to xform.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span> <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> <span class=\"keyword\">false</span>;</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::updateSelectionGranularity(<span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a>&amp; path, <a name=\"_a103\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_selection_context.html\">MHWRender::MSelectionContext</a>&amp; selectionContext)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// We do allow snapping, even though vertex are not selectable as components.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (pointSnappingActive())</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        selectionContext.<a name=\"a104\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_selection_context.html#ab1ead3c2bb71ebaaaa7b94b8a1dcaa3b\">setSelectionLevel</a>(<a name=\"a105\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_selection_context.html#a9bf800a895c6bfc0ef3fce84fb30625da02fee4c0e0e6f1b7ab7a678d61627461\">MHWRender::MSelectionContext::kComponent</a>);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::dirtyEverything()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    dirtyRenderItems();</div>\n\
<div class=\"line\">    dirtyVisibility();</div>\n\
<div class=\"line\">    dirtyWorldMatrix();</div>\n\
<div class=\"line\">    dirtyStreams();</div>\n\
<div class=\"line\">    dirtyMaterials();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::dirtyRenderItems()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    fUpdateRenderItemsRequired = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::dirtyVisibility()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    fUpdateVisibilityRequired = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::dirtyWorldMatrix()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    fUpdateWorldMatrixRequired = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::dirtyStreams()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    fUpdateStreamsRequired = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::dirtyMaterials()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    fUpdateMaterialsRequired = <span class=\"keyword\">true</span>;</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::resetDagPaths()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    fInstanceDagPaths.clear();</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::registerNodeDirtyCallbacks()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    assert(!fObject.isNull());</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fObject.isNull()) <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Register callbacks to all parents.</span></div>\n\
<div class=\"line\">    <a name=\"_a106\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path_array.html\">MDagPathArray</a> paths;</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#a6e4195497a9d3f031d159ddb60f94e74\">MDagPath::getAllPathsTo</a>(fObject, paths);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0; i &lt; paths.<a name=\"a107\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path_array.html#a580388f31f60c46fac867ca48a48da1e\">length</a>(); i++) {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html\">MDagPath</a> dagPath = paths[i];</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Register callbacks for this instance.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">while</span> (dagPath.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#a095ae34296e81703965265a42ee783ca\">isValid</a>() &amp;&amp; dagPath.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#af321be336f1f2d96ac2273a87cb3c8ab\">length</a>() &gt; 0) {</div>\n\
<div class=\"line\">            <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_object.html\">MObject</a> node = dagPath.<a name=\"a108\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#ae024049dad815f2f186e6a4fead8be51\">node</a>();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Monitor the parents and re-register callbacks.</span></div>\n\
<div class=\"line\">            MCallbackId parentAddedCallback = <a name=\"a109\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_message.html#a0cbf1f7d7670e5c7843dc1b8e021664d\">MDagMessage::addParentAddedDagPathCallback</a>(</div>\n\
<div class=\"line\">                dagPath, ParentChangedCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\">            MCallbackId parentRemovedCallback = <a name=\"a110\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_message.html#a7b9f16fb02898efdb74ef8e2106f1d53\">MDagMessage::addParentRemovedDagPathCallback</a>(</div>\n\
<div class=\"line\">                dagPath, ParentChangedCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Monitor parent display status changes.</span></div>\n\
<div class=\"line\">            MCallbackId nodeDirtyCallback = <a name=\"a111\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_m_node_message.html#a54c088182daaef8a244e375bc4124458\">MNodeMessage::addNodeDirtyPlugCallback</a>(</div>\n\
<div class=\"line\">                node, NodeDirtyCallback, <span class=\"keyword\">this</span>);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Add to array.</span></div>\n\
<div class=\"line\">            fNodeDirtyCallbacks.append(parentAddedCallback);</div>\n\
<div class=\"line\">            fNodeDirtyCallbacks.append(parentRemovedCallback);</div>\n\
<div class=\"line\">            fNodeDirtyCallbacks.append(nodeDirtyCallback);</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            dagPath.<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_dag_path.html#ac71eca2b78b8cfc088adc9af6f851dfd\">pop</a>();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::clearNodeDirtyCallbacks()</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (fNodeDirtyCallbacks.length() &gt; 0) {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_message.html#ac637287cc26b707b9e1a175a32f44e29\">MMessage::removeCallbacks</a>(fNodeDirtyCallbacks);</div>\n\
<div class=\"line\">        fNodeDirtyCallbacks.clear();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::updateRenderItems(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MHWRender::MSubSceneContainer</a>&amp;  container,</div>\n\
<div class=\"line\">                                         <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html\">MHWRender::MFrameContext</a>&amp; frameContext)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Early out if the gpuCache node has no cached data.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!fGeometry) {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Match the number of the instances.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> instanceCount = fInstanceDagPaths.length();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (instanceCount &gt; fInstanceRenderItems.size()) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Instance Added.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> difference = (<span class=\"keywordtype\">unsigned</span> int)(instanceCount - fInstanceRenderItems.size());</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0; i &lt; difference; i++) {</div>\n\
<div class=\"line\">            fInstanceRenderItems.push_back(</div>\n\
<div class=\"line\">                std::make_shared&lt;InstanceRenderItems&gt;());</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Recompute shadow map.</span></div>\n\
<div class=\"line\">        MRenderer::setLightsAndShadowsDirty();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">else</span> <span class=\"keywordflow\">if</span> (instanceCount &lt; fInstanceRenderItems.size()) {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Instance Removed.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> difference = (<span class=\"keywordtype\">unsigned</span> int)(fInstanceRenderItems.size() - instanceCount);</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0; i &lt; difference; i++) {</div>\n\
<div class=\"line\">            fInstanceRenderItems.back()-&gt;destroyRenderItems(container);</div>\n\
<div class=\"line\">            fInstanceRenderItems.pop_back();</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Recompute shadow map.</span></div>\n\
<div class=\"line\">        MRenderer::setLightsAndShadowsDirty();</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    assert(fInstanceDagPaths.length() == fInstanceRenderItems.size());</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// The MDagPath and MMatrix (world matrix) are the differences among instances.</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// We don&#39;t care the the instance number mapping. Just update the path and matrix.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span> (<span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0; i &lt; fInstanceRenderItems.size(); i++) {</div>\n\
<div class=\"line\">        assert(fInstanceRenderItems[i]);</div>\n\
<div class=\"line\">        <span class=\"comment\">// The name prefix for all render items of this instance</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// e.g. &quot;1:&quot; stands for the 2nd instance of the gpuCache node.</span></div>\n\
<div class=\"line\">        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a> instancePrefix = <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_string.html\">MString</a>(<span class=\"stringliteral\">&quot;&quot;</span>) + i + <span class=\"stringliteral\">&quot;:&quot;</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Update the bounding box render item.</span></div>\n\
<div class=\"line\">        fInstanceRenderItems[i]-&gt;updateRenderItems(</div>\n\
<div class=\"line\">            *<span class=\"keyword\">this</span>, container, fInstanceDagPaths[i], instancePrefix);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::updateVisibility(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MHWRender::MSubSceneContainer</a>&amp;  container,</div>\n\
<div class=\"line\">                                        <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html\">MHWRender::MFrameContext</a>&amp; frameContext)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Early out if the gpuCache node has no cached data.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!fGeometry) {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update the visibility for all instances.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span>(InstanceRenderItems::Ptr&amp; instance : fInstanceRenderItems) {</div>\n\
<div class=\"line\">        instance-&gt;updateVisibility(*<span class=\"keyword\">this</span>, container, fOutOfViewFrustum);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::updateWorldMatrix(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MHWRender::MSubSceneContainer</a>&amp;  container,</div>\n\
<div class=\"line\">                                         <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html\">MHWRender::MFrameContext</a>&amp; frameContext)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Early out if the gpuCache node has no cached data.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!fGeometry) {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update the world matrix for all instances.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span>(InstanceRenderItems::Ptr&amp; instance : fInstanceRenderItems) {</div>\n\
<div class=\"line\">        instance-&gt;updateWorldMatrix(*<span class=\"keyword\">this</span>, container);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::updateStreams(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MHWRender::MSubSceneContainer</a>&amp;  container,</div>\n\
<div class=\"line\">                                     <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html\">MHWRender::MFrameContext</a>&amp; frameContext)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Early out if the gpuCache node has no cached data.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!fGeometry) {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update the streams for all instances.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span>(InstanceRenderItems::Ptr&amp; instance : fInstanceRenderItems) {</div>\n\
<div class=\"line\">        instance-&gt;updateStreams(*<span class=\"keyword\">this</span>, container);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> SubSceneOverride::updateMaterials(<a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_sub_scene_container.html\">MHWRender::MSubSceneContainer</a>&amp;  container,</div>\n\
<div class=\"line\">                                       <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_m_h_w_render_1_1_m_frame_context.html\">MHWRender::MFrameContext</a>&amp; frameContext)</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Early out if the gpuCache node has no cached data.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> (!fGeometry) {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Update the diffuse color materials for all instances.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span>(InstanceRenderItems::Ptr&amp; instance : fInstanceRenderItems) {</div>\n\
<div class=\"line\">        instance-&gt;updateMaterials(*<span class=\"keyword\">this</span>, container);</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">//Update the materials.</span></div>\n\
<div class=\"line\">    ShaderInstanceCache::getInstance().updateCachedShadedShaders(fTimeInSeconds);</div>\n\
<div class=\"line\">}</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">}</div>\n\
</div><!-- fragment --> </div><!-- contents -->\n\
</div><!-- doc-content -->\n\
          <div class=\"footer-block\"><a href=\"../html/ac.cmtdialog.htm\" class=\"comments-anchor\" target=\"_blank\"><span class=\"comments-link\">Please send us your comment about this page</span></a></div></div>\n\
   </div></body>\n\
</html>\n\
";
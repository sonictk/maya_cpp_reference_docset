<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="MAYAUL" name="product"><meta content="2018" name="release"><meta content="Developer" name="book"><meta content="2017-06-22" name="created"><meta content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887" name="topicid"><meta content="concept" name="topic-type">
<title>gpuCache/gpuCacheSample.cpp</title>
<meta content="C++" name="topic-subtype"/></meta></meta></meta></meta></meta></meta></meta></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2gpu_cache_sample_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>gpuCache/gpuCacheSample.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">gpuCache/gpuCacheSample.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "gpuCacheSample.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheVBOProxy.h"</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;Alembic/Util/Murmur3.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/shared_array.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>GPUCache;</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// LOCAL FUNCTIONS &amp; CLASSES</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ArrayBaseImp</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>ArrayBaseImp </div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> ArrayBase::Callback Callback;</div>
<div class="line"> <span class="keyword">typedef</span> ArrayBase::Key      Key;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> registerCreationCallback(Callback callback)</div>
<div class="line">    {</div>
<div class="line">        creationCallbacks.push_back(callback);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> unregisterCreationCallback(Callback callback)</div>
<div class="line">    {</div>
<div class="line">        Callbacks::iterator it = std::find(</div>
<div class="line">            creationCallbacks.begin(), creationCallbacks.end(), callback);</div>
<div class="line"> <span class="keywordflow">if</span> (it != creationCallbacks.end()) {</div>
<div class="line">            creationCallbacks.erase(it);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> invokeCreationCallback(<span class="keyword">const</span> Key&amp; key)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Callback&amp; callback : creationCallbacks) {</div>
<div class="line">            (*callback)(key);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> registerDestructionCallback(Callback callback)</div>
<div class="line">    {</div>
<div class="line">        destructionCallbacks.push_back(callback);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> unregisterDestructionCallback(Callback callback)</div>
<div class="line">    {</div>
<div class="line">        Callbacks::iterator it = std::find(</div>
<div class="line">            destructionCallbacks.begin(), destructionCallbacks.end(), callback);</div>
<div class="line"> <span class="keywordflow">if</span> (it != destructionCallbacks.end()) {</div>
<div class="line">            destructionCallbacks.erase(it);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> invokeDestructionCallback(<span class="keyword">const</span> Key&amp; key)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Callback&amp; callback : destructionCallbacks) {</div>
<div class="line">            (*callback)(key);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">typedef</span> std::vector&lt;ArrayBase::Callback&gt; Callbacks;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> Callbacks creationCallbacks;</div>
<div class="line"> <span class="keyword">static</span> Callbacks destructionCallbacks;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">ArrayBaseImp::Callbacks ArrayBaseImp::creationCallbacks;</div>
<div class="line">ArrayBaseImp::Callbacks ArrayBaseImp::destructionCallbacks;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ArrayRegistryImp</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>ArrayRegistryImp</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> ArrayBase::Digest     Digest;</div>
<div class="line"> <span class="keyword">typedef</span> ArrayBase::Key        Key;</div>
<div class="line"> <span class="keyword">typedef</span> ArrayBase::KeyHash    KeyHash;</div>
<div class="line"> <span class="keyword">typedef</span> ArrayBase::KeyEqualTo KeyEqualTo;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> ArrayRegistryImp&lt;T&gt;&amp; singleton()</div>
<div class="line">    { <span class="keywordflow">return</span> fsSingleton; }</div>
<div class="line"></div>
<div class="line">    ~ArrayRegistryImp()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Unfortunately, we can't check that all buffers have been</span></div>
<div class="line"> <span class="comment">// freed here. The reason is Maya does not take the time to</span></div>
<div class="line"> <span class="comment">// clean-up the dependency graph when exiting. Therefore,</span></div>
<div class="line"> <span class="comment">// there might still exist some ShapeNode alived at exit time</span></div>
<div class="line"> <span class="comment">// and these will indirectly keep these buffers alive.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// The way to check that the mechanism is working correctly is</span></div>
<div class="line"> <span class="comment">// therefore to perform the following MEL commands "file -f</span></div>
<div class="line"> <span class="comment">// -new; gpuCache -q -sgs;" and check that everything has</span></div>
<div class="line"> <span class="comment">// been freed. The gpuCache regression test does that.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// assert(fMap.size() == 0);</span></div>
<div class="line">    } </div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    tbb::mutex&amp; mutex() </div>
<div class="line">    { <span class="keywordflow">return</span> fMutex; }</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;Array&lt;T&gt; &gt; lookup(</div>
<div class="line"> <span class="keyword">const</span> Digest&amp; digest,</div>
<div class="line"> <span class="keywordtype">size_t</span> size</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Caller will accept either readable or non-readable.  First look for non-readable.</span></div>
<div class="line">        std::shared_ptr&lt;Array&lt;T&gt; &gt; ret = lookupNonReadable(digest, size);</div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line">            ret = lookupReadable(digest, size);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;Array&lt;T&gt; &gt; lookupNonReadable(</div>
<div class="line"> <span class="keyword">const</span> Digest&amp; digest,</div>
<div class="line"> <span class="keywordtype">size_t</span> size</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">typename</span> Map::const_iterator it = fMapNonReadable.find(Key(size * <span class="keyword">sizeof</span>(T), digest));</div>
<div class="line"> <span class="keywordflow">if</span> (it != fMapNonReadable.end()) {</div>
<div class="line"> <span class="comment">// Might return null if the weak_ptr&lt;&gt; is now dangling</span></div>
<div class="line"> <span class="comment">// but not yet removed from the map...</span></div>
<div class="line">            std::shared_ptr&lt;Array&lt;T&gt; &gt; ret = it-&gt;second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line">                fMapNonReadable.erase(it);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordflow">return</span> std::shared_ptr&lt;Array&lt;T&gt; &gt;();</div>
<div class="line">        }</div>
<div class="line">    }   </div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; lookupReadable(</div>
<div class="line"> <span class="keyword">const</span> Digest&amp; digest,</div>
<div class="line"> <span class="keywordtype">size_t</span> size</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">typename</span> MapReadable::const_iterator it = fMapReadable.find(Key(size * <span class="keyword">sizeof</span>(T), digest));</div>
<div class="line"> <span class="keywordflow">if</span> (it != fMapReadable.end()) {</div>
<div class="line"> <span class="comment">// Might return null if the weak_ptr&lt;&gt; is now dangling</span></div>
<div class="line"> <span class="comment">// but not yet removed from the map...</span></div>
<div class="line">            std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; ret = it-&gt;second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line">                fMapReadable.erase(it);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordflow">return</span> std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt;();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> insert(std::shared_ptr&lt;Array&lt;T&gt; &gt; array)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (array-&gt;isReadable()) {</div>
<div class="line">            fMapReadable.insert(std::make_pair(array-&gt;key(), array-&gt;getReadableArray()));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            fMapNonReadable.insert(std::make_pair(array-&gt;key(), array));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> removeIfStaled(<span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> readable)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (readable) {</div>
<div class="line"> <span class="keyword">typename</span> MapReadable::const_iterator it = fMapReadable.find(key);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fMapReadable.end()) {</div>
<div class="line"> <span class="comment">// Might return null if the weak_ptr&lt;&gt; is now dangling</span></div>
<div class="line"> <span class="comment">// but not yet removed from the map...</span></div>
<div class="line">                std::shared_ptr&lt;Array&lt;T&gt; &gt; ret = it-&gt;second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line"> <span class="comment">// Get rid of the stalled entry so that insert() can</span></div>
<div class="line"> <span class="comment">// work properly.</span></div>
<div class="line">                    fMapReadable.erase(it);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keyword">typename</span> Map::const_iterator it = fMapNonReadable.find(key);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fMapNonReadable.end()) {</div>
<div class="line"> <span class="comment">// Might return null if the weak_ptr&lt;&gt; is now dangling</span></div>
<div class="line"> <span class="comment">// but not yet removed from the map...</span></div>
<div class="line">                std::shared_ptr&lt;Array&lt;T&gt; &gt; ret = it-&gt;second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line"> <span class="comment">// Get rid of the stalled entry so that insert() can</span></div>
<div class="line"> <span class="comment">// work properly.</span></div>
<div class="line">                    fMapNonReadable.erase(it);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">typedef</span> std::unordered_map&lt;</div>
<div class="line">        Key,</div>
<div class="line">        std::weak_ptr&lt;Array&lt;T&gt; &gt;,</div>
<div class="line">        KeyHash,</div>
<div class="line">        KeyEqualTo&gt; Map;</div>
<div class="line"> <span class="keyword">typedef</span> std::unordered_map&lt;</div>
<div class="line">        Key,</div>
<div class="line">        std::weak_ptr&lt;ReadableArray&lt;T&gt; &gt;,</div>
<div class="line">        KeyHash,</div>
<div class="line">        KeyEqualTo&gt; MapReadable;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> ArrayRegistryImp fsSingleton;</div>
<div class="line"></div>
<div class="line">    tbb::mutex fMutex;</div>
<div class="line">    Map fMapNonReadable;</div>
<div class="line">    MapReadable fMapReadable;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">ArrayRegistryImp&lt;T&gt; ArrayRegistryImp&lt;T&gt;::fsSingleton;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>ArrayRegistryImp&lt;IndexBuffer::index_t&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>ArrayRegistryImp&lt;float&gt;;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS IndexBufferRegistry</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>IndexBufferRegistry</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> IndexBuffer::index_t    index_t;</div>
<div class="line"> <span class="keyword">typedef</span> IndexBuffer::Key        Key;</div>
<div class="line"> <span class="keyword">typedef</span> IndexBuffer::KeyHash    KeyHash;</div>
<div class="line"> <span class="keyword">typedef</span> IndexBuffer::KeyEqualTo KeyEqualTo;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> IndexBufferRegistry&amp; singleton()</div>
<div class="line">    { <span class="keywordflow">return</span> fsSingleton; }</div>
<div class="line"></div>
<div class="line">    ~IndexBufferRegistry() {}</div>
<div class="line"></div>
<div class="line">    tbb::mutex&amp; mutex() </div>
<div class="line">    { <span class="keywordflow">return</span> fMutex; }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;IndexBuffer&gt; lookup(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;Array&lt;index_t&gt; &gt;&amp; array,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span> beginIdx,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span> endIdx</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        Map::const_iterator it = fMap.find(Key(array, beginIdx, endIdx));</div>
<div class="line"> <span class="keywordflow">if</span> (it != fMap.end()) {</div>
<div class="line"> <span class="comment">// Might return null if the weak_ptr&lt;&gt; is now dangling</span></div>
<div class="line"> <span class="comment">// but not yet removed from the map...</span></div>
<div class="line">            std::shared_ptr&lt;IndexBuffer&gt; ret = it-&gt;second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line"> <span class="comment">// Get rid of the stalled entry so that insert() can</span></div>
<div class="line"> <span class="comment">// work properly.</span></div>
<div class="line">                fMap.erase(it);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordflow">return</span> std::shared_ptr&lt;IndexBuffer&gt;();</div>
<div class="line">        }</div>
<div class="line">    }   </div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> insert(std::shared_ptr&lt;IndexBuffer&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        fMap.insert(</div>
<div class="line">            std::make_pair(</div>
<div class="line">                Key(buffer-&gt;array(), buffer-&gt;beginIdx(), buffer-&gt;endIdx()),</div>
<div class="line">                buffer));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> removeIfStaled(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;Array&lt;index_t&gt; &gt;&amp; array,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span> beginIdx,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span> endIdx</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        Map::const_iterator it = fMap.find(Key(array, beginIdx, endIdx));</div>
<div class="line"> <span class="keywordflow">if</span> (it != fMap.end()) {</div>
<div class="line"> <span class="comment">// Might return null if the weak_ptr&lt;&gt; is now dangling</span></div>
<div class="line"> <span class="comment">// but not yet removed from the map...</span></div>
<div class="line">            std::shared_ptr&lt;IndexBuffer&gt; ret = it-&gt;second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line"> <span class="comment">// Get rid of the stalled entry so that insert() can</span></div>
<div class="line"> <span class="comment">// work properly.</span></div>
<div class="line">                fMap.erase(it);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span> nbAllocated()</div>
<div class="line">    { <span class="keywordflow">return</span> fMap.size(); }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">size_t</span> nbAllocatedBytes()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">size_t</span> bytes = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Map::value_type&amp; v : fMap) {</div>
<div class="line">            std::shared_ptr&lt;IndexBuffer&gt; buf = v.second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (buf) {</div>
<div class="line">                bytes += buf-&gt;bytes();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> bytes;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">typedef</span> std::unordered_map&lt;</div>
<div class="line">        Key,</div>
<div class="line">        std::weak_ptr&lt;IndexBuffer&gt;,</div>
<div class="line">        KeyHash,</div>
<div class="line">        KeyEqualTo</div>
<div class="line">    &gt; Map;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> IndexBufferRegistry fsSingleton;</div>
<div class="line"></div>
<div class="line">    tbb::mutex fMutex;</div>
<div class="line">    Map fMap;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">IndexBufferRegistry IndexBufferRegistry::fsSingleton;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS VertexBufferRegistry</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>VertexBufferRegistry</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> VertexBuffer::Key Key;</div>
<div class="line"> <span class="keyword">typedef</span> VertexBuffer::KeyHash KeyHash;</div>
<div class="line"> <span class="keyword">typedef</span> VertexBuffer::KeyEqualTo KeyEqualTo;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> VertexBufferRegistry&amp; singleton()</div>
<div class="line">    { <span class="keywordflow">return</span> fsSingleton; }</div>
<div class="line"></div>
<div class="line">    ~VertexBufferRegistry() {}</div>
<div class="line"></div>
<div class="line">    tbb::mutex&amp; mutex() </div>
<div class="line">    { <span class="keywordflow">return</span> fMutex; }</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;VertexBuffer&gt; lookup(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;Array&lt;float&gt; &gt;&amp;     array,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a0"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a>&amp;   desc</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        Map::const_iterator it = fMap.find(Key(array, desc));</div>
<div class="line"> <span class="keywordflow">if</span> (it != fMap.end()) {</div>
<div class="line"> <span class="comment">// Might return null if the weak_ptr&lt;&gt; is now dangling</span></div>
<div class="line"> <span class="comment">// but not yet removed from the map...</span></div>
<div class="line">            std::shared_ptr&lt;VertexBuffer&gt; ret = it-&gt;second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line"> <span class="comment">// Get rid of the stalled entry so that insert() can</span></div>
<div class="line"> <span class="comment">// work properly.</span></div>
<div class="line">                fMap.erase(it);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordflow">return</span> std::shared_ptr&lt;VertexBuffer&gt;();</div>
<div class="line">        }</div>
<div class="line">    }   </div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> insert(std::shared_ptr&lt;VertexBuffer&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        fMap.insert(</div>
<div class="line">            std::make_pair(</div>
<div class="line">                Key(buffer-&gt;array(), buffer-&gt;descriptor()),</div>
<div class="line">                buffer));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> removeIfStaled(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;Array&lt;float&gt; &gt;&amp;     array,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a>&amp;   desc</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        Map::const_iterator it = fMap.find(Key(array, desc));</div>
<div class="line"> <span class="keywordflow">if</span> (it != fMap.end()) {</div>
<div class="line"> <span class="comment">// Might return null if the weak_ptr&lt;&gt; is now dangling</span></div>
<div class="line"> <span class="comment">// but not yet removed from the map...</span></div>
<div class="line">            std::shared_ptr&lt;VertexBuffer&gt; ret = it-&gt;second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line"> <span class="comment">// Get rid of the stalled entry so that insert() can</span></div>
<div class="line"> <span class="comment">// work properly.</span></div>
<div class="line">                fMap.erase(it);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span> nbAllocated()</div>
<div class="line">    { <span class="keywordflow">return</span> fMap.size(); }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">size_t</span> nbAllocatedBytes()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">size_t</span> bytes = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> Map::value_type&amp; v : fMap) {</div>
<div class="line">            std::shared_ptr&lt;VertexBuffer&gt; buf = v.second.lock();</div>
<div class="line"> <span class="keywordflow">if</span> (buf) {</div>
<div class="line">                bytes += buf-&gt;bytes();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> bytes;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">typedef</span> std::unordered_map&lt;</div>
<div class="line">        Key,</div>
<div class="line">        std::weak_ptr&lt;VertexBuffer&gt;,</div>
<div class="line">        KeyHash,</div>
<div class="line">        KeyEqualTo</div>
<div class="line">    &gt; Map;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> VertexBufferRegistry fsSingleton;</div>
<div class="line"></div>
<div class="line">    tbb::mutex fMutex;</div>
<div class="line">    Map fMap;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">VertexBufferRegistry VertexBufferRegistry::fsSingleton;</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ArrayBase</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ArrayBase::registerCreationCallback(Callback callback)</div>
<div class="line">{</div>
<div class="line">    ArrayBaseImp::registerCreationCallback(callback);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ArrayBase::unregisterCreationCallback(Callback callback)</div>
<div class="line">{</div>
<div class="line">    ArrayBaseImp::unregisterCreationCallback(callback);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ArrayBase::registerDestructionCallback(Callback callback)</div>
<div class="line">{</div>
<div class="line">    ArrayBaseImp::registerDestructionCallback(callback);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ArrayBase::unregisterDestructionCallback(Callback callback)</div>
<div class="line">{</div>
<div class="line">    ArrayBaseImp::unregisterDestructionCallback(callback);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ArrayBase::ArrayBase(<span class="keywordtype">size_t</span> bytes, <span class="keyword">const</span> Digest&amp; digest, <span class="keywordtype">bool</span> isReadable)</div>
<div class="line">    : fKey(bytes, digest)</div>
<div class="line">    , fIsReadable(isReadable)</div>
<div class="line">{</div>
<div class="line">    ArrayBaseImp::invokeCreationCallback(fKey);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ArrayBase::~ArrayBase()</div>
<div class="line">{</div>
<div class="line">    ArrayBaseImp::invokeDestructionCallback(fKey);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ArrayReadInterface</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>ArrayReadInterface&lt;IndexBuffer::index_t&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>ArrayReadInterface&lt;float&gt;;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS Array</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">Array&lt;T&gt;::~Array()</div>
<div class="line">{</div>
<div class="line">    tbb::mutex::scoped_lock lock(ArrayRegistryImp&lt;T&gt;::singleton().mutex());</div>
<div class="line">    ArrayRegistryImp&lt;T&gt;::singleton().removeIfStaled(key(), isReadable());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>Array&lt;IndexBuffer::index_t&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>Array&lt;float&gt;;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ReadableArray</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>ReadableArray&lt;IndexBuffer::index_t&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>ReadableArray&lt;float&gt;;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ArrayRegistry</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">tbb::mutex&amp; ArrayRegistry&lt;T&gt;::mutex()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> ArrayRegistryImp&lt;T&gt;::singleton().mutex();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::shared_ptr&lt;Array&lt;T&gt; &gt; ArrayRegistry&lt;T&gt;::lookup(</div>
<div class="line"> <span class="keyword">const</span> Digest&amp; digest,</div>
<div class="line"> <span class="keywordtype">size_t</span> size</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    std::shared_ptr&lt;Array&lt;T&gt; &gt; result =</div>
<div class="line">        ArrayRegistryImp&lt;T&gt;::singleton().lookup(digest, size);</div>
<div class="line"></div>
<div class="line">    assert(!result || result-&gt;digest() == digest);</div>
<div class="line">    assert(!result || result-&gt;bytes()  == size * <span class="keyword">sizeof</span>(T));</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::shared_ptr&lt;Array&lt;T&gt; &gt; ArrayRegistry&lt;T&gt;::lookupNonReadable(</div>
<div class="line"> <span class="keyword">const</span> Digest&amp; digest,</div>
<div class="line"> <span class="keywordtype">size_t</span> size</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    std::shared_ptr&lt;Array&lt;T&gt; &gt; result =</div>
<div class="line">        ArrayRegistryImp&lt;T&gt;::singleton().lookupNonReadable(digest, size);</div>
<div class="line"></div>
<div class="line">    assert(!result || result-&gt;digest() == digest);</div>
<div class="line">    assert(!result || result-&gt;bytes()  == size * <span class="keyword">sizeof</span>(T));</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"> std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt;  ArrayRegistry&lt;T&gt;::lookupReadable(</div>
<div class="line"> <span class="keyword">const</span> Digest&amp; digest,</div>
<div class="line"> <span class="keywordtype">size_t</span> size</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; result =</div>
<div class="line">        ArrayRegistryImp&lt;T&gt;::singleton().lookupReadable(digest, size);</div>
<div class="line"></div>
<div class="line">    assert(!result || result-&gt;digest() == digest);</div>
<div class="line">    assert(!result || result-&gt;bytes()  == size * <span class="keyword">sizeof</span>(T));</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> ArrayRegistry&lt;T&gt;::insert(</div>
<div class="line">    std::shared_ptr&lt;Array&lt;T&gt; &gt; array</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    ArrayRegistryImp&lt;T&gt;::singleton().insert(array);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>ArrayRegistry&lt;IndexBuffer::index_t&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>ArrayRegistry&lt;float&gt;;</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SharedArray</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt;</div>
<div class="line">SharedArray&lt;T&gt;::create(</div>
<div class="line"> <span class="keyword">const</span> boost::shared_array&lt;T&gt;&amp; data, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Compute the Murmur3 cryptographic hash-key.</span></div>
<div class="line">    Digest digest;</div>
<div class="line">    Alembic::Util::MurmurHash3_x64_128(</div>
<div class="line">        data.get(), size * <span class="keyword">sizeof</span>(T), <span class="keyword">sizeof</span>(T), digest.words);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> create(data, digest, size);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt;</div>
<div class="line">SharedArray&lt;T&gt;::create(</div>
<div class="line"> <span class="keyword">const</span> boost::shared_array&lt;T&gt;&amp; data, Digest digest, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// We first look if a similar array already exists in the</span></div>
<div class="line"> <span class="comment">// cache. If so, we return the cached array to promote sharing as</span></div>
<div class="line"> <span class="comment">// much as possible.</span></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; ret;</div>
<div class="line">    {</div>
<div class="line">        tbb::mutex::scoped_lock lock(ArrayRegistry&lt;T&gt;::mutex());</div>
<div class="line"></div>
<div class="line">        ret = ArrayRegistry&lt;T&gt;::lookupReadable(digest, size);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line">            ret = std::make_shared&lt;SharedArray&lt;T&gt; &gt;(</div>
<div class="line">                data, size, digest);</div>
<div class="line">            ArrayRegistry&lt;T&gt;::insert(ret);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">SharedArray&lt;T&gt;::~SharedArray()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">const</span> T* SharedArray&lt;T&gt;::get()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">return</span> fData.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>SharedArray&lt;IndexBuffer::index_t&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>SharedArray&lt;float&gt;;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS IndexBuffer</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;IndexBuffer&gt; IndexBuffer::create(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;Array&lt;index_t&gt; &gt;&amp; array,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span> beginIdx,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span> endIdx</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// We first look if a similar array already exists in the</span></div>
<div class="line"> <span class="comment">// cache. If so, we return the cached array to promote sharing as</span></div>
<div class="line"> <span class="comment">// much as possible.</span></div>
<div class="line">    std::shared_ptr&lt;IndexBuffer&gt; ret;</div>
<div class="line">    {</div>
<div class="line">        tbb::mutex::scoped_lock lock(</div>
<div class="line">            IndexBufferRegistry::singleton().mutex());</div>
<div class="line"></div>
<div class="line">        ret = IndexBufferRegistry::singleton().lookup(</div>
<div class="line">            array, beginIdx, endIdx);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line">            ret = std::make_shared&lt;IndexBuffer&gt;(</div>
<div class="line">                array, beginIdx, endIdx);</div>
<div class="line">            IndexBufferRegistry::singleton().insert(ret);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">size_t</span> IndexBuffer::nbAllocated()</div>
<div class="line">{</div>
<div class="line">    tbb::mutex::scoped_lock lock(</div>
<div class="line">        IndexBufferRegistry::singleton().mutex());</div>
<div class="line"> <span class="keywordflow">return</span> IndexBufferRegistry::singleton().nbAllocated();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> IndexBuffer::nbAllocatedBytes()</div>
<div class="line">{</div>
<div class="line">    tbb::mutex::scoped_lock lock(</div>
<div class="line">        IndexBufferRegistry::singleton().mutex());</div>
<div class="line"> <span class="keywordflow">return</span> IndexBufferRegistry::singleton().nbAllocatedBytes();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">IndexBuffer::~IndexBuffer()</div>
<div class="line">{</div>
<div class="line">    tbb::mutex::scoped_lock lock(</div>
<div class="line">        IndexBufferRegistry::singleton().mutex());</div>
<div class="line">    IndexBufferRegistry::singleton().removeIfStaled(</div>
<div class="line">        fArray, fBeginIdx, fEndIdx);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> IndexBuffer::ReplaceArrayInstance(std::shared_ptr&lt;Array&lt;index_t&gt; &gt;&amp; newArray)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    assert(ArrayBase::KeyEqualTo()(fArray-&gt;key(), newArray-&gt;key()));</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fArray != newArray) {</div>
<div class="line">        std::shared_ptr&lt;Array&lt;index_t&gt; &gt;&amp; nonConstArray = <span class="keyword">const_cast&lt;</span>std::shared_ptr&lt;Array&lt;index_t&gt; <span class="keyword">&gt;</span>&amp; &gt;(fArray);</div>
<div class="line">        nonConstArray = newArray;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS VertexBuffer</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;VertexBuffer&gt;</div>
<div class="line">VertexBuffer::createPositions(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;Array&lt;float&gt; &gt;&amp; array)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> create(array,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a>(</div>
<div class="line"> <a name="_a1"></a><a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">""</span>),</div>
<div class="line"> <a name="a2"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4aa20581584e5f9447cb96afb4f2e10703">MHWRender::MGeometry::kPosition</a>,</div>
<div class="line"> <a name="a3"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a5686197bafb177bdc82550848416a1ad">MHWRender::MGeometry::kFloat</a>, 3));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;VertexBuffer&gt;</div>
<div class="line">VertexBuffer::createNormals(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;Array&lt;float&gt; &gt;&amp; array)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> create(array,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a>(</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">""</span>),</div>
<div class="line"> <a name="a4"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a227e8416235cd3b43077ca91504a463f">MHWRender::MGeometry::kNormal</a>,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a5686197bafb177bdc82550848416a1ad">MHWRender::MGeometry::kFloat</a>, 3));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;VertexBuffer&gt;</div>
<div class="line">VertexBuffer::createUVs(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;Array&lt;float&gt; &gt;&amp; array)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> create( array,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a>(</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">"mayaUVIn"</span>),</div>
<div class="line"> <a name="a5"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93">MHWRender::MGeometry::kTexture</a>,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a5686197bafb177bdc82550848416a1ad">MHWRender::MGeometry::kFloat</a>, 2));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;VertexBuffer&gt;</div>
<div class="line">VertexBuffer::create(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;Array&lt;float&gt; &gt;&amp;     array,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a>&amp;   desc)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// We first look if a similar array already exists in the</span></div>
<div class="line"> <span class="comment">// cache. If so, we return the cached array to promote sharing as</span></div>
<div class="line"> <span class="comment">// much as possible.</span></div>
<div class="line">    std::shared_ptr&lt;VertexBuffer&gt; ret;</div>
<div class="line">    {</div>
<div class="line">        tbb::mutex::scoped_lock lock(</div>
<div class="line">            VertexBufferRegistry::singleton().mutex());</div>
<div class="line"></div>
<div class="line">        ret = VertexBufferRegistry::singleton().lookup(array, desc);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line">            ret = std::make_shared&lt;VertexBuffer&gt;(</div>
<div class="line">                array, desc);</div>
<div class="line">            VertexBufferRegistry::singleton().insert(ret);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">size_t</span> VertexBuffer::nbAllocated()</div>
<div class="line">{</div>
<div class="line">    tbb::mutex::scoped_lock lock(</div>
<div class="line">        VertexBufferRegistry::singleton().mutex());</div>
<div class="line"> <span class="keywordflow">return</span> VertexBufferRegistry::singleton().nbAllocated();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> VertexBuffer::nbAllocatedBytes()</div>
<div class="line">{</div>
<div class="line">    tbb::mutex::scoped_lock lock(</div>
<div class="line">        VertexBufferRegistry::singleton().mutex());</div>
<div class="line"> <span class="keywordflow">return</span> VertexBufferRegistry::singleton().nbAllocatedBytes();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">VertexBuffer::~VertexBuffer()</div>
<div class="line">{</div>
<div class="line">    tbb::mutex::scoped_lock lock(</div>
<div class="line">        VertexBufferRegistry::singleton().mutex());</div>
<div class="line">    VertexBufferRegistry::singleton().removeIfStaled(</div>
<div class="line">        fArray, fDescriptor);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> VertexBuffer::ReplaceArrayInstance(std::shared_ptr&lt;Array&lt;float&gt; &gt;&amp; newArray)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    assert(ArrayBase::KeyEqualTo()(fArray-&gt;key(), newArray-&gt;key()));</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fArray != newArray) {</div>
<div class="line">        std::shared_ptr&lt;Array&lt;float&gt; &gt;&amp; nonConstArray = <span class="keyword">const_cast&lt;</span>std::shared_ptr&lt;Array&lt;float&gt; <span class="keyword">&gt;</span>&amp; &gt;(fArray);</div>
<div class="line">        nonConstArray = newArray;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ShapeSample</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">ShapeSample::ShapeSample(</div>
<div class="line"> <span class="keywordtype">double</span> timeInSeconds,</div>
<div class="line"> <span class="keywordtype">size_t</span> numWires,</div>
<div class="line"> <span class="keywordtype">size_t</span> numVerts,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;IndexBuffer&gt;&amp;  wireVertIndices,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;IndexBuffer&gt;&amp;  triangleVertIndices,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;VertexBuffer&gt;&amp; positions,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a6"></a><a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>&amp; boundingBox,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a7"></a><a class="code" href="./class_m_color.html">MColor</a>&amp;       diffuseColor,</div>
<div class="line"> <span class="keywordtype">bool</span>                visibility</div>
<div class="line">) </div>
<div class="line">    : fTimeInSeconds(timeInSeconds),</div>
<div class="line">      fNumWires(numWires),</div>
<div class="line">      fNumVerts(numVerts),</div>
<div class="line">      fWireVertIndices(wireVertIndices),</div>
<div class="line">      fTriangleVertIndices(</div>
<div class="line">      std::vector&lt;std::shared_ptr&lt;IndexBuffer&gt; &gt;(1, triangleVertIndices)),</div>
<div class="line">      fPositions(positions),</div>
<div class="line">      fBoundingBox(boundingBox),</div>
<div class="line">      fDiffuseColor(diffuseColor),</div>
<div class="line">      fVisibility(visibility),</div>
<div class="line">      fBoundingBoxPlaceHolder(false)</div>
<div class="line">{</div>
<div class="line">    assert( wireVertIndices ? (wireVertIndices-&gt;numIndices() == 2 * fNumWires) : (fNumWires == 0) );</div>
<div class="line">    assert( positions ? (positions-&gt;numVerts() == fNumVerts) : (fNumVerts == 0) );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ShapeSample::ShapeSample(</div>
<div class="line"> <span class="keywordtype">double</span> timeInSeconds,</div>
<div class="line"> <span class="keywordtype">size_t</span> numWires,</div>
<div class="line"> <span class="keywordtype">size_t</span> numVerts,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;IndexBuffer&gt;&amp;  wireVertIndices,</div>
<div class="line"> <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;IndexBuffer&gt; &gt;&amp;  triangleVertIndices,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;VertexBuffer&gt;&amp; positions,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>&amp; boundingBox,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp;       diffuseColor,</div>
<div class="line"> <span class="keywordtype">bool</span>                visibility</div>
<div class="line">) </div>
<div class="line">    : fTimeInSeconds(timeInSeconds),</div>
<div class="line">      fNumWires(numWires),</div>
<div class="line">      fNumVerts(numVerts),</div>
<div class="line">      fWireVertIndices(wireVertIndices),</div>
<div class="line">      fTriangleVertIndices(triangleVertIndices),</div>
<div class="line">      fPositions(positions),</div>
<div class="line">      fBoundingBox(boundingBox),</div>
<div class="line">      fDiffuseColor(diffuseColor),</div>
<div class="line">      fVisibility(visibility),</div>
<div class="line">      fBoundingBoxPlaceHolder(false)</div>
<div class="line">{</div>
<div class="line">    assert( wireVertIndices ? (wireVertIndices-&gt;numIndices() == 2 * fNumWires) : (fNumWires == 0) );</div>
<div class="line">    assert( positions ? (positions-&gt;numVerts() == fNumVerts) : (fNumVerts == 0) );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ShapeSample::~ShapeSample()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">size_t</span> ShapeSample::numTriangles()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordtype">size_t</span> result = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;numIndexGroups(); ++i) {</div>
<div class="line">        result += numTriangles(i);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeSample::setNormals(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;VertexBuffer&gt;&amp; normals</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    assert( !normals || normals-&gt;numVerts() == fNumVerts );</div>
<div class="line">    fNormals = normals;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ShapeSample::setUVs(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;VertexBuffer&gt;&amp; uvs</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    assert( !uvs || uvs-&gt;numVerts() == fNumVerts );</div>
<div class="line">    fUVs = uvs;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</link></link></link></link></div></body>
</html>

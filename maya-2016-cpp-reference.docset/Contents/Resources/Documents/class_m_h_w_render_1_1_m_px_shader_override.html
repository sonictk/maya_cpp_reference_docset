<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="product" content="MAYAUL"><meta name="release" content="2016"><meta name="book" content="Developer"><meta name="created" content="2015-10-14"><meta name="topicid" content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887"><meta name="topic-type" content="concept">
      <title>MPxShaderOverride Class Reference</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_h_w_render_1_1_m_px_shader_override.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?siteData=y5CYlxTRD0znCzRLDwX0Wy7-g1EdC1XA4dSC-Y1LtaeScyli8_Ps5jPKqTr4xKxMI0OOUfkDplvX3uxN0JnPclebSYW8_J1HBzf4VLQEzQ8M4PsYXF_cMyp1Oumaetky&category=5297189e-446b-459e-ae1d-9d0360400781_tech&ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='position:absolute;right:20px;top:5px;z-index:100;color:white;background-color:#555555;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>MPxShaderOverride Class Reference</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="#!/url=./cpp_ref/classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="#!/url=./cpp_ref/hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="#!/url=./cpp_ref/functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  
  <div class="headertitle">
<div class="title">MPxShaderOverride Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" translate="no" href="#!/url=./cpp_ref/group___open_maya_render.html">OpenMayaRender - API module for rendering</a> &#124; <a class="el" translate="no" href="#!/url=./cpp_ref/group___m_px.html">Proxy classes</a></div></div>  </div>
<div id="OverviewLinksDiv"><div id="dynsection-overview" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><img id="dynsection-overview-trigger" src="cpp_ref/closed.png" alt="+"> Related help topics: </div><div id="dynsection-overview-content" class="dyncontent" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./files/GUID-6644CF46-6648-45B8-A3D8-76EDD7712571.htm">What's New / What's Changed? &gt; What's New in API in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-1BB599DB-D637-4D95-AD35-9F85AA5A35ED.htm">What's New / What's Changed? &gt; What's New in API in Maya 2016 &gt; C++ API Changes in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-DBDCB848-B0A5-4256-912C-6FCE25D12984.htm">What's New / What's Changed? &gt; Autodesk Maya 2015</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-9DBD7E49-7A17-4CEB-89AF-A3B509AD91E2.htm">What's New / What's Changed? &gt; Autodesk Maya 2014</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-F0CA7A2C-EE99-4A95-9E5E-C187F000092C.htm">What's New / What's Changed? &gt; Extension for Autodesk Maya 2013</a></li>
<li class="overviewLink"><a href="#!/url=./files/Writing_a_Hardware_Shading_Node_Hardware_Shading_node_plugin_examples.htm">Writing a Hardware Shading Node &gt; Hardware shading node plug-in examples</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-9496C634-9C18-49D4-A18C-D16600F73848.htm">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Scene Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-24BAA64A-DAEA-43DB-8FF0-5625F371AE67.htm">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Framework Classes</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-7E935B18-FFBB-4DD3-82EA-A2175CF7795C.htm">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Transition Guide</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-9A5432D0-FA89-4E64-8277-22DC81680B20.htm">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Developer Kit Samples</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-9B9CDD21-F3AD-4B79-B610-AAA42D4C6599.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; API constructs &gt; Frame and draw contexts</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-63572033-5999-4865-822D-A803A8BED59E.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Plug-in Entry Points &gt; Effect Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-585F5656-4069-4D82-B9BB-3D1AB2D0DFE6.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Plug-in Entry Points &gt; Shading Node Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-9F212D49-8063-4079-A175-BE3682221FF8.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Plug-in Entry Points &gt; Draw Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-D1853655-D22D-4B1C-8CBD-528CD1903B0E.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Lighting Interfaces</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-0F59EAA2-849E-4BAB-843B-6262B256D80F.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Customizing Geometric Data for Shaders</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-E171DC25-5750-4CA0-9A6C-A411EED1CE3E.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Effects interfaces</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-B8944200-F3A7-479F-BD54-990DF95EAD34.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Handling custom renderables for object overrides</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-A315D8E2-3D86-46BB-97DF-45E3ABE1A0AA.htm">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Devices and Draw APIs &gt; Accessing Resource Handles and Device Handle</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-13229A83-B6A0-4280-840C-F9C6F40BB13D.htm">Viewport 2.0 API &gt; Semantics and annotations supported by the dx11Shader and glslShader plug-ins in Viewport 2.0</a></li>
<li class="overviewLink"><a href="#!/url=./files/GUID-0939A615-81AC-455C-9B23-9ECEC5835F93.htm">Viewport 2.0 API &gt; Shader semantics supported by Viewport 2.0</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_h_w_render_1_1_m_px_shader_override.html#nested-classes">Classes</a> &#124;
<a href="class_m_h_w_render_1_1_m_px_shader_override.html#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_h_w_render_1_1_m_px_shader_override.html#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_m_h_w_render_1_1_m_px_shader_override.html#pro-methods">Protected Member Functions</a>  </div></div><!--header-->
<div class="contents">

<p><code>#include &lt;MPxShaderOverride.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><p>Base class for user defined shading effect draw overrides. </p>
<p><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a> allows the user to create a custom override for associating a "full shading effect" with a shading node (custom or standard) in Maya. Its primary use is for associating hardware effects with pre-existing plugin software shaders.</p>
<p>A "full shading effect" defines the complete shading and lighting involved to render a given object. Input resources for shading such as geometry, textures, and lights are defined and bound to the shading effect via the override as required. The override is fully responsible for these tasks.</p>
<p>As an example, for hardware shading, this can be thought of as implementing a CgFx or HLSL effect file renderer which can use the resources defined within a Maya scene.</p>
<p>There are three main phases that the override must implement:</p>
<p>1) Initialization Phase : This phase occurs when Maya determines that the hardware shader generated through this override needs to be rebuilt. This may be due to a new object using the shader, or because something has changed on the shader that requires a complete rebuild. For example a value change with <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a11ba79b61b2bfcc34362ee7675aca6b4" title="If this method returns true, it will force shader and geometry data to be rebuilt on any change to th...">rebuildAlways()</a> returning true will require a complete rebuild. During the initialization phase the geometric stream requirements can be specified. If an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a> is used as the shader for rendering then <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#abd43fa3203bf4c9df6e3b3cdb7b4d117" title="During the initialization phase the geometry requirements for the shading effect can be updated...">setGeometryRequirements()</a> should be called to extract the requirements from the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a>. Otherwise, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a1293e58405a12d8024512b733e2396d1" title="During the initialization phase the geometry requirements for the shading effect can be updated...">addGeometryRequirement()</a> or <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a155173d2a454b0af927b6c58a1fe09c4" title="During the initialization phase the geometry requirements for the shading effect can be updated...">addGeometryRequirements()</a> should be used. The requirements will determine which geometric streams are required from objects to which the given shading effect is assigned. If no requirements are specified then a single position stream requirement will be used.</p>
<p>The <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a0212be7dfc693d9d7a0f95ddcb81ba8d" title="Initialization occurs when Maya determines that the hardware shader needs to be rebuilt. ">initialize()</a> method must return a string representing the shader key. It often happens that different instances of the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a> represent essentially the same shader, but with different shader parameters. The shader key is used to identify the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a> instances representing the same shader. To optimize rendering, the Viewport 2.0 will make an effort to regroup the rendering of objects with the same <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a> shader key. This allows the plug-in to perform its setup only once for the entire sequence. It is up to each plug-in to decide what the meaning of representing the same shader is.</p>
<p>There are two possible versions of <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a0212be7dfc693d9d7a0f95ddcb81ba8d" title="Initialization occurs when Maya determines that the hardware shader needs to be rebuilt. ">initialize()</a> to implement (however it is only necessary to implement one, the default implementation of the second calls the first). The first simply receives the shader node that is being initialized. The second receives additional context (such as the DAG path for the object bound to the shader) and also allows the implementation to send back custom user data to attach to the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html" title="A single renderable entity. ">MRenderItem</a> representing the DAG-object/shader association. The custom user data must be derived from <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_user_data.html" title="Virtual base class for user data caching. ">MUserData</a>. If the deleteAfterUse() method returns true for the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_user_data.html" title="Virtual base class for user data caching. ">MUserData</a> instance then the data object will automatically be deleted when the render item is deleted. Otherwise the lifetime of the user data object is the responsibility of the caller. This user data may be accessed in the draw phase from the render item being drawn. Note that Maya objects which have render items that have custom user data can only be consolidated when the user data pointer on each item references the same user data instance. Draw performance will suffer without consolidation, however if the user data object is shared then memory management must be handled manually (ie. deleteAfterUse() should return false).</p>
<p>During initialization, if the current display mode is non-textured display mode, an internally defined static shader instance is used for all render items which use the shading node associated with a given shader override. This is a performance optimization to avoid any additional node monitoring as well as allow for render items which share this shader instance to be consolidated.</p>
<p>If it is desirable to override this behavior, the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#addc154cb86dafb4b95301938d97659d8" title="Return an override shader instance to be used when drawing in non-textured mode. ">nonTexturedShaderInstance()</a> method can be overridden to return a custom shader instance to be specified instead of the default shared instance. If this shader instance needs to be updated on node attribute changes, then a return parameter can be set to indicate this. If no monitoring is required Maya will attempt to skip the update phase while in non-textured mode. It is still possible that update is required for the shader which used for textured mode display. For example if <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a11ba79b61b2bfcc34362ee7675aca6b4" title="If this method returns true, it will force shader and geometry data to be rebuilt on any change to th...">rebuildAlways()</a> returns true then the update phase would be called regardless of the options set in this method.</p>
<p>2) Data Update Phase : In this phase, updating of all data values required for shading is performed. The interface has an explicit split of when the dependency graph can be accessed (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a3b74f9aeed8e4a00450e3d2045b53b39" title="This is the first part of the update phase. ">updateDG()</a>), and when the draw API (e.g. OpenGL) can be accessed (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a84ad0250e8df6abe4a2bab23778c24de" title="This is the second part of the update phase. ">updateDevice()</a>). Any intermediate data can be cleaned up when <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ae75638d96ce77bea32eb76333b76cbc5" title="This is the final part of the update phase. ">endUpdate()</a> is called.</p>
<p>As an example the override may require input from an attribute on a given node.</p><ul>
<li><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a3b74f9aeed8e4a00450e3d2045b53b39" title="This is the first part of the update phase. ">updateDG()</a> would evaluate the plug for the attribute and cache its value temporarily on the override.</li>
<li><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a84ad0250e8df6abe4a2bab23778c24de" title="This is the second part of the update phase. ">updateDevice()</a> would take the temporarily cached value and bind it to a shader stored on the graphic device.</li>
<li><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ae75638d96ce77bea32eb76333b76cbc5" title="This is the final part of the update phase. ">endUpdate()</a> would reset the temporary data on the override.</li>
</ul>
<p>If an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a> is being used, then the parameters on that instance should be updated during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a84ad0250e8df6abe4a2bab23778c24de" title="This is the second part of the update phase. ">updateDevice()</a>.</p>
<p>Note that the override can provide a draw hint as to whether shading will involve semi-transparency. This hint can be provided by overriding the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ab79d6d7859fceb8fc8b0e4ace1869612" title="During the update phase the override will be called to return whether it will be drawing with semi-tr...">isTransparent()</a> method which gets called between <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a84ad0250e8df6abe4a2bab23778c24de" title="This is the second part of the update phase. ">updateDevice()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ae75638d96ce77bea32eb76333b76cbc5" title="This is the final part of the update phase. ">endUpdate()</a>.</p>
<p>3) Drawing Phase : The actual drawing using the shader is performed in the pure virtual <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> method. The callback method should return true if it was able to draw successfully. If false is returned then drawing will be done using the default shader used for unsupported materials.</p>
<p>Drawing is explicitly not intermixed with the data update on purpose. By the time draw is being called all evaluation should have been completed. If there is user data that needs to be passed between the update and drawing phases the override must cache that data itself. It is an error to access the Maya dependency graph during draw and attempts to do so may result in instability.</p>
<p>Although it is possible for implementations of the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> method to handle all shader setup and geometry draw, the expected use of the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> method is to do shader setup only. Then <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a96b26e833c1533131841eb2bcb2288a4" title="This method may be called from draw() and will cause Maya to immediately draw the current geometry us...">drawGeometry()</a> can be called to allow Maya to handle the actual geometry drawing. If manual geometry binding is required however, it is possible to query the hardware resource handles through the geometry on each render item in the render item list passed into the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> method.</p>
<p>The <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a3b5dcab1b6940e042c0d4843a6ab6787" title="This method indicates whether the shader will handle the drawing based on the context passed in...">handlesDraw()</a> method will be invoked at the beginning of the draw phase to allow the plugin to indicate whether it will handle drawing based on the current draw context information. If this method returns false then <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ad5a9492e13c5e46460e36cf03b5821bc" title="Override this method if a shader instance (MShaderInstance) is to be used for drawing. ">shaderInstance()</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a8d7f721e0a413d81bd9c0b4c4bf451a9" title="This is the activateKey callback. ">activateKey()</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a9d3d971a5a62e06fcbac0537c11d33de" title="This is the terminateKey callback. ">terminateKey()</a> will not be called. The default implementation will return true if the shader is being used for a color pass and there is no per-frame shader override specified. An example of when such a shader override is used is when all objects in the scene are set to draw with the "default material".</p>
<p>The <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a8d7f721e0a413d81bd9c0b4c4bf451a9" title="This is the activateKey callback. ">activateKey()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a9d3d971a5a62e06fcbac0537c11d33de" title="This is the terminateKey callback. ">terminateKey()</a> method will also be invoked in the draw phase each time a render item is drawn with a different shader key (see the discussion above about shader keys). The <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a8d7f721e0a413d81bd9c0b4c4bf451a9" title="This is the activateKey callback. ">activateKey()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a9d3d971a5a62e06fcbac0537c11d33de" title="This is the terminateKey callback. ">terminateKey()</a> methods can be used to optimize rendering by configuring the rendering state only once for a batch of <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> calls that are sharing the same shader key.</p>
<p>The sequence of invocations will look like:</p><ul>
<li>shaderOverrideA-&gt;activateKey(...)</li>
<li>shaderOverrideA-&gt;draw(...)</li>
<li>shaderOverrideB-&gt;draw(...)</li>
<li>shaderOverrideC-&gt;draw(...)</li>
<li>...</li>
<li>shaderOverrideA-&gt;terminateKey(...)</li>
<li>shaderOverrideX-&gt;activateKey(...)</li>
</ul>
<p>Note that the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a9d3d971a5a62e06fcbac0537c11d33de" title="This is the terminateKey callback. ">terminateKey()</a> callback is always invoked on the same <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a> instance as the one used to invoked the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a8d7f721e0a413d81bd9c0b4c4bf451a9" title="This is the activateKey callback. ">activateKey()</a> callback.</p>
<p>If an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a> is being used for drawing, in order to take advatange of the batch drawing optimization, the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ad5a9492e13c5e46460e36cf03b5821bc" title="Override this method if a shader instance (MShaderInstance) is to be used for drawing. ">shaderInstance()</a> method should return the shader instance to use. The shader instance should then be bound during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a8d7f721e0a413d81bd9c0b4c4bf451a9" title="This is the activateKey callback. ">activateKey()</a> and unbound during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a9d3d971a5a62e06fcbac0537c11d33de" title="This is the terminateKey callback. ">terminateKey()</a>. An <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a> can be bound and unbound from within the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> method but will not be optimized for batch drawing.</p>
<p>The sequence using an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a> and the batch optimization will look like:</p><ul>
<li>shaderOverrideA-&gt;shaderInstance(...)</li>
<li>shaderOverrideA-&gt;activateKey(...)</li>
<li>shaderOverrideA-&gt;draw(...)</li>
<li>shaderOverrideB-&gt;draw(...)</li>
<li>shaderOverrideC-&gt;draw(...)</li>
<li>...</li>
<li>shaderOverrideA-&gt;terminateKey(...)</li>
<li>shaderOverrideX-&gt;shaderInstance(...)</li>
<li>shaderOverrideX-&gt;activateKey(...)</li>
</ul>
<p>Note if full draw control is desired, the proxy class <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_draw_override.html" title="Base class for user defined drawing of nodes. ">MPxDrawOverride</a> may be more appropriate.</p>
<p>Implementations of <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a> must be registered with Maya through <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_registry.html" title="Access the registry associating node types with custom implementations. ">MDrawRegistry</a>. </p>
<dl class="section "><div id="dynsection-example0" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example0-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example0-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8cpp-example.html#_a135">cgFx/cgfxShaderNode.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#_a39">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8cpp-example.html#_a7">customTextureShader/customTextureShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#_a0">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8cpp-example.html#_a0">dx11Shader/dx11ShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#_a0">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8cpp-example.html#_a2">glslShader/GLSLShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#_a0">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#_a105">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#_a15">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#_a25">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" translate="no" align="right" valign="top">struct &#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/struct_m_h_w_render_1_1_m_px_shader_override_1_1_m_init_context.html">MInitContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization context used by advanced initalization method.  <a href="#!/url=./cpp_ref/struct_m_h_w_render_1_1_m_px_shader_override_1_1_m_init_context.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" translate="no" align="right" valign="top">struct &#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/struct_m_h_w_render_1_1_m_px_shader_override_1_1_m_init_feedback.html">MInitFeedback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data to pass back to Maya after initialization.  <a href="#!/url=./cpp_ref/struct_m_h_w_render_1_1_m_px_shader_override_1_1_m_init_feedback.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b8db4077442a3e2f1fd93e1eb58f550"><td class="memItemLeft" translate="no" align="right" valign="top">&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a8b8db4077442a3e2f1fd93e1eb58f550">MPxShaderOverride</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;obj)</td></tr>
<tr class="memdesc:a8b8db4077442a3e2f1fd93e1eb58f550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a>.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a8b8db4077442a3e2f1fd93e1eb58f550">More...</a><br></td></tr>
<tr class="separator:a8b8db4077442a3e2f1fd93e1eb58f550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ada510e7e4ce1561bda7c4084c10b1"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="anchor" id="a22ada510e7e4ce1561bda7c4084c10b1"></a>
virtual&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a22ada510e7e4ce1561bda7c4084c10b1">~MPxShaderOverride</a> ()</td></tr>
<tr class="memdesc:a22ada510e7e4ce1561bda7c4084c10b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr class="separator:a22ada510e7e4ce1561bda7c4084c10b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0212be7dfc693d9d7a0f95ddcb81ba8d"><td class="memItemLeft" translate="no" align="right" valign="top">virtual <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a0212be7dfc693d9d7a0f95ddcb81ba8d">initialize</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> shader)</td></tr>
<tr class="memdesc:a0212be7dfc693d9d7a0f95ddcb81ba8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization occurs when Maya determines that the hardware shader needs to be rebuilt.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a0212be7dfc693d9d7a0f95ddcb81ba8d">More...</a><br></td></tr>
<tr class="separator:a0212be7dfc693d9d7a0f95ddcb81ba8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e802137b57af8f591880b98d8732e1"><td class="memItemLeft" translate="no" align="right" valign="top">virtual <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a10e802137b57af8f591880b98d8732e1">initialize</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/struct_m_h_w_render_1_1_m_px_shader_override_1_1_m_init_context.html">MInitContext</a> &amp;initContext, <a class="el" translate="no" href="#!/url=./cpp_ref/struct_m_h_w_render_1_1_m_px_shader_override_1_1_m_init_feedback.html">MInitFeedback</a> &amp;initFeedback)</td></tr>
<tr class="memdesc:a10e802137b57af8f591880b98d8732e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization occurs when Maya determines that the hardware shader needs to be rebuilt.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a10e802137b57af8f591880b98d8732e1">More...</a><br></td></tr>
<tr class="separator:a10e802137b57af8f591880b98d8732e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b74f9aeed8e4a00450e3d2045b53b39"><td class="memItemLeft" translate="no" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a3b74f9aeed8e4a00450e3d2045b53b39">updateDG</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> object)</td></tr>
<tr class="memdesc:a3b74f9aeed8e4a00450e3d2045b53b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the first part of the update phase.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a3b74f9aeed8e4a00450e3d2045b53b39">More...</a><br></td></tr>
<tr class="separator:a3b74f9aeed8e4a00450e3d2045b53b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ad0250e8df6abe4a2bab23778c24de"><td class="memItemLeft" translate="no" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a84ad0250e8df6abe4a2bab23778c24de">updateDevice</a> ()</td></tr>
<tr class="memdesc:a84ad0250e8df6abe4a2bab23778c24de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the second part of the update phase.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a84ad0250e8df6abe4a2bab23778c24de">More...</a><br></td></tr>
<tr class="separator:a84ad0250e8df6abe4a2bab23778c24de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75638d96ce77bea32eb76333b76cbc5"><td class="memItemLeft" translate="no" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ae75638d96ce77bea32eb76333b76cbc5">endUpdate</a> ()</td></tr>
<tr class="memdesc:ae75638d96ce77bea32eb76333b76cbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the final part of the update phase.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#ae75638d96ce77bea32eb76333b76cbc5">More...</a><br></td></tr>
<tr class="separator:ae75638d96ce77bea32eb76333b76cbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5dcab1b6940e042c0d4843a6ab6787"><td class="memItemLeft" translate="no" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a3b5dcab1b6940e042c0d4843a6ab6787">handlesDraw</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;context)</td></tr>
<tr class="memdesc:a3b5dcab1b6940e042c0d4843a6ab6787"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method indicates whether the shader will handle the drawing based on the context passed in.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a3b5dcab1b6940e042c0d4843a6ab6787">More...</a><br></td></tr>
<tr class="separator:a3b5dcab1b6940e042c0d4843a6ab6787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7f721e0a413d81bd9c0b4c4bf451a9"><td class="memItemLeft" translate="no" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a8d7f721e0a413d81bd9c0b4c4bf451a9">activateKey</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;context, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;key)</td></tr>
<tr class="memdesc:a8d7f721e0a413d81bd9c0b4c4bf451a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the activateKey callback.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a8d7f721e0a413d81bd9c0b4c4bf451a9">More...</a><br></td></tr>
<tr class="separator:a8d7f721e0a413d81bd9c0b4c4bf451a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fb6e971beb807417cb83a7b2b8268c"><td class="memItemLeft" translate="no" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c">draw</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;context, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a> &amp;renderItemList) const  =0</td></tr>
<tr class="memdesc:a26fb6e971beb807417cb83a7b2b8268c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the draw callback, the method is called during the draw phase.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c">More...</a><br></td></tr>
<tr class="separator:a26fb6e971beb807417cb83a7b2b8268c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3d971a5a62e06fcbac0537c11d33de"><td class="memItemLeft" translate="no" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a9d3d971a5a62e06fcbac0537c11d33de">terminateKey</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;context, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;key)</td></tr>
<tr class="memdesc:a9d3d971a5a62e06fcbac0537c11d33de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the terminateKey callback.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a9d3d971a5a62e06fcbac0537c11d33de">More...</a><br></td></tr>
<tr class="separator:a9d3d971a5a62e06fcbac0537c11d33de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a36b8ef8730fa92f11c853752cc1e0e"><td class="memItemLeft" translate="no" align="right" valign="top">virtual <a class="el" translate="no" href="#!/url=./cpp_ref/namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49">MHWRender::DrawAPI</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a0a36b8ef8730fa92f11c853752cc1e0e">supportedDrawAPIs</a> () const </td></tr>
<tr class="memdesc:a0a36b8ef8730fa92f11c853752cc1e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the draw API supported by this override.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a0a36b8ef8730fa92f11c853752cc1e0e">More...</a><br></td></tr>
<tr class="separator:a0a36b8ef8730fa92f11c853752cc1e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79d6d7859fceb8fc8b0e4ace1869612"><td class="memItemLeft" translate="no" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ab79d6d7859fceb8fc8b0e4ace1869612">isTransparent</a> ()</td></tr>
<tr class="memdesc:ab79d6d7859fceb8fc8b0e4ace1869612"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the update phase the override will be called to return whether it will be drawing with semi-transparency.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#ab79d6d7859fceb8fc8b0e4ace1869612">More...</a><br></td></tr>
<tr class="separator:ab79d6d7859fceb8fc8b0e4ace1869612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae919985341ff7706a78139a098146ed3"><td class="memItemLeft" translate="no" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ae919985341ff7706a78139a098146ed3">supportsAdvancedTransparency</a> () const </td></tr>
<tr class="memdesc:ae919985341ff7706a78139a098146ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the update phase the override will be called to return whether it supports advanced transparency algorithms (such as depth peeling).  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#ae919985341ff7706a78139a098146ed3">More...</a><br></td></tr>
<tr class="separator:ae919985341ff7706a78139a098146ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9341f2236028651e9d3b7b26d52dcb"><td class="memItemLeft" translate="no" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a1b9341f2236028651e9d3b7b26d52dcb">overridesDrawState</a> ()</td></tr>
<tr class="memdesc:a1b9341f2236028651e9d3b7b26d52dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the draw phase this method will be called to determine whether the override will override the draw state when drawing.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a1b9341f2236028651e9d3b7b26d52dcb">More...</a><br></td></tr>
<tr class="separator:a1b9341f2236028651e9d3b7b26d52dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ba79b61b2bfcc34362ee7675aca6b4"><td class="memItemLeft" translate="no" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a11ba79b61b2bfcc34362ee7675aca6b4">rebuildAlways</a> ()</td></tr>
<tr class="memdesc:a11ba79b61b2bfcc34362ee7675aca6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this method returns true, it will force shader and geometry data to be rebuilt on any change to the shader.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a11ba79b61b2bfcc34362ee7675aca6b4">More...</a><br></td></tr>
<tr class="separator:a11ba79b61b2bfcc34362ee7675aca6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f52a7284bd2c98697c744b009790fa"><td class="memItemLeft" translate="no" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a11f52a7284bd2c98697c744b009790fa">boundingBoxExtraScale</a> () const </td></tr>
<tr class="memdesc:a11f52a7284bd2c98697c744b009790fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to supply an extra scale factor to be applied to the object space bounding box of any objects which use the shader associated with this override.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a11f52a7284bd2c98697c744b009790fa">More...</a><br></td></tr>
<tr class="separator:a11f52a7284bd2c98697c744b009790fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c032b89513ada1a3c21260c42ea0da"><td class="memItemLeft" translate="no" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a09c032b89513ada1a3c21260c42ea0da">overridesNonMaterialItems</a> () const </td></tr>
<tr class="memdesc:a09c032b89513ada1a3c21260c42ea0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method if the shader instance should also be used to render non material items such as the wireframe and the selected edges/vertices components.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a09c032b89513ada1a3c21260c42ea0da">More...</a><br></td></tr>
<tr class="separator:a09c032b89513ada1a3c21260c42ea0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a9492e13c5e46460e36cf03b5821bc"><td class="memItemLeft" translate="no" align="right" valign="top">virtual <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MHWRender::MShaderInstance</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ad5a9492e13c5e46460e36cf03b5821bc">shaderInstance</a> () const </td></tr>
<tr class="memdesc:ad5a9492e13c5e46460e36cf03b5821bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method if a shader instance (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a>) is to be used for drawing.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#ad5a9492e13c5e46460e36cf03b5821bc">More...</a><br></td></tr>
<tr class="separator:ad5a9492e13c5e46460e36cf03b5821bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc154cb86dafb4b95301938d97659d8"><td class="memItemLeft" translate="no" align="right" valign="top">virtual <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MHWRender::MShaderInstance</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#addc154cb86dafb4b95301938d97659d8">nonTexturedShaderInstance</a> (bool &amp;monitorNode) const </td></tr>
<tr class="memdesc:addc154cb86dafb4b95301938d97659d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an override shader instance to be used when drawing in non-textured mode.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#addc154cb86dafb4b95301938d97659d8">More...</a><br></td></tr>
<tr class="separator:addc154cb86dafb4b95301938d97659d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ae16788a38ceee59f6b8ce18628d4b"><td class="memItemLeft" translate="no" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a59ae16788a38ceee59f6b8ce18628d4b">activateKey</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;context)</td></tr>
<tr class="memdesc:a59ae16788a38ceee59f6b8ce18628d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>This method is obsolete.</b>  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a59ae16788a38ceee59f6b8ce18628d4b">More...</a><br></td></tr>
<tr class="separator:a59ae16788a38ceee59f6b8ce18628d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bea6a5c34bb8ffa705abe72fb86a91"><td class="memItemLeft" translate="no" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a86bea6a5c34bb8ffa705abe72fb86a91">terminateKey</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;context)</td></tr>
<tr class="memdesc:a86bea6a5c34bb8ffa705abe72fb86a91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>This method is obsolete.</b>  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a86bea6a5c34bb8ffa705abe72fb86a91">More...</a><br></td></tr>
<tr class="separator:a86bea6a5c34bb8ffa705abe72fb86a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memItemLeft" translate="no" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this class.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1293e58405a12d8024512b733e2396d1"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a1293e58405a12d8024512b733e2396d1">addGeometryRequirement</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> &amp;desc)</td></tr>
<tr class="memdesc:a1293e58405a12d8024512b733e2396d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the initialization phase the geometry requirements for the shading effect can be updated.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a1293e58405a12d8024512b733e2396d1">More...</a><br></td></tr>
<tr class="separator:a1293e58405a12d8024512b733e2396d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155173d2a454b0af927b6c58a1fe09c4"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a155173d2a454b0af927b6c58a1fe09c4">addGeometryRequirements</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor_list.html">MVertexBufferDescriptorList</a> &amp;list)</td></tr>
<tr class="memdesc:a155173d2a454b0af927b6c58a1fe09c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the initialization phase the geometry requirements for the shading effect can be updated.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a155173d2a454b0af927b6c58a1fe09c4">More...</a><br></td></tr>
<tr class="separator:a155173d2a454b0af927b6c58a1fe09c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd43fa3203bf4c9df6e3b3cdb7b4d117"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#abd43fa3203bf4c9df6e3b3cdb7b4d117">setGeometryRequirements</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a> &amp;<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ad5a9492e13c5e46460e36cf03b5821bc">shaderInstance</a>)</td></tr>
<tr class="memdesc:abd43fa3203bf4c9df6e3b3cdb7b4d117"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the initialization phase the geometry requirements for the shading effect can be updated.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#abd43fa3203bf4c9df6e3b3cdb7b4d117">More...</a><br></td></tr>
<tr class="separator:abd43fa3203bf4c9df6e3b3cdb7b4d117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57354226fd39a0000138d98e224d7b3"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ac57354226fd39a0000138d98e224d7b3">addShaderSignature</a> (void *signature, size_t signatureSize)</td></tr>
<tr class="memdesc:ac57354226fd39a0000138d98e224d7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the initialization phase, the "signature" for the shader may be set.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#ac57354226fd39a0000138d98e224d7b3">More...</a><br></td></tr>
<tr class="separator:ac57354226fd39a0000138d98e224d7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d550a4e58ca302e68898d1902f896e0"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a1d550a4e58ca302e68898d1902f896e0">addShaderSignature</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a> &amp;shaderInsance)</td></tr>
<tr class="memdesc:a1d550a4e58ca302e68898d1902f896e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the initialization phase, the "signature" for the shader may be set.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a1d550a4e58ca302e68898d1902f896e0">More...</a><br></td></tr>
<tr class="separator:a1d550a4e58ca302e68898d1902f896e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5115ac0288ba1c49ae9c73a4e4dd783"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ab5115ac0288ba1c49ae9c73a4e4dd783">addIndexingRequirement</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html">MIndexBufferDescriptor</a> &amp;desc)</td></tr>
<tr class="memdesc:ab5115ac0288ba1c49ae9c73a4e4dd783"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the initialization phase the indexing requirements for the shading effect can be updated.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#ab5115ac0288ba1c49ae9c73a4e4dd783">More...</a><br></td></tr>
<tr class="separator:ab5115ac0288ba1c49ae9c73a4e4dd783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b26e833c1533131841eb2bcb2288a4"><td class="memItemLeft" translate="no" align="right" valign="top">void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a96b26e833c1533131841eb2bcb2288a4">drawGeometry</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;context) const </td></tr>
<tr class="memdesc:a96b26e833c1533131841eb2bcb2288a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method may be called from <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> and will cause Maya to immediately draw the current geometry using the current state of the draw API.  <a href="class_m_h_w_render_1_1_m_px_shader_override.html#a96b26e833c1533131841eb2bcb2288a4">More...</a><br></td></tr>
<tr class="separator:a96b26e833c1533131841eb2bcb2288a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8b8db4077442a3e2f1fd93e1eb58f550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html">MPxShaderOverride</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The Maya shading node this override will be used for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0212be7dfc693d9d7a0f95ddcb81ba8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization occurs when Maya determines that the hardware shader needs to be rebuilt. </p>
<p>Any initialization work may be performed here. Also, this is the only time that calls to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a1293e58405a12d8024512b733e2396d1" title="During the initialization phase the geometry requirements for the shading effect can be updated...">addGeometryRequirement()</a> may occur.</p>
<p>Changes to parameter values on the Maya shading node will not trigger a call to this method by default. If parameter value changes may cause the shader to alter its geometry requirements, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a11ba79b61b2bfcc34362ee7675aca6b4" title="If this method returns true, it will force shader and geometry data to be rebuilt on any change to th...">rebuildAlways()</a> should be overridden to return true. This will cause <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a0212be7dfc693d9d7a0f95ddcb81ba8d" title="Initialization occurs when Maya determines that the hardware shader needs to be rebuilt. ">initialize()</a> to be called before every update.</p>
<p>The implementation of this method must return the shader key that is used to identify the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a> instances representing the same shader.</p>
<p>Note: There are two versions of the initialize method. Derived classes should override exactly one of them.</p>
<p>The default implementation returns a constant string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shader</td><td>The Maya shading node this override is used for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shader key </dd></dl>
<dl class="section "><div id="dynsection-example1" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example1-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example1-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a40">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a3">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a3">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a3">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#a106">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a24">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a32">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a10e802137b57af8f591880b98d8732e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/struct_m_h_w_render_1_1_m_px_shader_override_1_1_m_init_context.html">MInitContext</a> &amp;&#160;</td>
          <td class="paramname"><em>initContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/struct_m_h_w_render_1_1_m_px_shader_override_1_1_m_init_feedback.html">MInitFeedback</a> &amp;&#160;</td>
          <td class="paramname"><em>initFeedback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization occurs when Maya determines that the hardware shader needs to be rebuilt. </p>
<p>Any initialization work may be performed here. Also, this is the only time that calls to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a1293e58405a12d8024512b733e2396d1" title="During the initialization phase the geometry requirements for the shading effect can be updated...">addGeometryRequirement()</a> may occur.</p>
<p>Changes to parameter values on the Maya shading node will not trigger a call to this method by default. If parameter value changes may cause the shader to alter its geometry requirements, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a11ba79b61b2bfcc34362ee7675aca6b4" title="If this method returns true, it will force shader and geometry data to be rebuilt on any change to th...">rebuildAlways()</a> should be overridden to return true. This will cause <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a0212be7dfc693d9d7a0f95ddcb81ba8d" title="Initialization occurs when Maya determines that the hardware shader needs to be rebuilt. ">initialize()</a> to be called before every update.</p>
<p>The implementation of this method must return the shader key that is used to identify the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a> instances representing the same shader.</p>
<p>Implementations of this method may also allocate and return custom user data derived from <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_user_data.html" title="Virtual base class for user data caching. ">MUserData</a>. This user data will be attached to the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html" title="A single renderable entity. ">MRenderItem</a> representing the association of the shader to the geometry instance specified by the initContext.dagPath parameter. If the deleteAfterUse() method returns true for the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_user_data.html" title="Virtual base class for user data caching. ">MUserData</a> instance then the data object will automatically be deleted when the render item is deleted. Otherwise, the lifetime of the user data object is the responsibility of the caller. This user data may be accessed in the draw phase directly from the render item being drawn. Note that Maya objects which have render items that have custom user data can only be consolidated when the user data pointer on each item references the same user data instance. Draw performance will suffer without consolidation, however if the user data object is shared then memory management must be handled manually (ie. deleteAfterUse() should return false).</p>
<p>Note: There are two versions of the initialize method. Derived classes should override exactly one of them.</p>
<p>The default implementation simply returns the result of <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a0212be7dfc693d9d7a0f95ddcb81ba8d" title="Initialization occurs when Maya determines that the hardware shader needs to be rebuilt. ">MPxShaderOverride::initialize</a>(initContext.shader).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initContext</td><td>Context information about the current initialization call, such as the path to the Maya object being bound to the shader. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">initFeedback</td><td>Data to return to Maya after initialization such as blind data to attach to the render item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shader key </dd></dl>

</div>
</div>
<a class="anchor" id="a3b74f9aeed8e4a00450e3d2045b53b39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void updateDG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the first part of the update phase. </p>
<p>Perform any work required to update the shading effect which is related to evaluating the dependency graph. This should be the only place that dependency graph evaluation occurs. Data retrieved from Maya may be cached on the override for use in later stages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The Maya shading node this override is used for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section "><div id="dynsection-example2" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example2-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example2-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a41">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a6">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a4">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a4">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a35">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a39">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a84ad0250e8df6abe4a2bab23778c24de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void updateDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the second part of the update phase. </p>
<p>Perform any work required to update the shading effect which is related to accessing the underlying graphics device. This is the only place that the graphics device may be safely accessed other than at draw time. </p>
<dl class="section "><div id="dynsection-example3" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example3-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example3-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a42">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a7">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a5">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a5">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a40">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a43">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ae75638d96ce77bea32eb76333b76cbc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void endUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the final part of the update phase. </p>
<p>This method is called by Maya to allow the plugin to clean up any data or state from the previous update stages. No dependency graph evaluation, nor graphics device access should be performed during this phase. </p>
<dl class="section "><div id="dynsection-example4" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example4-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example4-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a43">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a8">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a6">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a6">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a41">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a44">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a3b5dcab1b6940e042c0d4843a6ab6787"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool handlesDraw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method indicates whether the shader will handle the drawing based on the context passed in. </p>
<p>The default implementation will check the pass context. If the pass semantic is specified to be a color pass and the pass has no shader override (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_pass_context.html#a54cb1ff5e4a10ffc51cb05ddab8e69ab" title="Return if there is a shader instance override set for the current pass. ">MPassContext::hasShaderOverride()</a> returns false) then this method will return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The current draw context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if shader handles drawing </dd></dl>
<dl class="section "><div id="dynsection-example5" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example5-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example5-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a9">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a7">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a9">glslShader/GLSLShaderOverride.h</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a42">hwPhongShader/hwPhongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a8d7f721e0a413d81bd9c0b4c4bf451a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void activateKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the activateKey callback. </p>
<p>This method is called during the draw phase before invoking any <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> callback that are sharing a common shader key.</p>
<p>The default implementation is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The current draw context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The shader key that is being activated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section "><div id="dynsection-example6" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example6-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example6-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a44">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a11">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a9">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a7">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a58">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a47">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a26fb6e971beb807417cb83a7b2b8268c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a> &amp;&#160;</td>
          <td class="paramname"><em>renderItemList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the draw callback, the method is called during the draw phase. </p>
<p>The expected implementation of this method is to do shader setup and then call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a96b26e833c1533131841eb2bcb2288a4" title="This method may be called from draw() and will cause Maya to immediately draw the current geometry us...">drawGeometry()</a> to allow Maya to handle the actual geometry drawing. It is however possible to do all shader setup and geometry draw here directly by accessing the hardware resource handles for geometry and index buffers through the geometry associated with each render item in the render item list.</p>
<p>No dependency graph evaluation should occur during this phase. If data from Maya is needed here it must be cached on this object (or elsewhere) during the update phase.</p>
<p>This method should return true on successful draw. If false is returned, Maya will attempt to draw using the default internal draw mechanism.</p>
<p>Information about the current GPU state may be accessed through the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html" title="Class to allow access to hardware draw context information. ">MDrawContext</a> object passed to this method. The <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html" title="A list of MRenderItem objects. ">MRenderItemList</a> object contains one render item for each object that is meant to be drawn by this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The current draw context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderItemList</td><td>The list of renderable items to draw</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if draw was successful, false otherwise. </dd></dl>
<dl class="section "><div id="dynsection-example7" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example7-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example7-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a46">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a12">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a10">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a10">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#a113">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a63">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a50">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a9d3d971a5a62e06fcbac0537c11d33de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void terminateKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the terminateKey callback. </p>
<p>This method is called during the draw phase after invoking <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> callbacks that are sharing a common shader key.</p>
<p>The default implementation is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The current draw context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The shader key that is being terminated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section "><div id="dynsection-example8" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example8-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example8-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a48">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a14">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a12">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a12">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a62">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a49">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a0a36b8ef8730fa92f11c853752cc1e0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49">MHWRender::DrawAPI</a> supportedDrawAPIs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the draw API supported by this override. </p>
<p>The returned value may be formed as the bitwise 'or' of <a class="el" translate="no" href="#!/url=./cpp_ref/namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49" title="Draw API identifiers. ">MHWRender::DrawAPI</a> elements to indicate that the override supports multiple draw APIs. This method returns '<a class="el" translate="no" href="#!/url=./cpp_ref/namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49a72361be679c1aca1c1be5f9b500a3315" title="OpenGL. ">MHWRender::kOpenGL</a>' by default.</p>
<dl class="section return"><dt>Returns</dt><dd>The draw API supported by this override </dd></dl>
<dl class="section "><div id="dynsection-example9" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example9-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example9-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a49">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a15">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a13">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a13">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#a117">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a128">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a75">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ab79d6d7859fceb8fc8b0e4ace1869612"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool isTransparent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the update phase the override will be called to return whether it will be drawing with semi-transparency. </p>
<p>This call occurs after <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a84ad0250e8df6abe4a2bab23778c24de" title="This is the second part of the update phase. ">updateDevice()</a> which allows for any device evaluation to occur to determine the transparency state.</p>
<p>The default return value is false.</p>
<dl class="section return"><dt>Returns</dt><dd>True if semi-transparent drawing should occur. </dd></dl>
<dl class="section "><div id="dynsection-example10" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example10-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example10-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a50">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a16">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a14">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a14">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#a119">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a132">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a79">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ae919985341ff7706a78139a098146ed3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool supportsAdvancedTransparency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the update phase the override will be called to return whether it supports advanced transparency algorithms (such as depth peeling). </p>
<dl class="section return"><dt>Returns</dt><dd>True if advanced tranparency algorithm is supported. </dd></dl>
<dl class="section "><div id="dynsection-example11" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example11-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example11-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a15">dx11Shader/dx11ShaderOverride.h</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a15">glslShader/GLSLShaderOverride.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a1b9341f2236028651e9d3b7b26d52dcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool overridesDrawState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the draw phase this method will be called to determine whether the override will override the draw state when drawing. </p>
<p>This call occurs after <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a84ad0250e8df6abe4a2bab23778c24de" title="This is the second part of the update phase. ">updateDevice()</a> which allows for any device evaluation to occur to determine if the override will override the draw state.</p>
<p>The Viewport 2.0 renderer will skip setting the draw state for plugins that will override the draw state when drawing. Note that the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a9d3d971a5a62e06fcbac0537c11d33de" title="This is the terminateKey callback. ">MPxShaderOverride::terminateKey()</a> should still return the draw state to the value it had when activateKey was called.</p>
<p>The default return value is false.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the override overrides the draw state. </dd></dl>
<dl class="section "><div id="dynsection-example12" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example12-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example12-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a51">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a17">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a16">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a16">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a134">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a81">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a11ba79b61b2bfcc34362ee7675aca6b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool rebuildAlways </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this method returns true, it will force shader and geometry data to be rebuilt on any change to the shader. </p>
<p>This may be necessary for shaders that request specific named data sets like UVs or CPVs. Any change to the required data set means that geometry needs to be rebuilt.</p>
<p>The default return value is false.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the shader and geometry should be rebuilt on every update. </dd></dl>
<dl class="section "><div id="dynsection-example13" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example13-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example13-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8h-example.html#a52">cgFx/cgfxShaderNode.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a17">dx11Shader/dx11ShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a21">glslShader/GLSLShaderOverride.h</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#a116">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a11f52a7284bd2c98697c744b009790fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">double boundingBoxExtraScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method to supply an extra scale factor to be applied to the object space bounding box of any objects which use the shader associated with this override. </p>
<p>This is to allow the shader to indicate that the bounding box should be bigger than just the base geometry; normally due to shading effects like displacement. Note that the value returned here will only be used to put a lower bound on the extra scale applied to the bounding box. It may be made larger due to the demands of other shaders associated with the object.</p>
<p>This method will be called any time a change occurs which may affect the bounding box of associated objects. It is acceptable to access the Maya dependency graph within calls to this method as it will never be called during draw.</p>
<p>The default implementation returns the unit scale factor (1.0).</p>
<dl class="section return"><dt>Returns</dt><dd>Extra scale factor </dd></dl>
<dl class="section "><div id="dynsection-example14" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example14-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example14-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a18">dx11Shader/dx11ShaderOverride.h</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a17">glslShader/GLSLShaderOverride.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a09c032b89513ada1a3c21260c42ea0da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool overridesNonMaterialItems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method if the shader instance should also be used to render non material items such as the wireframe and the selected edges/vertices components. </p>
<p>This is particularly useful for shading effects that compute displacement for which the object geometry will not match the rendered material, making selection difficult.</p>
<p>The default implementation returns false indicating that the shader instance should not be used for non material items.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the shader instance should also be used to render non material items. </dd></dl>
<dl class="section "><div id="dynsection-example15" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example15-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example15-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_override_8h-example.html#a19">dx11Shader/dx11ShaderOverride.h</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a18">glslShader/GLSLShaderOverride.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ad5a9492e13c5e46460e36cf03b5821bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MHWRender::MShaderInstance</a> * shaderInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method if a shader instance (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a>) is to be used for drawing. </p>
<p>The default implementation returns a NULL value indicating that no shader instance will be used.</p>
<dl class="section return"><dt>Returns</dt><dd>Shader instance. </dd></dl>
<dl class="section "><div id="dynsection-example16" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example16-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example16-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8h-example.html#a5">customTextureShader/customTextureShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8h-example.html#a20">glslShader/GLSLShaderOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a57">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a46">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="addc154cb86dafb4b95301938d97659d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MHWRender::MShaderInstance</a> * nonTexturedShaderInstance </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>monitorNode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an override shader instance to be used when drawing in non-textured mode. </p>
<p>If NULL is returned an internallly defined non-modifiable shader instance is used.</p>
<p>Setting the "monitorNode" parameter on the method to return true will indicate that the associated shader node requires monitoring to call back to the override during the update phase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">monitorNode</td><td>Monitor for shader node attribute updates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shader instance. The default value is NULL. </dd></dl>
<dl class="section "><div id="dynsection-example17" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example17-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example17-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a133">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a80">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a774cd5d8fbebe8e7ed82a5aa587d1f04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">const char * className </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of this class. </dd></dl>

</div>
</div>
<a class="anchor" id="a1293e58405a12d8024512b733e2396d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> addGeometryRequirement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the initialization phase the geometry requirements for the shading effect can be updated. </p>
<p>The update is accomplished by calling this method once for each new data stream that needs to be added to the list of requirements.</p>
<p>If the geometry has multiple fields of the same type associated with it (e.g. multiple UV sets) the 'name' attribute of the vertex descriptor can be used to select the desired one. If that member is empty or does not match any of the fields then the default field of that type will be used.</p>
<p>Not all combinations of the 'semantic', 'dataType' and 'dimension' attributes of the vertex descriptor are permitted. Currently </p><ul>
<li>position, normal, tangent, bitangent and color can be 3-float or 4-float, </li>
<li>tangent with sign vectors are 4-float, </li>
<li>texture coordinates are 2-float, or any type if used as custom semantic.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The description of the geometry requirement to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1" title="The operation was successful. ">MS::kSuccess</a></b> Requirement was added. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00" title="The operation failed. ">MS::kFailure</a></b> Object error. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af8c5f748892ec74b32719c8fba7767e1" title="An invalid parameter was provided. ">MS::kInvalidParameter</a></b> An unsupported 'semantic' was specified; or the 'dataType'/'dimension' was not compatible with the 'semantic'. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a598e4c5d4c234c1bf09367d64487519c" title="&#160; ">MS::kNotImplemented</a></b> Requirement could not be added because method was called from outside of initialization phase. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example18" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example18-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example18-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/hw_color_per_vertex_shader_2hw_color_per_vertex_shader_8cpp-example.html#a108">hwColorPerVertexShader/hwColorPerVertexShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a34">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a38">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a155173d2a454b0af927b6c58a1fe09c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> addGeometryRequirements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor_list.html">MVertexBufferDescriptorList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the initialization phase the geometry requirements for the shading effect can be updated. </p>
<p>The update is accomplished by calling this method with a list containing descriptions of all data streams that are required by the shader.</p>
<p>If the geometry has multiple fields of the same type associated with it (e.g. multiple UV sets) the 'name' attribute of the vertex descriptor can be used to select the desired one. If that member is empty or does not match any of the fields then the default field of that type will be used.</p>
<p>Not all combinations of the 'semantic', 'dataType' and 'dimension' attributes of the vertex descriptor are permitted. Currently position, normal, tangent and bitangent vectors are 3-float, texture coordinates are 2-float, and colors are 4-float.</p>
<p>This method will attempt to add as many requirements as possible from the list, skipping invalid ones. If kInvalidParameter is returned it means at least one requirement failed to be added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list of descriptions of the geometry requirements to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1" title="The operation was successful. ">MS::kSuccess</a></b> Requirements were added. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00" title="The operation failed. ">MS::kFailure</a></b> Object error. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af8c5f748892ec74b32719c8fba7767e1" title="An invalid parameter was provided. ">MS::kInvalidParameter</a></b> An unsupported 'semantic' was specified; or the 'dataType'/'dimension' was not compatible with the 'semantic'. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a598e4c5d4c234c1bf09367d64487519c" title="&#160; ">MS::kNotImplemented</a></b> Requirements could not be added because method was called from outside of initialization phase. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abd43fa3203bf4c9df6e3b3cdb7b4d117"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> setGeometryRequirements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the initialization phase the geometry requirements for the shading effect can be updated. </p>
<p>The update can be accomplished by calling this method with a shader instance (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a>). The geometry requirements are copied from the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a> and used as the current shading effect requirements. If there are any requirements already specified for the shading effect, they will be replaced.</p>
<p>This method should not be used in conjunction with <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a1293e58405a12d8024512b733e2396d1" title="During the initialization phase the geometry requirements for the shading effect can be updated...">addGeometryRequirement()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a155173d2a454b0af927b6c58a1fe09c4" title="During the initialization phase the geometry requirements for the shading effect can be updated...">addGeometryRequirements()</a> methods. The reason is that when rendering the vertex format used must exactly match the one used for the shader instance. If any additional requirements are added, the geometry may not draw properly.</p>
<p>The corresponding <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#ac57354226fd39a0000138d98e224d7b3" title="During the initialization phase, the &quot;signature&quot; for the shader may be set. ">addShaderSignature()</a> method, which takes an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html" title="An instance of a shader that may be used with Viewport 2.0. ">MShaderInstance</a> as an input argument, should also be called during initialization if the utility method <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a96b26e833c1533131841eb2bcb2288a4" title="This method may be called from draw() and will cause Maya to immediately draw the current geometry us...">drawGeometry()</a> is used by the plug-in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shaderInstance</td><td>Shader instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1" title="The operation was successful. ">MS::kSuccess</a></b> Requirements were added. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00" title="The operation failed. ">MS::kFailure</a></b> Object error. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a598e4c5d4c234c1bf09367d64487519c" title="&#160; ">MS::kNotImplemented</a></b> Requirements could not be added because method was called from outside of initialization phase. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example19" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example19-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example19-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a25">hwPhongShader/hwPhongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ac57354226fd39a0000138d98e224d7b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> addShaderSignature </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>signatureSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the initialization phase, the "signature" for the shader may be set. </p>
<p>Certain Draw APIs (like DirectX 11) require a signature to allow a shading effect to be properly activated. The signature will be used if the override uses <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a96b26e833c1533131841eb2bcb2288a4" title="This method may be called from draw() and will cause Maya to immediately draw the current geometry us...">MPxShaderOverride::drawGeometry()</a> in the draw phase in order to perform drawing. If drawing is done manually, adding a shader signature is not necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>The signature of the shader </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signatureSize</td><td>The size of the signature block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1" title="The operation was successful. ">MS::kSuccess</a></b> Signature was set. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a598e4c5d4c234c1bf09367d64487519c" title="&#160; ">MS::kNotImplemented</a></b> Signature could not be set because method was called from outside of initialization phase. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example20" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example20-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example20-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a26">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a33">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a1d550a4e58ca302e68898d1902f896e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> addShaderSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the initialization phase, the "signature" for the shader may be set. </p>
<p>Certain Draw APIs (like DirectX 11) require a signature to allow a shading effect to be properly activated. The signature will be used if the override uses <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a96b26e833c1533131841eb2bcb2288a4" title="This method may be called from draw() and will cause Maya to immediately draw the current geometry us...">MPxShaderOverride::drawGeometry()</a> in the draw phase in order to perform drawing. If drawing is done manually, adding a shader signature is not necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shaderInstance</td><td>Add the signature associated with the shader instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1" title="The operation was successful. ">MS::kSuccess</a></b> Signature was set. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00" title="The operation failed. ">MS::kFailure</a></b> Object error. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a598e4c5d4c234c1bf09367d64487519c" title="&#160; ">MS::kNotImplemented</a></b> Signature could not be set because method was called from outside of initialization phase. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab5115ac0288ba1c49ae9c73a4e4dd783"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> addIndexingRequirement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html">MIndexBufferDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the initialization phase the indexing requirements for the shading effect can be updated. </p>
<p>The update is accomplished by calling this method once for each new index stream required by the shader.</p>
<p>A shader override can specify the type of primitive it supports. If the shader relies on a special primitive type like kPatch it should use this method to indicate that requirement to the system. Not all fields on the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html" title="MIndexBufferDescriptor describes an indexing scheme. ">MIndexBufferDescriptor</a> need to be filled in when using this method. Only the name(), primitive(), and primitiveStride() values are important for a shader to report as requirements.</p>
<p>The primitive type must be specified if the shader requires a primitive type different then a standard point, line, or triangle list or strip. The primitiveStride must be specified if using the kPatch primitive type. Valid values range from 1 - 32. The name can be specified to trigger a custom <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_primitive_generator.html" title="Base class for user defined primitive generators. ">MPxPrimitiveGenerator</a> plugin to be used to produce the desired primitive tessellation. When requesting custom primitives you should register an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_primitive_generator.html" title="Base class for user defined primitive generators. ">MPxPrimitiveGenerator</a> that knows how to produce the custom primitive needed by the shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The description of the indexing requirement to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1" title="The operation was successful. ">MS::kSuccess</a></b> Requirement was added. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00" title="The operation failed. ">MS::kFailure</a></b> Object error. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example21" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example21-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example21-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a29">hwPhongShader/hwPhongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a96b26e833c1533131841eb2bcb2288a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void drawGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method may be called from <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a26fb6e971beb807417cb83a7b2b8268c" title="This is the draw callback, the method is called during the draw phase. ">draw()</a> and will cause Maya to immediately draw the current geometry using the current state of the draw API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The current draw context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section "><div id="dynsection-example22" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example22-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example22-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8cpp-example.html#a25">customTextureShader/customTextureShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_override_8cpp-example.html#a17">glslShader/GLSLShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a88">hwPhongShader/hwPhongShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/vp2_blinn_shader_2vp2_blinn_shader_8cpp-example.html#a74">vp2BlinnShader/vp2BlinnShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a59ae16788a38ceee59f6b8ce18628d4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void activateKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>This method is obsolete.</b> </p>
<dl class="deprecated"><dt><b><a class="el" translate="no" href="#!/url=./cpp_ref/deprecated.html#_deprecated000170">Deprecated:</a></b></dt><dd>Use the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a8d7f721e0a413d81bd9c0b4c4bf451a9" title="This is the activateKey callback. ">activateKey(MDrawContext&amp;, const MString&amp;)</a> version instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86bea6a5c34bb8ffa705abe72fb86a91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void terminateKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>This method is obsolete.</b> </p>
<dl class="deprecated"><dt><b><a class="el" translate="no" href="#!/url=./cpp_ref/deprecated.html#_deprecated000171">Deprecated:</a></b></dt><dd>Use the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a9d3d971a5a62e06fcbac0537c11d33de" title="This is the terminateKey callback. ">terminateKey(MDrawContext&amp;, const MString&amp;)</a> version instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr>The documentation for this class was generated from the following files:<ul>
<li>MPxShaderOverride.h</li>
<li>MPxShaderOverride.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div><br></div>
   </div></body>
</html>

<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="MAYAUL" name="product"><meta content="2016" name="release"><meta content="Developer" name="book"><meta content="2015-10-14" name="created"><meta content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887" name="topicid"><meta content="concept" name="topic-type">
<title>glslShader/crackFreePrimitiveGenerator.cpp</title>
<meta content="C++" name="topic-subtype"/></meta></meta></meta></meta></meta></meta></meta></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('glsl_shader_2crack_free_primitive_generator_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?siteData=y5CYlxTRD0znCzRLDwX0Wy7-g1EdC1XA4dSC-Y1LtaeScyli8_Ps5jPKqTr4xKxMI0OOUfkDplvX3uxN0JnPclebSYW8_J1HBzf4VLQEzQ8M4PsYXF_cMyp1Oumaetky&category=5297189e-446b-459e-ae1d-9d0360400781_tech&ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="position:absolute;right:20px;top:5px;z-index:100;color:white;background-color:#555555;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>glslShader/crackFreePrimitiveGenerator.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">glslShader/crackFreePrimitiveGenerator.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk</span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download,</span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic</span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Example plugin: crackFreePrimitiveGenerator.cpp</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This plug-in is an example of a custom MPxIndexBufferMutator.</span></div>
<div class="line"><span class="comment">// It provides custom primitives based on shader requirements coming from </span></div>
<div class="line"><span class="comment">// an MPxShaderOverride.  The name() in the MIndexBufferDescriptor is used </span></div>
<div class="line"><span class="comment">// to signify a unique identifier for a custom buffer.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "crackFreePrimitiveGenerator.h"</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MStatus.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MIntArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPxVertexBufferGenerator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHWGeometry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDrawRegistry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MComponentDataIndexing.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line"> <span class="keyword">struct </span>Edge</div>
<div class="line">    {</div>
<div class="line">        Edge(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v0_ = 0, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v1_ = 0) : v0(v0_), v1(v1_) {}</div>
<div class="line"></div>
<div class="line">        Edge reversed()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> Edge(v1, v0);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> isEqual(<span class="keyword">const</span> Edge &amp;rhs)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> (v0 == rhs.v0 &amp;&amp; v1 == rhs.v1);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> isReverse(<span class="keyword">const</span> Edge &amp;rhs)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> (v0 == rhs.v1 &amp;&amp; v1 == rhs.v0);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v1;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> operator&lt; (<span class="keyword">const</span> Edge&amp; lhs, <span class="keyword">const</span> Edge&amp; rhs)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> (lhs.v0 &lt; rhs.v0) || (lhs.v0 == rhs.v0 &amp;&amp; lhs.v1 &lt; rhs.v1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">class </span>EdgeMapping</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">        EdgeMapping();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> addTriangle(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId0, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId2, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId0, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId2);</div>
<div class="line"> <span class="keywordtype">void</span> addEdge(<span class="keyword">const</span> Edge&amp; faceEdge, <span class="keyword">const</span> Edge&amp; polyEdge);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> addPositionUV(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId, <span class="keywordtype">float</span> u, <span class="keywordtype">float</span> v);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> adjacentEdge(<span class="keyword">const</span> Edge&amp; faceEdge, Edge&amp; adjacentEdge) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> dominantEdge(<span class="keyword">const</span> Edge&amp; faceEdge, Edge&amp; dominantEdge) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> dominantPosition(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; dominantVertexId) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line"> <span class="comment">// Map each face edge to its polygon edge.</span></div>
<div class="line"> <span class="keyword">typedef</span> std::map&lt; Edge, Edge &gt; FaceEdge2PolyEdgeMap;</div>
<div class="line">        FaceEdge2PolyEdgeMap fFaceEdge2PolyEdgeMap;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Map each poly edge to both face edges that match.</span></div>
<div class="line"> <span class="keyword">typedef</span> std::map&lt; Edge, std::pair&lt; Edge, Edge &gt; &gt; PolyEdge2FaceEdgeMap;</div>
<div class="line">        PolyEdge2FaceEdgeMap fPolyEdge2FaceEdgesMap;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Map a single face vertex id to its polygon vertex id.</span></div>
<div class="line"> <span class="keyword">typedef</span> std::map&lt; unsigned int, unsigned int &gt; FaceVertex2PolyVertexMap;</div>
<div class="line">        FaceVertex2PolyVertexMap fFaceVertex2PolyVertexMap;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Map dominant vertex position via lowest uv coords.</span></div>
<div class="line"> <span class="keyword">typedef</span> std::pair&lt; unsigned int, std::pair&lt; float, float &gt; &gt; VertexUVPair;</div>
<div class="line"> <span class="keyword">typedef</span> std::map&lt; unsigned int, VertexUVPair &gt; PolyVertex2FaceVertexUVMap;</div>
<div class="line">        PolyVertex2FaceVertexUVMap fPolyVertex2FaceVertexUVMap;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    EdgeMapping::EdgeMapping()</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> EdgeMapping::addTriangle(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId0, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId2, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId0, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId2)</div>
<div class="line">    {</div>
<div class="line">        addEdge( Edge(faceVertexId0, faceVertexId1), Edge(polyVertexId0, polyVertexId1) );</div>
<div class="line">        addEdge( Edge(faceVertexId1, faceVertexId2), Edge(polyVertexId1, polyVertexId2) );</div>
<div class="line">        addEdge( Edge(faceVertexId2, faceVertexId0), Edge(polyVertexId2, polyVertexId0) );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add a new edge</span></div>
<div class="line"> <span class="comment">// The edge is represented by two associated vertex ids pairs : one in face vertices array space and a second in polygon face vertices array space.</span></div>
<div class="line"> <span class="keywordtype">void</span> EdgeMapping::addEdge(<span class="keyword">const</span> Edge&amp; faceEdge, <span class="keyword">const</span> Edge&amp; polyEdge)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span>(polyEdge.v1 &lt; polyEdge.v0)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Revert edges</span></div>
<div class="line">            Edge faceEdgeR = faceEdge.reversed();</div>
<div class="line">            Edge polyEdgeR = polyEdge.reversed();</div>
<div class="line">            addEdge(faceEdgeR, polyEdgeR);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fFaceEdge2PolyEdgeMap[faceEdge] = polyEdge;</div>
<div class="line"> </div>
<div class="line">        PolyEdge2FaceEdgeMap::iterator itP2F = fPolyEdge2FaceEdgesMap.find( polyEdge );</div>
<div class="line"> <span class="keywordflow">if</span>(itP2F == fPolyEdge2FaceEdgesMap.end())</div>
<div class="line">        {</div>
<div class="line">            fPolyEdge2FaceEdgesMap[polyEdge] = std::make_pair( faceEdge, faceEdge );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            itP2F-&gt;second.second = faceEdge;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> EdgeMapping::addPositionUV(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId, <span class="keywordtype">float</span> u, <span class="keywordtype">float</span> v)</div>
<div class="line">    {</div>
<div class="line">        fFaceVertex2PolyVertexMap[faceVertexId] = polyVertexId;</div>
<div class="line"></div>
<div class="line">        PolyVertex2FaceVertexUVMap::iterator it = fPolyVertex2FaceVertexUVMap.find(polyVertexId);</div>
<div class="line"> <span class="keywordflow">if</span>(it == fPolyVertex2FaceVertexUVMap.end())</div>
<div class="line">        {</div>
<div class="line">            fPolyVertex2FaceVertexUVMap[polyVertexId] = std::make_pair( faceVertexId, std::make_pair(u,v) );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            VertexUVPair&amp; vertexUVPair = it-&gt;second;</div>
<div class="line"> <span class="keywordtype">float</span> lastU = vertexUVPair.second.first;</div>
<div class="line"> <span class="keywordtype">float</span> lastV = vertexUVPair.second.second;</div>
<div class="line"> <span class="keywordflow">if</span>( u &lt; lastU || ( u == lastU &amp;&amp; v &lt; lastV ) )</div>
<div class="line">            {</div>
<div class="line">                vertexUVPair.first = faceVertexId;</div>
<div class="line">                vertexUVPair.second = std::make_pair(u,v);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the adjacent edge that is shared between two faces.</span></div>
<div class="line"> <span class="comment">// The matching is done through the polygon vertex ids.</span></div>
<div class="line"> <span class="comment">// The returning edge have vertices in face space.</span></div>
<div class="line"> <span class="keywordtype">bool</span> EdgeMapping::adjacentEdge(<span class="keyword">const</span> Edge&amp; faceEdge, Edge&amp; adjacentEdge)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">        FaceEdge2PolyEdgeMap::const_iterator itF2P = fFaceEdge2PolyEdgeMap.find( faceEdge );</div>
<div class="line"> <span class="keywordflow">if</span>(itF2P == fFaceEdge2PolyEdgeMap.end())</div>
<div class="line">        {</div>
<div class="line">            Edge faceEdgeR = faceEdge.reversed();</div>
<div class="line">            itF2P = fFaceEdge2PolyEdgeMap.find( faceEdgeR );</div>
<div class="line"> <span class="keywordflow">if</span>(itF2P == fFaceEdge2PolyEdgeMap.end())</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> Edge&amp; polyEdge = itF2P-&gt;second;</div>
<div class="line"></div>
<div class="line">        PolyEdge2FaceEdgeMap::const_iterator itP2F = fPolyEdge2FaceEdgesMap.find( polyEdge );</div>
<div class="line"> <span class="keywordflow">if</span>(itP2F == fPolyEdge2FaceEdgesMap.end())</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> Edge&amp; faceEdge0 = itP2F-&gt;second.first;</div>
<div class="line"> <span class="keyword">const</span> Edge&amp; faceEdge1 = itP2F-&gt;second.second;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> foundMatch = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">if</span>(faceEdge.isEqual(faceEdge0))</div>
<div class="line">        {</div>
<div class="line">            adjacentEdge = faceEdge1;</div>
<div class="line">            foundMatch = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>(faceEdge.isReverse(faceEdge0))</div>
<div class="line">        {</div>
<div class="line">            adjacentEdge = faceEdge1.reversed();</div>
<div class="line">            foundMatch = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>(faceEdge.isEqual(faceEdge1))</div>
<div class="line">        {</div>
<div class="line">            adjacentEdge = faceEdge0;</div>
<div class="line">            foundMatch = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>(faceEdge.isReverse(faceEdge1))</div>
<div class="line">        {</div>
<div class="line">            adjacentEdge = faceEdge0.reversed();</div>
<div class="line">            foundMatch = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> foundMatch;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> EdgeMapping::dominantEdge(<span class="keyword">const</span> Edge&amp; faceEdge, Edge&amp; dominantEdge)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordtype">bool</span> returnReversed = <span class="keyword">true</span>;</div>
<div class="line">        FaceEdge2PolyEdgeMap::const_iterator itF2P = fFaceEdge2PolyEdgeMap.find( faceEdge );</div>
<div class="line"> <span class="keywordflow">if</span>(itF2P == fFaceEdge2PolyEdgeMap.end())</div>
<div class="line">        {</div>
<div class="line">            Edge faceEdgeR = faceEdge.reversed();</div>
<div class="line">            itF2P = fFaceEdge2PolyEdgeMap.find( faceEdgeR );</div>
<div class="line"> <span class="keywordflow">if</span>(itF2P == fFaceEdge2PolyEdgeMap.end())</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            returnReversed = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> Edge&amp; polyEdge = itF2P-&gt;second;</div>
<div class="line"></div>
<div class="line">        PolyEdge2FaceEdgeMap::const_iterator itP2F = fPolyEdge2FaceEdgesMap.find( polyEdge );</div>
<div class="line"> <span class="keywordflow">if</span>(itP2F == fPolyEdge2FaceEdgesMap.end())</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> Edge&amp; faceEdge0 = itP2F-&gt;second.first;</div>
<div class="line"> <span class="keyword">const</span> Edge&amp; faceEdge1 = itP2F-&gt;second.second;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(faceEdge0 &lt; faceEdge1)</div>
<div class="line">        {</div>
<div class="line">            dominantEdge = (returnReversed ? faceEdge0.reversed() : faceEdge0);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            dominantEdge = (returnReversed ? faceEdge1.reversed() : faceEdge1);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> EdgeMapping::dominantPosition(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; dominantVertexId)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">        FaceVertex2PolyVertexMap::const_iterator itF2P = fFaceVertex2PolyVertexMap.find(faceVertexId);</div>
<div class="line"> <span class="keywordflow">if</span>(itF2P == fFaceVertex2PolyVertexMap.end())</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> polyVertexId = itF2P-&gt;second;</div>
<div class="line"></div>
<div class="line">        PolyVertex2FaceVertexUVMap::const_iterator itP2FUV = fPolyVertex2FaceVertexUVMap.find(polyVertexId);</div>
<div class="line"> <span class="keywordflow">if</span>(itP2FUV == fPolyVertex2FaceVertexUVMap.end())</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        dominantVertexId = itP2FUV-&gt;second.first;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>VertexF</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> kTolerance;</div>
<div class="line">        VertexF(<span class="keyword">const</span> <span class="keywordtype">float</span>* buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufferPos = index * 3;</div>
<div class="line">            x = buffer[bufferPos++];</div>
<div class="line">            y = buffer[bufferPos++];</div>
<div class="line">            z = buffer[bufferPos++];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> isEqual(<span class="keyword">const</span> VertexF &amp;rhs)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> (fabs(x - rhs.x) &lt; kTolerance &amp;&amp; fabs(y - rhs.y) &lt; kTolerance &amp;&amp; fabs(z - rhs.z) &lt; kTolerance);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> VertexF::kTolerance = 1e-5f;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> operator&lt; (<span class="keyword">const</span> VertexF&amp; lhs, <span class="keyword">const</span> VertexF&amp; rhs)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> ((lhs.x - rhs.x) &lt; -VertexF::kTolerance) || </div>
<div class="line">               (fabs(lhs.x - rhs.x) &lt; VertexF::kTolerance &amp;&amp; (lhs.y - rhs.y) &lt; -VertexF::kTolerance) || </div>
<div class="line">               (fabs(lhs.x - rhs.x) &lt; VertexF::kTolerance &amp;&amp; fabs(lhs.y - rhs.y) &lt; VertexF::kTolerance &amp;&amp; (lhs.z - rhs.z) &lt; -VertexF::kTolerance);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>VertexFMap</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getVertexId( <span class="keyword">const</span> VertexF&amp; v );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> std::map&lt;VertexF, unsigned int&gt; TVtxMap;</div>
<div class="line">        TVtxMap vertexMap;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> VertexFMap::getVertexId( <span class="keyword">const</span> VertexF&amp; v )</div>
<div class="line">    {</div>
<div class="line">        VertexFMap::TVtxMap::const_iterator itVtx = vertexMap.find(v);</div>
<div class="line"> <span class="keywordflow">if</span> (itVtx != vertexMap.end())</div>
<div class="line"> <span class="keywordflow">return</span> itVtx-&gt;second;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextId = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertexMap.size();</div>
<div class="line">        vertexMap.insert(TVtxMap::value_type(v,nextId));</div>
<div class="line"> <span class="keywordflow">return</span> nextId;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Mode 1 : PN Triangles; no divergent normals and no displacement crack fix</span></div>
<div class="line"><span class="comment">// Mode 2 : PN AEN, divergent normals crack fix; no displacement UV seam crack fix</span></div>
<div class="line"><span class="comment">// Mode 3 : PN AEN, crack fix for divergent normals and UV seam displacement</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">CrackFreePrimitiveGenerator::CrackFreePrimitiveGenerator(<span class="keywordtype">bool</span> addAdjacentEdges, <span class="keywordtype">bool</span> addDominantEdges, <span class="keywordtype">bool</span> addDominantPosition)</div>
<div class="line">: fAddAdjacentEdges(addAdjacentEdges)</div>
<div class="line">, fAddDominantEdges(addDominantEdges)</div>
<div class="line">, fAddDominantPosition(addDominantPosition)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">CrackFreePrimitiveGenerator::~CrackFreePrimitiveGenerator() {}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CrackFreePrimitiveGenerator::computeTriangleSize(<span class="keywordtype">bool</span> bAddAdjacentEdges,</div>
<div class="line"> <span class="keywordtype">bool</span> bAddDominantEdges,</div>
<div class="line"> <span class="keywordtype">bool</span> bAddDominantPosition)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> 3                                <span class="comment">/* triangles vertices */</span></div>
<div class="line">        + (bAddAdjacentEdges ? 3 * 2 : 0)   <span class="comment">/* adjacent edges */</span></div>
<div class="line">        + (bAddDominantEdges ? 3 * 2 : 0)   <span class="comment">/* dominant edges */</span></div>
<div class="line">        + (bAddDominantPosition ? 3 : 0);   <span class="comment">/* dominant position */</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> CrackFreePrimitiveGenerator::mutateIndexBuffer( <span class="keyword">const</span> <a name="_a0"></a><a class="code" href="./class_m_uint_array.html">MUintArray</a>&amp; originalBufferIndices, </div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* positionBufferFloat, </div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* uvBufferFloat, </div>
<div class="line"> <span class="keywordtype">bool</span> bAddAdjacentEdges,</div>
<div class="line"> <span class="keywordtype">bool</span> bAddDominantEdges,</div>
<div class="line"> <span class="keywordtype">bool</span> bAddDominantPosition,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MHWRender::MGeometry::DataType</a> indexBufferDataType,</div>
<div class="line"> <span class="keywordtype">void</span>* indexData )</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriVerts = originalBufferIndices.<a name="a1"></a><a class="code" href="./class_m_uint_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"></div>
<div class="line">    EdgeMapping edges;</div>
<div class="line">    {</div>
<div class="line">        VertexFMap vertexMap;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Iterate all triangles found in the old index buffer:</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertexIndex = 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">while</span> (vertexIndex &lt; numTriVerts)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId0 = originalBufferIndices[vertexIndex++];</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId0 = vertexMap.getVertexId(VertexF(positionBufferFloat, faceVertexId0));</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId1 = originalBufferIndices[vertexIndex++];</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId1 = vertexMap.getVertexId(VertexF(positionBufferFloat, faceVertexId1));</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> faceVertexId2 = originalBufferIndices[vertexIndex++];</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> polyVertexId2 = vertexMap.getVertexId(VertexF(positionBufferFloat, faceVertexId2));</div>
<div class="line"></div>
<div class="line">            edges.addTriangle(faceVertexId0, faceVertexId1, faceVertexId2, polyVertexId0, polyVertexId1, polyVertexId2);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(bAddDominantPosition &amp;&amp; uvBufferFloat)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uvIndex;</div>
<div class="line">                uvIndex = faceVertexId0 * 2;</div>
<div class="line">                edges.addPositionUV(faceVertexId0, polyVertexId0, uvBufferFloat[uvIndex], uvBufferFloat[uvIndex+1]);</div>
<div class="line"></div>
<div class="line">                uvIndex = faceVertexId1 * 2;</div>
<div class="line">                edges.addPositionUV(faceVertexId1, polyVertexId1, uvBufferFloat[uvIndex], uvBufferFloat[uvIndex+1]);</div>
<div class="line"></div>
<div class="line">                uvIndex = faceVertexId2 * 2;</div>
<div class="line">                edges.addPositionUV(faceVertexId2, polyVertexId2, uvBufferFloat[uvIndex], uvBufferFloat[uvIndex+1]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newTriId = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> triId = 0; triId &lt; numTriVerts; )</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertexId0 = originalBufferIndices[triId++];</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertexId1 = originalBufferIndices[triId++];</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertexId2 = originalBufferIndices[triId++];</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (indexBufferDataType == <a name="a2"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6aa93f90f58b3077bdbedeb9506e0143fd">MHWRender::MGeometry::kUnsignedInt32</a>) {</div>
<div class="line"> <span class="comment">// Triangle vertices</span></div>
<div class="line">            ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = vertexId0;</div>
<div class="line">            ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = vertexId1;</div>
<div class="line">            ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = vertexId2;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Adjacent edges</span></div>
<div class="line"> <span class="keywordflow">if</span>(bAddAdjacentEdges)</div>
<div class="line">            {</div>
<div class="line">                Edge adjacentEdge;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge0 : vertexId0 - vertexId1</span></div>
<div class="line">                edges.adjacentEdge(Edge(vertexId0, vertexId1), adjacentEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = adjacentEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = adjacentEdge.v1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge1 : vertexId1 - vertexId2</span></div>
<div class="line">                edges.adjacentEdge(Edge(vertexId1, vertexId2), adjacentEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = adjacentEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = adjacentEdge.v1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge2 : vertexId2 - vertexId0</span></div>
<div class="line">                edges.adjacentEdge(Edge(vertexId2, vertexId0), adjacentEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = adjacentEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = adjacentEdge.v1;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Dominant edges</span></div>
<div class="line"> <span class="keywordflow">if</span>(bAddDominantEdges)</div>
<div class="line">            {</div>
<div class="line">                Edge dominantEdge;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge0 : vertexId0 - vertexId1</span></div>
<div class="line">                edges.dominantEdge(Edge(vertexId0, vertexId1), dominantEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = dominantEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = dominantEdge.v1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge1 : vertexId1 - vertexId2</span></div>
<div class="line">                edges.dominantEdge(Edge(vertexId1, vertexId2), dominantEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = dominantEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = dominantEdge.v1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge2 : vertexId2 - vertexId0</span></div>
<div class="line">                edges.dominantEdge(Edge(vertexId2, vertexId0), dominantEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = dominantEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = dominantEdge.v1;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Dominant position</span></div>
<div class="line"> <span class="keywordflow">if</span>(bAddDominantPosition)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dominantVertexId;</div>
<div class="line"></div>
<div class="line">                edges.dominantPosition(vertexId0, dominantVertexId);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = dominantVertexId;</div>
<div class="line"></div>
<div class="line">                edges.dominantPosition(vertexId1, dominantVertexId);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = dominantVertexId;</div>
<div class="line"></div>
<div class="line">                edges.dominantPosition(vertexId2, dominantVertexId);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexData)[newTriId++] = dominantVertexId;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexBufferDataType == <a name="a3"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a771a88748799bba09da625ffee5c6945">MHWRender::MGeometry::kUnsignedChar</a>) {</div>
<div class="line">            ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)vertexId0;</div>
<div class="line">            ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)vertexId1;</div>
<div class="line">            ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)vertexId2;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Adjacent edges</span></div>
<div class="line"> <span class="keywordflow">if</span>(bAddAdjacentEdges)</div>
<div class="line">            {</div>
<div class="line">                Edge adjacentEdge;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge0 : vertexId0 - vertexId1</span></div>
<div class="line">                edges.adjacentEdge(Edge(vertexId0, vertexId1), adjacentEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)adjacentEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)adjacentEdge.v1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge1 : vertexId1 - vertexId2</span></div>
<div class="line">                edges.adjacentEdge(Edge(vertexId1, vertexId2), adjacentEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)adjacentEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)adjacentEdge.v1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge2 : vertexId2 - vertexId0</span></div>
<div class="line">                edges.adjacentEdge(Edge(vertexId2, vertexId0), adjacentEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)adjacentEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)adjacentEdge.v1;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Dominant edges</span></div>
<div class="line"> <span class="keywordflow">if</span>(bAddDominantEdges)</div>
<div class="line">            {</div>
<div class="line">                Edge dominantEdge;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge0 : vertexId0 - vertexId1</span></div>
<div class="line">                edges.dominantEdge(Edge(vertexId0, vertexId1), dominantEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)dominantEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)dominantEdge.v1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge1 : vertexId1 - vertexId2</span></div>
<div class="line">                edges.dominantEdge(Edge(vertexId1, vertexId2), dominantEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)dominantEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)dominantEdge.v1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Edge2 : vertexId2 - vertexId0</span></div>
<div class="line">                edges.dominantEdge(Edge(vertexId2, vertexId0), dominantEdge);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)dominantEdge.v0;</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)dominantEdge.v1;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Dominant position</span></div>
<div class="line"> <span class="keywordflow">if</span>(bAddDominantPosition)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dominantVertexId;</div>
<div class="line"></div>
<div class="line">                edges.dominantPosition(vertexId0, dominantVertexId);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)dominantVertexId;</div>
<div class="line"></div>
<div class="line">                edges.dominantPosition(vertexId1, dominantVertexId);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)dominantVertexId;</div>
<div class="line"></div>
<div class="line">                edges.dominantPosition(vertexId2, dominantVertexId);</div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)indexData)[newTriId++] = (<span class="keywordtype">unsigned</span> short)dominantVertexId;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MHWRender::MGeometry::Primitive</a> CrackFreePrimitiveGenerator::mutateIndexing(<span class="keyword">const</span> <a name="_a4"></a><a class="code" href="./class_m_h_w_render_1_1_m_component_data_indexing_list.html">MHWRender::MComponentDataIndexingList</a>&amp; sourceIndexBuffers, </div>
<div class="line"> <span class="keyword">const</span> <a name="_a5"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html">MHWRender::MVertexBufferArray</a>&amp; vertexBuffers,</div>
<div class="line"> <a name="_a6"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MHWRender::MIndexBuffer</a>&amp; indexBuffer,</div>
<div class="line"> <span class="keywordtype">int</span>&amp; primitiveStride)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a name="_a7"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a> *positionBuffer = NULL;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a> *uvBuffer = NULL;</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ivb = 0; ivb &lt; vertexBuffers.<a name="a8"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html#ab1eb6de2bf3aa228929ab4b40c73507c">count</a>() &amp;&amp; (positionBuffer == NULL || uvBuffer == NULL); ++ivb)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a> *currBuffer = vertexBuffers.<a name="a9"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html#a621df52a0b7842e1bad3bb7472c8d5e0">getBuffer</a>(ivb);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer == NULL &amp;&amp; currBuffer-&gt;<a name="a10"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a331cfb987f5f4d632a747e7fbbbe4a43">descriptor</a>().<a name="a11"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>() == <a name="a12"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4aa20581584e5f9447cb96afb4f2e10703">MHWRender::MGeometry::kPosition</a>)</div>
<div class="line">            positionBuffer = currBuffer;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (uvBuffer == NULL &amp;&amp; currBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a331cfb987f5f4d632a747e7fbbbe4a43">descriptor</a>().<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>() == <a name="a13"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93">MHWRender::MGeometry::kTexture</a>)</div>
<div class="line">            uvBuffer = currBuffer;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer == NULL)</div>
<div class="line"> <span class="comment">// We need at least the positions:</span></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a14"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea7354c5e6b4c4c152b77e663e2e59e0c3">MHWRender::MGeometry::kInvalidPrimitive</a>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">float</span>* positionBufferFloat = (<span class="keywordtype">float</span>*)positionBuffer-&gt;<a name="a15"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230">map</a>();</div>
<div class="line"> <span class="keywordtype">float</span>* uvBufferFloat = NULL;</div>
<div class="line"> <span class="keywordflow">if</span> (uvBuffer)</div>
<div class="line">        uvBufferFloat = (<span class="keywordtype">float</span>*)uvBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230">map</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; sourceIndexBuffers.<a name="a16"></a><a class="code" href="./class_m_h_w_render_1_1_m_component_data_indexing_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>(); ++x)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (sourceIndexBuffers[x]-&gt;componentType() != MHWRender::MComponentDataIndexing::kFaceVertex)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_uint_array.html">MUintArray</a>&amp; originalBufferIndices = sourceIndexBuffers[x]-&gt;indices();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriVerts = originalBufferIndices.<a class="code" href="./class_m_uint_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTri = numTriVerts / 3;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> triSize = computeTriangleSize(fAddAdjacentEdges, fAddDominantEdges, fAddDominantPosition);</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufferSize = numTri * triSize;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* indexData = indexBuffer.<a name="a17"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(bufferSize, <span class="keyword">true</span> <span class="comment">/*writeOnly - we don't need the current buffer values*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (indexData != NULL)</div>
<div class="line">        {</div>
<div class="line">            mutateIndexBuffer( originalBufferIndices, positionBufferFloat, uvBufferFloat, </div>
<div class="line">                               fAddAdjacentEdges, fAddDominantEdges, fAddDominantPosition,</div>
<div class="line">                               indexBuffer.<a name="a18"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#abc7588a483f61d3d4a1e8204ca14d6f6">dataType</a>(), indexData );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer) positionBuffer-&gt;<a name="a19"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (uvBuffer) uvBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a>();</div>
<div class="line">        indexBuffer.<a name="a20"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(indexData);</div>
<div class="line">        primitiveStride = triSize;</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a21"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea23d4e011c2b72a286021ca9a5a121830">MHWRender::MGeometry::kPatch</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer) positionBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (uvBuffer) uvBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a>();</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea7354c5e6b4c4c152b77e663e2e59e0c3">MHWRender::MGeometry::kInvalidPrimitive</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// This is the primitive generator creation function registered with the DrawRegistry.</span></div>
<div class="line"><span class="comment">// Used to initialize a custom primitive generator.</span></div>
<div class="line"><a name="_a22"></a><a class="code" href="./class_m_h_w_render_1_1_m_px_index_buffer_mutator.html">MHWRender::MPxIndexBufferMutator</a>* CrackFreePrimitiveGenerator::createCrackFreePrimitiveGenerator18()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">new</span> CrackFreePrimitiveGenerator(<span class="keyword">true</span> <span class="comment">/*addAdjacentEdges*/</span>, <span class="keyword">true</span> <span class="comment">/*addDominantEdges*/</span>, <span class="keyword">true</span> <span class="comment">/*addDominantPosition*/</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_px_index_buffer_mutator.html">MHWRender::MPxIndexBufferMutator</a>* CrackFreePrimitiveGenerator::createCrackFreePrimitiveGenerator9()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">new</span> CrackFreePrimitiveGenerator(<span class="keyword">true</span> <span class="comment">/*addAdjacentEdges*/</span>, <span class="keyword">false</span> <span class="comment">/*addDominantEdges*/</span>, <span class="keyword">false</span> <span class="comment">/*addDominantPosition*/</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div><br/></div>
</link></link></link></link></div></body>
</html>

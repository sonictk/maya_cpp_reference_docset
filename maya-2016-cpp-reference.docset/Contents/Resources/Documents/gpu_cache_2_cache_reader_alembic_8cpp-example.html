<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
 <head>
  <script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript">
  </script>
  <script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript">
  </script>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
   <meta content="MAYAUL" name="product">
    <meta content="2016" name="release">
     <meta content="Developer" name="book">
      <meta content="2015-10-14" name="created">
       <meta content="GUID-02DEF634-1E7B-48C6-8ACD-2C934CA97887" name="topicid">
        <meta content="concept" name="topic-type">
         <title>
          gpuCache/CacheReaderAlembic.cpp
         </title>
         <meta content="C++" name="topic-subtype"/>
        </meta>
       </meta>
      </meta>
     </meta>
    </meta>
   </meta>
  </meta>
 </head>
 <body height="100%">
  <div class="body_content" id="body-content">
   <link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css">
    <link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css">
     <link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css">
      <link href="style/adsk.cpm.css" rel="stylesheet" type="text/css">
       <script language="javascript">
        var index = 'index.html';
       </script>
       <script>
        $(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });
       </script>
       <script type="text/javascript">
        var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2_cache_reader_alembic_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
       </script>
       <script>
        $("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();
       </script>
       <script type="text/javascript">
        $("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?siteData=y5CYlxTRD0znCzRLDwX0Wy7-g1EdC1XA4dSC-Y1LtaeScyli8_Ps5jPKqTr4xKxMI0OOUfkDplvX3uxN0JnPclebSYW8_J1HBzf4VLQEzQ8M4PsYXF_cMyp1Oumaetky&category=5297189e-446b-459e-ae1d-9d0360400781_tech&ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );
       </script>
       <script>
        if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
       </script>
       <!-- begin MT -->
       <div class="Dark" id="MicrosoftTranslatorWidget" style="position:absolute;right:20px;top:5px;z-index:100;color:white;background-color:#555555;height:58px;overflow:hidden">
       </div>
       <div>
        <div class="head">
         <h1>
          gpuCache/CacheReaderAlembic.cpp
         </h1>
        </div>
        <div id="top">
         <!-- Generated by Doxygen 1.8.10 -->
         <div class="tabs" id="navrow1">
          <ul class="tablist">
           <li>
            <a href="./index.html">
             <span>
              MainÂ Page
             </span>
            </a>
           </li>
           <li>
            <a href="./pages.html">
             <span>
              Topics
             </span>
            </a>
           </li>
           <li>
            <a href="./modules.html">
             <span>
              Modules
             </span>
            </a>
           </li>
           <li>
            <a href="./namespaces.html">
             <span>
              Namespaces
             </span>
            </a>
           </li>
           <li>
            <a href="./annotated.html">
             <span>
              Classes
             </span>
            </a>
           </li>
           <li>
            <a href="./examples.html">
             <span>
              Examples
             </span>
            </a>
           </li>
          </ul>
         </div>
        </div>
        <!-- top -->
        <div class="ui-resizable side-nav-resizable" id="side-nav">
         <div id="nav-tree">
          <div id="nav-tree-contents">
           <div class="sync" id="nav-sync">
           </div>
          </div>
         </div>
         <div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
         </div>
        </div>
        <div id="doc-content">
         <div class="header">
          <div class="headertitle">
           <div class="title">
            gpuCache/CacheReaderAlembic.cpp
           </div>
          </div>
         </div>
         <!--header-->
         <div class="contents">
          <div class="fragment">
           <div class="line">
            <span class="comment">
             //-
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //**************************************************************************/
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // Copyright 2015 Autodesk, Inc.  All rights reserved.
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // Use of this software is subject to the terms of the Autodesk
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // license agreement provided at the time of installation or download,
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // or which otherwise accompanies this software in either electronic
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // or hard copy form.
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //**************************************************************************/
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //+
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="preprocessor">
             #include "CacheReaderAlembic.h"
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include "CacheAlembicUtil.h"
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include "gpuCacheUtil.h"
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include "gpuCacheStrings.h"
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;Alembic/AbcCoreFactory/IFactory.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;Alembic/AbcGeom/Visibility.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;Alembic/AbcGeom/ArchiveBounds.h&gt;
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MStringArray.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MAnimControl.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MString.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MGlobal.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MFnMesh.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MFnNurbsCurve.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MFnNurbsCurveData.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MTrimBoundaryArray.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MFloatArray.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MFloatVector.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MPointArray.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MFloatPointArray.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MFloatVectorArray.h&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;maya/MUintArray.h&gt;
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;boost/ref.hpp&gt;
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;fstream&gt;
            </span>
           </div>
           <div class="line">
            <span class="preprocessor">
             #include &lt;cassert&gt;
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             using namespace
            </span>
            CacheAlembicUtil;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             namespace
            </span>
            GPUCache {
           </div>
           <div class="line">
            <span class="keyword">
             namespace
            </span>
            CacheReaderAlembicPrivate {
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS AlembicArray
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             template
            </span>
            &lt;
            <span class="keyword">
             class
            </span>
            ArrayProperty&gt;
           </div>
           <div class="line">
            boost::shared_ptr&lt;ReadableArray&lt;typename AlembicArray&lt;ArrayProperty&gt;::T&gt; &gt;
           </div>
           <div class="line">
            AlembicArray&lt;ArrayProperty&gt;::create(
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            ArraySamplePtr&amp; arraySamplePtr,
            <span class="keyword">
             const
            </span>
            Digest&amp; digest )
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             size_t
            </span>
            size = (arraySamplePtr-&gt;size() *
           </div>
           <div class="line">
            ArrayProperty::traits_type::dataType().getExtent());
           </div>
           <div class="line">
            <span class="preprocessor">
             #ifndef NDEBUG
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // Compute the Murmur3 cryptographic hash-key and make sure
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // that the digest found in the Alembic file is correct.
            </span>
           </div>
           <div class="line">
            Digest checkDigest;
           </div>
           <div class="line">
            Alembic::Util::MurmurHash3_x64_128(
           </div>
           <div class="line">
            arraySamplePtr-&gt;get(), size *
            <span class="keyword">
             sizeof
            </span>
            (T),
            <span class="keyword">
             sizeof
            </span>
            (T), checkDigest.words);
           </div>
           <div class="line">
            assert(digest == checkDigest);
           </div>
           <div class="line">
            <span class="preprocessor">
             #endif
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // We first look if a similar array already exists in the
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // cache. If so, we return the cached array to promote sharing as
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // much as possible.
            </span>
           </div>
           <div class="line">
            boost::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; ret;
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            tbb::mutex::scoped_lock lock(ArrayRegistry&lt;T&gt;::mutex());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Only accept arrays which contain data we own.  This array may happen on a
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // worker thread, so non-readable arrays can't be converted to readable.
            </span>
           </div>
           <div class="line">
            ret = ArrayRegistry&lt;T&gt;::lookupReadable(digest, size);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!ret) {
           </div>
           <div class="line">
            ret = boost::make_shared&lt;AlembicArray&lt;ArrayProperty&gt; &gt;(
           </div>
           <div class="line">
            arraySamplePtr, digest);
           </div>
           <div class="line">
            ArrayRegistry&lt;T&gt;::insert(ret);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ret;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             template
            </span>
            &lt;
            <span class="keyword">
             class
            </span>
            ArrayProperty&gt;
           </div>
           <div class="line">
            AlembicArray&lt;ArrayProperty&gt;::~AlembicArray() {}
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             template
            </span>
            &lt;
            <span class="keyword">
             class
            </span>
            ArrayProperty&gt;
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keyword">
             typename
            </span>
            AlembicArray&lt;ArrayProperty&gt;::T*
           </div>
           <div class="line">
            AlembicArray&lt;ArrayProperty&gt;::get()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             reinterpret_cast&lt;
            </span>
            <span class="keyword">
             const
            </span>
            T*
            <span class="keyword">
             &gt;
            </span>
            (fArraySamplePtr-&gt;get());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS ArrayPropertyCacheWithConverter
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             template
            </span>
            &lt;
            <span class="keyword">
             typename
            </span>
            PROPERTY&gt;
           </div>
           <div class="line">
            <span class="keyword">
             typename
            </span>
            ArrayPropertyCacheWithConverter&lt;PROPERTY&gt;::ConvertionMap
           </div>
           <div class="line">
            ArrayPropertyCacheWithConverter&lt;PROPERTY&gt;::fsConvertionMap;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             template
            </span>
            <span class="keyword">
             class
            </span>
            ArrayPropertyCacheWithConverter&lt;
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty&gt;;
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS ScopedUnlockAlembic
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             class
            </span>
            ScopedUnlockAlembic : boost::noncopyable
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keyword">
             public
            </span>
            :
           </div>
           <div class="line">
            ScopedUnlockAlembic()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            gsAlembicMutex.unlock();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            ~ScopedUnlockAlembic()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            gsAlembicMutex.lock();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            };
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // This function is the checkpoint of the worker thread's interrupt and pause state.
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            CheckInterruptAndPause(
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             char
            </span>
            * state)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            GlobalReaderCache&amp; readerCache = GlobalReaderCache::theCache();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (readerCache.isInterrupted()) {
           </div>
           <div class="line">
            <span class="comment">
             // Interrupted. Throw an exception to terminate this reader.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             throw
            </span>
            CacheReaderInterruptException(state);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (readerCache.isPaused()) {
           </div>
           <div class="line">
            <span class="comment">
             // Paused. Unlock the Alembic lock and return the control.
            </span>
           </div>
           <div class="line">
            ScopedUnlockAlembic unlock;
           </div>
           <div class="line">
            readerCache.pauseUntilNotified();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS DataProvider
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             template
            </span>
            &lt;
            <span class="keyword">
             class
            </span>
            INFO&gt;
           </div>
           <div class="line">
            DataProvider::DataProvider(
           </div>
           <div class="line">
            Alembic::AbcGeom::IGeomBaseSchema&lt;INFO&gt;&amp; abcGeom,
           </div>
           <div class="line">
            Alembic::Abc::TimeSamplingPtr            timeSampling,
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numSamples,
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            : fAnimTimeRange(TimeInterval::kInvalid),
           </div>
           <div class="line">
            fBBoxAndVisValidityInterval(TimeInterval::kInvalid),
           </div>
           <div class="line">
            fValidityInterval(TimeInterval::kInvalid),
           </div>
           <div class="line">
            fNeedUVs(needUVs)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            Alembic::Abc::IObject shapeObject = abcGeom.getObject();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // shape visibility
            </span>
           </div>
           <div class="line">
            Alembic::AbcGeom::IVisibilityProperty visibility =
           </div>
           <div class="line">
            Alembic::AbcGeom::GetVisibilityProperty(shapeObject);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (visibility) {
           </div>
           <div class="line">
            fVisibilityCache.init(visibility);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // bounding box
            </span>
           </div>
           <div class="line">
            fBoundingBoxCache.init(abcGeom.getSelfBoundsProperty());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Find parent IObjects
            </span>
           </div>
           <div class="line">
            std::vector&lt;Alembic::Abc::IObject&gt; parents;
           </div>
           <div class="line">
            Alembic::Abc::IObject current = shapeObject.getParent();
           </div>
           <div class="line">
            <span class="keywordflow">
             while
            </span>
            (current.valid()) {
           </div>
           <div class="line">
            parents.push_back(current);
           </div>
           <div class="line">
            current = current.getParent();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // parent visibility
            </span>
           </div>
           <div class="line">
            fParentVisibilityCache.resize(parents.size());
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0; i &lt; fParentVisibilityCache.size(); i++) {
           </div>
           <div class="line">
            Alembic::AbcGeom::IVisibilityProperty visibilityProp =
           </div>
           <div class="line">
            Alembic::AbcGeom::GetVisibilityProperty(parents[i]);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (visibilityProp) {
           </div>
           <div class="line">
            fParentVisibilityCache[i].init(visibilityProp);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // exact animation time range
            </span>
           </div>
           <div class="line">
            fAnimTimeRange = TimeInterval(
           </div>
           <div class="line">
            timeSampling-&gt;getSampleTime(0),
           </div>
           <div class="line">
            timeSampling-&gt;getSampleTime(numSamples &gt; 0 ? numSamples-1 : 0)
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            DataProvider::~DataProvider()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            fValidityInterval = TimeInterval::kInvalid;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // free the property readers
            </span>
           </div>
           <div class="line">
            fVisibilityCache.reset();
           </div>
           <div class="line">
            fBoundingBoxCache.reset();
           </div>
           <div class="line">
            fParentVisibilityCache.clear();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            DataProvider::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fBoundingBoxCache.valid();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;const ShapeSample&gt;
           </div>
           <div class="line">
            DataProvider::getBBoxPlaceHolderSample(
            <span class="keywordtype">
             double
            </span>
            seconds)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            boost::shared_ptr&lt;ShapeSample&gt; sample =
           </div>
           <div class="line">
            ShapeSample::createBoundingBoxPlaceHolderSample(
           </div>
           <div class="line">
            seconds,
           </div>
           <div class="line">
            getBoundingBox(),
           </div>
           <div class="line">
            isVisible()
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            sample;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            DataProvider::fillBBoxAndVisSample(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            fBBoxAndVisValidityInterval = updateBBoxAndVisCache(time);
           </div>
           <div class="line">
            assert(fBBoxAndVisValidityInterval.valid());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            DataProvider::fillTopoAndAttrSample(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            fValidityInterval = updateCache(time);
           </div>
           <div class="line">
            assert(fValidityInterval.valid());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval DataProvider::updateBBoxAndVisCache(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Notes:
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // When possible, we try to reuse the samples from the previously
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // read sample.
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // update caches
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fVisibilityCache.valid()) {
           </div>
           <div class="line">
            fVisibilityCache.setTime(time);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            fBoundingBoxCache.setTime(time);
           </div>
           <div class="line">
            BOOST_FOREACH (ScalarPropertyCache&lt;Alembic::Abc::ICharProperty&gt;&amp;
           </div>
           <div class="line">
            parentVisPropCache, fParentVisibilityCache) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (parentVisPropCache.valid()) {
           </div>
           <div class="line">
            parentVisPropCache.setTime(time);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // return the new cache valid interval
            </span>
           </div>
           <div class="line">
            TimeInterval validityInterval(TimeInterval::kInfinite);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fVisibilityCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fVisibilityCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            validityInterval &amp;= fBoundingBoxCache.getValidityInterval();
           </div>
           <div class="line">
            BOOST_FOREACH (ScalarPropertyCache&lt;Alembic::Abc::ICharProperty&gt;&amp;
           </div>
           <div class="line">
            parentVisPropCache, fParentVisibilityCache) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (parentVisPropCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= parentVisPropCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval DataProvider::updateCache(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            updateBBoxAndVisCache(time);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            DataProvider::isVisible()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="comment">
             // shape invisible
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fVisibilityCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fVisibilityCache.getValue() == char(Alembic::AbcGeom::kVisibilityHidden)) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // parent invisible
            </span>
           </div>
           <div class="line">
            BOOST_FOREACH (
            <span class="keyword">
             const
            </span>
            ScalarPropertyCache&lt;Alembic::Abc::ICharProperty&gt;&amp;
           </div>
           <div class="line">
            parentVisPropCache, fParentVisibilityCache) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (parentVisPropCache.valid() &amp;&amp;
           </div>
           <div class="line">
            parentVisPropCache.getValue() == char(Alembic::AbcGeom::kVisibilityHidden)) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // visible
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS PolyDataProvider
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             template
            </span>
            &lt;
            <span class="keyword">
             class
            </span>
            SCHEMA&gt;
           </div>
           <div class="line">
            PolyDataProvider::PolyDataProvider(
           </div>
           <div class="line">
            SCHEMA&amp;                         abcMesh,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            : DataProvider(abcMesh, abcMesh.getTimeSampling(),
           </div>
           <div class="line">
            abcMesh.getNumSamples(), needUVs)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // polygon counts
            </span>
           </div>
           <div class="line">
            fFaceCountsCache.init(abcMesh.getFaceCountsProperty());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // positions
            </span>
           </div>
           <div class="line">
            fPositionsCache.init(abcMesh.getPositionsProperty());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            PolyDataProvider::~PolyDataProvider()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // free the property readers
            </span>
           </div>
           <div class="line">
            fFaceCountsCache.reset();
           </div>
           <div class="line">
            fPositionsCache.reset();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            PolyDataProvider::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            DataProvider::valid() &amp;&amp;
           </div>
           <div class="line">
            fFaceCountsCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fPositionsCache.valid();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval
           </div>
           <div class="line">
            PolyDataProvider::updateCache(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            TimeInterval validityInterval(DataProvider::updateCache(time));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // update caches
            </span>
           </div>
           <div class="line">
            fFaceCountsCache.setTime(time);
           </div>
           <div class="line">
            fPositionsCache.setTime(time);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // return the new cache valid interval
            </span>
           </div>
           <div class="line">
            validityInterval &amp;= fFaceCountsCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fPositionsCache.getValidityInterval();
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS RawDataProvider
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            RawDataProvider::RawDataProvider(
           </div>
           <div class="line">
            Alembic::AbcGeom::IPolyMeshSchema&amp; abcMesh,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            : PolyDataProvider(abcMesh, needUVs),
           </div>
           <div class="line">
            fFaceIndicesCache(correctPolygonWinding)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // triangle indices
            </span>
           </div>
           <div class="line">
            fFaceIndicesCache.init(abcMesh.getFaceIndicesProperty());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // custom reader for wireframe indices
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (abcMesh.getPropertyHeader(kCustomPropertyWireIndices) != NULL) {
           </div>
           <div class="line">
            fWireIndicesCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty(abcMesh.getPtr(), kCustomPropertyWireIndices));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (abcMesh.getPropertyHeader(kCustomPropertyWireIndicesOld) != NULL) {
           </div>
           <div class="line">
            fWireIndicesCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty(abcMesh.getPtr(), kCustomPropertyWireIndicesOld));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // custom reader for group info
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (abcMesh.getPropertyHeader(kCustomPropertyShadingGroupSizes) != NULL) {
           </div>
           <div class="line">
            fGroupSizesCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty(abcMesh.getPtr(), kCustomPropertyShadingGroupSizes));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // custom reader for diffuse color
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (abcMesh.getPropertyHeader(kCustomPropertyDiffuseColor) != NULL) {
           </div>
           <div class="line">
            fDiffuseColorCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IC4fProperty(abcMesh.getPtr(), kCustomPropertyDiffuseColor));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // normals, we do not support indexed/facevarying normals
            </span>
           </div>
           <div class="line">
            Alembic::AbcGeom::IN3fGeomParam normals = abcMesh.getNormalsParam();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (normals.valid()) {
           </div>
           <div class="line">
            assert(!normals.isIndexed());
           </div>
           <div class="line">
            assert(normals.getScope() == Alembic::AbcGeom::kVertexScope);
           </div>
           <div class="line">
            fNormalsCache.init(normals.getValueProperty());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNeedUVs) {
           </div>
           <div class="line">
            <span class="comment">
             // UVs, we do not support indexed/facevarying UVs
            </span>
           </div>
           <div class="line">
            Alembic::AbcGeom::IV2fGeomParam UVs = abcMesh.getUVsParam();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (UVs.valid()) {
           </div>
           <div class="line">
            assert(!UVs.isIndexed());
           </div>
           <div class="line">
            assert(UVs.getScope() == Alembic::AbcGeom::kVertexScope);
           </div>
           <div class="line">
            fUVsCache.init(UVs.getValueProperty());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            RawDataProvider::~RawDataProvider()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // free the property readers
            </span>
           </div>
           <div class="line">
            fFaceIndicesCache.reset();
           </div>
           <div class="line">
            fWireIndicesCache.reset();
           </div>
           <div class="line">
            fGroupSizesCache.reset();
           </div>
           <div class="line">
            fDiffuseColorCache.reset();
           </div>
           <div class="line">
            fNormalsCache.reset();
           </div>
           <div class="line">
            fUVsCache.reset();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            RawDataProvider::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            PolyDataProvider::valid() &amp;&amp;
           </div>
           <div class="line">
            fFaceIndicesCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fWireIndicesCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fDiffuseColorCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fNormalsCache.valid();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;const ShapeSample&gt;
           </div>
           <div class="line">
            RawDataProvider::getSample(
            <span class="keywordtype">
             double
            </span>
            seconds)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            std::vector&lt;boost::shared_ptr&lt;IndexBuffer&gt; &gt; triangleVertIndices;
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            boost::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; indexBuffer =
           </div>
           <div class="line">
            fFaceIndicesCache.getValue();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fGroupSizesCache.valid()) {
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            boost::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; groupSizes =
           </div>
           <div class="line">
            fGroupSizesCache.getValue();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* groupSizesPtr = groupSizes-&gt;get();
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i=0, offset=0; i&lt;groupSizes-&gt;size(); offset+=3*groupSizesPtr[i], ++i) {
           </div>
           <div class="line">
            triangleVertIndices.push_back(
           </div>
           <div class="line">
            IndexBuffer::create(
           </div>
           <div class="line">
            indexBuffer, offset, offset+3*groupSizesPtr[i]));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            triangleVertIndices.push_back(IndexBuffer::create(indexBuffer));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            Alembic::Abc::C4f diffuseColor = fDiffuseColorCache.getValue();
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;ShapeSample&gt; sample = ShapeSample::create(
           </div>
           <div class="line">
            seconds,
            <span class="comment">
             // time (in seconds)
            </span>
           </div>
           <div class="line">
            fWireIndicesCache.getValue()-&gt;size() / 2,
            <span class="comment">
             // number of wireframes
            </span>
           </div>
           <div class="line">
            fPositionsCache.getValue()-&gt;size() / 3,
            <span class="comment">
             // number of vertices
            </span>
           </div>
           <div class="line">
            IndexBuffer::create(fWireIndicesCache.getValue()),
            <span class="comment">
             // wireframe indices
            </span>
           </div>
           <div class="line">
            triangleVertIndices,
            <span class="comment">
             // triangle indices
            </span>
           </div>
           <div class="line">
            VertexBuffer::createPositions(fPositionsCache.getValue()),
            <span class="comment">
             // position
            </span>
           </div>
           <div class="line">
            getBoundingBox(),
            <span class="comment">
             // bounding box
            </span>
           </div>
           <div class="line">
            <a name="_a0">
            </a>
            <a class="code" href="./class_m_color.html">
             MColor
            </a>
            (diffuseColor.r, diffuseColor.g, diffuseColor.b, diffuseColor.a),
           </div>
           <div class="line">
            isVisible()
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalsCache.valid()) {
           </div>
           <div class="line">
            sample-&gt;setNormals(
           </div>
           <div class="line">
            VertexBuffer::createNormals(fNormalsCache.getValue()));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            sample-&gt;setUVs(
           </div>
           <div class="line">
            VertexBuffer::createUVs(fUVsCache.getValue()));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            sample;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt;
           </div>
           <div class="line">
            RawDataProvider::correctPolygonWinding(
            <span class="keyword">
             const
            </span>
            Alembic::Abc::Int32ArraySamplePtr&amp; indices)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            count = (*indices).size();
           </div>
           <div class="line">
            boost::shared_array&lt;IndexBuffer::index_t&gt; faceIndicesCCW(
           </div>
           <div class="line">
            <span class="keyword">
             new
            </span>
            IndexBuffer::index_t[count]);
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0; i &lt; count; i += 3) {
           </div>
           <div class="line">
            faceIndicesCCW[i + 2] = (*indices)[i + 0];
           </div>
           <div class="line">
            faceIndicesCCW[i + 1] = (*indices)[i + 1];
           </div>
           <div class="line">
            faceIndicesCCW[i + 0] = (*indices)[i + 2];
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            SharedArray&lt;IndexBuffer::index_t&gt;::create(
           </div>
           <div class="line">
            faceIndicesCCW, count);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval RawDataProvider::updateCache(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            TimeInterval validityInterval(PolyDataProvider::updateCache(time));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // update caches
            </span>
           </div>
           <div class="line">
            fFaceIndicesCache.setTime(time);
           </div>
           <div class="line">
            fWireIndicesCache.setTime(time);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fGroupSizesCache.valid()) {
           </div>
           <div class="line">
            fGroupSizesCache.setTime(time);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            fNormalsCache.setTime(time);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            fUVsCache.setTime(time);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            fDiffuseColorCache.setTime(time);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // return the new cache valid interval
            </span>
           </div>
           <div class="line">
            validityInterval &amp;= fFaceIndicesCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fWireIndicesCache.getValidityInterval();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fGroupSizesCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fGroupSizesCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            validityInterval &amp;= fNormalsCache.getValidityInterval();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fUVsCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            validityInterval &amp;= fDiffuseColorCache.getValidityInterval();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // check sample consistency
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numVerts     = fPositionsCache.getValue()-&gt;size() / 3;
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numTriangles = fFaceIndicesCache.getValue()-&gt;size() / 3;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fFaceCountsCache.getValue()-&gt;size() != numTriangles) {
           </div>
           <div class="line">
            assert(fFaceCountsCache.getValue()-&gt;size() == numTriangles);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            TimeInterval::kInvalid;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalsCache.getValue()-&gt;size() / 3 != numVerts) {
           </div>
           <div class="line">
            assert(fNormalsCache.getValue()-&gt;size() / 3 == numVerts);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            TimeInterval::kInvalid;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.getValue()-&gt;size() / 2 != numVerts) {
           </div>
           <div class="line">
            assert(fUVsCache.getValue()-&gt;size() / 2 == numVerts);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            TimeInterval::kInvalid;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS Triangulator
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            Triangulator::Triangulator(
           </div>
           <div class="line">
            Alembic::AbcGeom::IPolyMeshSchema&amp; abcMesh,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            : PolyDataProvider(abcMesh, needUVs),
           </div>
           <div class="line">
            fNormalsScope(Alembic::AbcGeom::kUnknownScope), fUVsScope(Alembic::AbcGeom::kUnknownScope)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // polygon indices
            </span>
           </div>
           <div class="line">
            fFaceIndicesCache.init(abcMesh.getFaceIndicesProperty());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // optional normals
            </span>
           </div>
           <div class="line">
            Alembic::AbcGeom::IN3fGeomParam normals = abcMesh.getNormalsParam();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (normals.valid()) {
           </div>
           <div class="line">
            fNormalsScope = normals.getScope();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalsScope == Alembic::AbcGeom::kVaryingScope ||
           </div>
           <div class="line">
            fNormalsScope == Alembic::AbcGeom::kVertexScope ||
           </div>
           <div class="line">
            fNormalsScope == Alembic::AbcGeom::kFacevaryingScope) {
           </div>
           <div class="line">
            fNormalsCache.init(normals.getValueProperty());
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (normals.isIndexed()) {
           </div>
           <div class="line">
            fNormalIndicesCache.init(normals.getIndexProperty());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // optional UVs
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNeedUVs) {
           </div>
           <div class="line">
            Alembic::AbcGeom::IV2fGeomParam UVs = abcMesh.getUVsParam();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (UVs.valid()) {
           </div>
           <div class="line">
            fUVsScope = UVs.getScope();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsScope == Alembic::AbcGeom::kVaryingScope ||
           </div>
           <div class="line">
            fUVsScope == Alembic::AbcGeom::kVertexScope ||
           </div>
           <div class="line">
            fUVsScope == Alembic::AbcGeom::kFacevaryingScope) {
           </div>
           <div class="line">
            fUVsCache.init(UVs.getValueProperty());
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (UVs.isIndexed()) {
           </div>
           <div class="line">
            fUVIndicesCache.init(UVs.getIndexProperty());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            Triangulator::~Triangulator()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // free the property readers
            </span>
           </div>
           <div class="line">
            fFaceIndicesCache.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fNormalsScope = Alembic::AbcGeom::kUnknownScope;
           </div>
           <div class="line">
            fNormalsCache.reset();
           </div>
           <div class="line">
            fNormalIndicesCache.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fUVsScope = Alembic::AbcGeom::kUnknownScope;
           </div>
           <div class="line">
            fUVsCache.reset();
           </div>
           <div class="line">
            fUVIndicesCache.reset();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            Triangulator::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            PolyDataProvider::valid() &amp;&amp;
           </div>
           <div class="line">
            fFaceIndicesCache.valid();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;const ShapeSample&gt;
           </div>
           <div class="line">
            Triangulator::getSample(
            <span class="keywordtype">
             double
            </span>
            seconds)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // empty mesh
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fWireIndices || !fTriangleIndices) {
           </div>
           <div class="line">
            boost::shared_ptr&lt;ShapeSample&gt; sample =
           </div>
           <div class="line">
            ShapeSample::createEmptySample(seconds);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            sample;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // triangle indices
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // Currently, we only have 1 group
            </span>
           </div>
           <div class="line">
            std::vector&lt;boost::shared_ptr&lt;IndexBuffer&gt; &gt; triangleVertIndices;
           </div>
           <div class="line">
            triangleVertIndices.push_back(IndexBuffer::create(fTriangleIndices));
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;ShapeSample&gt; sample = ShapeSample::create(
           </div>
           <div class="line">
            seconds,
            <span class="comment">
             // time (in seconds)
            </span>
           </div>
           <div class="line">
            fWireIndices-&gt;size() / 2,
            <span class="comment">
             // number of wireframes
            </span>
           </div>
           <div class="line">
            fMappedPositions-&gt;size() / 3,
            <span class="comment">
             // number of vertices
            </span>
           </div>
           <div class="line">
            IndexBuffer::create(fWireIndices),
            <span class="comment">
             // wireframe indices
            </span>
           </div>
           <div class="line">
            triangleVertIndices,
            <span class="comment">
             // triangle indices (1 group)
            </span>
           </div>
           <div class="line">
            VertexBuffer::createPositions(fMappedPositions),
            <span class="comment">
             // position
            </span>
           </div>
           <div class="line">
            getBoundingBox(),
            <span class="comment">
             // bounding box
            </span>
           </div>
           <div class="line">
            Config::kDefaultGrayColor,
            <span class="comment">
             // diffuse color
            </span>
           </div>
           <div class="line">
            isVisible()
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fMappedNormals) {
           </div>
           <div class="line">
            sample-&gt;setNormals(
           </div>
           <div class="line">
            VertexBuffer::createNormals(fMappedNormals));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fMappedUVs) {
           </div>
           <div class="line">
            sample-&gt;setUVs(
           </div>
           <div class="line">
            VertexBuffer::createUVs(fMappedUVs));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            sample;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval Triangulator::updateCache(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // update faceCounts/position cache here so that we can detect topology/position change.
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // next setTime() in DataProvider::updateCache() simply returns early
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            topologyChanged = fFaceCountsCache.setTime(time);
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            positionChanged = fPositionsCache.setTime(time);
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval validityInterval(PolyDataProvider::updateCache(time));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // update caches
            </span>
           </div>
           <div class="line">
            topologyChanged = fFaceIndicesCache.setTime(time) || topologyChanged;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalsCache.valid()) {
           </div>
           <div class="line">
            fNormalsCache.setTime(time);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalIndicesCache.valid()) {
           </div>
           <div class="line">
            fNormalIndicesCache.setTime(time);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            fUVsCache.setTime(time);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVIndicesCache.valid()) {
           </div>
           <div class="line">
            fUVIndicesCache.setTime(time);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // return the new cache valid interval
            </span>
           </div>
           <div class="line">
            validityInterval &amp;= fFaceIndicesCache.getValidityInterval();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalsCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fNormalsCache.getValidityInterval();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalIndicesCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fNormalIndicesCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fUVsCache.getValidityInterval();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVIndicesCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fUVIndicesCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // do a minimal check for the consistency
            </span>
           </div>
           <div class="line">
            check();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // convert the mesh to display-friend format
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (positionChanged || topologyChanged || !fComputedNormals) {
           </div>
           <div class="line">
            <span class="comment">
             // recompute normals on position/topology change
            </span>
           </div>
           <div class="line">
            computeNormals();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (topologyChanged || !fVertAttribsIndices) {
           </div>
           <div class="line">
            <span class="comment">
             // convert multi-indexed streams on topology change
            </span>
           </div>
           <div class="line">
            convertMultiIndexedStreams();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            remapVertAttribs();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (topologyChanged || !fWireIndices) {
           </div>
           <div class="line">
            <span class="comment">
             // recompute wireframe indices on topology change
            </span>
           </div>
           <div class="line">
            computeWireIndices();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (topologyChanged || !fTriangleIndices) {
           </div>
           <div class="line">
            <span class="comment">
             // recompute triangulation on topology change
            </span>
           </div>
           <div class="line">
            triangulate();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             template
            </span>
            &lt;
            <span class="keywordtype">
             size_t
            </span>
            SIZE&gt;
           </div>
           <div class="line">
            boost::shared_ptr&lt;ReadableArray&lt;float&gt; &gt; Triangulator::convertMultiIndexedStream(
           </div>
           <div class="line">
            boost::shared_ptr&lt;ReadableArray&lt;float&gt; &gt; attribArray,
           </div>
           <div class="line">
            boost::shared_ptr&lt;ReadableArray&lt;IndexBuffer::index_t&gt; &gt; indexArray)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // map the indexed array to direct array
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numVerts                                 = indexArray-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * srcAttribs                         = attribArray-&gt;get();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* srcIndices          = indexArray-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_array&lt;float&gt; mappedAttribs(
            <span class="keyword">
             new
            </span>
            <span class="keywordtype">
             float
            </span>
            [numVerts * SIZE]);
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0; i &lt; numVerts; i++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            j = 0; j &lt; SIZE; j++) {
           </div>
           <div class="line">
            mappedAttribs[i * SIZE + j] = srcAttribs[srcIndices[i] * SIZE + j];
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            SharedArray&lt;float&gt;::create(mappedAttribs, numVerts * SIZE);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            Triangulator::check()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numVerts       = fPositionsCache.getValue()-&gt;size() / 3;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Normals
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numExpectedNormals = 0;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalsScope == Alembic::AbcGeom::kVaryingScope ||
           </div>
           <div class="line">
            fNormalsScope == Alembic::AbcGeom::kVertexScope) {
           </div>
           <div class="line">
            numExpectedNormals = numVerts;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (fNormalsScope == Alembic::AbcGeom::kFacevaryingScope) {
           </div>
           <div class="line">
            numExpectedNormals = numFaceIndices;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numActualNormals = 0;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalsCache.valid()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalIndicesCache.valid()) {
           </div>
           <div class="line">
            numActualNormals = fNormalIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            numActualNormals = fNormalsCache.getValue()-&gt;size() / 3;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // clear previous result
            </span>
           </div>
           <div class="line">
            fCheckedNormalsScope = Alembic::AbcGeom::kUnknownScope;
           </div>
           <div class="line">
            fCheckedNormals.reset();
           </div>
           <div class="line">
            fCheckedNormalIndices.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // forward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numExpectedNormals == numActualNormals) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalsCache.valid()) {
           </div>
           <div class="line">
            fCheckedNormalsScope = fNormalsScope;
           </div>
           <div class="line">
            fCheckedNormals      = fNormalsCache.getValue();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormalIndicesCache.valid()) {
           </div>
           <div class="line">
            fCheckedNormalIndices = fNormalIndicesCache.getValue();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            DisplayWarning(kBadNormalsMsg);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // UVs
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numExpectedUVs = 0;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsScope == Alembic::AbcGeom::kVaryingScope ||
           </div>
           <div class="line">
            fUVsScope == Alembic::AbcGeom::kVertexScope) {
           </div>
           <div class="line">
            numExpectedUVs = numVerts;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (fUVsScope == Alembic::AbcGeom::kFacevaryingScope) {
           </div>
           <div class="line">
            numExpectedUVs = numFaceIndices;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numActualUVs = 0;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVIndicesCache.valid()) {
           </div>
           <div class="line">
            numActualUVs = fUVIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            numActualUVs = fUVsCache.getValue()-&gt;size() / 2;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // clear previous result
            </span>
           </div>
           <div class="line">
            fCheckedUVsScope = Alembic::AbcGeom::kUnknownScope;
           </div>
           <div class="line">
            fCheckedUVs.reset();
           </div>
           <div class="line">
            fCheckedUVIndices.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // forward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numExpectedUVs == numActualUVs) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            fCheckedUVsScope = fUVsScope;
           </div>
           <div class="line">
            fCheckedUVs      = fUVsCache.getValue();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVIndicesCache.valid()) {
           </div>
           <div class="line">
            fCheckedUVIndices = fUVIndicesCache.getValue();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            DisplayWarning(kBadUVsMsg);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            Triangulator::computeNormals()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // compute normals if the normals are missing
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // later on, we can safely assume that the normals always exist
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedNormals &amp;&amp; (fCheckedNormalsScope == Alembic::AbcGeom::kVaryingScope
           </div>
           <div class="line">
            || fCheckedNormalsScope == Alembic::AbcGeom::kVertexScope
           </div>
           <div class="line">
            || fCheckedNormalsScope == Alembic::AbcGeom::kFacevaryingScope)) {
           </div>
           <div class="line">
            <span class="comment">
             // the normals exist and we recognize these normals
            </span>
           </div>
           <div class="line">
            fComputedNormals      = fCheckedNormals;
           </div>
           <div class="line">
            fComputedNormalsScope = fCheckedNormalsScope;
           </div>
           <div class="line">
            fComputedNormalIndices.reset();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedNormalIndices) {
           </div>
           <div class="line">
            fComputedNormalIndices = fCheckedNormalIndices;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceCounts           = fFaceCountsCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * faceCounts = fFaceCountsCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numPositions = fPositionsCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * positions = fPositionsCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numVerts = numPositions / 3;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numVerts == 0) {
           </div>
           <div class="line">
            fComputedNormalsScope = Alembic::AbcGeom::kUnknownScope;
           </div>
           <div class="line">
            fComputedNormals.reset();
           </div>
           <div class="line">
            fComputedNormalIndices.reset();
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // allocate buffers for the new normals
            </span>
           </div>
           <div class="line">
            boost::shared_array&lt;float&gt; computedFaceNormals(
            <span class="keyword">
             new
            </span>
            <span class="keywordtype">
             float
            </span>
            [numFaceCounts * 3]);
           </div>
           <div class="line">
            boost::shared_array&lt;float&gt; computedNormals(
            <span class="keyword">
             new
            </span>
            <span class="keywordtype">
             float
            </span>
            [numVerts * 3]);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // compute the face normals
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0, polyVertOffset = 0; i &lt; numFaceCounts; polyVertOffset += faceCounts[i], i++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numPoints = faceCounts[i];
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Newell's Method
            </span>
           </div>
           <div class="line">
            <a name="_a1">
            </a>
            <a class="code" href="./class_m_float_vector.html">
             MFloatVector
            </a>
            faceNormal(0.0f, 0.0f, 0.0f);
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            j = 0; j &lt; numPoints; j++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            thisJ = numPoints - j - 1;
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            nextJ = numPoints - ((j + 1) % numPoints) - 1;
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * thisPoint = &amp;positions[faceIndices[polyVertOffset + thisJ] * 3];
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * nextPoint = &amp;positions[faceIndices[polyVertOffset + nextJ] * 3];
           </div>
           <div class="line">
            faceNormal.
            <a name="a2">
            </a>
            <a class="code" href="./class_m_float_vector.html#ad0da36b2558901e21e7a30f6c227a45e">
             x
            </a>
            += (thisPoint[1] - nextPoint[1]) * (thisPoint[2] + nextPoint[2]);
           </div>
           <div class="line">
            faceNormal.
            <a name="a3">
            </a>
            <a class="code" href="./class_m_float_vector.html#aa4f0d3eebc3c443f9be81bf48561a217">
             y
            </a>
            += (thisPoint[2] - nextPoint[2]) * (thisPoint[0] + nextPoint[0]);
           </div>
           <div class="line">
            faceNormal.
            <a name="a4">
            </a>
            <a class="code" href="./class_m_float_vector.html#af73583b1e980b0aa03f9884812e9fd4d">
             z
            </a>
            += (thisPoint[0] - nextPoint[0]) * (thisPoint[1] + nextPoint[1]);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            faceNormal.
            <a name="a5">
            </a>
            <a class="code" href="./class_m_float_vector.html#ab66b0c7697d96a278da9bca810f4dee1">
             normalize
            </a>
            ();
           </div>
           <div class="line">
           </div>
           <div class="line">
            computedFaceNormals[i * 3 + 0] = faceNormal.
            <a class="code" href="./class_m_float_vector.html#ad0da36b2558901e21e7a30f6c227a45e">
             x
            </a>
            ;
           </div>
           <div class="line">
            computedFaceNormals[i * 3 + 1] = faceNormal.
            <a class="code" href="./class_m_float_vector.html#aa4f0d3eebc3c443f9be81bf48561a217">
             y
            </a>
            ;
           </div>
           <div class="line">
            computedFaceNormals[i * 3 + 2] = faceNormal.
            <a class="code" href="./class_m_float_vector.html#af73583b1e980b0aa03f9884812e9fd4d">
             z
            </a>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // compute the normals
            </span>
           </div>
           <div class="line">
            memset(&amp;computedNormals[0], 0,
            <span class="keyword">
             sizeof
            </span>
            (
            <span class="keywordtype">
             float
            </span>
            ) * numVerts * 3);
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0, polyVertOffset = 0; i &lt; numFaceCounts; polyVertOffset += faceCounts[i], i++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numPoints = faceCounts[i];
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * faceNormal = &amp;computedFaceNormals[i * 3];
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // accumulate the face normal
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            j = 0; j &lt; numPoints; j++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             float
            </span>
            * normal = &amp;computedNormals[faceIndices[polyVertOffset + j] * 3];
           </div>
           <div class="line">
            normal[0] += faceNormal[0];
           </div>
           <div class="line">
            normal[1] += faceNormal[1];
           </div>
           <div class="line">
            normal[2] += faceNormal[2];
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // normalize normals, MFloatVector functions are inline functions
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0; i &lt; numVerts; i++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             float
            </span>
            * normal = &amp;computedNormals[i * 3];
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_float_vector.html">
             MFloatVector
            </a>
            vector(normal[0], normal[1], normal[2]);
           </div>
           <div class="line">
            vector.
            <a class="code" href="./class_m_float_vector.html#ab66b0c7697d96a278da9bca810f4dee1">
             normalize
            </a>
            ();
           </div>
           <div class="line">
           </div>
           <div class="line">
            normal[0] = vector.
            <a class="code" href="./class_m_float_vector.html#ad0da36b2558901e21e7a30f6c227a45e">
             x
            </a>
            ;
           </div>
           <div class="line">
            normal[1] = vector.
            <a class="code" href="./class_m_float_vector.html#aa4f0d3eebc3c443f9be81bf48561a217">
             y
            </a>
            ;
           </div>
           <div class="line">
            normal[2] = vector.
            <a class="code" href="./class_m_float_vector.html#af73583b1e980b0aa03f9884812e9fd4d">
             z
            </a>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            fComputedNormalsScope = Alembic::AbcGeom::kVertexScope;
           </div>
           <div class="line">
            fComputedNormals      = SharedArray&lt;float&gt;::create(computedNormals, numVerts * 3);
           </div>
           <div class="line">
            fComputedNormalIndices.reset();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            Triangulator::convertMultiIndexedStreams()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // convert multi-indexed streams to single-indexed streams
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // assume the scope is kVarying/kVertex/kFacevarying
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input polygons data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input normals
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            normalFaceVarying =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* normalIndices     = NULL;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fComputedNormals) {
           </div>
           <div class="line">
            normalFaceVarying = (fComputedNormalsScope == Alembic::AbcGeom::kFacevaryingScope);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fComputedNormalIndices) {
           </div>
           <div class="line">
            normalIndices = fComputedNormalIndices-&gt;get();
           </div>
           <div class="line">
            assert(fComputedNormalIndices-&gt;size() == numFaceIndices);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input UV indices
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            uvFaceVarying =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* uvIndices     = NULL;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVs) {
           </div>
           <div class="line">
            uvFaceVarying = (fCheckedUVsScope == Alembic::AbcGeom::kFacevaryingScope);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVIndices) {
           </div>
           <div class="line">
            uvIndices = fCheckedUVIndices-&gt;get();
           </div>
           <div class="line">
            assert(fCheckedUVIndices-&gt;size() == numFaceIndices);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // determine the number of multi-indexed streams
            </span>
           </div>
           <div class="line">
            MultiIndexedStreamsConverter&lt;IndexBuffer::index_t&gt; converter(
           </div>
           <div class="line">
            numFaceIndices, faceIndices);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (normalFaceVarying) {
           </div>
           <div class="line">
            converter.addMultiIndexedStream(normalIndices);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (uvFaceVarying) {
           </div>
           <div class="line">
            converter.addMultiIndexedStream(uvIndices);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // only one multi-indexed streams, no need to convert it
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (converter.numStreams() == 1) {
           </div>
           <div class="line">
            fVertAttribsIndices.reset();
           </div>
           <div class="line">
            fMappedFaceIndices = fFaceIndicesCache.getValue();
           </div>
           <div class="line">
            fNumVertices       = fPositionsCache.getValue()-&gt;size() / 3;
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // convert the multi-indexed streams
            </span>
           </div>
           <div class="line">
            converter.compute();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // the mapped face indices
            </span>
           </div>
           <div class="line">
            fMappedFaceIndices = SharedArray&lt;IndexBuffer::index_t&gt;::create(
           </div>
           <div class="line">
            converter.mappedFaceIndices(), numFaceIndices);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // indices to remap streams
            </span>
           </div>
           <div class="line">
            fVertAttribsIndices = converter.vertAttribsIndices();
           </div>
           <div class="line">
            fNumVertices        = converter.numVertices();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            Triangulator::remapVertAttribs()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // remap vertex attribute streams according to the result of convertMultiIndexedStreams()
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // assume the scope is kVarying/kVertex/kFacevarying
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // no multi-index streams, just drop indices
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fVertAttribsIndices) {
           </div>
           <div class="line">
            <span class="comment">
             // positions is the only stream, just use it
            </span>
           </div>
           <div class="line">
            fMappedPositions = fPositionsCache.getValue();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // get rid of normal indices
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fComputedNormals) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fComputedNormalIndices) {
           </div>
           <div class="line">
            fMappedNormals = convertMultiIndexedStream&lt;3&gt;(
           </div>
           <div class="line">
            fComputedNormals, fComputedNormalIndices);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            fMappedNormals = fComputedNormals;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // get rid of UV indices
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVs) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVIndices) {
           </div>
           <div class="line">
            fMappedUVs = convertMultiIndexedStream&lt;2&gt;(
           </div>
           <div class="line">
            fCheckedUVs, fCheckedUVIndices);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            fMappedUVs = fCheckedUVs;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input polygons data
            </span>
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            *                positions   = fPositionsCache.getValue()-&gt;get();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input normals
            </span>
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            *                normals       = NULL;
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* normalIndices = NULL;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fComputedNormals) {
           </div>
           <div class="line">
            normals = fComputedNormals-&gt;get();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fComputedNormalIndices) {
           </div>
           <div class="line">
            normalIndices = fComputedNormalIndices-&gt;get();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input UV indices
            </span>
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            *                UVs       = NULL;
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* uvIndices = NULL;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVs) {
           </div>
           <div class="line">
            UVs = fCheckedUVs-&gt;get();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVIndices) {
           </div>
           <div class="line">
            uvIndices = fCheckedUVIndices-&gt;get();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // set up multi-indexed streams remapper
            </span>
           </div>
           <div class="line">
            MultiIndexedStreamsRemapper&lt;IndexBuffer::index_t&gt; remapper(
           </div>
           <div class="line">
            faceIndices, fNumVertices, fVertAttribsIndices.get());
           </div>
           <div class="line">
           </div>
           <div class="line">
            remapper.addMultiIndexedStream(positions, NULL,
            <span class="keyword">
             false
            </span>
            , 3);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (normals) {
           </div>
           <div class="line">
            remapper.addMultiIndexedStream(normals, normalIndices,
           </div>
           <div class="line">
            fComputedNormalsScope == Alembic::AbcGeom::kFacevaryingScope, 3);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (UVs) {
           </div>
           <div class="line">
            remapper.addMultiIndexedStream(UVs, uvIndices,
           </div>
           <div class="line">
            fCheckedUVsScope == Alembic::AbcGeom::kFacevaryingScope, 2);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // remap streams
            </span>
           </div>
           <div class="line">
            remapper.compute();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fMappedPositions = SharedArray&lt;float&gt;::create(
           </div>
           <div class="line">
            remapper.mappedVertAttribs(0), fNumVertices * 3);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            streamIndex = 1;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (normals) {
           </div>
           <div class="line">
            fMappedNormals = SharedArray&lt;float&gt;::create(
           </div>
           <div class="line">
            remapper.mappedVertAttribs(streamIndex++), fNumVertices * 3);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (UVs) {
           </div>
           <div class="line">
            fMappedUVs = SharedArray&lt;float&gt;::create(
           </div>
           <div class="line">
            remapper.mappedVertAttribs(streamIndex++), fNumVertices * 2);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            Triangulator::computeWireIndices()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // compute the wireframe indices
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceCounts = fFaceCountsCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * faceCounts = fFaceCountsCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* mappedFaceIndices = fMappedFaceIndices-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Compute wireframe indices
            </span>
           </div>
           <div class="line">
            WireIndicesGenerator&lt;IndexBuffer::index_t&gt; wireIndicesGenerator(
           </div>
           <div class="line">
            numFaceCounts, faceCounts, numFaceIndices, faceIndices, mappedFaceIndices);
           </div>
           <div class="line">
            wireIndicesGenerator.compute();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (wireIndicesGenerator.numWires() == 0) {
           </div>
           <div class="line">
            fWireIndices.reset();
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            fWireIndices = SharedArray&lt;IndexBuffer::index_t&gt;::create(
           </div>
           <div class="line">
            wireIndicesGenerator.wireIndices(), wireIndicesGenerator.numWires() * 2);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            Triangulator::triangulate()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // triangulate the polygons
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // assume that there are no holes
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceCounts = fFaceCountsCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * faceCounts = fFaceCountsCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* faceIndices = fMappedFaceIndices-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * positions = fMappedPositions-&gt;get();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * normals   = fMappedNormals ? fMappedNormals-&gt;get() : NULL;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numFaceCounts == 0) {
           </div>
           <div class="line">
            fTriangleIndices.reset();
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Triangulate polygons
            </span>
           </div>
           <div class="line">
            PolyTriangulator&lt;IndexBuffer::index_t&gt; polyTriangulator(
           </div>
           <div class="line">
            numFaceCounts, faceCounts, faceIndices,
            <span class="keyword">
             true
            </span>
            , positions, normals);
           </div>
           <div class="line">
           </div>
           <div class="line">
            polyTriangulator.compute();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fTriangleIndices = SharedArray&lt;IndexBuffer::index_t&gt;::create(
           </div>
           <div class="line">
            polyTriangulator.triangleIndices(), polyTriangulator.numTriangles() * 3);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS NurbsTessellator
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            NurbsTessellator::NurbsTessellator(
           </div>
           <div class="line">
            Alembic::AbcGeom::INuPatchSchema&amp; abcNurbs,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            : DataProvider(abcNurbs, abcNurbs.getTimeSampling(),
           </div>
           <div class="line">
            abcNurbs.getNumSamples(), needUVs),
           </div>
           <div class="line">
            fSurfaceValid(
            <span class="keyword">
             false
            </span>
            )
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Control point positions
            </span>
           </div>
           <div class="line">
            fPositionsCache.init(abcNurbs.getPositionsProperty());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Number of control points
            </span>
           </div>
           <div class="line">
            fNumUCache.init(Alembic::Abc::IInt32Property(abcNurbs.getPtr(),
            <span class="stringliteral">
             "nu"
            </span>
            ));
           </div>
           <div class="line">
            fNumVCache.init(Alembic::Abc::IInt32Property(abcNurbs.getPtr(),
            <span class="stringliteral">
             "nv"
            </span>
            ));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Order (Degree + 1)
            </span>
           </div>
           <div class="line">
            fUOrderCache.init(Alembic::Abc::IInt32Property(abcNurbs.getPtr(),
            <span class="stringliteral">
             "uOrder"
            </span>
            ));
           </div>
           <div class="line">
            fVOrderCache.init(Alembic::Abc::IInt32Property(abcNurbs.getPtr(),
            <span class="stringliteral">
             "vOrder"
            </span>
            ));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Knots
            </span>
           </div>
           <div class="line">
            fUKnotCache.init(abcNurbs.getUKnotsProperty());
           </div>
           <div class="line">
            fVKnotCache.init(abcNurbs.getVKnotsProperty());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Control point weights
            </span>
           </div>
           <div class="line">
            Alembic::AbcGeom::IFloatArrayProperty positionWeights = abcNurbs.getPositionWeightsProperty();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (positionWeights.valid()) {
           </div>
           <div class="line">
            fPositionWeightsCache.init(positionWeights);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Trim curves
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (abcNurbs.hasTrimCurve()) {
           </div>
           <div class="line">
            <span class="comment">
             // Number of loops
            </span>
           </div>
           <div class="line">
            fTrimNumLoopsCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IInt32Property(abcNurbs.getPtr(),
            <span class="stringliteral">
             "trim_nloops"
            </span>
            ));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Number of curves
            </span>
           </div>
           <div class="line">
            fTrimNumCurvesCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty(abcNurbs.getPtr(),
            <span class="stringliteral">
             "trim_ncurves"
            </span>
            ));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Number of control points
            </span>
           </div>
           <div class="line">
            fTrimNumVerticesCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty(abcNurbs.getPtr(),
            <span class="stringliteral">
             "trim_n"
            </span>
            ));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Curve Orders
            </span>
           </div>
           <div class="line">
            fTrimOrderCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty(abcNurbs.getPtr(),
            <span class="stringliteral">
             "trim_order"
            </span>
            ));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Curve Knots
            </span>
           </div>
           <div class="line">
            fTrimKnotCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IFloatArrayProperty(abcNurbs.getPtr(),
            <span class="stringliteral">
             "trim_knot"
            </span>
            ));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Curve U
            </span>
           </div>
           <div class="line">
            fTrimUCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IFloatArrayProperty(abcNurbs.getPtr(),
            <span class="stringliteral">
             "trim_u"
            </span>
            ));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Curve V
            </span>
           </div>
           <div class="line">
            fTrimVCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IFloatArrayProperty(abcNurbs.getPtr(),
            <span class="stringliteral">
             "trim_v"
            </span>
            ));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Curve W
            </span>
           </div>
           <div class="line">
            fTrimWCache.init(
           </div>
           <div class="line">
            Alembic::Abc::IFloatArrayProperty(abcNurbs.getPtr(),
            <span class="stringliteral">
             "trim_w"
            </span>
            ));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            NurbsTessellator::~NurbsTessellator()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // free the property readers
            </span>
           </div>
           <div class="line">
            fPositionsCache.reset();
           </div>
           <div class="line">
            fNumUCache.reset();
           </div>
           <div class="line">
            fNumVCache.reset();
           </div>
           <div class="line">
            fUOrderCache.reset();
           </div>
           <div class="line">
            fVOrderCache.reset();
           </div>
           <div class="line">
            fUKnotCache.reset();
           </div>
           <div class="line">
            fVKnotCache.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fPositionWeightsCache.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fTrimNumLoopsCache.reset();
           </div>
           <div class="line">
            fTrimNumCurvesCache.reset();
           </div>
           <div class="line">
            fTrimNumVerticesCache.reset();
           </div>
           <div class="line">
            fTrimOrderCache.reset();
           </div>
           <div class="line">
            fTrimKnotCache.reset();
           </div>
           <div class="line">
            fTrimUCache.reset();
           </div>
           <div class="line">
            fTrimVCache.reset();
           </div>
           <div class="line">
            fTrimWCache.reset();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            NurbsTessellator::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            DataProvider::valid() &amp;&amp;
           </div>
           <div class="line">
            fPositionsCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fNumUCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fNumVCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fUOrderCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fVOrderCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fUKnotCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fVKnotCache.valid();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;const ShapeSample&gt;
           </div>
           <div class="line">
            NurbsTessellator::getSample(
            <span class="keywordtype">
             double
            </span>
            seconds)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // empty mesh
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fWireIndices || !fTriangleIndices) {
           </div>
           <div class="line">
            boost::shared_ptr&lt;ShapeSample&gt; sample =
           </div>
           <div class="line">
            ShapeSample::createEmptySample(seconds);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            sample;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // triangle indices
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // Currently, we only have 1 group
            </span>
           </div>
           <div class="line">
            std::vector&lt;boost::shared_ptr&lt;IndexBuffer&gt; &gt; triangleVertIndices;
           </div>
           <div class="line">
            triangleVertIndices.push_back(IndexBuffer::create(fTriangleIndices));
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;ShapeSample&gt; sample = ShapeSample::create(
           </div>
           <div class="line">
            seconds,
            <span class="comment">
             // time (in seconds)
            </span>
           </div>
           <div class="line">
            fWireIndices-&gt;size() / 2,
            <span class="comment">
             // number of wireframes
            </span>
           </div>
           <div class="line">
            fPositions-&gt;size() / 3,
            <span class="comment">
             // number of vertices
            </span>
           </div>
           <div class="line">
            IndexBuffer::create(fWireIndices),
            <span class="comment">
             // wireframe indices
            </span>
           </div>
           <div class="line">
            triangleVertIndices,
            <span class="comment">
             // triangle indices (1 group)
            </span>
           </div>
           <div class="line">
            VertexBuffer::createPositions(fPositions),
            <span class="comment">
             // position
            </span>
           </div>
           <div class="line">
            getBoundingBox(),
            <span class="comment">
             // bounding box
            </span>
           </div>
           <div class="line">
            Config::kDefaultGrayColor,
            <span class="comment">
             // diffuse color
            </span>
           </div>
           <div class="line">
            isVisible()
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormals) {
           </div>
           <div class="line">
            sample-&gt;setNormals(
           </div>
           <div class="line">
            VertexBuffer::createNormals(fNormals));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVs) {
           </div>
           <div class="line">
            sample-&gt;setUVs(
           </div>
           <div class="line">
            VertexBuffer::createUVs(fUVs));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            sample;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval NurbsTessellator::updateCache(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            TimeInterval validityInterval(DataProvider::updateCache(time));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // update caches
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            positionsChanged = fPositionsCache.setTime(time);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            topologyChanged = fNumUCache.setTime(time);
           </div>
           <div class="line">
            topologyChanged      = fNumVCache.setTime(time)   || topologyChanged;
           </div>
           <div class="line">
            topologyChanged      = fUOrderCache.setTime(time) || topologyChanged;
           </div>
           <div class="line">
            topologyChanged      = fVOrderCache.setTime(time) || topologyChanged;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            knotChanged = fUKnotCache.setTime(time);
           </div>
           <div class="line">
            knotChanged      = fVKnotCache.setTime(time) || knotChanged;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fPositionWeightsCache.valid()) {
           </div>
           <div class="line">
            positionsChanged = fPositionWeightsCache.setTime(time) || positionsChanged;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            trimCurvesChanged =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fTrimNumLoopsCache.valid()) {
           </div>
           <div class="line">
            trimCurvesChanged = fTrimNumLoopsCache.setTime(time)    || trimCurvesChanged;
           </div>
           <div class="line">
            trimCurvesChanged = fTrimNumCurvesCache.setTime(time)   || trimCurvesChanged;
           </div>
           <div class="line">
            trimCurvesChanged = fTrimNumVerticesCache.setTime(time) || trimCurvesChanged;
           </div>
           <div class="line">
            trimCurvesChanged = fTrimOrderCache.setTime(time)       || trimCurvesChanged;
           </div>
           <div class="line">
            trimCurvesChanged = fTrimKnotCache.setTime(time)        || trimCurvesChanged;
           </div>
           <div class="line">
            trimCurvesChanged = fTrimUCache.setTime(time)           || trimCurvesChanged;
           </div>
           <div class="line">
            trimCurvesChanged = fTrimVCache.setTime(time)           || trimCurvesChanged;
           </div>
           <div class="line">
            trimCurvesChanged = fTrimWCache.setTime(time)           || trimCurvesChanged;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // return the new cache valid interval
            </span>
           </div>
           <div class="line">
            validityInterval &amp;= fPositionsCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fNumUCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fNumVCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fUOrderCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fVOrderCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fUKnotCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fVKnotCache.getValidityInterval();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fPositionWeightsCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fPositionWeightsCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fTrimNumLoopsCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fTrimNumLoopsCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fTrimNumCurvesCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fTrimNumVerticesCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fTrimOrderCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fTrimKnotCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fTrimUCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fTrimVCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fTrimWCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // do a minimal check for the consistency
            </span>
           </div>
           <div class="line">
            check();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // set Alembic INuPatch to Maya MFnNurbsSurface
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            rebuild = topologyChanged || knotChanged ||
           </div>
           <div class="line">
            trimCurvesChanged || fNurbsData.object().isNull();
           </div>
           <div class="line">
            setNurbs(rebuild, positionsChanged);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // tessellate Maya NURBS and convert to poly
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (rebuild || positionsChanged) {
           </div>
           <div class="line">
            tessellate();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (isVisible()) {
           </div>
           <div class="line">
            convertToPoly();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            NurbsTessellator::check()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // reset valid flag
            </span>
           </div>
           <div class="line">
            <a name="_a6">
            </a>
            <a class="code" href="./class_m_status.html">
             MStatus
            </a>
            status;
           </div>
           <div class="line">
            fSurfaceValid =
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // numKnots = numCV + degree + 1
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             int
            </span>
            uDegree   = fUOrderCache.getValue() - 1;
           </div>
           <div class="line">
            <span class="keywordtype">
             int
            </span>
            vDegree   = fVOrderCache.getValue() - 1;
           </div>
           <div class="line">
            <span class="keywordtype">
             int
            </span>
            numUCV    = fNumUCache.getValue();
           </div>
           <div class="line">
            <span class="keywordtype">
             int
            </span>
            numVCV    = fNumVCache.getValue();
           </div>
           <div class="line">
            <span class="keywordtype">
             int
            </span>
            numUKnots = (int)fUKnotCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keywordtype">
             int
            </span>
            numVKnots = (int)fVKnotCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numUKnots != numUCV + uDegree + 1 || numVKnots != numVCV + vDegree + 1) {
           </div>
           <div class="line">
            fSurfaceValid =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            DisplayWarning(kBadNurbsMsg);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // numCV = numU * numV
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numCVs = numUCV * numVCV;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numCVs * 3 != fPositionsCache.getValue()-&gt;size()) {
           </div>
           <div class="line">
            fSurfaceValid =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            DisplayWarning(kBadNurbsMsg);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // numCV = numWeight
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fPositionWeightsCache.valid() &amp;&amp;
           </div>
           <div class="line">
            numCVs != fPositionWeightsCache.getValue()-&gt;size()) {
           </div>
           <div class="line">
            fSurfaceValid =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            DisplayWarning(kBadNurbsMsg);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            NurbsTessellator::setNurbs(
            <span class="keywordtype">
             bool
            </span>
            rebuild,
            <span class="keywordtype">
             bool
            </span>
            positionsChanged)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fSurfaceValid) {
           </div>
           <div class="line">
            <span class="comment">
             // invalid NURBS
            </span>
           </div>
           <div class="line">
            fNurbsData.setObject(
            <a name="a7">
            </a>
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            fNurbs.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Number of control points in U/V direction
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            numU = 0;
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            numV = 0;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a name="_a8">
            </a>
            <a class="code" href="./class_m_point_array.html">
             MPointArray
            </a>
            mayaPositions;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (rebuild || positionsChanged) {
           </div>
           <div class="line">
            numU = fNumUCache.getValue();
           </div>
           <div class="line">
            numV = fNumVCache.getValue();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Positions and their weights
            </span>
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * positions = fPositionsCache.getValue()-&gt;
            <a name="a9">
            </a>
            <a class="code" href="./class_m_point_array.html#aab050cd677ada1564ca558d3840628cd">
             get
            </a>
            ();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * positionWeights = NULL;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fPositionWeightsCache.valid()) {
           </div>
           <div class="line">
            positionWeights = fPositionWeightsCache.getValue()-&gt;get();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // allocate memory for positions
            </span>
           </div>
           <div class="line">
            mayaPositions.
            <a name="a10">
            </a>
            <a class="code" href="./class_m_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">
             setLength
            </a>
            (numU * numV);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Maya is U-major and has inversed V
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            u = 0; u &lt; numU; u++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            v = 0; v &lt; numV; v++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            alembicIndex = v * numU + u;
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            mayaIndex    = u * numV + (numV - v - 1);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a name="_a11">
            </a>
            <a class="code" href="./class_m_point.html">
             MPoint
            </a>
            point(positions[alembicIndex * 3 + 0],
           </div>
           <div class="line">
            positions[alembicIndex * 3 + 1],
           </div>
           <div class="line">
            positions[alembicIndex * 3 + 2],
           </div>
           <div class="line">
            1.0);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (positionWeights) {
           </div>
           <div class="line">
            point.w = positionWeights[alembicIndex];
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            mayaPositions[mayaIndex] = point;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (rebuild) {
           </div>
           <div class="line">
            <span class="comment">
             // Nurbs degree
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            uDegree = fUOrderCache.getValue() - 1;
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            vDegree = fVOrderCache.getValue() - 1;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Nurbs form
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // Alemblic file does not record the form of nurb surface, we get the form
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // by checking the CV data. If the first degree number CV overlap the last
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // degree number CV, then the form is kPeriodic. If only the first CV overlaps
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // the last CV, then the form is kClosed.
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66">
             MFnNurbsSurface::Form
            </a>
            uForm =
            <a name="a12">
            </a>
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a0ed9d38a35a60087a093558dad96d882">
             MFnNurbsSurface::kPeriodic
            </a>
            ;
           </div>
           <div class="line">
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66">
             MFnNurbsSurface::Form
            </a>
            vForm =
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a0ed9d38a35a60087a093558dad96d882">
             MFnNurbsSurface::kPeriodic
            </a>
            ;
           </div>
           <div class="line">
            <span class="comment">
             // Check all curves
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            notOpen =
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            v = 0; notOpen &amp;&amp; v &lt; numV; v++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            u = 0; u &lt; uDegree; u++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            firstIndex = u * numV + (numV - v - 1);
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            lastPeriodicIndex = (numU - uDegree + u) * numV + (numV - v - 1);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!mayaPositions[firstIndex].isEquivalent(mayaPositions[lastPeriodicIndex])) {
           </div>
           <div class="line">
            uForm =
            <a name="a13">
            </a>
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">
             MFnNurbsSurface::kOpen
            </a>
            ;
           </div>
           <div class="line">
            notOpen =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             break
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (uForm ==
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">
             MFnNurbsSurface::kOpen
            </a>
            ) {
           </div>
           <div class="line">
            uForm =
            <a name="a14">
            </a>
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a44be8f61450ed22be5adcc881a95570f">
             MFnNurbsSurface::kClosed
            </a>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            v = 0; v &lt; numV; v++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            lastUIndex = (numU - 1) * numV + (numV - v - 1);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!mayaPositions[numV-v-1].isEquivalent(mayaPositions[lastUIndex])) {
           </div>
           <div class="line">
            uForm =
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">
             MFnNurbsSurface::kOpen
            </a>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             break
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            notOpen =
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            u = 0; notOpen &amp;&amp; u &lt; numU; u++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            v = 0; v &lt; vDegree; v++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            firstIndex = u * numV + (numV - v - 1);
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            lastPeriodicIndex =  u * numV + (vDegree - v - 1);
            <span class="comment">
             //numV - (numV - vDegree + v) - 1;
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!mayaPositions[firstIndex].isEquivalent(mayaPositions[lastPeriodicIndex])) {
           </div>
           <div class="line">
            vForm =
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">
             MFnNurbsSurface::kOpen
            </a>
            ;
           </div>
           <div class="line">
            notOpen =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             break
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (vForm ==
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">
             MFnNurbsSurface::kOpen
            </a>
            ) {
           </div>
           <div class="line">
            vForm =
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a44be8f61450ed22be5adcc881a95570f">
             MFnNurbsSurface::kClosed
            </a>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            u = 0; u &lt; numU; u++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!mayaPositions[u*numV+(numV-1)].isEquivalent(mayaPositions[u*numV])) {
           </div>
           <div class="line">
            vForm =
            <a class="code" href="./class_m_fn_nurbs_surface.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">
             MFnNurbsSurface::kOpen
            </a>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             break
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Knots
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //   Dispose the leading and trailing knots
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //   Alembic duplicate CVs if the form is not kOpen
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //   For more information, refer to MFnNurbsSurface
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            numUKnot = (
            <span class="keywordtype">
             unsigned
            </span>
            int)fUKnotCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            numVKnot = (
            <span class="keywordtype">
             unsigned
            </span>
            int)fVKnotCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * uKnot    = fUKnotCache.getValue()-&gt;get();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * vKnot    = fVKnotCache.getValue()-&gt;get();
           </div>
           <div class="line">
            <a name="_a15">
            </a>
            <a class="code" href="./class_m_double_array.html">
             MDoubleArray
            </a>
            mayaUKnots(uKnot + 1, numUKnot - 2);
           </div>
           <div class="line">
            <a class="code" href="./class_m_double_array.html">
             MDoubleArray
            </a>
            mayaVKnots(vKnot + 1, numVKnot - 2);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Create the Nurbs
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_status.html">
             MStatus
            </a>
            status;
           </div>
           <div class="line">
            <a name="_a16">
            </a>
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            nurbsData = fNurbsData.create();
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            nurbs     = fNurbs.create(mayaPositions,
           </div>
           <div class="line">
            mayaUKnots, mayaVKnots,
           </div>
           <div class="line">
            uDegree, vDegree,
           </div>
           <div class="line">
            uForm,
           </div>
           <div class="line">
            vForm,
           </div>
           <div class="line">
            <span class="keyword">
             true
            </span>
            ,
           </div>
           <div class="line">
            nurbsData,
           </div>
           <div class="line">
            &amp;status);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (status !=
            <a name="a17">
            </a>
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            || nurbs.
            <a name="a18">
            </a>
            <a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">
             isNull
            </a>
            ()) {
           </div>
           <div class="line">
            <span class="comment">
             // creation failure
            </span>
           </div>
           <div class="line">
            fNurbsData.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            fNurbs.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Trim Nurbs
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fTrimNumLoopsCache.valid()) {
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            trimNumLoops = fTrimNumLoopsCache.getValue();
           </div>
           <div class="line">
            <span class="comment">
             // mayaV = offsetV - alembicV
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             double
            </span>
            startU, endU, startV, endV;
           </div>
           <div class="line">
            fNurbs.getKnotDomain(startU, endU, startV, endV);
           </div>
           <div class="line">
            <span class="keywordtype">
             double
            </span>
            offsetV = startV + endV;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a name="_a19">
            </a>
            <a class="code" href="./class_m_trim_boundary_array.html">
             MTrimBoundaryArray
            </a>
            boundaryArray;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * trimNumCurves =
           </div>
           <div class="line">
            fTrimNumCurvesCache.getValue()-&gt;
            <a name="a20">
            </a>
            <a class="code" href="./class_m_trim_boundary_array.html#af99b4425d90f73b88634ec50327ae48a">
             get
            </a>
            ();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * trimNumVertices =
           </div>
           <div class="line">
            fTrimNumVerticesCache.getValue()-&gt;
            <a name="a21">
            </a>
            <a class="code" href="./class_m_object_array.html#a8223a66b2c37fdf38b8a95b53566a7a7">
             get
            </a>
            ();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * trimOrder =
           </div>
           <div class="line">
            fTrimOrderCache.getValue()-&gt;get();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * trimKnot = fTrimKnotCache.getValue()-&gt;get();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * trimU    = fTrimUCache.getValue()-&gt;get();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * trimV    = fTrimVCache.getValue()-&gt;get();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * trimW    = fTrimWCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; trimNumLoops; i++) {
           </div>
           <div class="line">
            <span class="comment">
             // Set up curves for each boundary
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            numCurves = *trimNumCurves;
           </div>
           <div class="line">
            <a name="_a22">
            </a>
            <a class="code" href="./class_m_object_array.html">
             MObjectArray
            </a>
            boundary(numCurves);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            j = 0; j &lt; numCurves; j++) {
           </div>
           <div class="line">
            <span class="comment">
             // Set up one curve
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            numVertices = *trimNumVertices;
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            degree      = *trimOrder - 1;
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            numKnots    = numVertices + degree + 1;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_point_array.html">
             MPointArray
            </a>
            controlPoints;
           </div>
           <div class="line">
            controlPoints.
            <a class="code" href="./class_m_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">
             setLength
            </a>
            (numVertices);
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            k = 0; k &lt; numVertices; k++) {
           </div>
           <div class="line">
            <a class="code" href="./class_m_point.html">
             MPoint
            </a>
            point(trimU[k], offsetV - trimV[k], 0, trimW[k]);
           </div>
           <div class="line">
            controlPoints[k] = point;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_double_array.html">
             MDoubleArray
            </a>
            knots(trimKnot + 1, numKnots - 2);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Create the curve
            </span>
           </div>
           <div class="line">
            <a name="_a23">
            </a>
            <a class="code" href="./class_m_fn_nurbs_curve_data.html">
             MFnNurbsCurveData
            </a>
            curveData;
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            curveDataObject = curveData.
            <a name="a24">
            </a>
            <a class="code" href="./class_m_fn_nurbs_curve_data.html#af1adb4abaf5243c6c0749bcca7b5c418">
             create
            </a>
            ();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a name="_a25">
            </a>
            <a class="code" href="./class_m_fn_nurbs_curve.html">
             MFnNurbsCurve
            </a>
            curve;
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            curveObject  = curve.
            <a name="a26">
            </a>
            <a class="code" href="./class_m_fn_nurbs_curve.html#a4b11e346021c91845e781e9d7d06859f">
             create
            </a>
            (controlPoints, knots, degree,
           </div>
           <div class="line">
            <a name="a27">
            </a>
            <a class="code" href="./class_m_fn_nurbs_curve.html#a99f5203c7742378941e34926280c8e66a7fb3bf49ba349ca1a266be41df447b5b">
             MFnNurbsCurve::kOpen
            </a>
            ,
            <span class="keyword">
             true
            </span>
            ,
            <span class="keyword">
             true
            </span>
            , curveDataObject, &amp;status);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (status ==
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            &amp;&amp; !curveObject.
            <a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">
             isNull
            </a>
            ()) {
           </div>
           <div class="line">
            boundary[j] = curveDataObject;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // next curve
            </span>
           </div>
           <div class="line">
            trimNumVertices++;
           </div>
           <div class="line">
            trimOrder++;
           </div>
           <div class="line">
            trimKnot += numKnots;
           </div>
           <div class="line">
            trimU    += numVertices;
           </div>
           <div class="line">
            trimV    += numVertices;
           </div>
           <div class="line">
            trimW    += numVertices;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            boundaryArray.
            <a name="a28">
            </a>
            <a class="code" href="./class_m_trim_boundary_array.html#a58aa0ffd87a8ca32834b827e1452f23e">
             append
            </a>
            (boundary);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // next loop
            </span>
           </div>
           <div class="line">
            trimNumCurves++;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_trim_boundary_array.html">
             MTrimBoundaryArray
            </a>
            oneRegion;
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; boundaryArray.
            <a name="a29">
            </a>
            <a class="code" href="./class_m_trim_boundary_array.html#a580388f31f60c46fac867ca48a48da1e">
             length
            </a>
            (); i++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (i &gt; 0) {
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            loopData = boundaryArray.
            <a name="a30">
            </a>
            <a class="code" href="./class_m_trim_boundary_array.html#a8c5c9d056371db0b771e14526c08b520">
             getMergedBoundary
            </a>
            (i, &amp;status);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (status !=
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            )
            <span class="keywordflow">
             continue
            </span>
            ;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_fn_nurbs_curve.html">
             MFnNurbsCurve
            </a>
            loop(loopData, &amp;status);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (status !=
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            )
            <span class="keywordflow">
             continue
            </span>
            ;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Check whether this loop is an outer boundary.
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            isOuterBoundary =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             double
            </span>
            length  = loop.
            <a name="a31">
            </a>
            <a class="code" href="./class_m_fn_nurbs_curve.html#acdf47b43a3196b3eb5f7b78a64003ba9">
             length
            </a>
            ();
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            segment = std::max(loop.
            <a name="a32">
            </a>
            <a class="code" href="./class_m_fn_nurbs_curve.html#addc4a2b6312ad1c7265478f2680b7566">
             numCVs
            </a>
            (), 10);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_point_array.html">
             MPointArray
            </a>
            curvePoints;
           </div>
           <div class="line">
            curvePoints.
            <a class="code" href="./class_m_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">
             setLength
            </a>
            (segment);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            j = 0; j &lt; segment; j++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             double
            </span>
            param = loop.
            <a name="a33">
            </a>
            <a class="code" href="./class_m_fn_nurbs_curve.html#a6fc77e351e95b453079bbad771940d9f">
             findParamFromLength
            </a>
            (length * j / segment);
           </div>
           <div class="line">
            loop.
            <a name="a34">
            </a>
            <a class="code" href="./class_m_fn_nurbs_curve.html#ab2f1acb5a0653b12d7430d5786ef2e3e">
             getPointAtParam
            </a>
            (param, curvePoints[j]);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Find the right most curve point
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_point.html">
             MPoint
            </a>
            rightMostPoint = curvePoints[0];
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            rightMostIndex = 0;
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            j = 0; j &lt; curvePoints.length(); j++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (rightMostPoint.
            <a name="a35">
            </a>
            <a class="code" href="./class_m_point.html#af88b946fb90d5f08b5fb740c70e98c10">
             x
            </a>
            &lt; curvePoints[j].x) {
           </div>
           <div class="line">
            rightMostPoint = curvePoints[j];
           </div>
           <div class="line">
            rightMostIndex = j;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Find the vertex just before and after the right most vertex
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            beforeIndex = (rightMostIndex == 0) ? curvePoints.length() - 1 : rightMostIndex - 1;
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            afterIndex  = (rightMostIndex == curvePoints.length() - 1) ? 0 : rightMostIndex + 1;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            j = 0; j &lt; curvePoints.length(); j++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fabs(curvePoints[beforeIndex].x - curvePoints[rightMostIndex].x) &lt; 1e-5) {
           </div>
           <div class="line">
            beforeIndex = (beforeIndex == 0) ? curvePoints.length() - 1 : beforeIndex - 1;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            j = 0; j &lt; curvePoints.length(); j++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fabs(curvePoints[afterIndex].x - curvePoints[rightMostIndex].x) &lt; 1e-5) {
           </div>
           <div class="line">
            afterIndex = (afterIndex == curvePoints.length() - 1) ? 0 : afterIndex + 1;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // failed. not a closed curve.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fabs(curvePoints[afterIndex].x - curvePoints[rightMostIndex].x) &lt; 1e-5 &amp;&amp;
           </div>
           <div class="line">
            fabs(curvePoints[beforeIndex].x - curvePoints[rightMostIndex].x) &lt; 1e-5) {
           </div>
           <div class="line">
            <span class="keywordflow">
             continue
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Compute the cross product
            </span>
           </div>
           <div class="line">
            <a name="_a36">
            </a>
            <a class="code" href="./class_m_vector.html">
             MVector
            </a>
            vector1 = curvePoints[beforeIndex] - curvePoints[rightMostIndex];
           </div>
           <div class="line">
            <a class="code" href="./class_m_vector.html">
             MVector
            </a>
            vector2 = curvePoints[afterIndex]  - curvePoints[rightMostIndex];
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            ((vector1 ^ vector2).z &lt; 0) {
           </div>
           <div class="line">
            isOuterBoundary =
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Trim the NURBS surface. An outer boundary starts a new region.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (isOuterBoundary) {
           </div>
           <div class="line">
            status = fNurbs.trimWithBoundaries(oneRegion,
            <span class="keyword">
             false
            </span>
            , 1e-3, 1e-5,
            <span class="keyword">
             true
            </span>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (status !=
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            ) {
           </div>
           <div class="line">
            fNurbsData.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            fNurbs.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            oneRegion.
            <a name="a37">
            </a>
            <a class="code" href="./class_m_trim_boundary_array.html#ad5522f028dde0080b753279426415a4a">
             clear
            </a>
            ();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            oneRegion.
            <a class="code" href="./class_m_trim_boundary_array.html#a58aa0ffd87a8ca32834b827e1452f23e">
             append
            </a>
            (boundaryArray[i]);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            status = fNurbs.trimWithBoundaries(oneRegion,
            <span class="keyword">
             false
            </span>
            , 1e-3, 1e-5,
            <span class="keyword">
             true
            </span>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (status !=
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            ) {
           </div>
           <div class="line">
            fNurbsData.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            fNurbs.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            assert(!fNurbsData.object().isNull());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (positionsChanged) {
           </div>
           <div class="line">
            fNurbs.setCVs(mayaPositions);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            NurbsTessellator::tessellate()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fSurfaceValid || fNurbsData.object().isNull()) {
           </div>
           <div class="line">
            fPolyMeshData.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            fPolyMesh.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Create the mesh data to own the mesh
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            polyMeshData = fPolyMeshData.create();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Set up parameters
            </span>
           </div>
           <div class="line">
            <a name="_a38">
            </a>
            <a class="code" href="./class_m_tesselation_params.html">
             MTesselationParams
            </a>
            params(
           </div>
           <div class="line">
            <a name="a39">
            </a>
            <a class="code" href="./class_m_tesselation_params.html#a5b2a7c1776e72b64f6b50fc95871c146a0d4e0874a457fb879a20aa067222b65b">
             MTesselationParams::kStandardFitFormat
            </a>
            ,
            <a name="a40">
            </a>
            <a class="code" href="./class_m_tesselation_params.html#a05266719b7393f22777306c9b4faf514aa2c70dd76c8172a9298334473c914304">
             MTesselationParams::kTriangles
            </a>
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Tess the NURBS to triangles
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_status.html">
             MStatus
            </a>
            status;
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            polyObject = fNurbs.tesselate(params, polyMeshData, &amp;status);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (status !=
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            || !polyObject.
            <a name="a41">
            </a>
            <a class="code" href="./class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">
             hasFn
            </a>
            (
            <a name="a42">
            </a>
            <a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a19fd562fc0900a60162e6073df36cb62">
             MFn::kMesh
            </a>
            )) {
           </div>
           <div class="line">
            <span class="comment">
             // tessellation failed
            </span>
           </div>
           <div class="line">
            fPolyMeshData.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            fPolyMesh.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            status = fPolyMesh.setObject(polyObject);
           </div>
           <div class="line">
            assert(status ==
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            );
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            NurbsTessellator::convertToPoly()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fSurfaceValid || fPolyMeshData.object().isNull() ||
           </div>
           <div class="line">
            fPolyMesh.numVertices() == 0 || fPolyMesh.numFaceVertices() == 0) {
           </div>
           <div class="line">
            fTriangleIndices.reset();
           </div>
           <div class="line">
            fWireIndices.reset();
           </div>
           <div class="line">
            fPositions.reset();
           </div>
           <div class="line">
            fNormals.reset();
           </div>
           <div class="line">
            fUVs.reset();
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            MayaMeshExtractor&lt;IndexBuffer::index_t&gt; extractor(fPolyMeshData.object());
           </div>
           <div class="line">
            extractor.setWantUVs(fNeedUVs);
           </div>
           <div class="line">
            extractor.compute();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fTriangleIndices = extractor.triangleIndices();
           </div>
           <div class="line">
            fWireIndices     = extractor.wireIndices();
           </div>
           <div class="line">
            fPositions       = extractor.positions();
           </div>
           <div class="line">
            fNormals         = extractor.normals();
           </div>
           <div class="line">
            fUVs.reset();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNeedUVs) {
           </div>
           <div class="line">
            fUVs         = extractor.uvs();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS SubDSmoother
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            SubDSmoother::SubDSmoother(
           </div>
           <div class="line">
            Alembic::AbcGeom::ISubDSchema&amp;  abcSubD,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            : PolyDataProvider(abcSubD, needUVs)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Face Indices
            </span>
           </div>
           <div class="line">
            fFaceIndicesCache.init(abcSubD.getFaceIndicesProperty());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Crease Edges
            </span>
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty creaseIndicesProp =
           </div>
           <div class="line">
            abcSubD.getCreaseIndicesProperty();
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty creaseLengthsProp =
           </div>
           <div class="line">
            abcSubD.getCreaseLengthsProperty();
           </div>
           <div class="line">
            Alembic::Abc::IFloatArrayProperty creaseSharpnessesProp =
           </div>
           <div class="line">
            abcSubD.getCreaseSharpnessesProperty();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (creaseIndicesProp.valid() &amp;&amp;
           </div>
           <div class="line">
            creaseLengthsProp.valid() &amp;&amp;
           </div>
           <div class="line">
            creaseSharpnessesProp.valid()) {
           </div>
           <div class="line">
            fCreaseIndicesCache.init(creaseIndicesProp);
           </div>
           <div class="line">
            fCreaseLengthsCache.init(creaseLengthsProp);
           </div>
           <div class="line">
            fCreaseSharpnessesCache.init(creaseSharpnessesProp);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Crease Vertices
            </span>
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty cornerIndicesProp =
           </div>
           <div class="line">
            abcSubD.getCornerIndicesProperty();
           </div>
           <div class="line">
            Alembic::Abc::IFloatArrayProperty cornerSharpnessesProp =
           </div>
           <div class="line">
            abcSubD.getCornerSharpnessesProperty();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (cornerIndicesProp.valid() &amp;&amp; cornerSharpnessesProp.valid()) {
           </div>
           <div class="line">
            fCornerIndicesCache.init(cornerIndicesProp);
           </div>
           <div class="line">
            fCornerSharpnessesCache.init(cornerSharpnessesProp);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Invisible Faces
            </span>
           </div>
           <div class="line">
            Alembic::Abc::IInt32ArrayProperty holesProp =
           </div>
           <div class="line">
            abcSubD.getHolesProperty();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (holesProp.valid()) {
           </div>
           <div class="line">
            fHolesCache.init(holesProp);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // UVs
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNeedUVs) {
           </div>
           <div class="line">
            Alembic::AbcGeom::IV2fGeomParam UVs = abcSubD.getUVsParam();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (UVs.valid()) {
           </div>
           <div class="line">
            fUVsScope = UVs.getScope();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsScope == Alembic::AbcGeom::kVaryingScope ||
           </div>
           <div class="line">
            fUVsScope == Alembic::AbcGeom::kVertexScope ||
           </div>
           <div class="line">
            fUVsScope == Alembic::AbcGeom::kFacevaryingScope) {
           </div>
           <div class="line">
            fUVsCache.init(UVs.getValueProperty());
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (UVs.isIndexed()) {
           </div>
           <div class="line">
            fUVIndicesCache.init(UVs.getIndexProperty());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            SubDSmoother::~SubDSmoother()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // free the property readers
            </span>
           </div>
           <div class="line">
            fFaceIndicesCache.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fCreaseIndicesCache.reset();
           </div>
           <div class="line">
            fCreaseLengthsCache.reset();
           </div>
           <div class="line">
            fCreaseSharpnessesCache.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fCornerIndicesCache.reset();
           </div>
           <div class="line">
            fCornerSharpnessesCache.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fHolesCache.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fUVsScope = Alembic::AbcGeom::kUnknownScope;
           </div>
           <div class="line">
            fUVsCache.reset();
           </div>
           <div class="line">
            fUVIndicesCache.reset();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            SubDSmoother::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            PolyDataProvider::valid() &amp;&amp;
           </div>
           <div class="line">
            fFaceIndicesCache.valid();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;const ShapeSample&gt;
           </div>
           <div class="line">
            SubDSmoother::getSample(
            <span class="keywordtype">
             double
            </span>
            seconds)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // empty mesh
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fWireIndices || !fTriangleIndices) {
           </div>
           <div class="line">
            boost::shared_ptr&lt;ShapeSample&gt; sample =
           </div>
           <div class="line">
            ShapeSample::createEmptySample(seconds);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            sample;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // triangle indices
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // Currently, we only have 1 group
            </span>
           </div>
           <div class="line">
            std::vector&lt;boost::shared_ptr&lt;IndexBuffer&gt; &gt; triangleVertIndices;
           </div>
           <div class="line">
            triangleVertIndices.push_back(IndexBuffer::create(fTriangleIndices));
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;ShapeSample&gt; sample = ShapeSample::create(
           </div>
           <div class="line">
            seconds,
            <span class="comment">
             // time (in seconds)
            </span>
           </div>
           <div class="line">
            fWireIndices-&gt;size() / 2,
            <span class="comment">
             // number of wireframes
            </span>
           </div>
           <div class="line">
            fPositions-&gt;size() / 3,
            <span class="comment">
             // number of vertices
            </span>
           </div>
           <div class="line">
            IndexBuffer::create(fWireIndices),
            <span class="comment">
             // wireframe indices
            </span>
           </div>
           <div class="line">
            triangleVertIndices,
            <span class="comment">
             // triangle indices (1 group)
            </span>
           </div>
           <div class="line">
            VertexBuffer::createPositions(fPositions),
            <span class="comment">
             // position
            </span>
           </div>
           <div class="line">
            getBoundingBox(),
            <span class="comment">
             // bounding box
            </span>
           </div>
           <div class="line">
            Config::kDefaultGrayColor,
            <span class="comment">
             // diffuse color
            </span>
           </div>
           <div class="line">
            isVisible()
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNormals) {
           </div>
           <div class="line">
            sample-&gt;setNormals(
           </div>
           <div class="line">
            VertexBuffer::createNormals(fNormals));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVs) {
           </div>
           <div class="line">
            sample-&gt;setUVs(
           </div>
           <div class="line">
            VertexBuffer::createUVs(fUVs));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            sample;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval SubDSmoother::updateCache(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // update faceCounts/position cache here so that we can detect topology/position change.
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // next setTime() in DataProvider::updateCache() simply returns early
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            topologyChanged = fFaceCountsCache.setTime(time);
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            positionChanged = fPositionsCache.setTime(time);
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval validityInterval(PolyDataProvider::updateCache(time));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // update caches
            </span>
           </div>
           <div class="line">
            topologyChanged = fFaceIndicesCache.setTime(time) || topologyChanged;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            creaseEdgeChanged =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCreaseSharpnessesCache.valid()) {
           </div>
           <div class="line">
            creaseEdgeChanged = fCreaseIndicesCache.setTime(time) || creaseEdgeChanged;
           </div>
           <div class="line">
            creaseEdgeChanged = fCreaseLengthsCache.setTime(time) || creaseEdgeChanged;
           </div>
           <div class="line">
            creaseEdgeChanged = fCreaseSharpnessesCache.setTime(time) || creaseEdgeChanged;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            creaseVertexChanged =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCornerSharpnessesCache.valid()) {
           </div>
           <div class="line">
            creaseVertexChanged = fCornerIndicesCache.setTime(time) || creaseVertexChanged;
           </div>
           <div class="line">
            creaseVertexChanged = fCornerSharpnessesCache.setTime(time) || creaseVertexChanged;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            invisibleFaceChanged =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fHolesCache.valid()) {
           </div>
           <div class="line">
            invisibleFaceChanged = fHolesCache.setTime(time);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            uvChanged =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            uvChanged = fUVsCache.setTime(time);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVIndicesCache.valid()) {
           </div>
           <div class="line">
            uvChanged = fUVIndicesCache.setTime(time) || uvChanged;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // return the new cache valid interval
            </span>
           </div>
           <div class="line">
            validityInterval &amp;= fFaceIndicesCache.getValidityInterval();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCreaseSharpnessesCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fCreaseIndicesCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fCreaseLengthsCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fCreaseSharpnessesCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCornerSharpnessesCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fCornerIndicesCache.getValidityInterval();
           </div>
           <div class="line">
            validityInterval &amp;= fCornerSharpnessesCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fHolesCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fHolesCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fUVsCache.getValidityInterval();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVIndicesCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fUVIndicesCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // do a minimal check for the consistency
            </span>
           </div>
           <div class="line">
            check();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (topologyChanged || creaseEdgeChanged || creaseVertexChanged ||
           </div>
           <div class="line">
            invisibleFaceChanged || fSubDData.object().isNull()) {
           </div>
           <div class="line">
            rebuildSubD();
           </div>
           <div class="line">
            setCreaseEdges();
           </div>
           <div class="line">
            setCreaseVertices();
           </div>
           <div class="line">
            setInvisibleFaces();
           </div>
           <div class="line">
            setUVs();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (positionChanged) {
           </div>
           <div class="line">
            setPositions();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (uvChanged) {
           </div>
           <div class="line">
            setUVs();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (isVisible()) {
           </div>
           <div class="line">
            convertToPoly();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            SubDSmoother::check()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numVerts       = fPositionsCache.getValue()-&gt;size() / 3;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // UVs
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numExpectedUVs = 0;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsScope == Alembic::AbcGeom::kVaryingScope ||
           </div>
           <div class="line">
            fUVsScope == Alembic::AbcGeom::kVertexScope) {
           </div>
           <div class="line">
            numExpectedUVs = numVerts;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (fUVsScope == Alembic::AbcGeom::kFacevaryingScope) {
           </div>
           <div class="line">
            numExpectedUVs = numFaceIndices;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numActualUVs = 0;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVIndicesCache.valid()) {
           </div>
           <div class="line">
            numActualUVs = fUVIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            numActualUVs = fUVsCache.getValue()-&gt;size() / 2;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // clear previous result
            </span>
           </div>
           <div class="line">
            fCheckedUVsScope = Alembic::AbcGeom::kUnknownScope;
           </div>
           <div class="line">
            fCheckedUVs.reset();
           </div>
           <div class="line">
            fCheckedUVIndices.reset();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // forward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numExpectedUVs == numActualUVs) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVsCache.valid()) {
           </div>
           <div class="line">
            fCheckedUVsScope = fUVsScope;
           </div>
           <div class="line">
            fCheckedUVs      = fUVsCache.getValue();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fUVIndicesCache.valid()) {
           </div>
           <div class="line">
            fCheckedUVIndices = fUVIndicesCache.getValue();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            DisplayWarning(kBadUVsMsg);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            SubDSmoother::rebuildSubD()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // input data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceCounts           = fFaceCountsCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * faceCounts = fFaceCountsCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceIndices                   = fFaceIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numPositions    = fPositionsCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * positions = fPositionsCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numVertices = numPositions / 3;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Build Maya data structure
            </span>
           </div>
           <div class="line">
            <a name="_a43">
            </a>
            <a class="code" href="./class_m_int_array.html">
             MIntArray
            </a>
            mayaCounts, mayaConnects;
           </div>
           <div class="line">
            mayaCounts.
            <a name="a44">
            </a>
            <a class="code" href="./class_m_int_array.html#a8c66dfa06f3736b2a214c5aed58bd216">
             setLength
            </a>
            ((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numFaceCounts);
           </div>
           <div class="line">
            mayaConnects.
            <a class="code" href="./class_m_int_array.html#a8c66dfa06f3736b2a214c5aed58bd216">
             setLength
            </a>
            ((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numFaceIndices);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0, polyVertOffset = 0; i &lt; numFaceCounts; i++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            faceCount = mayaCounts[i] = faceCounts[i];
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            j = 0; j &lt; faceCount; j++) {
           </div>
           <div class="line">
            <span class="comment">
             // Alembic's polygon winding is CW
            </span>
           </div>
           <div class="line">
            mayaConnects[polyVertOffset + j] = faceIndices[polyVertOffset + faceCount - j - 1];
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            polyVertOffset += faceCount;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a name="_a45">
            </a>
            <a class="code" href="./class_m_float_point_array.html">
             MFloatPointArray
            </a>
            mayaPositions;
           </div>
           <div class="line">
            mayaPositions.
            <a name="a46">
            </a>
            <a class="code" href="./class_m_float_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">
             setLength
            </a>
            ((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numVertices);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; numVertices; i++) {
           </div>
           <div class="line">
            mayaPositions[i] =
            <a name="_a47">
            </a>
            <a class="code" href="./class_m_float_point.html">
             MFloatPoint
            </a>
            (positions[i * 3 + 0],
           </div>
           <div class="line">
            positions[i * 3 + 1],
           </div>
           <div class="line">
            positions[i * 3 + 2]);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Create Maya mesh
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_status.html">
             MStatus
            </a>
            status;
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            subdData = fSubDData.create(&amp;status);
           </div>
           <div class="line">
            assert(status ==
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            fSubD.setCheckSamePointTwice(
            <span class="keyword">
             false
            </span>
            );
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            subd = fSubD.create((
            <span class="keywordtype">
             int
            </span>
            )numVertices, (
            <span class="keywordtype">
             int
            </span>
            )numFaceCounts,
           </div>
           <div class="line">
            mayaPositions, mayaCounts, mayaConnects, subdData, &amp;status);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (status !=
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            || subd.
            <a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">
             isNull
            </a>
            ()) {
           </div>
           <div class="line">
            fSubDData.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            fSubD.setObject(
            <a class="code" href="./class_m_object.html#ae6af14e0aa2c92bdda88c81280e1d122">
             MObject::kNullObj
            </a>
            );
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            SubDSmoother::setPositions()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fSubDData.object().isNull()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numPositions    = fPositionsCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * positions = fPositionsCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numVertices = numPositions / 3;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Set vertex positions only
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_float_point_array.html">
             MFloatPointArray
            </a>
            mayaPositions;
           </div>
           <div class="line">
            mayaPositions.
            <a class="code" href="./class_m_float_point_array.html#a8c66dfa06f3736b2a214c5aed58bd216">
             setLength
            </a>
            ((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numVertices);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; numVertices; i++) {
           </div>
           <div class="line">
            mayaPositions[i] =
            <a class="code" href="./class_m_float_point.html">
             MFloatPoint
            </a>
            (positions[i * 3 + 0],
           </div>
           <div class="line">
            positions[i * 3 + 1],
           </div>
           <div class="line">
            positions[i * 3 + 2]);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            fSubD.setPoints(mayaPositions);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            SubDSmoother::setCreaseEdges()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fSubDData.object().isNull() ||
           </div>
           <div class="line">
            !fCreaseIndicesCache.valid() ||
           </div>
           <div class="line">
            !fCreaseLengthsCache.valid() ||
           </div>
           <div class="line">
            !fCreaseSharpnessesCache.valid()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numCreaseIndices = fCreaseIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * creaseIndices = fCreaseIndicesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numCreaseLengths = fCreaseLengthsCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * creaseLengths = fCreaseLengthsCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numCreaseSharpnesses = fCreaseSharpnessesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * creaseSharpnesses = fCreaseSharpnessesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numCreaseSharpnesses == 0) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Prepare (startVertex, endVertex) =&gt; (edgeId) lookup map
            </span>
           </div>
           <div class="line">
            <span class="keyword">
             typedef
            </span>
            boost::unordered_map&lt;std::pair&lt;int,int&gt;,
            <span class="keywordtype">
             int
            </span>
            &gt; EdgeMap;
           </div>
           <div class="line">
            EdgeMap edgeMap(
            <span class="keywordtype">
             size_t
            </span>
            (fSubD.numEdges() / 0.75f));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             int
            </span>
            numEdges = fSubD.numEdges();
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; numEdges; i++) {
           </div>
           <div class="line">
            int2 vertexList;
           </div>
           <div class="line">
            fSubD.getEdgeVertices(i, vertexList);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (vertexList[0] &gt; vertexList[1]) {
           </div>
           <div class="line">
            std::swap(vertexList[0], vertexList[1]);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            edgeMap.insert(std::make_pair(std::make_pair(vertexList[0], vertexList[1]), i));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Fill Maya crease edges
            </span>
           </div>
           <div class="line">
            <a name="_a48">
            </a>
            <a class="code" href="./class_m_uint_array.html">
             MUintArray
            </a>
            mayaEdgeIds;
           </div>
           <div class="line">
            <a class="code" href="./class_m_double_array.html">
             MDoubleArray
            </a>
            mayaCreaseData;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0, index = 0; i &lt; numCreaseLengths &amp;&amp; i &lt; numCreaseSharpnesses; i++) {
           </div>
           <div class="line">
            <span class="comment">
             // length should always be 2
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            length    = creaseLengths[i];
           </div>
           <div class="line">
            <span class="keywordtype">
             float
            </span>
            sharpness = creaseSharpnesses[i];
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (length == 2 &amp;&amp; index + length &lt;= numCreaseIndices) {
           </div>
           <div class="line">
            <span class="comment">
             // find the edge ID from vertex ID
            </span>
           </div>
           <div class="line">
            std::pair&lt;int,int&gt; edge = std::make_pair(creaseIndices[index],creaseIndices[index+1]);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (edge.first &gt; edge.second) {
           </div>
           <div class="line">
            std::swap(edge.first, edge.second);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            EdgeMap::iterator iter = edgeMap.find(edge);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (iter != edgeMap.end() &amp;&amp; iter-&gt;second &lt; numEdges) {
           </div>
           <div class="line">
            <span class="comment">
             // edge found, store it crease data
            </span>
           </div>
           <div class="line">
            mayaEdgeIds.
            <a name="a49">
            </a>
            <a class="code" href="./class_m_uint_array.html#a29ccefc020c96f15e099924ebe83eb07">
             append
            </a>
            (iter-&gt;second);
           </div>
           <div class="line">
            mayaCreaseData.
            <a name="a50">
            </a>
            <a class="code" href="./class_m_double_array.html#aafcfe8ff7afecc2dee4defccbdfb8e55">
             append
            </a>
            (sharpness);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            index += length;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Set Maya crease edges
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_status.html">
             MStatus
            </a>
            status;
           </div>
           <div class="line">
            status = fSubD.setCreaseEdges(mayaEdgeIds, mayaCreaseData);
           </div>
           <div class="line">
            assert(status ==
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            );
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            SubDSmoother::setCreaseVertices()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fSubDData.object().isNull() ||
           </div>
           <div class="line">
            !fCornerIndicesCache.valid() ||
           </div>
           <div class="line">
            !fCornerSharpnessesCache.valid()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numCornerIndices = fCornerIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * cornerIndices = fCornerIndicesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numCornerSharpnesses = fCornerSharpnessesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * cornerSharpnesses = fCornerSharpnessesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (cornerSharpnesses == 0) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Fill Maya crease vertices
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_uint_array.html">
             MUintArray
            </a>
            mayaVertexIds;
           </div>
           <div class="line">
            <a class="code" href="./class_m_double_array.html">
             MDoubleArray
            </a>
            mayaCreaseData;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numCreaseVertices = std::min(numCornerIndices, numCornerSharpnesses);
           </div>
           <div class="line">
            mayaVertexIds.
            <a name="a51">
            </a>
            <a class="code" href="./class_m_uint_array.html#a8c66dfa06f3736b2a214c5aed58bd216">
             setLength
            </a>
            ((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numCreaseVertices);
           </div>
           <div class="line">
            mayaCreaseData.
            <a name="a52">
            </a>
            <a class="code" href="./class_m_double_array.html#a8c66dfa06f3736b2a214c5aed58bd216">
             setLength
            </a>
            ((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numCreaseVertices);
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; numCreaseVertices; i++) {
           </div>
           <div class="line">
            mayaVertexIds[i]  = cornerIndices[i];
           </div>
           <div class="line">
            mayaCreaseData[i] = cornerSharpnesses[i];
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Set Maya crease vertices
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_status.html">
             MStatus
            </a>
            status;
           </div>
           <div class="line">
            status = fSubD.setCreaseVertices(mayaVertexIds, mayaCreaseData);
           </div>
           <div class="line">
            assert(status ==
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            );
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            SubDSmoother::setInvisibleFaces()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fSubDData.object().isNull() ||
           </div>
           <div class="line">
            !fHolesCache.valid()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numHoles = fHolesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * holes = fHolesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numHoles == 0) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Fill Maya invisible faces
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_uint_array.html">
             MUintArray
            </a>
            mayaFaceIds(holes, (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numHoles);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Set Maya invisible faces
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_status.html">
             MStatus
            </a>
            status;
           </div>
           <div class="line">
            status = fSubD.setInvisibleFaces(mayaFaceIds);
           </div>
           <div class="line">
            assert(status ==
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            );
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            SubDSmoother::setUVs()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fSubDData.object().isNull()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // unsupported scope
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVsScope != Alembic::AbcGeom::kVaryingScope &amp;&amp;
           </div>
           <div class="line">
            fCheckedUVsScope != Alembic::AbcGeom::kVertexScope &amp;&amp;
           </div>
           <div class="line">
            fCheckedUVsScope != Alembic::AbcGeom::kFacevaryingScope) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // no UVs
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fCheckedUVs) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // input data
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceCounts = fFaceCountsCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            * faceCounts = fFaceCountsCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numFaceIndices = fFaceIndicesCache.getValue()-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* faceIndices = fFaceIndicesCache.getValue()-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numUVs = fCheckedUVs-&gt;size();
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             float
            </span>
            * UVs = fCheckedUVs-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            IndexBuffer::index_t* uvIndices = NULL;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVIndices) {
           </div>
           <div class="line">
            uvIndices    = fCheckedUVIndices-&gt;get();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Clear Maya UVs if the number of UVs does not equal
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // MFnMesh::setUVs() only allow uv arrays equal or larger than current UV set size
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (
            <span class="keywordtype">
             int
            </span>
            (numUVs) != fSubD.numUVs()) {
           </div>
           <div class="line">
            fSubD.clearUVs();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // no UVs, we are done
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numUVs == 0) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Fill Maya UVs
            </span>
           </div>
           <div class="line">
            <a name="_a53">
            </a>
            <a class="code" href="./class_m_float_array.html">
             MFloatArray
            </a>
            mayaUArray((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numUVs);
           </div>
           <div class="line">
            <a class="code" href="./class_m_float_array.html">
             MFloatArray
            </a>
            mayaVArray((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numUVs);
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; numUVs; i++) {
           </div>
           <div class="line">
            mayaUArray[i] = UVs[i * 2 + 0];
           </div>
           <div class="line">
            mayaVArray[i] = UVs[i * 2 + 1];
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Fill Maya UV indices
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_int_array.html">
             MIntArray
            </a>
            mayaUVCounts((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numFaceCounts);
           </div>
           <div class="line">
            <a class="code" href="./class_m_int_array.html">
             MIntArray
            </a>
            mayaUVIds((
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            )numFaceIndices);
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0, polyVertOffset = 0; i &lt; numFaceCounts; i++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            faceCount = mayaUVCounts[i] = faceCounts[i];
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            j = 0; j &lt; faceCount; j++) {
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            uvIndex = 0;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Alembic's polygon winding is CW
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            polyVertIndex = polyVertOffset + faceCount - j - 1;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVsScope == Alembic::AbcGeom::kVaryingScope ||
           </div>
           <div class="line">
            fCheckedUVsScope == Alembic::AbcGeom::kVertexScope) {
           </div>
           <div class="line">
            <span class="comment">
             // per-vertex UV
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            vertIndex = faceIndices[polyVertIndex];
           </div>
           <div class="line">
            uvIndex = uvIndices ? uvIndices[vertIndex] : vertIndex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (fCheckedUVsScope == Alembic::AbcGeom::kFacevaryingScope) {
           </div>
           <div class="line">
            <span class="comment">
             // per-face per-vertex UV
            </span>
           </div>
           <div class="line">
            uvIndex = uvIndices ? uvIndices[polyVertIndex] : polyVertIndex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            assert(0);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            mayaUVIds[polyVertOffset + j] = uvIndex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            polyVertOffset += faceCount;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Set Maya UVs and UV indices
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_status.html">
             MStatus
            </a>
            status;
           </div>
           <div class="line">
            status = fSubD.setUVs(mayaUArray, mayaVArray);
           </div>
           <div class="line">
            assert(status ==
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            );
           </div>
           <div class="line">
            status = fSubD.assignUVs(mayaUVCounts, mayaUVIds);
           </div>
           <div class="line">
            assert(status ==
            <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">
             MS::kSuccess
            </a>
            );
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            SubDSmoother::convertToPoly()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fSubDData.object().isNull() ||
           </div>
           <div class="line">
            fSubD.numVertices() == 0 || fSubD.numFaceVertices() == 0) {
           </div>
           <div class="line">
            fTriangleIndices.reset();
           </div>
           <div class="line">
            fWireIndices.reset();
           </div>
           <div class="line">
            fPositions.reset();
           </div>
           <div class="line">
            fNormals.reset();
           </div>
           <div class="line">
            fUVs.reset();
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Smooth the subdivision mesh
            </span>
           </div>
           <div class="line">
            <a name="_a54">
            </a>
            <a class="code" href="./class_m_fn_mesh_data.html">
             MFnMeshData
            </a>
            smoothMeshData;
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            smoothMeshDataObj = smoothMeshData.
            <a name="a55">
            </a>
            <a class="code" href="./class_m_fn_mesh_data.html#af1adb4abaf5243c6c0749bcca7b5c418">
             create
            </a>
            ();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a name="_a56">
            </a>
            <a class="code" href="./class_m_mesh_smooth_options.html">
             MMeshSmoothOptions
            </a>
            smoothOptions;
           </div>
           <div class="line">
            smoothOptions.
            <a name="a57">
            </a>
            <a class="code" href="./class_m_mesh_smooth_options.html#ae83b35db107d4c6252c7bd7f36b5a723">
             setDivisions
            </a>
            (2);
           </div>
           <div class="line">
            <a class="code" href="./class_m_object.html">
             MObject
            </a>
            smoothMeshObj = fSubD.generateSmoothMesh(smoothMeshDataObj, &amp;smoothOptions);
           </div>
           <div class="line">
           </div>
           <div class="line">
            MayaMeshExtractor&lt;IndexBuffer::index_t&gt; extractor(smoothMeshDataObj);
           </div>
           <div class="line">
            extractor.setWantUVs(fNeedUVs);
           </div>
           <div class="line">
            extractor.compute();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fTriangleIndices = extractor.triangleIndices();
           </div>
           <div class="line">
            fWireIndices     = extractor.wireIndices();
           </div>
           <div class="line">
            fPositions       = extractor.positions();
           </div>
           <div class="line">
            fNormals         = extractor.normals();
           </div>
           <div class="line">
            fUVs.reset();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNeedUVs) {
           </div>
           <div class="line">
            fUVs         = extractor.uvs();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS AlembicCacheObjectReader
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheObjectReader::Ptr
           </div>
           <div class="line">
            AlembicCacheObjectReader::create(Alembic::Abc::IObject&amp; abcObj,
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            CheckInterruptAndPause(
            <span class="stringliteral">
             "reader initialization"
            </span>
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The object type can be mesh or nurbs.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (Alembic::AbcGeom::IPolyMesh::matches(abcObj.getHeader()) ||
           </div>
           <div class="line">
            Alembic::AbcGeom::INuPatch::matches(abcObj.getHeader()) ||
           </div>
           <div class="line">
            Alembic::AbcGeom::ISubD::matches(abcObj.getHeader())) {
           </div>
           <div class="line">
            Ptr reader = boost::make_shared&lt;AlembicCacheMeshReader&gt;(abcObj, needUVs);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            reader-&gt;valid() ? reader : Ptr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // or an xform...
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (Alembic::AbcGeom::IXform::matches(abcObj.getHeader())) {
           </div>
           <div class="line">
            Ptr reader = boost::make_shared&lt;AlembicCacheXformReader&gt;(abcObj, needUVs);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            reader-&gt;valid() ? reader : Ptr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            Ptr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheObjectReader::~AlembicCacheObjectReader()
           </div>
           <div class="line">
            {}
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS AlembicCacheTopReader
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheTopReader::AlembicCacheTopReader(
           </div>
           <div class="line">
            Alembic::Abc::IObject abcObj,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             bool
            </span>
            needUVs
           </div>
           <div class="line">
            )
           </div>
           <div class="line">
            : fBoundingBoxValidityInterval(TimeInterval::kInvalid)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            fXformData = XformData::create();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numChildren = abcObj.getNumChildren();
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            ii=0; ii&lt;numChildren; ++ii)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            Alembic::Abc::IObject child(abcObj, abcObj.getChildHeader(ii).getName());
           </div>
           <div class="line">
            Ptr childReader = create(child, needUVs);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (childReader)
           </div>
           <div class="line">
            fChildren.push_back(childReader);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Compute the exact animation time range
            </span>
           </div>
           <div class="line">
            TimeInterval animTimeRange(TimeInterval::kInvalid);
           </div>
           <div class="line">
            BOOST_FOREACH(
            <span class="keyword">
             const
            </span>
            AlembicCacheObjectReader::Ptr&amp; childReader, fChildren) {
           </div>
           <div class="line">
            animTimeRange |= childReader-&gt;getAnimTimeRange();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            fXformData-&gt;setAnimTimeRange(animTimeRange);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheTopReader::~AlembicCacheTopReader()
           </div>
           <div class="line">
            {}
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            AlembicCacheTopReader::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheTopReader::sampleHierarchy(
            <span class="keywordtype">
             double
            </span>
            seconds,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <a name="_a58">
            </a>
            <a class="code" href="./class_m_matrix.html">
             MMatrix
            </a>
            &amp; rootMatrix, TimeInterval rootMatrixInterval)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            TimeInterval validityInterval(TimeInterval::kInfinite);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a name="_a59">
            </a>
            <a class="code" href="./class_m_bounding_box.html">
             MBoundingBox
            </a>
            bbox;
           </div>
           <div class="line">
            TimeInterval bboxValIntrvl(TimeInterval::kInfinite);
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH(
            <span class="keyword">
             const
            </span>
            AlembicCacheObjectReader::Ptr&amp; childReader, fChildren) {
           </div>
           <div class="line">
            validityInterval &amp;= childReader-&gt;sampleHierarchy(seconds,
           </div>
           <div class="line">
            rootMatrix, rootMatrixInterval);
           </div>
           <div class="line">
           </div>
           <div class="line">
            bbox.
            <a name="a60">
            </a>
            <a class="code" href="./class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">
             expand
            </a>
            (childReader-&gt;getBoundingBox());
           </div>
           <div class="line">
            bboxValIntrvl &amp;= childReader-&gt;getBoundingBoxValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The computed validity interval must contain the current time.
            </span>
           </div>
           <div class="line">
            assert(validityInterval.contains(seconds));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The current and previous bounding box intervals are either
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // disjoint or equal.
            </span>
           </div>
           <div class="line">
            assert(!(fBoundingBoxValidityInterval &amp; bboxValIntrvl).valid() ||
           </div>
           <div class="line">
            fBoundingBoxValidityInterval == bboxValIntrvl);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (seconds == bboxValIntrvl.startTime()) {
           </div>
           <div class="line">
            fBoundingBox                 = bbox;
           </div>
           <div class="line">
            fBoundingBoxValidityInterval = bboxValIntrvl;
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;GPUCache::XformSample&gt; sample =
           </div>
           <div class="line">
            GPUCache::XformSample::create(
           </div>
           <div class="line">
            seconds,
           </div>
           <div class="line">
            <a name="a61">
            </a>
            <a class="code" href="./class_m_matrix.html#a85de986c9f953535d185c6780cecb77e">
             MMatrix::identity
            </a>
            ,
           </div>
           <div class="line">
            fBoundingBox,
           </div>
           <div class="line">
            <span class="keyword">
             true
            </span>
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
            fXformData-&gt;addSample(sample);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheTopReader::sampleShape(
            <span class="keywordtype">
             double
            </span>
            seconds)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Top reader has no shape data!
            </span>
           </div>
           <div class="line">
            assert(0);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            TimeInterval(TimeInterval::kInvalid);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            SubNode::MPtr AlembicCacheTopReader::get()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            SubNode::MPtr node =
           </div>
           <div class="line">
            SubNode::create(
            <a name="_a62">
            </a>
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            (
            <span class="stringliteral">
             "|"
            </span>
            ), fXformData);
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH(
            <span class="keyword">
             const
            </span>
            AlembicCacheObjectReader::Ptr&amp; childReader, fChildren) {
           </div>
           <div class="line">
            SubNode::MPtr child = childReader-&gt;get();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (child)
           </div>
           <div class="line">
            SubNode::connect(node, child);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (node-&gt;getChildren().empty()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            SubNode::MPtr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            node;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_bounding_box.html">
             MBoundingBox
            </a>
            AlembicCacheTopReader::getBoundingBox()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fBoundingBox;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheTopReader::getBoundingBoxValidityInterval()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fBoundingBoxValidityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheTopReader::getAnimTimeRange()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fXformData-&gt;animTimeRange();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            AlembicCacheTopReader::saveAndReset(AlembicCacheReader&amp; cacheReader)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // We don't save xform readers. Just call children's saveAndReset().
            </span>
           </div>
           <div class="line">
            BOOST_FOREACH (
            <span class="keyword">
             const
            </span>
            AlembicCacheObjectReader::Ptr&amp; childReader, fChildren) {
           </div>
           <div class="line">
            childReader-&gt;saveAndReset(cacheReader);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS AlembicCacheXformReader
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheXformReader::AlembicCacheXformReader(
           </div>
           <div class="line">
            Alembic::Abc::IObject abcObj,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             bool
            </span>
            needUVs
           </div>
           <div class="line">
            )
           </div>
           <div class="line">
            : fName(abcObj.getName()),
           </div>
           <div class="line">
            fValidityInterval(TimeInterval::kInvalid),
           </div>
           <div class="line">
            fBoundingBoxValidityInterval(TimeInterval::kInvalid)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            Alembic::AbcGeom::IXform xform(abcObj, Alembic::Abc::kWrapExisting);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Xform schema
            </span>
           </div>
           <div class="line">
            Alembic::AbcGeom::IXformSchema schema = xform.getSchema();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // transform
            </span>
           </div>
           <div class="line">
            fXformCache.init(schema);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // transform visibility
            </span>
           </div>
           <div class="line">
            Alembic::AbcGeom::IVisibilityProperty visibility =
           </div>
           <div class="line">
            Alembic::AbcGeom::GetVisibilityProperty(abcObj);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (visibility) {
           </div>
           <div class="line">
            fVisibilityCache.init(visibility);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            fXformData = XformData::create();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             size_t
            </span>
            numChildren = abcObj.getNumChildren();
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            ii=0; ii&lt;numChildren; ++ii)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            Alembic::Abc::IObject child(abcObj, abcObj.getChildHeader(ii).getName());
           </div>
           <div class="line">
            Ptr childReader = create(child, needUVs);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (childReader)
           </div>
           <div class="line">
            fChildren.push_back(childReader);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Compute the exact animation time range
            </span>
           </div>
           <div class="line">
            Alembic::Abc::TimeSamplingPtr timeSampling = schema.getTimeSampling();
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numSamples = schema.getNumSamples();
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval animTimeRange(
           </div>
           <div class="line">
            timeSampling-&gt;getSampleTime(0),
           </div>
           <div class="line">
            timeSampling-&gt;getSampleTime(numSamples &gt; 0 ? numSamples-1 : 0) );
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH(
            <span class="keyword">
             const
            </span>
            AlembicCacheObjectReader::Ptr&amp; childReader, fChildren) {
           </div>
           <div class="line">
            animTimeRange |= childReader-&gt;getAnimTimeRange();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            fXformData-&gt;setAnimTimeRange(animTimeRange);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheXformReader::~AlembicCacheXformReader()
           </div>
           <div class="line">
            {}
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            AlembicCacheXformReader::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fXformCache.valid();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheXformReader::sampleHierarchy(
            <span class="keywordtype">
             double
            </span>
            seconds,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <a class="code" href="./class_m_matrix.html">
             MMatrix
            </a>
            &amp; rootMatrix, TimeInterval rootMatrixInterval)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Fill the sample if this sample has not been read
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fValidityInterval.contains(seconds)) {
           </div>
           <div class="line">
            fillTopoAndAttrSample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Inherit transformation
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_matrix.html">
             MMatrix
            </a>
            newRootMatrix = fXformCache.getValue() * rootMatrix;
           </div>
           <div class="line">
            TimeInterval newRootMatrixInterval =
           </div>
           <div class="line">
            fXformCache.getValidityInterval() &amp; rootMatrixInterval;
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval validityInterval = fValidityInterval;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_bounding_box.html">
             MBoundingBox
            </a>
            bbox;
           </div>
           <div class="line">
            TimeInterval bboxValIntrvl(TimeInterval::kInfinite);
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH(
            <span class="keyword">
             const
            </span>
            AlembicCacheObjectReader::Ptr&amp; childReader, fChildren) {
           </div>
           <div class="line">
            validityInterval &amp;= childReader-&gt;sampleHierarchy(seconds,
           </div>
           <div class="line">
            newRootMatrix, newRootMatrixInterval);
           </div>
           <div class="line">
           </div>
           <div class="line">
            bbox.
            <a class="code" href="./class_m_bounding_box.html#aee704d46278fb5925a7bd814a5773ccd">
             expand
            </a>
            (childReader-&gt;getBoundingBox());
           </div>
           <div class="line">
            bboxValIntrvl &amp;= childReader-&gt;getBoundingBoxValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The computed validity interval must contain the current time.
            </span>
           </div>
           <div class="line">
            assert(validityInterval.contains(seconds));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The current and previous bounding box intervals are either
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // disjoint or equal.
            </span>
           </div>
           <div class="line">
            assert(!(fBoundingBoxValidityInterval &amp; bboxValIntrvl).valid() ||
           </div>
           <div class="line">
            fBoundingBoxValidityInterval == bboxValIntrvl);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (seconds == (fValidityInterval &amp; bboxValIntrvl).startTime()) {
           </div>
           <div class="line">
            fBoundingBox                 = bbox;
           </div>
           <div class="line">
            fBoundingBoxValidityInterval = bboxValIntrvl;
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;GPUCache::XformSample&gt; sample =
           </div>
           <div class="line">
            GPUCache::XformSample::create(
           </div>
           <div class="line">
            seconds,
           </div>
           <div class="line">
            fXformCache.getValue(),
           </div>
           <div class="line">
            fBoundingBox,
           </div>
           <div class="line">
            isVisible()
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
            fXformData-&gt;addSample(sample);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheXformReader::sampleShape(
            <span class="keywordtype">
             double
            </span>
            seconds)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Transform reader has no shape data!
            </span>
           </div>
           <div class="line">
            assert(0);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            TimeInterval(TimeInterval::kInvalid);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            SubNode::MPtr AlembicCacheXformReader::get()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            SubNode::MPtr node =
           </div>
           <div class="line">
            SubNode::create(
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            (fName.c_str()), fXformData);
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH(
            <span class="keyword">
             const
            </span>
            AlembicCacheObjectReader::Ptr&amp; childReader, fChildren) {
           </div>
           <div class="line">
            SubNode::MPtr child = childReader-&gt;get();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (child)
           </div>
           <div class="line">
            SubNode::connect(node, child);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (node-&gt;getChildren().empty()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            SubNode::MPtr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            node;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            AlembicCacheXformReader::fillTopoAndAttrSample(chrono_t time)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Notes:
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // When possible, we try to reuse the samples from the previously
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // read sample.
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // update caches
            </span>
           </div>
           <div class="line">
            fXformCache.setTime(time);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fVisibilityCache.valid()) {
           </div>
           <div class="line">
            fVisibilityCache.setTime(time);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // return the new cache valid interval
            </span>
           </div>
           <div class="line">
            TimeInterval validityInterval(TimeInterval::kInfinite);
           </div>
           <div class="line">
            validityInterval &amp;= fXformCache.getValidityInterval();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fVisibilityCache.valid()) {
           </div>
           <div class="line">
            validityInterval &amp;= fVisibilityCache.getValidityInterval();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            assert(validityInterval.valid());
           </div>
           <div class="line">
           </div>
           <div class="line">
            fValidityInterval = validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            AlembicCacheXformReader::isVisible()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="comment">
             // xform invisible
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fVisibilityCache.valid() &amp;&amp;
           </div>
           <div class="line">
            fVisibilityCache.getValue() == char(Alembic::AbcGeom::kVisibilityHidden)) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // visible
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_bounding_box.html">
             MBoundingBox
            </a>
            AlembicCacheXformReader::getBoundingBox()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fBoundingBox;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheXformReader::getBoundingBoxValidityInterval()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fBoundingBoxValidityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheXformReader::getAnimTimeRange()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fXformData-&gt;animTimeRange();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            AlembicCacheXformReader::saveAndReset(AlembicCacheReader&amp; cacheReader)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // We don't save xform readers. Just call children's saveAndReset().
            </span>
           </div>
           <div class="line">
            BOOST_FOREACH (
            <span class="keyword">
             const
            </span>
            AlembicCacheObjectReader::Ptr&amp; childReader, fChildren) {
           </div>
           <div class="line">
            childReader-&gt;saveAndReset(cacheReader);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS AlembicCacheMeshReader
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheMeshReader::AlembicCacheMeshReader(
           </div>
           <div class="line">
            Alembic::Abc::IObject
            <span class="keywordtype">
             object
            </span>
            ,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <span class="keywordtype">
             bool
            </span>
            needUVs
           </div>
           <div class="line">
            )
           </div>
           <div class="line">
            : fName(
            <span class="keywordtype">
             object
            </span>
            .getName()),
           </div>
           <div class="line">
            fFullName(
            <span class="keywordtype">
             object
            </span>
            .getFullName()),
           </div>
           <div class="line">
            fBoundingBoxValidityInterval(TimeInterval::kInvalid),
           </div>
           <div class="line">
            fNumTransparentSample(0)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Shape schema
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (Alembic::AbcGeom::IPolyMesh::matches(
            <span class="keywordtype">
             object
            </span>
            .getHeader())) {
           </div>
           <div class="line">
            Alembic::AbcGeom::IPolyMesh       meshObj(
            <span class="keywordtype">
             object
            </span>
            , Alembic::Abc::kWrapExisting);
           </div>
           <div class="line">
            Alembic::AbcGeom::IPolyMeshSchema schema = meshObj.getSchema();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // check the existence of wireframe index property
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // if the mesh is written by gpuCache command, the wireframe index property must exist
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (schema.getPropertyHeader(kCustomPropertyWireIndices) != NULL ||
           </div>
           <div class="line">
            schema.getPropertyHeader(kCustomPropertyWireIndicesOld) != NULL) {
           </div>
           <div class="line">
            fDataProvider.reset(
            <span class="keyword">
             new
            </span>
            RawDataProvider(schema, needUVs));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            fDataProvider.reset(
            <span class="keyword">
             new
            </span>
            Triangulator(schema, needUVs));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (Alembic::AbcGeom::INuPatch::matches(
            <span class="keywordtype">
             object
            </span>
            .getHeader())) {
           </div>
           <div class="line">
            Alembic::AbcGeom::INuPatch       nurbsObj(
            <span class="keywordtype">
             object
            </span>
            , Alembic::Abc::kWrapExisting);
           </div>
           <div class="line">
            Alembic::AbcGeom::INuPatchSchema schema = nurbsObj.getSchema();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fDataProvider.reset(
            <span class="keyword">
             new
            </span>
            NurbsTessellator(schema, needUVs));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (Alembic::AbcGeom::ISubD::matches(
            <span class="keywordtype">
             object
            </span>
            .getHeader())) {
           </div>
           <div class="line">
            Alembic::AbcGeom::ISubD       subdObj(
            <span class="keywordtype">
             object
            </span>
            , Alembic::Abc::kWrapExisting);
           </div>
           <div class="line">
            Alembic::AbcGeom::ISubDSchema schema = subdObj.getSchema();
           </div>
           <div class="line">
           </div>
           <div class="line">
            fDataProvider.reset(
            <span class="keyword">
             new
            </span>
            SubDSmoother(schema, needUVs));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            DisplayWarning(kUnsupportedGeomMsg);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            fShapeData = ShapeData::create();
           </div>
           <div class="line">
            fShapeData-&gt;setAnimTimeRange(fDataProvider-&gt;getAnimTimeRange());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Whole object material assignment
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            material;
           </div>
           <div class="line">
           </div>
           <div class="line">
            std::string materialAssignmentPath;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (Alembic::AbcMaterial::getMaterialAssignmentPath(
           </div>
           <div class="line">
            <span class="keywordtype">
             object
            </span>
            , materialAssignmentPath)) {
           </div>
           <div class="line">
            <span class="comment">
             // We assume all materials are stored in "/materials"
            </span>
           </div>
           <div class="line">
            std::string prefix =
            <span class="stringliteral">
             "/"
            </span>
            ;
           </div>
           <div class="line">
            prefix += kMaterialsObject;
           </div>
           <div class="line">
            prefix +=
            <span class="stringliteral">
             "/"
            </span>
            ;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (std::equal(prefix.begin(), prefix.end(), materialAssignmentPath.begin())) {
           </div>
           <div class="line">
            std::string objectName = materialAssignmentPath.substr(prefix.size()).c_str();
           </div>
           <div class="line">
            <span class="comment">
             // No material inheritance here.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (objectName.find(
            <span class="stringliteral">
             "/"
            </span>
            ) == std::string::npos) {
           </div>
           <div class="line">
            material = objectName.c_str();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (material.
            <a name="a63">
            </a>
            <a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">
             length
            </a>
            () &gt; 0) {
           </div>
           <div class="line">
            fShapeData-&gt;setMaterial(material);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheMeshReader::~AlembicCacheMeshReader()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            fDataProvider.reset();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            AlembicCacheMeshReader::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fDataProvider &amp;&amp; fDataProvider-&gt;valid();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheMeshReader::sampleHierarchy(
            <span class="keywordtype">
             double
            </span>
            seconds,
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <a class="code" href="./class_m_matrix.html">
             MMatrix
            </a>
            &amp; rootMatrix, TimeInterval rootMatrixInterval)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            CheckInterruptAndPause(
            <span class="stringliteral">
             "sampling hierarchy"
            </span>
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Fill the sample if this sample has not been read
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fDataProvider-&gt;getBBoxAndVisValidityInterval().contains(seconds)) {
           </div>
           <div class="line">
            <span class="comment">
             // Read minimal data to construct the hierarchy
            </span>
           </div>
           <div class="line">
            fDataProvider-&gt;fillBBoxAndVisSample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval validityInterval = fDataProvider-&gt;getBBoxAndVisValidityInterval();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Compute bounding box in root sub-node axis
            </span>
           </div>
           <div class="line">
            fBoundingBox = fDataProvider-&gt;getBoundingBox();
           </div>
           <div class="line">
            fBoundingBox.transformUsing(rootMatrix);
           </div>
           <div class="line">
            fBoundingBoxValidityInterval = rootMatrixInterval &amp;
           </div>
           <div class="line">
            fDataProvider-&gt;getBoundingBoxValidityInterval();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // We only add the sample if it is the first sample of the
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // interval.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (seconds == validityInterval.startTime()) {
           </div>
           <div class="line">
            boost::shared_ptr&lt;const ShapeSample&gt; sample =
           </div>
           <div class="line">
            fDataProvider-&gt;getBBoxPlaceHolderSample(seconds);
           </div>
           <div class="line">
            fShapeData-&gt;addSample(sample);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheMeshReader::sampleShape(
            <span class="keywordtype">
             double
            </span>
            seconds)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            CheckInterruptAndPause(
            <span class="stringliteral">
             "sampling shape"
            </span>
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Fill the sample if this sample has not been read
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fDataProvider-&gt;getValidityInterval().contains(seconds)) {
           </div>
           <div class="line">
            fDataProvider-&gt;fillTopoAndAttrSample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval validityInterval = fDataProvider-&gt;getValidityInterval();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // We only add the sample if it is the first sample of the
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // interval.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (seconds == validityInterval.startTime()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fDataProvider-&gt;isVisible()) {
           </div>
           <div class="line">
            boost::shared_ptr&lt;const ShapeSample&gt; sample =
           </div>
           <div class="line">
            fDataProvider-&gt;getSample(seconds);
           </div>
           <div class="line">
            fShapeData-&gt;addSample(sample);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             float
            </span>
            alpha = sample-&gt;diffuseColor()[3];
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (alpha &gt; 0.0f &amp;&amp; alpha &lt; 1.0f) {
           </div>
           <div class="line">
            fNumTransparentSample++;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            <span class="comment">
             // hidden geometry, simply append an empty sample
            </span>
           </div>
           <div class="line">
            boost::shared_ptr&lt;ShapeSample&gt; sample =
           </div>
           <div class="line">
            ShapeSample::createEmptySample(seconds);
           </div>
           <div class="line">
            fShapeData-&gt;addSample(sample);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            SubNode::MPtr AlembicCacheMeshReader::get()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fShapeData-&gt;getSamples().size() == 1 &amp;&amp;
           </div>
           <div class="line">
            !fShapeData-&gt;getSamples().begin()-&gt;second-&gt;visibility()) {
           </div>
           <div class="line">
            <span class="comment">
             // Prune the node entirely if it is hidden.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            SubNode::MPtr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            SubNode::MPtr subNode = SubNode::create(
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            (fName.c_str()), fShapeData);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (fNumTransparentSample == 0) {
           </div>
           <div class="line">
            subNode-&gt;setTransparentType(SubNode::kOpaque);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (fNumTransparentSample == fShapeData-&gt;getSamples().size()) {
           </div>
           <div class="line">
            subNode-&gt;setTransparentType(SubNode::kTransparent);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            subNode-&gt;setTransparentType(SubNode::kOpaqueAndTransparent);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            subNode;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <a class="code" href="./class_m_bounding_box.html">
             MBoundingBox
            </a>
            AlembicCacheMeshReader::getBoundingBox()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fBoundingBox;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheMeshReader::getBoundingBoxValidityInterval()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fBoundingBoxValidityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheMeshReader::getAnimTimeRange()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fShapeData-&gt;animTimeRange();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            AlembicCacheMeshReader::saveAndReset(AlembicCacheReader&amp; cacheReader)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Clear the content of this reader for reuse.
            </span>
           </div>
           <div class="line">
            fBoundingBox.
            <a name="a64">
            </a>
            <a class="code" href="./class_m_bounding_box.html#ac8bb3912a3ce86b15842e79d0b421204">
             clear
            </a>
            ();
           </div>
           <div class="line">
            fBoundingBoxValidityInterval = TimeInterval(TimeInterval::kInvalid);
           </div>
           <div class="line">
            fNumTransparentSample = 0;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Create a new shape data.
            </span>
           </div>
           <div class="line">
            ShapeData::MPtr newShapeData = ShapeData::create();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Animation time range and material assignment won't change so just copy them.
            </span>
           </div>
           <div class="line">
            newShapeData-&gt;setAnimTimeRange(fShapeData-&gt;animTimeRange());
           </div>
           <div class="line">
            newShapeData-&gt;setMaterials(fShapeData-&gt;getMaterials());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Release the reference to the old shape data to avoid instability.
            </span>
           </div>
           <div class="line">
            fShapeData = newShapeData;
           </div>
           <div class="line">
           </div>
           <div class="line">
            Ptr thisPtr = shared_from_this();
           </div>
           <div class="line">
            cacheReader.saveReader(fFullName, thisPtr);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS AlembicCacheMaterialReader
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheMaterialReader::AlembicCacheMaterialReader(Alembic::Abc::IObject abcObj)
           </div>
           <div class="line">
            : fName(abcObj.getName()),
           </div>
           <div class="line">
            fValidityInterval(TimeInterval::kInvalid)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Wrap with IMaterial
            </span>
           </div>
           <div class="line">
            Alembic::AbcMaterial::IMaterial material(abcObj, Alembic::Abc::kWrapExisting);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Material schema
            </span>
           </div>
           <div class="line">
            Alembic::AbcMaterial::IMaterialSchema schema = material.getSchema();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Create the material graph
            </span>
           </div>
           <div class="line">
            fMaterialGraph = boost::make_shared&lt;MaterialGraph&gt;(
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            (fName.c_str()));
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The number of nodes in the material
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numNetworkNodes = schema.getNumNetworkNodes();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Map: name -&gt; (IMaterialSchema::NetworkNode,MaterialNode)
            </span>
           </div>
           <div class="line">
            <span class="keyword">
             typedef
            </span>
            std::pair&lt;Alembic::AbcMaterial::IMaterialSchema::NetworkNode,MaterialNode::MPtr&gt; NodePair;
           </div>
           <div class="line">
            <span class="keyword">
             typedef
            </span>
            boost::unordered_map&lt;std::string,NodePair&gt; NodeMap;
           </div>
           <div class="line">
            NodeMap nodeMap;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Read nodes
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0; i &lt; numNetworkNodes; i++) {
           </div>
           <div class="line">
            Alembic::AbcMaterial::IMaterialSchema::NetworkNode abcNode = schema.getNetworkNode(i);
           </div>
           <div class="line">
           </div>
           <div class="line">
            std::string target;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!abcNode.valid() || !abcNode.getTarget(target) || target != kMaterialsGpuCacheTarget) {
           </div>
           <div class="line">
            <span class="keywordflow">
             continue
            </span>
            ;
            <span class="comment">
             // Invalid node
            </span>
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            std::string type;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!abcNode.getNodeType(type) || type.empty()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             continue
            </span>
            ;
            <span class="comment">
             // Invalid type
            </span>
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Node name
            </span>
           </div>
           <div class="line">
            std::string name = abcNode.getName();
           </div>
           <div class="line">
            assert(!name.empty());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Create material node
            </span>
           </div>
           <div class="line">
            MaterialNode::MPtr node = MaterialNode::create(name.c_str(), type.c_str());
           </div>
           <div class="line">
            assert(node);
           </div>
           <div class="line">
           </div>
           <div class="line">
            fMaterialGraph-&gt;addNode(node);
           </div>
           <div class="line">
            nodeMap.insert(std::make_pair(name, std::make_pair(abcNode, node)));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Initialize property caches.
            </span>
           </div>
           <div class="line">
            BOOST_FOREACH (NodeMap::value_type&amp; val, nodeMap) {
           </div>
           <div class="line">
            Alembic::AbcMaterial::IMaterialSchema::NetworkNode&amp; abcNode = val.second.first;
           </div>
           <div class="line">
            MaterialNode::MPtr&amp; node = val.second.second;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Loop over all child properties
            </span>
           </div>
           <div class="line">
            Alembic::Abc::ICompoundProperty compoundProp = abcNode.getParameters();
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numProps = compoundProp.getNumProperties();
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0; i &lt; numProps; i++) {
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            Alembic::Abc::PropertyHeader&amp; header = compoundProp.getPropertyHeader(i);
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            std::string propName = header.getName();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (Alembic::Abc::IBoolProperty::matches(header)) {
           </div>
           <div class="line">
            fBoolCaches.push_back(
           </div>
           <div class="line">
            ScalarMaterialProp&lt;Alembic::Abc::IBoolProperty&gt;(compoundProp, propName, node));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (Alembic::Abc::IInt32Property::matches(header)) {
           </div>
           <div class="line">
            fInt32Caches.push_back(
           </div>
           <div class="line">
            ScalarMaterialProp&lt;Alembic::Abc::IInt32Property&gt;(compoundProp, propName, node));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (Alembic::Abc::IFloatProperty::matches(header)) {
           </div>
           <div class="line">
            fFloatCaches.push_back(
           </div>
           <div class="line">
            ScalarMaterialProp&lt;Alembic::Abc::IFloatProperty&gt;(compoundProp, propName, node));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (Alembic::Abc::IV2fProperty::matches(header)) {
           </div>
           <div class="line">
            fFloat2Caches.push_back(
           </div>
           <div class="line">
            ScalarMaterialProp&lt;Alembic::Abc::IV2fProperty&gt;(compoundProp, propName, node));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (Alembic::Abc::IV3fProperty::matches(header)) {
           </div>
           <div class="line">
            fFloat3Caches.push_back(
           </div>
           <div class="line">
            ScalarMaterialProp&lt;Alembic::Abc::IV3fProperty&gt;(compoundProp, propName, node));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (Alembic::Abc::IC3fProperty::matches(header)) {
           </div>
           <div class="line">
            fRGBCaches.push_back(
           </div>
           <div class="line">
            ScalarMaterialProp&lt;Alembic::Abc::IC3fProperty&gt;(compoundProp, propName, node));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (Alembic::Abc::IWstringProperty::matches(header)) {
           </div>
           <div class="line">
            fStringCaches.push_back(
           </div>
           <div class="line">
            ScalarMaterialProp&lt;Alembic::Abc::IWstringProperty&gt;(compoundProp, propName, node));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Read connections
            </span>
           </div>
           <div class="line">
            BOOST_FOREACH (NodeMap::value_type&amp; val, nodeMap) {
           </div>
           <div class="line">
            Alembic::AbcMaterial::IMaterialSchema::NetworkNode&amp; abcNode = val.second.first;
           </div>
           <div class="line">
            MaterialNode::MPtr&amp; node = val.second.second;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Loop over the connections and connect properties
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numConnections = abcNode.getNumConnections();
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0; i &lt; numConnections; i++) {
           </div>
           <div class="line">
            std::string inputName, connectedNodeName, connectedOutputName;
           </div>
           <div class="line">
            abcNode.getConnection(i, inputName, connectedNodeName, connectedOutputName);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Find destination property
            </span>
           </div>
           <div class="line">
            MaterialProperty::MPtr prop = node-&gt;findProperty(inputName.c_str());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Find source node
            </span>
           </div>
           <div class="line">
            MaterialNode::MPtr srcNode;
           </div>
           <div class="line">
            NodeMap::iterator it = nodeMap.find(connectedNodeName);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (it != nodeMap.end()) {
           </div>
           <div class="line">
            srcNode = (*it).second.second;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Find source property
            </span>
           </div>
           <div class="line">
            MaterialProperty::MPtr srcProp;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (srcNode) {
           </div>
           <div class="line">
            srcProp = srcNode-&gt;findProperty(connectedOutputName.c_str());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Make the connection
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (prop &amp;&amp; srcNode &amp;&amp; srcProp) {
           </div>
           <div class="line">
            prop-&gt;connect(srcNode, srcProp);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Read Terminal node (ignore output)
            </span>
           </div>
           <div class="line">
            std::string rootNodeName, rootOutput;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (schema.getNetworkTerminal(kMaterialsGpuCacheTarget, kMaterialsGpuCacheType, rootNodeName, rootOutput)) {
           </div>
           <div class="line">
            NodeMap::iterator it = nodeMap.find(rootNodeName);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (it != nodeMap.end()) {
           </div>
           <div class="line">
            fMaterialGraph-&gt;setRootNode((*it).second.second);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheMaterialReader::~AlembicCacheMaterialReader()
           </div>
           <div class="line">
            {}
           </div>
           <div class="line">
           </div>
           <div class="line">
            TimeInterval AlembicCacheMaterialReader::sampleMaterial(
            <span class="keywordtype">
             double
            </span>
            seconds)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            TimeInterval validityInterval(TimeInterval::kInfinite);
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH (ScalarMaterialProp&lt;Alembic::Abc::IBoolProperty&gt;&amp; cache, fBoolCaches) {
           </div>
           <div class="line">
            validityInterval &amp;= cache.sample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH (ScalarMaterialProp&lt;Alembic::Abc::IInt32Property&gt;&amp; cache, fInt32Caches) {
           </div>
           <div class="line">
            validityInterval &amp;= cache.sample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH (ScalarMaterialProp&lt;Alembic::Abc::IFloatProperty&gt;&amp; cache, fFloatCaches) {
           </div>
           <div class="line">
            validityInterval &amp;= cache.sample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH (ScalarMaterialProp&lt;Alembic::Abc::IV2fProperty&gt;&amp; cache, fFloat2Caches) {
           </div>
           <div class="line">
            validityInterval &amp;= cache.sample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH (ScalarMaterialProp&lt;Alembic::Abc::IV3fProperty&gt;&amp; cache, fFloat3Caches) {
           </div>
           <div class="line">
            validityInterval &amp;= cache.sample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH (ScalarMaterialProp&lt;Alembic::Abc::IC3fProperty&gt;&amp; cache, fRGBCaches) {
           </div>
           <div class="line">
            validityInterval &amp;= cache.sample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            BOOST_FOREACH (ScalarMaterialProp&lt;Alembic::Abc::IWstringProperty&gt;&amp; cache, fStringCaches) {
           </div>
           <div class="line">
            validityInterval &amp;= cache.sample(seconds);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            validityInterval;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            MaterialGraph::MPtr AlembicCacheMaterialReader::get()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="comment">
             // Check invalid graph.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fMaterialGraph || !fMaterialGraph-&gt;rootNode() || fMaterialGraph-&gt;getNodes().empty()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            MaterialGraph::MPtr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fMaterialGraph;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            }
            <span class="comment">
             // namespace CacheReaderAlembicPrivate
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // CLASS AlembicCacheReader
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //==============================================================================
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
            boost::shared_ptr&lt;CacheReader&gt; AlembicCacheReader::create(
            <span class="keyword">
             const
            </span>
            <a name="_a65">
            </a>
            <a class="code" href="./class_m_file_object.html">
             MFileObject
            </a>
            &amp; file)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            boost::make_shared&lt;AlembicCacheReader&gt;(file);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheReader::AlembicCacheReader(
            <span class="keyword">
             const
            </span>
            <a class="code" href="./class_m_file_object.html">
             MFileObject
            </a>
            &amp; file)
           </div>
           <div class="line">
            : fFile(file)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Open the archive for reading.
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            resolvedFullName = file.
            <a name="a66">
            </a>
            <a class="code" href="./class_m_file_object.html#a9484f49594e6f95729f1be1608a6ae8f">
             resolvedFullName
            </a>
            ();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             try
            </span>
            {
           </div>
           <div class="line">
            tbb::mutex::scoped_lock alembicLock(gsAlembicMutex);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (resolvedFullName.
            <a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">
             length
            </a>
            () != 0 &amp;&amp; std::ifstream(resolvedFullName.
            <a name="a67">
            </a>
            <a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">
             asChar
            </a>
            ()).good()) {
           </div>
           <div class="line">
            Alembic::AbcCoreFactory::IFactory factory;
           </div>
           <div class="line">
            <span class="comment">
             // Disable Alembic caching as we have implemented our own
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // caching...
            </span>
           </div>
           <div class="line">
            factory.setSampleCache( Alembic::AbcCoreAbstract::ReadArraySampleCachePtr());
           </div>
           <div class="line">
            factory.setPolicy(Alembic::Abc::ErrorHandler::kThrowPolicy);
           </div>
           <div class="line">
            fAbcArchive = factory.getArchive(resolvedFullName.
            <a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">
             asChar
            </a>
            ());
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // File exists but Alembic fails to open.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!fAbcArchive.valid()) {
           </div>
           <div class="line">
            DisplayError(kFileFormatWrongMsg, file.
            <a name="a68">
            </a>
            <a class="code" href="./class_m_file_object.html#a2f505a3eabc9709fad04e2a14d960614">
             rawFullName
            </a>
            ());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            <span class="comment">
             // File doesn't exist.
            </span>
           </div>
           <div class="line">
            DisplayError(kFileDoesntExistMsg, file.
            <a class="code" href="./class_m_file_object.html#a2f505a3eabc9709fad04e2a14d960614">
             rawFullName
            </a>
            ());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (CacheReaderInterruptException&amp; ex) {
           </div>
           <div class="line">
            <span class="comment">
             // pass upward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             throw
            </span>
            ex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (std::exception&amp; ex) {
           </div>
           <div class="line">
            <span class="comment">
             //The resolved full name will be empty if the resolution fails.
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //Print the raw full name in case of this situation.
            </span>
           </div>
           <div class="line">
            DisplayError(kCacheOpenFileErrorMsg, file.
            <a class="code" href="./class_m_file_object.html#a2f505a3eabc9709fad04e2a14d960614">
             rawFullName
            </a>
            (), ex.what());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheReader::~AlembicCacheReader()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             try
            </span>
            {
           </div>
           <div class="line">
            tbb::mutex::scoped_lock alembicLock(gsAlembicMutex);
           </div>
           <div class="line">
            fAbcArchive.reset();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (CacheReaderInterruptException&amp; ex) {
           </div>
           <div class="line">
            <span class="comment">
             // pass upward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             throw
            </span>
            ex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (std::exception&amp; ex) {
           </div>
           <div class="line">
            DisplayError(kCloseFileErrorMsg, fFile.resolvedFullName(), ex.what());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            AlembicCacheReader::valid()
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            tbb::mutex::scoped_lock alembicLock(gsAlembicMutex);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            fAbcArchive.valid();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            AlembicCacheReader::validateGeomPath(
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            &amp; geomPath,
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            &amp; validatedGeomPath)
            <span class="keyword">
             const
            </span>
           </div>
           <div class="line">
            <span class="keyword">
            </span>
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!valid()) {
           </div>
           <div class="line">
            validatedGeomPath =
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            (
            <span class="stringliteral">
             "|"
            </span>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             try
            </span>
            {
           </div>
           <div class="line">
            tbb::mutex::scoped_lock alembicLock(gsAlembicMutex);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // path: |xform1|xform2|meshShape
            </span>
           </div>
           <div class="line">
            <a name="_a69">
            </a>
            <a class="code" href="./class_m_string_array.html">
             MStringArray
            </a>
            pathArray;
           </div>
           <div class="line">
            geomPath.
            <a name="a70">
            </a>
            <a class="code" href="./class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">
             split
            </a>
            (
            <span class="charliteral">
             '|'
            </span>
            , pathArray);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            valid =
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // find the mesh in Alembic archive
            </span>
           </div>
           <div class="line">
            validatedGeomPath =
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            ();
           </div>
           <div class="line">
            Alembic::Abc::IObject current = fAbcArchive.getTop();
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; pathArray.
            <a name="a71">
            </a>
            <a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">
             length
            </a>
            (); i++) {
           </div>
           <div class="line">
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            step = pathArray[i];
           </div>
           <div class="line">
            current = current.getChild(step.
            <a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">
             asChar
            </a>
            ());
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!current.valid()) {
           </div>
           <div class="line">
            valid =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             break
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            validatedGeomPath +=
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            (
            <span class="stringliteral">
             "|"
            </span>
            );
           </div>
           <div class="line">
            validatedGeomPath += step;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (validatedGeomPath.
            <a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">
             length
            </a>
            () == 0) {
           </div>
           <div class="line">
            validatedGeomPath =
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            (
            <span class="stringliteral">
             "|"
            </span>
            );
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            valid;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (CacheReaderInterruptException&amp; ex) {
           </div>
           <div class="line">
            <span class="comment">
             // pass upward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             throw
            </span>
            ex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (std::exception&amp; ex) {
           </div>
           <div class="line">
            DisplayError(kReadMeshErrorMsg, fFile.resolvedFullName(), geomPath, ex.what());
           </div>
           <div class="line">
           </div>
           <div class="line">
            validatedGeomPath =
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            (
            <span class="stringliteral">
             "|"
            </span>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            SubNode::Ptr AlembicCacheReader::readScene(
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            &amp; geomPath,
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // Read sub-node hierarchy
            </span>
           </div>
           <div class="line">
            SubNode::Ptr top = readHierarchy(geomPath, needUVs);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!top)
            <span class="keywordflow">
             return
            </span>
            SubNode::Ptr();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Extract shape paths
            </span>
           </div>
           <div class="line">
            ShapePathVisitor::ShapePathAndSubNodeList shapeGeomPaths;
           </div>
           <div class="line">
            ShapePathVisitor shapePathVisitor(shapeGeomPaths);
           </div>
           <div class="line">
            top-&gt;accept(shapePathVisitor);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The absolute shape path in the archive is prefix+shapePath
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            prefix;
           </div>
           <div class="line">
            <span class="keywordtype">
             int
            </span>
            lastStep = geomPath.
            <a name="a72">
            </a>
            <a class="code" href="./class_m_string.html#a8b323761724ea9659348e33b0fea356b">
             rindexW
            </a>
            (
            <span class="charliteral">
             '|'
            </span>
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (lastStep &gt; 0) {
           </div>
           <div class="line">
            prefix = geomPath.
            <a name="a73">
            </a>
            <a class="code" href="./class_m_string.html#ad748626e545fa6db3afc2f61644b5d62">
             substringW
            </a>
            (0, lastStep - 1);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Read shapes
            </span>
           </div>
           <div class="line">
            BOOST_FOREACH (
            <span class="keyword">
             const
            </span>
            ShapePathVisitor::ShapePathAndSubNode&amp; pair, shapeGeomPaths) {
           </div>
           <div class="line">
            SubNode::Ptr shape = readShape(prefix + pair.first, needUVs);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (shape &amp;&amp; pair.first.length() &gt; 0) {
           </div>
           <div class="line">
            ReplaceSubNodeData(top, shape, pair.first);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Update transparent type
            </span>
           </div>
           <div class="line">
            SubNodeTransparentTypeVisitor transparentTypeVisitor;
           </div>
           <div class="line">
            top-&gt;accept(transparentTypeVisitor);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            top;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            SubNode::Ptr AlembicCacheReader::readHierarchy(
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            &amp; geomPath,
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keyword">
             using namespace
            </span>
            CacheReaderAlembicPrivate;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!valid())
            <span class="keywordflow">
             return
            </span>
            SubNode::Ptr();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             try
            </span>
            {
           </div>
           <div class="line">
            tbb::mutex::scoped_lock alembicLock(gsAlembicMutex);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // path: |xform1|xform2|meshShape
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_string_array.html">
             MStringArray
            </a>
            pathArray;
           </div>
           <div class="line">
            geomPath.
            <a class="code" href="./class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">
             split
            </a>
            (
            <span class="charliteral">
             '|'
            </span>
            , pathArray);
           </div>
           <div class="line">
           </div>
           <div class="line">
            Alembic::Abc::IObject current = fAbcArchive.getTop();
           </div>
           <div class="line">
            AlembicCacheObjectReader::Ptr reader;
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (pathArray.
            <a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">
             length
            </a>
            () == 0) {
           </div>
           <div class="line">
            <span class="comment">
             // Determine the number of children under the top level object.
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // We skip objects that we don't recognize. (Cameras, Materials, ..)
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numChildren = 0;
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            lastChild   = 0;
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0; i &lt; current.getNumChildren(); i++) {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (Alembic::AbcGeom::IPolyMesh::matches(current.getChildHeader(i)) ||
           </div>
           <div class="line">
            Alembic::AbcGeom::INuPatch::matches(current.getChildHeader(i)) ||
           </div>
           <div class="line">
            Alembic::AbcGeom::ISubD::matches(current.getChildHeader(i)) ||
           </div>
           <div class="line">
            Alembic::AbcGeom::IXform::matches(current.getChildHeader(i))) {
           </div>
           <div class="line">
            numChildren++;
           </div>
           <div class="line">
            lastChild = i;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numChildren == 1) {
           </div>
           <div class="line">
            current = Alembic::Abc::IObject(
           </div>
           <div class="line">
            current, current.getChildHeader(lastChild).getName());
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (current.valid())
           </div>
           <div class="line">
            reader = AlembicCacheObjectReader::create(
           </div>
           <div class="line">
            current, needUVs);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            <span class="keywordflow">
             if
            </span>
            (numChildren &gt; 1) {
           </div>
           <div class="line">
            <span class="comment">
             // The top level object is not a proper xform object. We
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // therefore have to create a dummy top-level transform in
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // that case.
            </span>
           </div>
           <div class="line">
            reader = boost::make_shared&lt;AlembicCacheTopReader&gt;(
           </div>
           <div class="line">
            current, needUVs);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            <span class="comment">
             // find the top level node in the Alembic archive
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            geometryFound =
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; pathArray.
            <a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">
             length
            </a>
            (); i++) {
           </div>
           <div class="line">
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            step = pathArray[i];
           </div>
           <div class="line">
            current = current.getChild(step.
            <a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">
             asChar
            </a>
            ());
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!current.valid()) {
           </div>
           <div class="line">
            geometryFound =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             break
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (geometryFound)
           </div>
           <div class="line">
            reader = AlembicCacheObjectReader::create(current, needUVs);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!reader || !reader-&gt;valid())
            <span class="keywordflow">
             return
            </span>
            SubNode::Ptr();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Each time samplings only records the start time, i.e. there
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // is no way to ask for the end time of a TimeSampling!
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // Therefore, to determine the end of the animation, we simply
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // loop until time no longer advances...
            </span>
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            TimeInterval interval = reader-&gt;sampleHierarchy(
           </div>
           <div class="line">
            -std::numeric_limits&lt;double&gt;::max(),
           </div>
           <div class="line">
            <a class="code" href="./class_m_matrix.html#a85de986c9f953535d185c6780cecb77e">
             MMatrix::identity
            </a>
            , TimeInterval::kInfinite);
           </div>
           <div class="line">
            <span class="keywordflow">
             while
            </span>
            (interval.endTime() != std::numeric_limits&lt;double&gt;::max()) {
           </div>
           <div class="line">
            interval = reader-&gt;sampleHierarchy(
           </div>
           <div class="line">
            interval.endTime(),
           </div>
           <div class="line">
            <a class="code" href="./class_m_matrix.html#a85de986c9f953535d185c6780cecb77e">
             MMatrix::identity
            </a>
            , TimeInterval::kInfinite);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The sub-node hierarchy with bounding box place holders.
            </span>
           </div>
           <div class="line">
            SubNode::Ptr top = reader-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Save the object readers for reuse.
            </span>
           </div>
           <div class="line">
            reader-&gt;saveAndReset(*
            <span class="keyword">
             this
            </span>
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            top;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (CacheReaderInterruptException&amp; ex) {
           </div>
           <div class="line">
            <span class="comment">
             // pass upward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             throw
            </span>
            ex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (std::exception&amp; ex) {
           </div>
           <div class="line">
            DisplayError(kReadMeshErrorMsg, fFile.resolvedFullName(), geomPath, ex.what());
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            SubNode::Ptr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            SubNode::Ptr AlembicCacheReader::readShape(
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            &amp; geomPath,
            <span class="keywordtype">
             bool
            </span>
            needUVs)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keyword">
             using namespace
            </span>
            CacheReaderAlembicPrivate;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!valid())
            <span class="keywordflow">
             return
            </span>
            SubNode::Ptr();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             try
            </span>
            {
           </div>
           <div class="line">
            tbb::mutex::scoped_lock alembicLock(gsAlembicMutex);
           </div>
           <div class="line">
           </div>
           <div class="line">
            AlembicCacheObjectReader::Ptr reader;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Search saved readers
            </span>
           </div>
           <div class="line">
            ObjectReaderMap::iterator iter = fSavedReaders.find(geomPath.
            <a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">
             asChar
            </a>
            ());
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (iter != fSavedReaders.end()) {
           </div>
           <div class="line">
            reader = (*iter).second;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             else
            </span>
            {
           </div>
           <div class="line">
            <span class="comment">
             // path: |xform1|xform2|meshShape
            </span>
           </div>
           <div class="line">
            <a class="code" href="./class_m_string_array.html">
             MStringArray
            </a>
            pathArray;
           </div>
           <div class="line">
            geomPath.
            <a class="code" href="./class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">
             split
            </a>
            (
            <span class="charliteral">
             '|'
            </span>
            , pathArray);
           </div>
           <div class="line">
           </div>
           <div class="line">
            Alembic::Abc::IObject current = fAbcArchive.getTop();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (pathArray.
            <a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">
             length
            </a>
            () &gt; 0) {
           </div>
           <div class="line">
            <span class="comment">
             // Find the shape in the Alembic archive
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            geometryFound =
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; pathArray.
            <a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">
             length
            </a>
            (); i++) {
           </div>
           <div class="line">
            <a class="code" href="./class_m_string.html">
             MString
            </a>
            step = pathArray[i];
           </div>
           <div class="line">
            current = current.getChild(step.
            <a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">
             asChar
            </a>
            ());
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!current.valid()) {
           </div>
           <div class="line">
            geometryFound =
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            <span class="keywordflow">
             break
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (geometryFound) {
           </div>
           <div class="line">
            reader = AlembicCacheObjectReader::create(current, needUVs);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!reader || !reader-&gt;valid())
            <span class="keywordflow">
             return
            </span>
            SubNode::Ptr();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Each time samplings only records the start time, i.e. there
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // is no way to ask for the end time of a TimeSampling!
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // Therefore, to determine the end of the animation, we simply
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // loop until time no longer advances...
            </span>
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            TimeInterval interval = reader-&gt;sampleShape(
           </div>
           <div class="line">
            -std::numeric_limits&lt;double&gt;::max());
           </div>
           <div class="line">
            <span class="keywordflow">
             while
            </span>
            (interval.endTime() != std::numeric_limits&lt;double&gt;::max()) {
           </div>
           <div class="line">
            interval = reader-&gt;sampleShape(
           </div>
           <div class="line">
            interval.endTime());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The sub-node with mesh shape data.
            </span>
           </div>
           <div class="line">
            SubNode::Ptr top = reader-&gt;get();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Save the object readers for reuse.
            </span>
           </div>
           <div class="line">
            reader-&gt;saveAndReset(*
            <span class="keyword">
             this
            </span>
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            top;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (CacheReaderInterruptException&amp; ex) {
           </div>
           <div class="line">
            <span class="comment">
             // pass upward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             throw
            </span>
            ex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (std::exception&amp; ex) {
           </div>
           <div class="line">
            DisplayError(kReadMeshErrorMsg, fFile.resolvedFullName(), geomPath, ex.what());
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            SubNode::Ptr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            MaterialGraphMap::Ptr AlembicCacheReader::readMaterials()
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keyword">
             using namespace
            </span>
            CacheReaderAlembicPrivate;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!valid())
            <span class="keywordflow">
             return
            </span>
            MaterialGraphMap::Ptr();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             try
            </span>
            {
           </div>
           <div class="line">
            tbb::mutex::scoped_lock alembicLock(gsAlembicMutex);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Find "/materials"
            </span>
           </div>
           <div class="line">
            Alembic::Abc::IObject topObject = fAbcArchive.getTop();
           </div>
           <div class="line">
            Alembic::Abc::IObject materialsObject = topObject.getChild(kMaterialsObject);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // "/materials" doesn't exist!
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!materialsObject.valid()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            MaterialGraphMap::Ptr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            MaterialGraphMap::MPtr materials = boost::make_shared&lt;MaterialGraphMap&gt;();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Read materials one by one. Hierarchical materials are not supported.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             size_t
            </span>
            i = 0; i &lt; materialsObject.getNumChildren(); i++) {
           </div>
           <div class="line">
            Alembic::Abc::IObject
            <span class="keywordtype">
             object
            </span>
            = materialsObject.getChild(i);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (Alembic::AbcMaterial::IMaterial::matches(
            <span class="keywordtype">
             object
            </span>
            .getHeader())) {
           </div>
           <div class="line">
            AlembicCacheMaterialReader reader(
            <span class="keywordtype">
             object
            </span>
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Read the material
            </span>
           </div>
           <div class="line">
            TimeInterval interval = reader.sampleMaterial(
           </div>
           <div class="line">
            -std::numeric_limits&lt;double&gt;::max());
           </div>
           <div class="line">
            <span class="keywordflow">
             while
            </span>
            (interval.endTime() != std::numeric_limits&lt;double&gt;::max()) {
           </div>
           <div class="line">
            interval = reader.sampleMaterial(interval.endTime());
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            MaterialGraph::MPtr graph = reader.get();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (graph) {
           </div>
           <div class="line">
            materials-&gt;addMaterialGraph(graph);
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // No materials..
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (materials-&gt;getGraphs().empty()) {
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            MaterialGraphMap::Ptr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            materials;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (CacheReaderInterruptException&amp; ex) {
           </div>
           <div class="line">
            <span class="comment">
             // pass upward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             throw
            </span>
            ex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (std::exception&amp; ex) {
           </div>
           <div class="line">
            DisplayError(kReadFileErrorMsg, fFile.resolvedFullName(), ex.what());
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            MaterialGraphMap::Ptr();
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             bool
            </span>
            AlembicCacheReader::readAnimTimeRange(GPUCache::TimeInterval&amp; range)
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (!valid())
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordflow">
             try
            </span>
            {
           </div>
           <div class="line">
            tbb::mutex::scoped_lock alembicLock(gsAlembicMutex);
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Try *.samples property.
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             double
            </span>
            samplesMin = std::numeric_limits&lt;double&gt;::infinity();
           </div>
           <div class="line">
            <span class="keywordtype">
             double
            </span>
            samplesMax = -std::numeric_limits&lt;double&gt;::infinity();
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            numTimeSamplings = fAbcArchive.getNumTimeSamplings();
           </div>
           <div class="line">
            <span class="keywordflow">
             for
            </span>
            (
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            i = 0; i &lt; numTimeSamplings; i++) {
           </div>
           <div class="line">
            <span class="comment">
             // *.samples property
            </span>
           </div>
           <div class="line">
            std::stringstream propName;
           </div>
           <div class="line">
            propName &lt;&lt; i &lt;&lt;
            <span class="stringliteral">
             ".samples"
            </span>
            ;
           </div>
           <div class="line">
            Alembic::Abc::IUInt32Property samplesProp(
           </div>
           <div class="line">
            fAbcArchive.getTop().getProperties(),
           </div>
           <div class="line">
            propName.str(),
           </div>
           <div class="line">
            Alembic::Abc::ErrorHandler::kQuietNoopPolicy
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // The time sampling.
            </span>
           </div>
           <div class="line">
            Alembic::Abc::TimeSamplingPtr timeSampling = fAbcArchive.getTimeSampling(i);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (samplesProp &amp;&amp; timeSampling) {
           </div>
           <div class="line">
            <span class="keywordtype">
             unsigned
            </span>
            <span class="keywordtype">
             int
            </span>
            numSamples = 0;
           </div>
           <div class="line">
            samplesProp.get(numSamples);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numSamples &gt; 0) {
           </div>
           <div class="line">
            samplesMin = std::min(samplesMin, timeSampling-&gt;getSampleTime(0));
           </div>
           <div class="line">
            samplesMax = std::max(samplesMax, timeSampling-&gt;getSampleTime(numSamples - 1));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Successfully read *.samples property.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (samplesMin &lt;= samplesMax) {
           </div>
           <div class="line">
            range = TimeInterval(samplesMin, samplesMax);
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // Try archive bounds property.
            </span>
           </div>
           <div class="line">
            Alembic::Abc::IBox3dProperty boxProp = Alembic::AbcGeom::GetIArchiveBounds(
           </div>
           <div class="line">
            fAbcArchive, Alembic::Abc::ErrorHandler::kQuietNoopPolicy);
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (boxProp) {
           </div>
           <div class="line">
            <span class="comment">
             // The time range of the archive bounds property.
            </span>
           </div>
           <div class="line">
            <span class="keywordtype">
             size_t
            </span>
            numSamples                          = boxProp.getNumSamples();
           </div>
           <div class="line">
            Alembic::Abc::TimeSamplingPtr timeSampling = boxProp.getTimeSampling();
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (numSamples &gt; 0 &amp;&amp; timeSampling) {
           </div>
           <div class="line">
            range = TimeInterval(
           </div>
           <div class="line">
            timeSampling-&gt;getSampleTime(0),
           </div>
           <div class="line">
            timeSampling-&gt;getSampleTime(numSamples - 1)
           </div>
           <div class="line">
            );
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             true
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="comment">
             // No enough animation range info on the archive.
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (CacheReaderInterruptException&amp; ex) {
           </div>
           <div class="line">
            <span class="comment">
             // pass upward
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             throw
            </span>
            ex;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            <span class="keywordflow">
             catch
            </span>
            (std::exception&amp; ex) {
           </div>
           <div class="line">
            DisplayError(kReadFileErrorMsg, fFile.resolvedFullName(), ex.what());
           </div>
           <div class="line">
            <span class="keywordflow">
             return
            </span>
            <span class="keyword">
             false
            </span>
            ;
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
            <span class="keywordtype">
             void
            </span>
            AlembicCacheReader::saveReader(
           </div>
           <div class="line">
            <span class="keyword">
             const
            </span>
            std::string&amp; fullName,
           </div>
           <div class="line">
            CacheReaderAlembicPrivate::AlembicCacheObjectReader::Ptr&amp; reader
           </div>
           <div class="line">
            )
           </div>
           <div class="line">
            {
           </div>
           <div class="line">
            <span class="comment">
             // We save the object reader in this AlembicCacheReader so that
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // the object reader won't be destroyed after readHierarchy() or readShape().
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // The life time of the object reader would be the same as this AlembicCacheReader.
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // The object reader can be reused as long as the Alembic archive is not closed.
            </span>
           </div>
           <div class="line">
            <span class="comment">
             // There are 2 situations that will cause an Alembic archive to be closed:
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //   1) There are no references to CacheReaderProxy. (Read complete)
            </span>
           </div>
           <div class="line">
            <span class="comment">
             //   2) Maya is running out of file handles. (Temporarily close some inactive archives)
            </span>
           </div>
           <div class="line">
            <span class="keywordflow">
             if
            </span>
            (reader &amp;&amp; reader-&gt;valid()) {
           </div>
           <div class="line">
            std::string geometryPath = fullName;
           </div>
           <div class="line">
            std::replace(geometryPath.begin(), geometryPath.end(),
            <span class="charliteral">
             '/'
            </span>
            ,
            <span class="charliteral">
             '|'
            </span>
            );
           </div>
           <div class="line">
            fSavedReaders.insert(std::make_pair(geometryPath, reader));
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
            }
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
           <div class="line">
            }
            <span class="comment">
             // namespace GPUCache
            </span>
           </div>
           <div class="line">
           </div>
           <div class="line">
           </div>
          </div>
          <!-- fragment -->
         </div>
         <!-- contents -->
        </div>
        <!-- doc-content -->
        <div class="footer-block">
         <a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank">
          <span class="comments-link">
           Please send us your comment about this page
          </span>
         </a>
        </div>
        <br/>
       </div>
      </link>
     </link>
    </link>
   </link>
  </div>
 </body>
</html>

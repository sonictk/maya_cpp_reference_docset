<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../style/prettify.css" type="text/css" rel="stylesheet">
<script type="text/javascript" src="../../scripts/prettify.js"></script><script src="../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="generator" content="pandoc"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../../scripts/utils/adsk.redirect.js"></script>
      <title>Communication Between Manipulators and Nodes</title>
   <meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script></script><script></script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Communication Between Manipulators and Nodes</h1>
         </div>

<div class='section'><a id="communication-between-manipulators-and-nodes"></a></div>
<p>Manipulators communicate with plugs on nodes to set the values of the plugs. Additionally, manipulators also set the manipulator values with respect to the values of the plugs.</p>
<p>The communication between manipulators and nodes is done in one of these two ways: simple one-to-one associations, or through complex conversion functions. The following diagram illustrates the communication between nodes and manipulators.</p>
<div class='figure'><img src='developer/images/comp_container.png' title=''></div>
<p>The converter manages the communication between the plugs on the nodes and manipulator values. The arrows in the diagram indicate the direction in which the information flows. Each container manipulator has one converter, which is the interface between the children manipulators and the affected plugs.</p>
<p>The square boxes indicate the data items on the converter and the base manipulators. The items on the converter that are related to the children manipulator values are called the converterManipValue items. The items on the converter that are related to the node plug values are called the converterPlugValue items.</p>
<p>The items on the base manipulators are called the manipValue items. Some manipValue items relate directly to an affordance of the manipulator. For example, <span class='code'><a href="javascript:void(0)" data-symbol="MFnDiscManip::angleIndex()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_disc_manip.html#a0fb85fe9f1c304c0e0386aebe95696f1&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDiscManip::angleIndex()</a></span> relates directly to the rotation affordance of the DiscManip. Other manipValue items do not relate to an affordance of the manipulator, but provide important information on the position or orientation of the manipulator such as <span class='code'><a href="javascript:void(0)" data-symbol="MFnDiscManip::centerIndex()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_disc_manip.html#aba4f86f4c4c0a8c7b2b238a7b57e9d6f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDiscManip::centerIndex()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MFnDiscManip::axisIndex()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_disc_manip.html#a01d33e6362f9dc25edbda43c03e73083&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDiscManip::axisIndex()</a></span>.</p>
<p>Each converterManipValue item and converterPlugValue item has an integer index to uniquely identify the item. Each manipValue item on a base manipulator also has an integer index to uniquely identify the item.</p>
<p>Note: There is a one-to-one correspondence between a converterManipValue item and a base manipulator’s manipValue item, and these items share the same integer index. There is also a one-to-one correspondence between a converterPlugValue item and a plug on a node, which is affected by the manipulator.</p>
<p>As shown in the diagram, there are one-to-one associations directly between a converterManipValue item and a converterPlugValue item.</p>
<p>More complex conversions between converterManipValue items and converterPlugValue items are performed through conversion functions. These functions can use any number of converterPlugValue items or converterManipValue items to calculate the corresponding converterManipValue or converterPlugValue item.</p>
<div class='section'><a id="one-to-one-association"></a><h2 id="one-to-one-association">One-to-one Association</h2></div>
<p>One-to-one association synchronizes the manipulator values with the plug values. In other words, the manipulator value equals the plug value, and vice versa.</p>
<p>One-to-one associations between a converterManipValue item and a converterPlugValue item are established through methods on the manipulator classes derived from <span class='code'><a href="javascript:void(0)" data-symbol="MFnManip3D" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_manip3_d.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_fn_manip3_d.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnManip3D</a></span>.These methods and the data types corresponding to the plugs they connect to are the following:</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnFreePointTriadManip::connectToPointPlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_free_point_triad_manip.html#a8c602939f7633280f84288c8e3bc94e5&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnFreePointTriadManip::connectToPointPlug()</a></span> (three doubles)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnDirectionManip::connectToDirectionPlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_direction_manip.html#ae050f632f776ba0bde4acc6e63d09fcf&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDirectionManip::connectToDirectionPlug()</a></span> (three doubles)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnDistanceManip::connectToDistancePlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_distance_manip.html#ab095c6cd5a52c56e46b043831a84a083&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDistanceManip::connectToDistancePlug()</a></span> (double)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnPointOnCurveManip::connectToCurvePlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_point_on_curve_manip.html#a08db0f5d342d3bb69e6182a8b8949062&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnPointOnCurveManip::connectToCurvePlug()</a></span> (curve)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnPointOnCurveManip::connectToParamPlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_point_on_curve_manip.html#a05a5e0e765044955515fbb0429544dee&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnPointOnCurveManip::connectToParamPlug()</a></span> (double)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnPointOnSurfaceManip::connectToSurfacePlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_point_on_surface_manip.html#aa59ed882f5e6f704ec4d0d8384b16c86&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnPointOnSurfaceManip::connectToSurfacePlug()</a></span> (surface)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnPointOnSurfaceManip::connectToParamPlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_point_on_surface_manip.html#a05a5e0e765044955515fbb0429544dee&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnPointOnSurfaceManip::connectToParamPlug()</a></span> (two doubles)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnDiscManip::connectToAnglePlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_disc_manip.html#a862d477b9d3cc93d504f1ca5415876ba&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDiscManip::connectToAnglePlug()</a></span> (double)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnCircleSweepManip::connectToAnglePlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_circle_sweep_manip.html#a862d477b9d3cc93d504f1ca5415876ba&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnCircleSweepManip::connectToAnglePlug()</a></span> (double)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnToggleManip::connectToTogglePlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_toggle_manip.html#a37257134f4d1cd42d583d76249436eed&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnToggleManip::connectToTogglePlug()</a></span> (boolean)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnStateManip::connectToStatePlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_state_manip.html#af32c5986c5ab670965291e08ff32f8bd&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnStateManip::connectToStatePlug()</a></span> (long)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnCurveSegmentManip::connectToCurvePlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_curve_segment_manip.html#a08db0f5d342d3bb69e6182a8b8949062&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnCurveSegmentManip::connectToCurvePlug()</a></span> (curve)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnCurveSegmentManip::connectToStartParamPlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_curve_segment_manip.html#a5c74876108b7c48f72fb67fa65f35460&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnCurveSegmentManip::connectToStartParamPlug()</a></span> (double)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnCurveSegmentManip::connectToEndParamPlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_curve_segment_manip.html#a9ee5f036268a0181a9521edd4f67eca3&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnCurveSegmentManip::connectToEndParamPlug()</a></span> (double)</li>
<li><span class='code'>MFnRotateManip::connectToRotatePlug()</span> (three doubles)</li>
<li><span class='code'>MFnRotateManip::connectToRotateCenterPlug()</span> (three doubles)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnScaleManip::connectToScalePlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_scale_manip.html#ab04b675c1d633536263c27de34681ac8&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnScaleManip::connectToScalePlug()</a></span> (three doubles)</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MFnScaleManip::connectToScaleCenterPlug()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_scale_manip.html#a0128b552fa5c1638ac4a37c3604b5c22&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnScaleManip::connectToScaleCenterPlug()</a></span> (three doubles)</li>
</ul>
<p>These methods must be called from the <span class='code'>connectToDependNode()</span> method. For example, in the footPrintManip example:</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> footPrintLocatorManip::connectToDependNode(const <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> &amp;node)

{
    ...
    <a href="javascript:void(0)" data-symbol="MFnDistanceManip" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_distance_manip.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDistanceManip</a> distanceManipFn(fDistanceManip);
    <a href="javascript:void(0)" data-symbol="MFnDependencyNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_dependency_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDependencyNode</a> nodeFn(node);
    <a href="javascript:void(0)" data-symbol="MPlug" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_plug.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPlug</a> sizePlug = nodeFn.findPlug(&quot;size&quot;, &amp;stat);
    if (<a href="javascript:void(0)" data-symbol="MStatus::kFailure" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus::kFailure</a> != stat) {
        distanceManipFn.connectToDistancePlug(sizePlug);
        ...
        finishAddingManips();
        <a href="javascript:void(0)" data-symbol="MPxManipContainer::connectToDependNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manip_container.html#ac7013eba743cd3226bc9a72b1ea27cff&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipContainer::connectToDependNode</a>(node);
    }
    return stat;
} 

</pre></div><p>The following figure shows the one-to-one association between the distance manipulator value and the value of the <em>size</em> plug on a node.</p>
<div class='figure'><img src='developer/images/mappingone.png' title=''></div>
<p>After you set the one-to-one association, whenever the manipulator value changes, the corresponding plug value also changes, and vice versa.</p>
<p>One-to-one association is a convenient approach to set the relationships between manipulator values and plug values. However, it might not be useful for more complex requirements. For example, you cannot set the distance manipulator value to 5 x the value of size. Also, when you move the node, the distance manipulator will not appear at the center of the node, and you cannot move the manipulator along the position of the node. If the position of a manipulator needs to be affected by the position of an object, or a group of manipulators has to move together in a specific way, then you need to use conversion functions.</p>
<div class='section'><a id="conversion-functions"></a><h2 id="conversion-functions">Conversion Functions</h2></div>
<p>Conversion functions are used to convert between manipulator values and plug values. They are implemented as callback methods. Conversion functions are used to set complex relationships between manipulator values and plug values.</p>
<p>A simple example of a manipulator that uses conversion functions is a container manipulator with a DiscManip connected to a plug (associated with an attribute of type <span class='code'><a href="javascript:void(0)" data-symbol="MFnUnitAttribute::kAngle" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_unit_attribute.html#a1d1cfd8ffb84e947f82999c682b666a7a7a9a81c214c05358fc6382f8e1f54196&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnUnitAttribute::kAngle</a></span>) that takes the rotation of the disc manipulator and multiplies that rotation by 10. The conversion function uses <span class='code'><a href="javascript:void(0)" data-symbol="MPxManipContainer::getConverterManipValue()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manip_container.html#aa36968962a8bd654cb1aedf3bee8abd3&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipContainer::getConverterManipValue()</a></span> on <span class='code'><a href="javascript:void(0)" data-symbol="MFnDiscManip::angleIndex()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_disc_manip.html#a0fb85fe9f1c304c0e0386aebe95696f1&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDiscManip::angleIndex()</a></span> and then multiplies that angle by 10.</p>
<p>Conversion functions are very useful when the position of a manipulator has to be affected by the position of an object, or to move a group of manipulators together in a specific way. Without conversion functions, manipulators cannot move together as a unit, and certain components of the manipulator will remain either at the origin or a fixed position in space.</p>
<p>Note: Conversion functions are not required when a FreePointTriadManip specifies a position or a PointOnCurveManip specifies a parameter along a curve. However, if you have a DiscManip that you want to move along with the PointOnCurveManip, you need a conversion function to give the DiscManip information about its position and normal.</p>
<p>There are two kinds of conversion callback methods: plugToManip and manipToPlug.</p>
<div class='section'><a id="conversion-callback---plugtomanip"></a><h3 id="conversion-callback---plugtomanip">Conversion Callback - plugToManip</h3></div>
<p>A plugToManip conversion callback is used to get the value of a converterManipValue item from various converterPlugValue items. This callback has access to all the converterPlugValue items and returns the value of a converterManipValue item.</p>
<p>The plugToManip conversion is implemented by calling <span class='code'><a href="javascript:void(0)" data-symbol="MPxManipContainer::addPlugToManipConversionCallback()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manip_container.html#a7a6ba1ac9297d5d85ef8a51d25c052d2&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipContainer::addPlugToManipConversionCallback()</a></span>.</p>
<p>Each visual control property has a corresponding index registered with the manipulator. To set the plugToManip conversion relationship, when <span class='code'><a href="javascript:void(0)" data-symbol="MPxManipContainer::addPlugToManipConversionCallback()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manip_container.html#a7a6ba1ac9297d5d85ef8a51d25c052d2&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipContainer::addPlugToManipConversionCallback()</a></span> is called, the index of the manipulator value must be passed. In each base manipulator function set class, there are functions to retrieve different indices for individual properties.</p>
<p>The following code from footPrintManip illustrates how to retrieve the index of the starting point of the manipulator and pass it to the <span class='code'>addPlugToManipConversionCallback()</span> function call. The second parameter of this function call is the callback conversion function, which calculates the manipulator value of the starting point based on some plug values.</p>
<div class="codeBlock"><pre class="prettyprint">unsigned startPointIndex = distanceManipFn.startPointIndex();
addPlugToManipConversionCallback (startPointIndex,(plugToManipConversionCallback)&amp;footPrintLocatorManip::startPointCallback);
</pre></div><p>The plugToManip conversion callback accesses the plug values, calculates the manipulator values based on the custom algorithm, and returns them. In this example, the callback function does not request the plug values, instead, it retrieves the node translation in world space and returns this value. By doing so, it actually sets the start point manipulator value to be the same as the node translation. The result is that whenever the node moves, the manipulator moves along with it, and always appears in the center of the node.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a> footPrintLocatorManip::startPointCallback(unsigned index) const {
    <a href="javascript:void(0)" data-symbol="MFnNumericData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData</a> numData;
    <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> numDataObj =numData.create(<a href="javascript:void(0)" data-symbol="MFnNumericData::k3Double" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7add817d1d2e1e1d24ac2e2819a58e8f99&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData::k3Double</a>);
    <a href="javascript:void(0)" data-symbol="MVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MVector</a> vec = nodeTranslation();
    numData.setData (vec.x, vec.y, vec.z);
    return(<a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a> (numDataObj));
}
<div class='figure'><img src='developer/images/plugToManip.png' title=''></div>
</pre></div><p>The conversion callback returns a data type called MManipData and sets the manipulator value to what the MManipData represents.</p>
<div class='section'><a id="conversion-callback---maniptoplug"></a><h3 id="conversion-callback---maniptoplug">Conversion Callback - manipToPlug</h3></div>
<p>A manipToPlug conversion callback is used to get the value of a converterPlugValue item from various converterManipValue items. This callback has access to all the converterManipValue items and returns the value of a converterPlugValue item.</p>
<p>The manipToPlug conversion is implemented by calling <span class='code'><a href="javascript:void(0)" data-symbol="MPxManipContainer::addManipToPlugConversionCallback()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manip_container.html#ae29d6090c0c5dafea44ad50748fbbedf&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipContainer::addManipToPlugConversionCallback()</a></span>. The corresponding plug needs to be passed in as the first parameter because the callback needs to know which plug values to change.</p>
<p>The following code from the rotateManip example demonstrates using this technique with the node&#39;s rotate plug passed in.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MFnDependencyNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_dependency_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDependencyNode</a> nodeFn (node);
<a href="javascript:void(0)" data-symbol="MPlug" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_plug.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPlug</a> rPlug =nodeFn.findPlug (&quot;rotate&quot;, &amp;stat);
…
rotatePlugIndex = addManipToPlugConversionCallback(rPlug,(manipToPlugConversionCallback)&amp;exampleRotateManip::rotationChangedCallback);
</pre></div><p>The <span class='code'>addManipToPlugConversionCallback()</span> function call returns the index <span class='code'>rotatePlugIndex</span> to identify which plug is registered with this callback. When the actual callback function is invoked, the index of the plug value to be calculated is passed in as the parameter of the function call. The callback function then determines if the passed-in value is the index that is registered for this callback. If there is more than one plug registered with this callback, a condition statement can be used to distinguish different passed-in plug index, and calculate corresponding manipulator values. In the following <span class='code'>rotationChangedCallback()</span> example, the passed-in index is compared with <span class='code'>rotatePlugIndex</span>. If they are equal, <span class='code'>getConverterManipValue()</span> is called with rotate manipulator index to retrieve the rotate manipulator value. By returning the rotate manipulator value as a <span class='code'><a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a></span> object, this callback function is setting the rotate plug value to be the same as the rotate manipulator value. Depending on your specific requirement, more complex relationship between rotate plug value and rotate manipulator value can be set using conversion callback.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a> exampleRotateManip::rotationChangedCallback(unsigned index) {
    <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> obj =<a href="javascript:void(0)" data-symbol="MObject::kNullObj" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject::kNullObj</a>;
    // If we entered the callback with an invalid index, print an error and
    // return.  Because, we registered the callback only for one plug, all
    // invocations of the callback must be for that plug.
    if (index != rotatePlugIndex) {
        <a href="javascript:void(0)" data-symbol="MGlobal::displayError" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_global.html#a4ddbe97e58a90e1ab05d45a62c006cf0&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGlobal::displayError</a>(&quot;Invalid index in rotation changed callback!&quot;);
        // For invalid indices, return vector of 0&#39;s
        <a href="javascript:void(0)" data-symbol="MFnNumericData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData</a> numericData;
        obj = numericData.create(<a href="javascript:void(0)" data-symbol="MFnNumericData::k3Double" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7add817d1d2e1e1d24ac2e2819a58e8f99&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData::k3Double</a>);
        numericData.setData (0.0, 0.0, 0.0);
        return (obj);
    }
    <a href="javascript:void(0)" data-symbol="MFnNumericData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData</a> numericData;
    obj =numericData.create(<a href="javascript:void(0)" data-symbol="MFnNumericData::k3Double" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7add817d1d2e1e1d24ac2e2819a58e8f99&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData::k3Double</a>); 
    <a href="javascript:void(0)" data-symbol="MEulerRotation" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_euler_rotation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEulerRotation</a> manipRotation;
    if (!getConverterManipValue(rotateManip.rotationIndex(),manipRotation)) {
        <a href="javascript:void(0)" data-symbol="MGlobal::displayError" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_global.html#a4ddbe97e58a90e1ab05d45a62c006cf0&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGlobal::displayError</a>(&quot;Error retrieving manip value&quot;);
        numericData.setData(0.0, 0.0, 0.0);
    } else {
        numericData.setData(manipRotation.x, manipRotation.y, manipRotation.z);
    }
    return <a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a>(obj);
}
<div class='figure'><img src='developer/images/manipToPlug.png' title=''></div>
</pre></div><p>In general, manipToPlug conversions are not used commonly. In addition to using converterPlugValues and converterManipValues, it is sometimes useful to use class data, such as a DAG path. (See the footPrintManip for an example of how fNodePath is used to calculate the node translation.) For manipulators that operate on components, it might also be useful to store initial component positions (see the componentScaleManip for an example of how this is done).</p>
<div class='section'><a id="mmanipdata"></a><h3 id="mmanipdata">MManipData</h3></div>
<p>The conversion callback methods return a data type called <span class='code'><a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a></span>. <span class='code'><a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a></span> encapsulates manipulator data which is returned from the manipulator conversion functions. It represents data that is either simple or complex. The simple data methods on <span class='code'><a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a></span> are used to represent bool, short, long, unsigned, float, and double types.</p>
<p>Note: Sometimes attributes associated with the simple data types have higher level meanings such as distance, angle, and time (for example, <span class='code'><a href="javascript:void(0)" data-symbol="MFnUnitAttribute::kAngle" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_unit_attribute.html#a1d1cfd8ffb84e947f82999c682b666a7a7a9a81c214c05358fc6382f8e1f54196&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnUnitAttribute::kAngle</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MFnUnitAttribute::kDistance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_unit_attribute.html#a1d1cfd8ffb84e947f82999c682b666a7a1925172d8d6f77cdb98f7f486f706024&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnUnitAttribute::kDistance</a></span>, and <span class='code'><a href="javascript:void(0)" data-symbol="MFnUnitAttribute::kTime" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_unit_attribute.html#a1d1cfd8ffb84e947f82999c682b666a7a65c3a8bb75ba1a57e36c86855169752e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnUnitAttribute::kTime</a></span>).</p>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a></span> is also used to represent complex data types created by <span class='code'><a href="javascript:void(0)" data-symbol="MFnData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnData</a></span> or classes derived from <span class='code'><a href="javascript:void(0)" data-symbol="MFnData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnData</a></span>, such as matrices, curves, and arrays of data.</p>
<p>The footPrintManip plug-in has an example of a plugToManip conversion callback called startPointCallback. The startPointCallback returns an <span class='code'><a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a></span> which is set to an <span class='code'><a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a></span> that is created by <span class='code'><a href="javascript:void(0)" data-symbol="MFnNumericData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData</a></span>.</p>
<div class="codeBlock"><pre class="prettyprint">class footPrintLocatorManip : public <a href="javascript:void(0)" data-symbol="MPxManipContainer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manip_container.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipContainer</a>
{
    public:
        ...
        <a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a> startPointCallback(unsigned index) const;
        <a href="javascript:void(0)" data-symbol="MVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MVector</a> nodeTranslation() const;
        <a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDagPath</a> fDistanceManip;
        ...
};
<a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a> footPrintLocatorManip::startPointCallback
    (unsigned index) const
{
    // The index is the startPointIndex that is
    // specified in addPlugToManipConversionCallback,
    // but it is not necessary to use this in the callback.
    <a href="javascript:void(0)" data-symbol="MFnNumericData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_numeric_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData</a> numData;
    <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> numDataObj =
        numData.create(<a href="javascript:void(0)" data-symbol="MFnNumericData::k3Double" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7add817d1d2e1e1d24ac2e2819a58e8f99&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData::k3Double</a>);
    <a href="javascript:void(0)" data-symbol="MVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MVector</a> vec = nodeTranslation();
    numData.setData(vec.x, vec.y, vec.z);
    return <a href="javascript:void(0)" data-symbol="MManipData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_manip_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MManipData</a>(numDataObj);
}
<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> footPrintLocatorManip::connectToDependNode
    (const <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> &amp;node)
{
    ...
    unsigned startPointIndex =
        distanceManipFn.startPointIndex();
    addPlugToManipConversionCallback(
        startPointIndex, 
        (plugToManipConversionCallback) startPointCallback);
    ...
}

</pre></div><div class='section'><a id="tips"></a><h3 id="tips">Tips</h3></div>
<p><strong>Conversion Functions for Python and C++</strong> – For python plug-ins, the only functions that you can use to register conversion callback are: <span class='code'>addManipToPlugConversion()</span> and <span class='code'>addPlugToManipConversion()</span>. For C++ plug-ins, you can either use the <span class='code'>addPlugToManipConversionCallback()</span>/<span class='code'>addManipToPlugConversionCallback()</span> functions or <span class='code'>addManipToPlugConversion()</span>/<span class='code'>addPlugToManipConversion()</span> functions to register conversion callback.</p>
<p><strong>Manip Index and Plug Index</strong> – The visual control properties have a manip index registered within the manipulator. For example, <span class='code'><a href="javascript:void(0)" data-symbol="MFnDistanceManip::startPointIndex()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_distance_manip.html#ae9b705156995d243973d36040b36a84d&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDistanceManip::startPointIndex()</a></span> returns the index of the start point and <span class='code'><a href="javascript:void(0)" data-symbol="MFnRotateManip::rotationIndex()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_rotate_manip.html#af1cc0841a9512d86b698239a61fa8edf&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnRotateManip::rotationIndex()</a></span> returns the index of the rotation manipulator value. To specify which manipulator value is set with a plugToManip conversion callback, the manip index must be used when <span class='code'>addPlugToManipConversionCallback()</span> or <span class='code'>addPlugToManipConversion()</span> is called.</p>
<p>The plug index is returned by <span class='code'>addManipToPlugConversionCallback()</span> and <span class='code'>addManipToPlugConversion()</span> to identify which plug is registered with the manipToPlug conversion callback.</p>
<p>In addition, the manip indexes are used to retrieve the manipulator values from the <span class='code'>getConverterManipValue()</span> function, and the plug indexes are used to retrieve the plug values from the <span class='code'>getConverterPlugValue()</span> function.</p>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

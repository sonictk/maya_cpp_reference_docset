<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../../../style/prettify.css" type="text/css" rel="stylesheet">
<script type="text/javascript" src="../../../../scripts/prettify.js"></script><script src="../../../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="generator" content="pandoc"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../../../../scripts/utils/adsk.redirect.js"></script>
      <title>Handling custom renderables for object overrides</title>
   <meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script></script><script></script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Handling custom renderables for object overrides</h1>
         </div>

<div class='section'><a id="handling-custom-renderables-for-object-overrides"></a></div>
<p>This section focuses on <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_surface_shape_u_i.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShape" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_surface_shape.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShape</a></span> which are found in Viewport 1.0 (default viewport), and the mapping of concepts to Viewport 2.0 interfaces. The focus is on <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSubSceneOverride</a></span>, and any notable differences in approach between the two interfaces are highlighted.</p>
<p>The main goal is to show how custom renderables can be instantiated for “custom” drawing.</p>
<div class='section'><a id="viewport-1.0-only-interfaces"></a><h2 id="viewport-1.0-only-interfaces">Viewport 1.0 only interfaces</h2></div>
<p>The Viewport 2.0 API only provides a rendering / drawing interface.</p>
<p>Pre-existing Viewport 1.0 interfaces should be used for selection and component handling. This includes methods such as <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::select()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#ad847ba49d36027fa9ae1184695b248b6&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::select()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::snap()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#a6589cad7b86cc9f0925b14385c609e62&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::snap()</a></span>.</p>
<p>Drawing into the UV Editor is unchanged. The existing Viewport 1.0 methods should be used, as there are no Viewport 2.0 specific interfaces for doing the same; for example, methods such as <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::drawUV()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#acd02e3ec15c17ad6aa4243492cf9ae4a&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::drawUV()</a></span>/<span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::canDrawUV()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#a2c71c259ae0919e4ef14d87e5a4c3546&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::canDrawUV()</a></span>.</p>
<p>Viewport 1.0 methods for overriding associated materials are not required for Viewport 2.0 rendering. This includes <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::material()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#a94d753f8b614df1c5408e36219c06577&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::material()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::materials()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#aebced9a23459227e5fff95e077c69804&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::materials()</a></span>.</p>
<div class='section'><a id="renderables-render-items"></a><h2 id="renderables-render-items">Renderables (render items)</h2></div>
<p>The <strong>renderable</strong> is the main element of concern.</p>
<p>For Viewport 1.0, these are represented as draw requests (<span class='code'><a href="javascript:void(0)" data-symbol="MDrawRequest" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_request.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_draw_request.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDrawRequest</a></span>). For Viewport 2.0, the closest construct to this is a <strong>render item</strong> (<span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderItem</a></span>). A collection of these can be thought of as representing the total set of renderables for an object.</p>
<p>For Viewport 1.0, there are no predefined <span class='code'>MDrawRequests</span>.</p>
<p>For Viewport 2.0, <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderItem</a></span>s that represent drawing using the assigned material(s) for an object are provided. We call these <strong>material</strong> render items. Anything not predefined by the renderer is considered to be <strong>custom</strong>.</p>
<p>The Viewport 1.0 paradigm is to create and return draw requests to the appropriate collection and then explicitly draw the requests at draw time. The Viewport 2.0 paradigm is to create, <strong>update</strong> and/or selectively <strong>override</strong> existing render items and return them to the appropriate collection for geometry update and eventual internal drawing.</p>
<p>The persistent nature of render items entails considering up-front creation of the total set of render items that will be used.</p>
<div class='section'><a id="provided-render-items"></a><h2 id="provided-render-items">Provided render items</h2></div>
<p>Viewport 2.0 renderer maintains material and bounding box render items.</p>
<ul>
<li>For material render items, only geometry requirements filling is required.</li>
<li>For bounding box render items, no additional coding is required.</li>
</ul>
<p>It is possible, but not necessary, to override the shaders used for material render items. It is also possible to disable these render items and replace them with custom render items.</p>
<p>Note that the handling of objects that do not have any shader assignments is left up to the plug-in. In Viewport 1.0, the material interfaces return a default material. In Viewport 2.0, the fallback for non-plug-in objects is to show a wireframe. Because a default wireframe render item cannot be provided, this (or an alternative appropriate fallback) must be explicitly provided by the plug-in.</p>
<div class='section'><a id="custom-render-items"></a><h2 id="custom-render-items">Custom render items</h2></div>
<p>If only material and bounding box render items are provided, then the question arises as to when additional “custom” render items may be required. This is highly dependent on the type of plug-in being written, but one common situation is the rendering of non-material render items; another the overriding of existing material or bounding box drawing.</p>
<div class='section'><a id="non-material-render-items"></a><h3 id="non-material-render-items">Non-material render items</h3></div>
<p>In general, some minimal support for wireframe display mode drawing should be implemented for a custom shape. Anything else is dependent on the plug-in and the types of additional UI elements that must be drawn.</p>
<p>The rule-of-thumb is that: each additional variation of how or when to render should result in a new render item instance. A scan of <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderItem</a></span> shows the variations possible.</p>
<p>The following are some of the main variants:</p>
<ol>
<li><p>The render item is specific to a display mode (for example, wireframe versus shaded/textured modes). It is important to note that the display mode is matched against the current display modes used for rendering and suitably filtered out as necessary. For example: a shaded mode item is not drawn when the viewport is in wireframe mode.</p>
<div class='figure'><img src='developer/images/API_white_paper_section4_4_fig67_resized.png' title=''></div>
<p>Figure 78</p>
<p>A basic pipeline showing how draw mode filtering can potentially remove items from proceeding to the draw phase. This generally supersedes any filtering that is based on whether an item is considered to be “shaded” or “non-shaded”.</p></li>
<li>The primitive type needs to be different. For example, one render draws lines and another draws points.</li>
<li>The shader instance (<span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MShaderInstance</a></span>) needs to be different. For example, usage of a stipple line shader and a solid line shader would require different render items. Refer to <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Handling-custom-renderables-for.html#choosing-shaders-and-shader-instances' title=''>4.4.4.3 Choosing shaders and shader instances</a> for more information.</li>
<li>The shader parameter values need to be different. For example, two line shader instances need to have different colors. Refer to <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Handling-custom-renderables-for.html#choosing-shaders-and-shader-instances' title=''>4.4.4.3 Choosing shaders and shader instances</a> for more information.</li>
<li><p>The depth priority needs to be different.</p>
<div class='figure'><img src='developer/images/API_white_paper_section4_4_fig68.png' title=''></div>
<p>Figure 79</p>
<p>Logical illustration of the effect of different depth priority settings that move the render item towards the active camera. “Custom” priorities can be used instead of stock ones. The arrow shows the direction of the camera (viewer).</p></li>
<li><p>The streams of geometry data required by the shader need to be different. Variations include number of streams and stream description.</p></li>
</ol>
<div class='section'><a id="pre-planning-render-item-sets"></a><h3 id="pre-planning-render-item-sets">Pre-planning render item sets</h3></div>
<p>It is advisable to pre-plan all the render items that could possibly be used at any given time during the interaction with the plug-in object. This working set of items help determine the dependent resources required, including: shaders, textures and geometry, and the amount of reuse that may be possible.</p>
<p>In general, the render item set remains fixed, with only parameter changes and enabling/disabling occurring for various items during the lifetime of the plug-in.</p>
<p>Having a large set of render items should not be a concern with respect to performance, given the assumption that variations are being created, and they are not all enabled at the same time. If large numbers of the same variation is required, then the plug-in writer may want to consider using <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSubSceneOverride</a></span> as opposed to an <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride</a></span>.</p>
<p>For UI drawing, it is best to minimize the number of overlapping elements to avoid overdraw cost. If this cannot be avoided, then it is best to determine the number of elements that may be enabled simultaneously. This drives the number of required render item variants with different depth priorities. For example, the drawing of an active line component on top of a dormant line component, on top of a wireframe requires three render items even though they may be identical in all respects except for depth priority.</p>
<p>In the case where render items are required per instance of a DAG object, it is worthwhile to keep in mind that different render items can be created per instance. It is up to the plug-in writer to maintain any explicit associations between items and instances.</p>
<div class='section'><a id="choosing-shaders-and-shader-instances"></a><h3 id="choosing-shaders-and-shader-instances">Choosing shaders and shader instances</h3></div>
<p>The options for choosing a shader for a render item can vary in complexity and application. Regardless of which option is chosen, it is best to separate shaders from geometry handling.</p>
<p>The simplest option is to use stock shaders provided via <span class='code'><a href="javascript:void(0)" data-symbol="MShaderManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MShaderManager</a></span>. These provide default configurations for shaders that can be used for <em>point</em>, <em>line</em>, and <em>triangle</em> UI drawing, as well as a few stock material shaders. Stock shader instances are specific to the primitive type; for example, a dashed line shader would be inappropriate for rendering triangles.</p>
<p>Using custom effect file shaders is also possible for greater control but requires implementations for all draw APIs (for example, DirectX11, and OpenGL). One reason for using custom shaders is to have a more complex set of parameters that can allow for dynamic updates as opposed to a larger set of static render item variants.</p>
<p>Fragment based shaders are best suited for integration with Maya&#39;s shading networks and are not recommended for UI drawing. Using built-in fragments is a simple way to get full shading and lighting support.</p>
<p>For the most flexibility, shaders should not be owned and controlled by geometry overrides but instead separate <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span>s should be used. Thus geometry overrides are <strong>geometry handlers</strong> and shader overrides are <strong>material handlers</strong>.</p>
<p>Each shader has a set of parameters and geometry requirements associated with it. Each instance of a shader has different shader parameters and/or requirements, resulting in different render items for each shader instance.</p>
<p>Depending on the frequency of updates, it may be easier to attach callbacks to <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MShaderInstance</a></span>s for parameter updating. For example, this would allow changing the thickness parameter of a line shader during a callback, as opposed to creating two separate shader instances (hence render items) with different line thickness parameter values.</p>
<p>In the case where different streams are bound to the same set of geometry requirements, different shader instances are not required, as geometry binding is performed dynamically.</p>
<div class='section'><a id="handling-change"></a><h2 id="handling-change">Handling change</h2></div>
<div class='section'><a id="handling-display-status-changes"></a><h3 id="handling-display-status-changes">Handling display status changes</h3></div>
<p>By default, the plug-in gets called to update its UI render items when the display status of the associated DAG objects changes. This occurs in the following situations:</p>
<ul>
<li>The object’s selection state changes: dormant / active / highlight, active-component are a few of the possible states.</li>
<li>The object&#39;s per object visibility or template status changes.</li>
<li>The object’s per object draw override options change.</li>
<li>The object display layer association changes or the options on associated display layer changes</li>
</ul>
<p>Selection state changes generally imply a change in the color for a render item. There can be two approaches: either multiple render items can be created for each selection state; or, a single one with sufficient shader parameters can be used. If geometry is generally shared, then the inherent cost of having multiple items is small. If the draw mode differs, then a different render item is required. For example, a different item would be used for dormant versus active wireframe as the first only draws in wireframe mode, while the latter draws in all draw modes.</p>
<p>The actual control of colors can generally be handled by utilities such as <span class='code'><a href="javascript:void(0)" data-symbol="MGeometryUtilities::wireframeColor()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#a6221bc7407b14246b14f79a751496276&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MGeometryUtilities::wireframeColor()</a></span>, which returns the correct color, taking into account current object state.</p>
<p>For object visibility, material render items are automatically handled, as are the UI render items. However, template status change can be considered to be a visibility change with respect to certain render items. For example, component render items should be manually disabled to be consistent with Maya’s internal behaviour. <span class='code'><a href="javascript:void(0)" data-symbol="MGeometryUtilities::displayStatus()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#aa2838b92c9f7db4a810690a986199134&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MGeometryUtilities::displayStatus()</a></span> is a utility which is useful for checking status.</p>
<p>For draw overrides (exposed in the Attribute Editor Draw Overrides tab), template control needs to be handled as well as custom color overrides. The same utilities mentioned above may be used.</p>
<p>Display layers can invoke updates for templating, as well as color overrides.</p>
<p>Any additional items that are not controlled via Maya have its own internal plug-in logic and corresponding update logic. For example, adding the display of face centers could be an attribute on the node that drives the display of a custom render item to show these centers.</p>
<div class='section'><a id="handling-of-display-mode-changes"></a><h3 id="handling-of-display-mode-changes">Handling of display mode changes</h3></div>
<p>By default, an override is not called when the display mode for rendering changes. This is important to know as this means that all render items for all possible display modes need to be taken into consideration. The recommended approach is to create all render items with the appropriate parameters and handle any updates not related to display mode as required at “update” time.</p>
<p>An important difference between geometry overrides and sub-scene overrides is that sub-scene overrides receive constant update calls where a frame context is provided. In this case, render items can be created or modified on-demand.</p>
<div class='section'><a id="general-state-monitoring"></a><h3 id="general-state-monitoring">General state monitoring</h3></div>
<p>For general events that occur in Maya, it is up to the plug-in to determine which events to monitor and determine if they require a custom render item update. For example, view-dependent render items need to perform their own camera monitoring (for example, via <span class='code'>MUIMessage</span>).</p>
<div class='section'><a id="geometry-handling"></a><h3 id="geometry-handling">Geometry handling</h3></div>
<p>Custom render items are named and thus there is a set of named render items to manage. There is also the possibly of the requirement for geometry streams of the same semantic but with different names.</p>
<p>For example, two streams of positions (semantic) may be required for the case where a material render item draw and a render item that draws face normal are required. The first could be named “My shaded item” and the second “My face center item”. The latter could call <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::setShader()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#ad283b157fa4f6c40bceb9d398c53a72a&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderItem::setShader()</a></span> with a custom stream name of “face center”.</p>
<p>Additionally, as no explicit association is given between streams and render items, it can sometimes be useful to name streams if it is required that they be used for specific custom render items. There are trade-offs, as each named stream may result in additional geometry data and indexing allocation being required. Also, geometry updates must handle the fact that stream naming is per render item. That is, it applies to all streams for an item. An example usage is given in <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Handling-custom-renderables-for.html#basic-component-handling' title=''>4.4.5.5 Basic component handling</a>.</p>
<div class='figure'><img src='developer/images/API_white_paper_section4_4_fig69_resized.png' title=''></div>
<p>Figure 80</p>
<p>The figure above shows three render items on the left. The top-most item is for drawing face centers. It requires only positions and has a custom name of &quot;face center&quot;. Next is an item to draw active vertices and requires positions and has a custom stream name of &quot;Active Vertices&quot;. The last is a material render item which requires positions and normal. There are no custom names. When the final cumulative set of requirements comes back for which the override must provide geometry, there are descriptions for 4 streams of data required (<span class='code'><a href="javascript:void(0)" data-symbol="MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBufferDescriptor</a></span>): 3 position streams and one normal stream. The position streams could be shared for material and active vertex display.</p>
<p>No assumptions should be made as to when data is required, and as such, all requirements should always be fulfilled. The renderer may attempt to provide some default data if the appropriate data is not provided, but there is no guarantee that the appropriate data can be provided. For example, one viewport panel may require the data for a wireframe render item in addition to a shaded one if the viewport configuration has one panel in shaded mode and the other with wire-on-shaded mode enabled. The shaded render item may require tangents to be provided.</p>
<div class='section'><a id="basic-component-handling"></a><h3 id="basic-component-handling">Basic component handling</h3></div>
<p>When components have been modified, an override should extract the appropriate component information from the plug-in object at DG evaluation time. For example, component indexing could be cached. (For <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride</a></span>, this is during <span class='code'>updatedDG()</span>). This indexing can be used to provide the primitive indexing for the render items associated with the supported component. For example, for a single indexed component such as vertices, the vertex identifiers could be cached.</p>
<p>For each component type, the override can have one or more render items created depending on the display variations required (For <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride</a></span>, this is during <span class='code'>updateRenderItems()</span>). In the aforementioned vertex component example, there can be one item for displaying unselected vertices and one item for selected vertices. Each, for example, can have a different color, size and/or depth priority (if they overlap).</p>
<p>A stock shader instance appropriate for point drawing could be associated with each render item. The unselected vertex render item would only apply when in wireframe mode so that draw mode should be associated with it. The selected vertex render item would be set to draw in shaded, texture and wireframe modes since it can be seen in all of these modes. By default, the items would be enabled when vertex display is enabled, or when the object’s display status is in “hilite” mode.</p>
<p>At geometry update time (for <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride</a></span>, this is during <span class='code'>populateGeometry()</span>), the appropriate stream data is requested based on the shader geometry requirements. Depending on the component indexing evaluated previously, the appropriate primitive indexing needs to be created/updated.</p>
<p>For sub-scene overrides, the entire transaction would be handled in the <span class='code'>update()</span> method.</p>
<p>As an example of using named streams, one position stream may be used for unselected drawing and another for selected vertex drawing. On the plus side, the number of selected vertices could be small resulting in reduced indexing and data transfer. On the minus side, an additional stream needs to be allocated, increasing memory cost. Re-using the same stream would mean re-using the same memory, with the potential for complex indexing computation and overdraw.</p>
<div class='section'><a id="custom-ui-drawing-example"></a><h2 id="custom-ui-drawing-example">Custom UI drawing example</h2></div>
<p>As an example, a plug-in can create custom render items for the following:</p>
<ul>
<li>Dormant wireframe draw</li>
<li>Active wireframe draw</li>
<li>Dormant vertex draw</li>
<li>Active vertex draw</li>
<li>Shaded template wireframe draw</li>
<li>Proxy drawing when no shader is assigned to the DAG object</li>
</ul>
<div class='figure'><img src='developer/images/API_white_paper_section4_4_fig70.png' title=''></div>
<p>Figure 81</p>
<p>Green boxes represent areas that the plug-in would create and manage. White boxes are provided by the renderer.</p>
<p>The following are example parameters of the items illustrated above and their proposed update frequency:</p>
<ul>
<li>Depth priority: Uniqueness of the item depends on this parameter; so, would be set at creation time.</li>
<li>Draw mode: Uniqueness of the item depends on this parameter; so, would be set at creation time. Just as the active and dormant wireframe items would be set to only show in wireframe mode, a shaded template wireframe item is specifically created to handle drawing of template wireframe when in shaded mode.</li>
<li>Color: This is a shader parameter that can be dynamically set at render item update time. As an example, the color would update depending on the current object display status.</li>
<li>Point size: For the same reasons as color, this can be dynamically set at render item update time.</li>
</ul>
<p>The crescent “container” shows how logically both geometry and subscene override render items are collected into a set of render items. The main difference is that subscene override container classes are explicitly exposed in the API.</p>
<p>The following are some example user workflows and how the plug-in could handle their render items:</p>
<ol>
<li>User goes into component selection mode while in shaded mode:
<ol>
<li>The object is in highlight mode so the dormant wireframe item should be enabled and the color set appropriately.</li>
<li>The dormant vertex render item should be enabled and the color set appropriately.</li>
<li>The active wireframe item should be disabled.</li>
<li>The active vertex item should be disabled.</li>
<li>The shaded template item should be disabled.</li>
<li><p>The shaded proxy item should be disabled.</p>
<blockquote>
<p><strong>Note:</strong> The material shaded item is enabled internally, and was enabled when entering into shaded mode.</p>
</blockquote></li>
</ol></li>
<li>The user then selects some vertices:
<ol>
<li>The active vertex item should be enabled. The active components should be parsed to set the appropriate indexing to show a subset of vertices.</li>
</ol></li>
<li>The user switches back to object selection mode:
<ol>
<li>Dormant and active vertex items are disabled.</li>
<li>Active wireframe item is enabled.</li>
<li>The dormant wireframe item is disabled.</li>
</ol></li>
<li>The user switches to wireframe mode:
<ol>
<li>“Nothing” needs to be done in the plug-in as the render items marked to draw in shaded mode are filtered out in the draw pipeline.</li>
</ol></li>
<li>The user sets the object override to make the object template:
<ol>
<li>If there are any custom material render items, they should be disabled. Provided material render items are automatically disabled.</li>
<li>The dormant and active wireframe items should be disabled.</li>
<li>The dormant vertex item should be disabled.</li>
<li>The shaded template item should be enabled and set to the appropriate color depending on whether or not the object is active.</li>
</ol></li>
</ol>
<div class='figure'><img src='developer/images/API_white_paper_section4_4_fig71.png' title=''></div>
<p>Figure 82</p>
<p>From top to bottom, and left to right are the five actions listed above, shown graphically. At all times, all the render items are retained with basic enabling and disabling occurring as well as possible parameter changes such as color. Items in green are enabled while all other render items are disabled.</p>
<p>For geometry overrides, the majority of the handling is done in <span class='code'>updateRenderItems()</span>, for sub-scene overrides in <span class='code'>update()</span>. The SDK plug-in <strong>apiMeshShape</strong> contains example code which contains logic to support workflows like the above, as well as many “standard” workflows.</p>
<div class='section'><a id="custom-materials"></a><h2 id="custom-materials">Custom materials</h2></div>
<p>If custom material rendering is required, then the level of integration is dependent on the interfaces that are used. The following table outlines the main trade-offs associated with each interface. Increased flexibility generally requires more work to be done by the plug-in writer. To a certain extent, simpler shaders can be maintained inside the geometry handler/override.</p>
<p><span class='code'>Fragment</span>, <span class='code'>Effects</span>, and <span class='code'>Stock</span> are options available via the shader manager, and hence supported options are determined by the internal renderer. <span class='code'>Shader Override</span> is <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span>.</p>
<table cellpadding="0" cellspacing="0" class="not-ruled"><colgroup><col> <col> <col> <col> <col> </colgroup><tbody><tr class="not-ruled-odd-row"><td class="table-body">&nbsp;</td><td class="table-body"><em class="strong">Fragment Shader</em></td><td class="table-body"><em class="strong">Effects Shader</em></td><td class="table-body"><em class="strong">Stock Shader</em></td><td class="table-body"><em class="strong">Shader Override</em></td></tr><tr class="not-ruled-even-row"><td class="table-body">Flexibility : Complexity ratio</td><td class="table-body">High : High</td><td class="table-body">Medium : Low</td><td class="table-body">Low : Low</td><td class="table-body">High : High</td></tr><tr class="not-ruled-odd-row"><td class="table-body">Use case</td><td class="table-body"><a name="GUID-195FD156-172A-4515-875E-7AD44CF3A3F1"></a><p class="table-body">Generally used to enhance the set of existing fragments.</p><a name="GUID-5E6B0A04-ECFB-4841-81F4-4DC12855513D"></a><p class="table-body">Can be used as “stock” shader but more complex to set up appropriate shading network.</p><a name="GUID-7E0DDA34-D3D7-4341-B9A4-C809404EBC25"></a><p class="table-body">All internal semantic bindings supported.</p></td><td class="table-body">Self-contained effect which can use default semantic bindings.</td><td class="table-body"><a name="GUID-CFC94058-6A26-4966-B8A7-BA3635C69EDB"></a><p class="table-body">Simple built in effect is “good enough”.</p><a name="GUID-870EA2AC-7D5E-461F-A8AD-30E7F106FA50"></a><p class="table-body">Useful when plug-in does not want to deal with writing complex UI shaders to replace any previously easy-to-write fixed-function code.</p></td><td class="table-body">Complex shading support is required beyond what the internal renderer can provide; for example, tessellation shaders.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Render item “type”</td><td class="table-body">Custom.</td><td class="table-body">Custom.</td><td class="table-body">Custom.</td><td class="table-body">Non-Custom.</td></tr><tr class="not-ruled-odd-row"><td class="table-body">Shading graph support</td><td class="table-body"><a name="GUID-D648A865-ABE1-4014-A04C-C8B913235CC5"></a><p class="table-body">If using individual fragments, none.</p><a name="GUID-69940340-5C8E-4957-B4CE-F8FA1F0A0F23"></a><p class="table-body">If the fragment shader is used in a node as part of a Maya shader tree, then it is fully integrated. If the fragment shader is used to create an <span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MShaderInstance</a></span> then there is no explicit support.</p></td><td class="table-body">None.</td><td class="table-body">None.</td><td class="table-body">Plug-in determined.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Lighting support</td><td class="table-body">Integrated.</td><td class="table-body">No automatic binding.</td><td class="table-body">Ignored by design.</td><td class="table-body">Plug-in binds via access to draw context.</td></tr><tr class="not-ruled-odd-row"><td class="table-body">Post effects support</td><td class="table-body">Integrated.</td><td class="table-body">Not integrated.</td><td class="table-body">Ignored by design.</td><td class="table-body">Plug-in provides techniques to support various passes required by effects.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Draw API Support</td><td class="table-body">If custom, requires implementation for each draw API, otherwise API agnostic.</td><td class="table-body">Plug-in writer writes versions for APIs to support.</td><td class="table-body">Built-in.</td><td class="table-body">Plug-in writer writes versions for APIs to support.</td></tr><tr class="not-ruled-odd-row"><td class="table-body">Shader stages supported</td><td class="table-body">Vertex, Pixel.</td><td class="table-body">Vertex, Pixel, Geometry.</td><td class="table-body">Not exposed.</td><td class="table-body">Determined by plug-in.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Separation from geometry handler (override)</td><td class="table-body">Can be used for shader instances on render items created by geometry handler.</td><td class="table-body">Can be used for shader instances on render items created by geometry handler.</td><td class="table-body">Can be used for shader instances on render items created by geometry handler.</td><td class="table-body">Independent from geometry handling.</td></tr></tbody></table>
<p>When dealing with material items, there are generally render items that have “shaded” or “shaded and textured” draw modes being passed to an override. There can be 0 or more sets of these passed in, depending on the number of materials that are assigned to the DAG object.</p>
<div class='figure'><img src='developer/images/API_white_paper_section4_5_7_fig80.png' title=''></div>
<p>Figure 83</p>
<p>In this example, a DAG object has 2 shaders assigned to different components on the DAG object. It is possible to have 4 “material” render items: one for each component shader to draw in “shaded” draw mode, and one for each component shader to draw in “shaded and textured” mode.</p>
<p>Parameters on these render items can be used as is, modified, or they can be disabled. If disabled, then the plug-in is responsible for providing replacements. If no replacement is provided, then the object appears to “disappear” when in shaded and/or textured modes. Depending on the type of replacement, different levels of integration may result.</p>
<p>When the shader handling complexity for certain render items reaches a point where an <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span> is required, then the complexity of the geometry handler is reduced, and it only fulfills the geometry requirements for these render items.</p>
<p>For example, the plug-in may require only a built-in Blinn shader with some pre-set shading configuration that is fully integrated. A stock fragment shader can be used in this case. In another example, tessellation may be required for a hair shader. In this case, it is best to not control this from inside the geometry handler and instead create a custom <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span> “hair shader node” which “feeds” render items to a custom “hair geometry node” override.</p>
<div class='figure'><img src='developer/images/API_white_paper_section4_4_fig73.png' title=''></div>
<p>Figure 84</p>
<p>The various possible options are all shown at once.</p>
<p>The renderer provided (material) render item is shown uncoloured. There could be a mix of internal shaders and plug-in shaders used to derive these items. Some nodes may supply a custom fragment shader or a shader override may be associated. The geometry handler (override) receives these as non-custom render items.</p>
<p>Custom render items (in green) can be instantiated with shader instances which are created via the shader manager using <span class='code'>fragment</span>, <span class='code'>stock</span> or <span class='code'>effects files</span> interfaces.</p>
<div class='section'><a id="ui-draw-manager"></a><h2 id="ui-draw-manager">UI Draw Manager</h2></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MUIDrawManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MUIDrawManager</a></span> class provides a convenience interface for queuing additional UI drawing that are generally not associated with being part of an object. The “drawables” which may be queued can be thought of as being roughly equivalent to render items.</p>
<p>A direct implication of using the manager is that the “drawables” are never persistent and as such, the number of drawables queued via this interface should be kept relatively small. If more items are required or the data content is large, then interfaces such as the <span class='code'>mesh()</span> call be used. Custom render items are otherwise recommended.</p>
<p>For example, for drawing a large number of vertices on a plug-in object, a custom render item would be recommended over drawing individual points in the draw manager. However for drawing a 3d or 2d label on an object, the draw manager would be a better choice.</p>
<p>One other aspect to consider is that the UI drawn via the manager may draw at a fixed place within the overall pipeline and with a more rigid set of pre-defined drawing properties.</p>
<div class='section'><a id="effects-and-context-interaction"></a><h2 id="effects-and-context-interaction">Effects and context interaction</h2></div>
<p>By default, render items used for UI drawing (lines, points) are excluded from scene effects such as screen-space ambient occlusion, motion blur, and depth-of-field. Additionally, they do not, in general, cast or receive shadows. Render items using internal material shader instances participate in these effects.</p>
<p>Effects drawing is performed within some drawing context.</p>
<p>Geometry overrides are never passed any context information and their behaviour is for the most part independent of context (shader callbacks being the exception). Subscene overrides are provided with context but only a frame context which does not provide access to a pass context. Thus, any items should work independently of the pass from which they are being called.</p>
<div class='section'><a id="viewport-1.0-viewport-2.0-comparison-chart"></a><h2 id="viewport-1.0-viewport-2.0-comparison-chart">Viewport 1.0 / Viewport 2.0 comparison chart</h2></div>
<table cellpadding="0" cellspacing="0" class="not-ruled"><colgroup><col> <col> <col> </colgroup><tbody><tr class="not-ruled-odd-row"><td class="table-body">&nbsp;</td><td class="table-body"><em class="strong">Viewport 1.0</em></td><td class="table-body"><em class="strong">Viewport 2.0</em></td></tr><tr class="not-ruled-even-row"><td class="table-body">Custom renderable creation</td><td class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MDrawInfo::getPrototype()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_info.html#a7056c15c87746a72e32634d684694bc0&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDrawInfo::getPrototype()</a></span></td><td class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MRenderItem::Create()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#ac74a014f3346d8ddac693b7f034fa228&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderItem::Create()</a></span></td></tr><tr class="not-ruled-odd-row"><td class="table-body">Custom renderable deletion</td><td class="table-body">Draw requests are transient and released internally every refresh.</td><td class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MRenderItem::Destroy()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a52cc993ee0ac8e3718904a1e4537e9f3&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderItem::Destroy()</a></span></td></tr><tr class="not-ruled-even-row"><td class="table-body">Queuing renderables</td><td class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::getDrawRequests()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#a27dc15d8c360596ae16b5f3fbd236625&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::getDrawRequests()</a></span></td><td class="table-body"><a name="GUID-2953ED3C-986E-4739-AE18-DB3885E85CDF"></a><p class="table-body"><span class="code" translate="no">MPxGeometryOverride::updatedDG()</span> and <span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MPxGeometryOverride::updateRenderItems()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#abad8e8b1f0e06eea32e2be8f97200941&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride::updateRenderItems()</a></span>.</p><a name="GUID-FAC24746-7035-4B0F-9557-F402B3FD1597"></a><p class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride::update()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html#ac74e57c764a59c2fa2a8e6a5b72090d5&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSubSceneOverride::update()</a></span></p></td></tr><tr class="not-ruled-odd-row"><td class="table-body">Rendering</td><td class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::draw()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#adb2bed7a0e37f8760ff6e48bce677443&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::draw()</a></span></td><td class="table-body">Not applicable. Rendering is done by the renderer.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Material handling</td><td class="table-body">Template fixed function material provided. Can be overridden at will.</td><td class="table-body"><a name="GUID-4F672FC6-9D5B-4477-BA3D-436F4D1A79D0"></a><p class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MShaderInstance</a></span> based. Parameters modifiable at update time. Shader binding (rebinding) to render items possible.</p><a name="GUID-9703C409-1ED6-437F-A1AF-2B861428FF3F"></a><p class="table-body">More complex / decoupled material handling should be done via <span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span>.</p></td></tr><tr class="not-ruled-odd-row"><td class="table-body">Display Mode Handling</td><td class="table-body">Display mode is provided as input and can be ignored at will.</td><td class="table-body">Draw modes are intrinsic part of a render item. Internal logic prune items based on display mode membership.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Geometry Requirements Interface</td><td class="table-body">No concept.</td><td class="table-body"><a name="GUID-16829389-A27D-4CD4-8E5F-C5885AB04118"></a><p class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MPxGeometryOverride::populateGeometry()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#a37c7a59c1e34ed5e0528fe0ac351b519&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride::populateGeometry()</a></span></p><a name="GUID-249F52E8-7562-4C27-BE7C-EF1928CA1CAE"></a><p class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride::setGeometryForRenderItem()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html#a0bf2b383d48c8a4b554376626e4c7a40&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSubSceneOverride::setGeometryForRenderItem()</a></span></p></td></tr><tr class="not-ruled-odd-row"><td class="table-body">Geometry Requirements Filling</td><td class="table-body">No concept.</td><td class="table-body">Explicit stream naming possible for different render items resulting in additional buffer and index handling.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Bounding box draw</td><td class="table-body">Internally controlled.</td><td class="table-body">Internally controlled.</td></tr><tr class="not-ruled-odd-row"><td class="table-body">Ghosting Control</td><td class="table-body">Multiple draw calls are made for single set of draw requests.</td><td class="table-body">Plug-in controlled. Single set of calls for all ghosts.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Shadow Casting / Receiving</td><td class="table-body">Control via the "cast" and "receives" attributes on the object, if they exist. Otherwise, no control.</td><td class="table-body">Control per custom render item, as applicable.</td></tr><tr class="not-ruled-odd-row"><td class="table-body">Display Status Query</td><td class="table-body">Display status information passed in as part of <span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MDrawInfo" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_info.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_draw_info.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDrawInfo</a></span>.</td><td class="table-body">Display status can be queried from <span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDagPath</a></span>, <span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MGeometryUtilities" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_geometry_utilities.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MGeometryUtilities</a></span>.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Component Management</td><td class="table-body">Passable to draw requests. Plug-in performs management.</td><td class="table-body">Component information can be passed to draw with appropriate render items. Viewport 1.0 interfaces perform component management.</td></tr><tr class="not-ruled-odd-row"><td class="table-body">Visibility Handling</td><td class="table-body">Prune requests when queuing draw requests or drawing.</td><td class="table-body">Plug-in enables / disables render items as required, or sets draw mode to use internal draw mode filtering.</td></tr><tr class="not-ruled-even-row"><td class="table-body">UV Rendering</td><td class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::drawUV()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#acd02e3ec15c17ad6aa4243492cf9ae4a&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::drawUV()</a></span></td><td class="table-body">No concept. Uses Viewport 1.0 interface.</td></tr><tr class="not-ruled-odd-row"><td class="table-body">Selection</td><td class="table-body"><span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MPxSurfaceShapeUI::select()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_surface_shape_u_i.html#ad847ba49d36027fa9ae1184695b248b6&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSurfaceShapeUI::select()</a></span></td><td class="table-body">No concept. Uses Viewport 1.0 interface.</td></tr><tr class="not-ruled-even-row"><td class="table-body">Selection Status Query</td><td class="table-body">Information found in the <span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MDrawInfo" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_info.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_draw_info.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDrawInfo</a></span> class indicates if drawing is occurring for the selection.</td><td class="table-body">Selection is not part of Viewport 2.0, so not applicable.</td></tr><tr class="not-ruled-odd-row"><td class="table-body">User interaction feedback</td><td class="table-body">Some information is available via <span class="code" translate="no"><a href="javascript:void(0)" data-symbol="MDrawInfo" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_info.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_draw_info.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDrawInfo</a></span>.</td><td class="table-body">Plug-in explicitly monitors for user events of interest.</td></tr></tbody></table>
<div class='section'><a id="sample-code"></a><h2 id="sample-code">Sample code</h2></div>
<p>The <em>apiMeshShape</em> developer kit example takes into account a number of workflows related to UI handling as well as for proxy shader handling.</p>
<div class='figure'><img src='developer/images/API_white_paper_section4_4_fig74.png' title=''></div>
<p>Figure 85</p>
<p><em>apiMeshShape</em> sample scene in wireframe mode.</p>
<div class='figure'><img src='developer/images/API_white_paper_section4_4_fig75.png' title=''></div>
<p>Figure 86</p>
<p><em>apiMeshShape</em> sample scene in shaded mode.</p>
<p>The above snapshots demonstrate a number of different custom render items being used. All objects except the planes and the IK chain are drawn using the same plug-in. Included are:</p>
<ul>
<li>Dormant wire items :
<ul>
<li>blue wireframes using default dormant color</li>
<li>red and green wireframes using display layer color</li>
<li>black wireframe using “draw override” color</li>
<li>grey wireframe on template object in wireframe mode</li>
<li>pink wireframe on active-affected object (affected by IK chain)</li>
</ul></li>
<li>Active wire items:
<ul>
<li>White wireframe for lead object.</li>
</ul></li>
<li>Shaded template item:
<ul>
<li>grey wireframe in shaded mode</li>
</ul></li>
<li>Provided material:
<ul>
<li>Red, green, blue, pink Blinn and grey Lambert shaded items</li>
</ul></li>
<li>Proxy shaded item:
<ul>
<li>“Rainbow” colored color-per-vertex dashed line wireframe item</li>
</ul></li>
</ul>
<div class='section'><a id="sample-code-for-active-wireframe-handling"></a><h3 id="sample-code-for-active-wireframe-handling">Sample code for active wireframe handling</h3></div>
<p>The following code demonstrates the handling of an “active wireframe” render item from within <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride::updateRenderItems()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#abad8e8b1f0e06eea32e2be8f97200941&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride::updateRenderItems()</a></span>. The code logic would be similar if used with <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxSubSceneOverride</a></span>, except that the render item would belong to the container (<span class='code'>MPxSubSceneContainer</span>) instead of an <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItemList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_item_list.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderItemList</a></span>.</p>
<p>The following is an example method used to set the color parameter on a shader:</p>
<div class="codeBlock"><pre class="prettyprint">// Utility to set the color on a shader instance.
void setSolidColor(<a href="javascript:void(0)" data-symbol="MHWRender::MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MShaderInstance</a>* shaderInstance, const float *value)
{
  if (!shaderInstance)
    return;
  const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> colorParameterName = &quot;solidColor&quot;;
  shaderInstance-&gt;setParameter(colorParameterName, value);
}
</pre></div><p>During <span class='code'>updateRenderItems()</span>, a new “active” wireframe item is created if it does not already exist. If a new wireframe is created, then the draw mode is set to “all” modes and the item is set to draw above any shaded render item.</p>
<div class="codeBlock"><pre class="prettyprint">// **\*****\*****\*****\*****\**** Update during updateRenderItems() **\*****\*****\******
…
// Unique name for active wireframe
<a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> fSelectedWireframeItemName = “selectedWireframeName”;
// Create the item once. Use enable/disable toggle to control when it should
// be drawn (below)
<a href="javascript:void(0)" data-symbol="MHWRender::MRenderItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MRenderItem</a>* selectItem = NULL;
int index = list.indexOf( // list = MRenderItemList passed as an input argument
    fSelectedWireframeItemName,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kLines" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea9808e481c6346dfc333afb4c52890ac9&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kLines</a>, // Type of primitive is lines 
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kAll" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a8d857bf5569760ac7306382a558cb092&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kAll</a>); // Draw in all display modes
if (index &lt; 0)
{
    static const bool raiseAboveShaded = true;
    selectItem = <a href="javascript:void(0)" data-symbol="MHWRender::MRenderItem::Create" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#ac74a014f3346d8ddac693b7f034fa228&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MRenderItem::Create</a>(
        fSelectedWireframeItemName,
        <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kLines" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea9808e481c6346dfc333afb4c52890ac9&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kLines</a>,
        <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kAll" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a8d857bf5569760ac7306382a558cb092&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kAll</a>,
        raiseAboveShaded);
    // This is the same as setting the argument raiseAboveShaded = true,
    // since it sets the priority value to be the same. This line is just
    // an example of another way to do the same thing after creation of
    // the render item.
    selectItem-&gt;depthPriority( <a href="javascript:void(0)" data-symbol="MHWRender::MRenderItem::sActiveWireDepthPriority" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#adb484c507442ebce56eac38bd07cac07&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MRenderItem::sActiveWireDepthPriority</a>);
    list.append(selectItem);

    // Choose an line shader to match primitive type
    <a href="javascript:void(0)" data-symbol="MHWRender::MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MShaderInstance</a>* shader = 
        shaderMgr-&gt;getStockShader( <a href="javascript:void(0)" data-symbol="MHWRender::MShaderManager::k3dSolidShader" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a1f7c5db8a3b5804c6ffce5f305bf51a8a7a0eb28b48e8f9ed6f666b52a27a45f5&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MShaderManager::k3dSolidShader</a> );
    if (shader)
    {

        // Assign shader
        selectItem-&gt;setShader(shader);
        // Once assigned, no need to hold on to shader instance
        shaderMgr-&gt;releaseShader(shader);
    }
}
else
{
    selectItem = list.itemAt(index);
}


</pre></div><p>Based on the display status, during each update, the color for the wireframe item is updated. It switches colors based on statuses such as <span class='code'>lead</span>, <span class='code'>active</span>, <span class='code'>highlight</span>, and <span class='code'>active-component</span>.</p>
<div class="codeBlock"><pre class="prettyprint">// Perform updates on the render item parameters. In this case
// update the shader instance.
//
<a href="javascript:void(0)" data-symbol="MHWRender::MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MShaderInstance</a>* shader = NULL;
if (selectItem)
{
    shader = selectItem-&gt;getShader();
}

// Check the current display status of the object and color to use for this
// instance of the object.
<a href="javascript:void(0)" data-symbol="MHWRender::DisplayStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bca&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::DisplayStatus</a> displayStatus = 
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometryUtilities::displayStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#aa2838b92c9f7db4a810690a986199134&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometryUtilities::displayStatus</a>(path);
<a href="javascript:void(0)" data-symbol="MColor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_color.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MColor</a> wireColor = <a href="javascript:void(0)" data-symbol="MHWRender::MGeometryUtilities::wireframeColor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#a6221bc7407b14246b14f79a751496276&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometryUtilities::wireframeColor</a>(path);

// It is not necessary to use the colors provided and instead a custom color could be 
// used if (fUseCustomColors) is set.
bool fUseCustomColors = false;
switch (displayStatus) {
case MHWRender::kLead:
    selectItem-&gt;enable(true);
    if (shader)
    {
        static const float theColor[] = { 0.0f, 0.8f, 0.0f, 1.0f };
        setSolidColor( shader, !fUseCustomColors ? &amp;(wireColor.r) : theColor );
    }
    break;
case MHWRender::kActive:
    if (shader)
    {
        static const float theColor[] = { 1.0f, 1.0f, 1.0f, 1.0f };
        setSolidColor( shader, !fUseCustomColors ? &amp;(wireColor.r) : theColor );
    }
    selectItem-&gt;enable(true); // Enable if the object is active
    break;
case MHWRender::kHilite:
case MHWRender::kActiveComponent:
    if (shader)
    {
        static const float theColor[] = { 0.0f, 0.5f, 0.7f, 1.0f };
        setSolidColor( shader, !fUseCustomColors ? &amp;(wireColor.r) : theColor );
    }
    selectItem-&gt;enable(true); // Enable if the object is hilite, or 
                                  // its components are active.

    break;
default:
    // Otherwise make sure to disable it. The item is still present, it will just
    // not be sent down the rendering pipeline to draw.
    selectItem-&gt;enable(false);
    break;
};

</pre></div><div class='section'><a id="sample-code-for-active-vertex-handling"></a><h3 id="sample-code-for-active-vertex-handling">Sample code for active vertex handling</h3></div>
<p>The following is sample code for handling of an “active vertex” render item from within <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride::updateRenderItems()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#abad8e8b1f0e06eea32e2be8f97200941&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride::updateRenderItems()</a></span>. There is a separate utility method which checks display status to determine whether or not the component render item should be disabled.</p>
<p>The test also considers if there are any active vertices, which is determined during DG update time (<span class='code'>updatedDG()</span>).</p>
<p>Note that this code path has been written to allow for named streams to be used. Inside the <span class='code'>populateGeometry()</span> method, these named streams can be checked and a different set of positions can be used to draw active vertices with.</p>
<p>The following code executes during DG update time. It gets the component list from the object and caches the element IDs in an integer array.</p>
<div class="codeBlock"><pre class="prettyprint">/**\*** Call in MPxGeometryOverride::updatedDG() to perform any DG operations ****/
void updateDG()
{
    fActiveVertices.clear(); // fActiveVertices is an <a href="javascript:void(0)" data-symbol="MIntArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_int_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MIntArray</a> 
    
    <a href="javascript:void(0)" data-symbol="MObjectArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MObjectArray</a> clist = // Get the active vertex components – plug-in specific ;
    if (clist.length())
    {
        <a href="javascript:void(0)" data-symbol="MFnSingleIndexedComponent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_single_indexed_component.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MFnSingleIndexedComponent</a> fnComponent( clist[0] );
        if (fnComponent.elementCount())
        {
            // Cache the vertex identifiers for later usage.
            fnComponent.getElements( fActiveVertices );
        }
    }
}
</pre></div><p>The following utility tests to determine whether or not to hide components:</p>
<div class="codeBlock"><pre class="prettyprint">/* Test to see if active components should be enabled.
           Based on active vertices + non-template state
*/
bool enableActiveComponentDisplay(const <a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_dag_path.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDagPath</a> &amp;path) const
{
    bool enable = true;

    // If no active components then disable the active
    // component render item
    if (fActiveVertices.length() == 0)
    {
        enable = false;
    }
    else
    {
        // If there are components then we need to check
        // either the display status of the object, or
        // in the case of a templated object make sure 
        // to hide components to be consistent with how
        // internal objects behave
        //
        <a href="javascript:void(0)" data-symbol="MHWRender::DisplayStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bca&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::DisplayStatus</a> displayStatus = 
            <a href="javascript:void(0)" data-symbol="MHWRender::MGeometryUtilities::displayStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#aa2838b92c9f7db4a810690a986199134&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometryUtilities::displayStatus</a>(path);
        if (displayStatus == <a href="javascript:void(0)" data-symbol="MHWRender::kTemplate" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bcaa6bb0a85723422491e296021425470b5e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::kTemplate</a> ||
            displayStatus == <a href="javascript:void(0)" data-symbol="MHWRender::kActiveTemplate" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bcaa9c6881453a663753048e212084859338&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::kActiveTemplate</a>)
        {
            enable = false;
        }
        else
        {
            // Do an explicit path test for templated
            // since display status does not indicate this.
            if (path.isTemplated())
                enable = false;
        }
    }
    return enable;
}

</pre></div><p>During <span class='code'>updateRenderItems()</span>, the appropriate item is created as needed to draw in &quot;all&quot; modes. The depth priority is set to avoid being obscured by dormant vertices and any wireframe items. The item is enabled based on whether or not components should be displayed.</p>
<div class="codeBlock"><pre class="prettyprint">…
// Unique name identifier for the render item
<a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> fActiveVertexItemName = “activeVertexItemName”;
<a href="javascript:void(0)" data-symbol="MHWRender::MRenderItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MRenderItem</a>* activeItem = NULL;
int index = list.indexOf(
    fActiveVertexItemName,
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kPoints" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea57a311fc6dd7498f2339ab45af414377&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kPoints</a>,// Primitive type is points.
    <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kAll" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a8d857bf5569760ac7306382a558cb092&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kAll</a>); // Render item should display in all display modes.
if (index &lt; 0)
{
    activeItem = <a href="javascript:void(0)" data-symbol="MHWRender::MRenderItem::Create" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#ac74a014f3346d8ddac693b7f034fa228&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MRenderItem::Create</a>(
        fActiveVertexItemName,
        <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kPoints" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea57a311fc6dd7498f2339ab45af414377&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kPoints</a>,
        <a href="javascript:void(0)" data-symbol="MHWRender::MGeometry::kAll" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a8d857bf5569760ac7306382a558cb092&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometry::kAll</a>,
        false);
    // Set depth priority to be active point. This should offset it 
    // to be visible above items with &quot;dormant point&quot; priority.
    activeItem-&gt;depthPriority( <a href="javascript:void(0)" data-symbol="MHWRender::MRenderItem::sActivePointDepthPriority" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#ac0ade2503ccc47f3bd487b9ae7bf53e4&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MRenderItem::sActivePointDepthPriority</a> );
    list.append(activeItem);

    <a href="javascript:void(0)" data-symbol="MHWRender::MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MShaderInstance</a>* shader = shaderMgr-&gt;getStockShader(
        <a href="javascript:void(0)" data-symbol="MHWRender::MShaderManager::k3dFatPointShader" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a1f7c5db8a3b5804c6ffce5f305bf51a8a6790e2efa2fa44e937ae5f9986c27e38&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MShaderManager::k3dFatPointShader</a> );
    if (shader)
    {
        // Set the point size parameter. Make it slightly larger for active
        // vertices
        static const float pointSize = 5.0f;
        setSolidPointSize( shader, pointSize );

        // Assign shader. Use a named stream if we want to supply a different
        // set of &quot;shared&quot; vertices for drawing active vertices
        bool fDrawSharedActiveVertices = true;
        <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> fActiveVertexStreamName = “activeVertexStreamName”;
        if (fDrawSharedActiveVertices)
        {
            activeItem-&gt;setShader(shader, &amp;fActiveVertexStreamName );
        }
        else
        {
            activeItem-&gt;setShader(shader, NULL);
        }

        // once assigned, no need to hold on to shader instance
        shaderMgr-&gt;releaseShader(shader);
    }
}
else
{
    activeItem = list.itemAt(index);
}

// Update the color and enable / disable the render item as appropriate.
// Just using a fixed color and not checking display status.
bool enableActiveDisplay = enableActiveComponentDisplay( &lt;dagpath&gt; );
if (activeItem)
{
    <a href="javascript:void(0)" data-symbol="MHWRender::MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MShaderInstance</a>* shader = activeItem-&gt;getShader();
    if (shader)
    {
        // Set active color
        static const float theColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };
            setSolidColor( shader, theColor); // See code for active 
                    // wireframe for this code utility.
    }

    activeItem-&gt;enable( enableActiveDisplay );
}
</pre></div><p>The following is part of the code logic for handling the custom named stream in <span class='code'>populateGeometry()</span>. The key part of the code is the checking of the vertex buffer descriptor name to see if it matches the name set when calling <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::setShader()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#ad283b157fa4f6c40bceb9d398c53a72a&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MRenderItem::setShader()</a></span> during <span class='code'>updateRenderItems()</span> above. The plug-in is then free to fill in the data, and create the appropriate indexing structure for the render item with the name matching the value stored in the variable: <em>fActiveVertexItemName</em>.</p>
<div class="codeBlock"><pre class="prettyprint">const <a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptorList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptorList</a>&amp; descList =
        requirements.vertexRequirements();
int numVertexReqs = descList.length();
<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a> desc;
for (int reqNum=0; reqNum&lt;numVertexReqs; reqNum++)
{
    if (!descList.getDescriptor(reqNum, desc))
    {
        continue;
    }

    // Fill in vertex data for drawing active vertex components 
    //
    if (fDrawSharedActiveVertices &amp;&amp; (desc.name() == fActiveVertexStreamName))
    switch (desc.semantic())
    {
        case MHWRender::MGeometry::kPosition:
        {
            if (!activeVertexPositionBuffer)
            {
                activeVertexPositionBuffer = data.createVertexBuffer(desc);
                if (activeVertexPositionBuffer)
                {
                   // Allocate a position buffer to fit the # of active vertices
                   unsigned int activeVertexCount = fActiveVertices.length()
                   activeVertexPositions =
                      (float*)activeVertexPositionBuffer&gt;acquire(
                              activeVertexCount, 
                              true 
                              /*writeOnly*/             
                }
            }
        }
        break;

        default:
            break;
    }
}
</pre></div>      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

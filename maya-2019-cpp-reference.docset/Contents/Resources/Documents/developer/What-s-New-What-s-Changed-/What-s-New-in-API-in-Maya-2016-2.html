<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../style/prettify.css" type="text/css" rel="stylesheet">
<script type="text/javascript" src="../../scripts/prettify.js"></script><script src="../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="generator" content="pandoc"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../../scripts/utils/adsk.redirect.js"></script>
      <title>What&#39;s New in API in Maya 2016</title>
   <meta name="contextid" content="WHATS_NEW_API_2016"><meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script></script><script></script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>What&#39;s New in API in Maya 2016</h1>
         </div>

<div class='section'><a id="whats-new-in-api-in-maya-2016"></a></div>
<p>The Maya 2016 Developer Kit is now available online at Autodesk Exchange at <a href='https://apps.exchange.autodesk.com/MAYA/en/Home/Index' title='' target='_blank'>https://apps.exchange.autodesk.com/MAYA/en/Home/Index</a>.</p>
<p>Jump to the following sections:</p>
<ul>
<li><a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html#rendering' title=''>Rendering</a></li>
<li><a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html#component-selection' title=''>Component selection</a></li>
<li><a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html#animation' title=''>Animation</a></li>
<li><a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html#modeling' title=''>Modeling</a></li>
<li><a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html#profiler' title=''>Profiler</a></li>
<li><a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html#64-bit-integer-support' title=''>64-bit integer support</a></li>
<li><a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html#general' title=''>General</a></li>
<li><a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html#removed-classes' title=''>Removed classes</a></li>
<li><a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html#-net-api' title=''>.NET API</a></li>
</ul>
<div class='section'><a id="api-compatibility"></a><h2 id="api-compatibility">API compatibility</h2></div>
<p>Maya 2016 Extension 2 is not binary compatible with Maya 2016. To obtain the Maya 2016 and Maya 2016 Extension 1 API Guide, see <a href='http://www.autodesk.com/me-sdk-docs-2016' title='' target='_blank'>http://www.autodesk.com/me-sdk-docs-2016</a>.</p>
<p>C++ plug-ins that were compiled against Maya 2016 or Maya 2016 Extension 1, including Maya 2016 service pack releases, must be re-compiled against Maya 2016 Extension 2 in order to be recognized by this version of Maya.</p>
<p>In addition, plug-ins compiled against Maya 2016 Extension 2 will either not load or exhibit unpredictable behavior if loaded in Maya 2016, Maya 2016 Extension 1, or any Maya 2016 service pack release.</p>
<div class='section'><a id="python-api-2.0"></a><h2 id="python-api-2.0">Python API 2.0</h2></div>
<p>Since Extension for Maya 2015, 23 new classes have been added to the Python API 2.0 and additional developer kit examples are also available in the <span class='code'>plug-ins\scripted</span> directory of the Maya Developer Kit. All Python API 2.0 developer kit examples are named with the prefix <span class='code'>py</span>.</p>
<p>For a list of Python classes added since Extension for Maya 2015, see <a href='#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2/New-Python-API-2-0-classes-in-2.html' title=''>New Python API 2.0 classes in Maya 2016</a>.</p>
<p>The Python Learning Path is updated to include Python API 2.0 examples.</p>
<p>For more information, see Maya Python API 2.0 Reference.</p>
<div class='section'><a id="rendering"></a><h2 id="rendering">Rendering</h2></div>
<div class='section'><a id="openmayarender"></a><h3 id="openmayarender">OpenMayaRender</h3></div>
<p>UI Draw Manager Enhancements</p>
<ul>
<li><p>The ordering of the calls made through the UI manager interface is now consistent with the ordering used for the legacy default viewport</p></li>
<li>Convenience methods have been added to draw large sets of points or lines:
<ul>
<li><span class='code'>points (const <a href="javascript:void(0)" data-symbol="MPointArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_point_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_point_array.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPointArray</a>&amp; points, bool draw2D)</span> for drawing points in 2d or 3d</li>
<li><span class='code'>lineList (const <a href="javascript:void(0)" data-symbol="MPointArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_point_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_point_array.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPointArray</a>&amp; points, bool draw2D)</span> for drawing a list of line segments (1 pair of points per segment) in 2d or 3d</li>
<li><span class='code'>lineStrip (const <a href="javascript:void(0)" data-symbol="MPointArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_point_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_point_array.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPointArray</a>&amp; points, bool draw2D)</span> for drawing a line strip (connected line segments) in 2d or 3d</li>
<li>The <em>uiDrawManager</em> developer kit example has been modified to include the option to draw using these three new interfaces.</li>
</ul></li>
<li><p>To support the drawing of internally specified icons, the following interfaces have been added:</p>
<ul>
<li><span class='code'>icon( const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> &amp;iconName, float scale )</span> : This method draws a single icon with the specified name and 3d scale.</li>
<li><span class='code'>getIconNames( <a href="javascript:void(0)" data-symbol="MStringArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStringArray</a> &amp;iconNames )</span> : This static method allows plug-ins to query the list of available icon names to use with the <span class='code'>icon()</span> method.</li>
</ul>
<p>The <em>uiDrawManager</em> developer kit example has been modified to include the option to draw an icon per locator, as well as the ability to choose the icon name and scale factor from the Attribute Editor. The icon option appears in the UI Type drop-down list and an Icon Parameters section is available that contains drop-down lists for the Icon and Icon Scale attributes.</p>
<p>This image shows the drawing of a set of icons, where each icon is a locator created using the <em>uiDrawManager</em> developer kit example.</p>
<div class='figure'><img src='developer/images/MUIDrawManager_Icons_resized.png' title=''></div></li>
</ul>
<p>MShaderInstance Enhancements</p>
<ul>
<li>Added functions to query the value of an annotation that is associated with a given uniform: <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::annotationAsInt()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a6ac8f4963e622a8c5e90b239b43e4053&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::annotationAsInt()</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::annotationAsFloat()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#ac0df7133a628e2f3b4b133b3bdf68357&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::annotationAsFloat()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::annotationAsString()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#ab599917ae85e9ae38c4c3420b241005d&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::annotationAsString()</a></span>. These functions take the name of the parameter and the name of the annotation as input.</li>
<li>Added function <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::parameterSemantic()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a3745b5e21757c70121874f7bfbbf510f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::parameterSemantic()</a></span> to query the semantic of a given uniform parameter.</li>
<li>Added function <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::parameterDefaultValue()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a5720d0407f69d7a901202c3f662c7673&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::parameterDefaultValue()</a></span> to query the initial value of a uniform. This value can be set in the effects file when initializing a uniform.</li>
<li>Added function <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::resourceName()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a631564a83982f06e34c0bfcf85418977&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::resourceName()</a></span> to retrieve the name of a texture from the effects file. The resource name can be specified in the effects file using the <span class='code'>ResourceName</span> annotation.</li>
<li>Added functions <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::uiWidget()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a832b4dcdaca5b69433b92681f87261c9&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::uiWidget()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::uiName()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#aa876e5b0cec80084b3b00e71023aa0e1&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::uiName()</a></span> to retrieve the widget type and the UI name of a parameter. These can be specified using the <span class='code'>UIWidget</span> and <span class='code'>UIName</span> annotations in the effects file.</li>
<li>Added functions <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::techniqueAnnotationAsString()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#ab4cdd5188b6d83e53ffe09840a57f76e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::techniqueAnnotationAsString()</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::techniqueAnnotationAsInt()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a1bca5978f5c6c2741d75e84a53e22edc&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::techniqueAnnotationAsInt()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::techniqueAnnotationAsFloat()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a9be279f0ab8714207daf0d0c0197e36d&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::techniqueAnnotationAsFloat()</a></span> to query the current technique annotation value.</li>
<li>Added functions <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::passAnnotationAsString()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a4423c31344cd4836118db5fc5d8a5093&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::passAnnotationAsString()</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::passAnnotationAsInt()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a16c9aaa7a390ceddf9c28dabb872425e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::passAnnotationAsInt()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::passAnnotationAsFloat()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a23b861baf75e6e04a427f0f9d5d0d3de&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::passAnnotationAsFloat()</a></span> to retrieve pass annotation values.</li>
</ul>
<p>MShaderManager Enhancements</p>
<ul>
<li>Added function <span class='code'><a href="javascript:void(0)" data-symbol="MShaderManager::getEffectsTechniques()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a67d96162d64617bc3299f75cd7c13dff&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderManager::getEffectsTechniques()</a></span>. This function takes an effects file name as input and returns a list of all techniques that are defined in the effects file.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MShaderManager::getEffectsFileShader()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a581c659670f0e3168750382c61a91a25&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderManager::getEffectsFileShader()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MShaderManager::getEffectsTechniques()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a67d96162d64617bc3299f75cd7c13dff&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderManager::getEffectsTechniques()</a></span> now accept the use of compiled DX11 FX files (<span class='code'>.fxo</span>)</li>
</ul>
<p>MRenderItem Enhancements</p>
<ul>
<li>Added a new <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::RenderItemType" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::RenderItemType</a></span> <span class='code'>OverrideNonMaterialItem</span>, which corresponds to internal (non material) items for which the default shader effect has been overridden by an <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride</a></span></li>
<li>Added functions <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::availableShaderParameters()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a5a6a1b1d1c5ea0c20e8c1bd4af494cf9&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::availableShaderParameters()</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::getShaderBoolParameter()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#af46934e943ed250ed5e0debff7ff3d25&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::getShaderBoolParameter()</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::getShaderIntParameter()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a5d0c11952deda4b25f9b490620fe2034&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::getShaderIntParameter()</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::getShaderFloatParameter()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a859f4b66ae4574cfa3c683f3bfa26d57&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::getShaderFloatParameter()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::getShaderFloatArrayParameter()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a70a11ae313e27dea9015dbf7baf58428&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::getShaderFloatArrayParameter()</a></span>. These functions may be used on <span class='code'>OverrideNonMaterialItem</span> to retrieve outstanding shader parameters that this item overrides (such as the default color, the line width and the point size).</li>
<li>Added function <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::setShaderFromNode()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a1f821e0772346c0567396a67bb5fee7b&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::setShaderFromNode()</a></span>, which sets the shader instance to a render item by evaluating the shading network of a surface shader node (either standard or custom) in the scene.</li>
<li>Added function <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::isShaderFromNode()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a2d1a4a42bc868748d574acbe644677a1&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::isShaderFromNode()</a></span>, which returns true if the shader instance was set by evaluating the shading network of a surface shader node (either standard or custom) in the scene via the <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::setShaderFromNode()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a1f821e0772346c0567396a67bb5fee7b&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::setShaderFromNode()</a></span> method.</li>
<li>Added a definition for the callback function <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::LinkLostCallback" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#add4c63eeebc656e8a6495b725bb7a545&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::LinkLostCallback</a></span>, which is triggered when the shader instance assigned by <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::setShaderFromNode()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a1f821e0772346c0567396a67bb5fee7b&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::setShaderFromNode()</a></span> is no longer valid.</li>
</ul>
<p>Shader Fragment Enhancements</p>
<ul>
<li><p>XML schema files are now available as part of the install in the <span class='code'>..bin/ShadeFragment</span> folder of the Maya installation.</p>
<p><span class='code'>v2pFragment.xsd</span> is the XML schema for shading fragments, and can also be found in <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/XML-Schema/XML-Schema-for-Shading-Fragments.html' title=''>XML Schema for Shading Fragments</a>.</p>
<p><span class='code'>vp2FragmentGraph.xsd</span> is the XML schema for fragment graphs, and can be found in <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/XML-Schema/XML-Schema-for-Fragment-Graphs.html' title=''>XML Schema for Fragment Graphs</a>.</p></li>
<li>The <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/XML-Schema/XML-Schema-for-Shading-Fragments.html' title=''>XML Schema for Shading Fragments</a> topic has been updated, and the <xs:simpletype name="LanguageType"> section now includes the line <xs:enumeration value="GLSL"></xs:enumeration>. This line was added because Maya 2016 now supports GLSL fragments.</xs:simpletype></li>
<li>The <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/XML-Schema/XML-Schema-for-Fragment-Graphs.html' title=''>XML Schema for Fragment Graphs</a> topic has been updated, and the <xs:complextype name="ConnectionListType"> section of the schema has an additional line <xs:attribute name="name" type="xs:string"></xs:attribute> added.</xs:complextype></li>
<li>The <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/XML-Schema/XML-file-for-fragment-graph-of-a.html' title=''>XML file for fragment graph for phong1</a> topic provides an example XML file of the fragment graph for a shading network rooted at phong1.</li>
<li>If a software shader has attributes with names that match the following, and no shader override is specified, then an attempt is made to automatically map these values for display in Viewport 2.0. This feature is provided in addition to the already supported attributes. See <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/XML-Schema/XML-file-for-fragment-graph-of-a.html' title=''>XML file for fragment graph for phong1</a> for more information.
<ul>
<li>translucence: A float attribute type</li>
<li>translucenceFocus: A float attribute type</li>
<li>translucenceDepth : A float attribute type</li>
<li>matteOpacity : A float attribute type</li>
<li>mattOpacityMode : A 16, or 32 bit, or enum attribute type</li>
</ul></li>
</ul>
<p>MFrameContext Enhancements</p>
<ul>
<li><p>Added new <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext::getHwFogParameters()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#aa4e74730699e09cec07f3b59fd2679e8&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext::getHwFogParameters()</a></span> method, which allows users to obtain global fog parameters from the frame context. The method returns <span class='code'>struct <a href="javascript:void(0)" data-symbol="HwFogParams" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/struct_m_h_w_render_1_1_m_frame_context_1_1_hw_fog_params.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">HwFogParams</a></span> which includes the following information: whether hardware fog is enabled, hardware fog mode, fog start, fog end, fog density, and fog color.</p>
<p>See also <a href='#!/url=./developer/Viewport-2-0-API/Semantics-and-annotations.html#hardware-fog-specific-semantics' title=''>Hardware fog specific semantics</a> and <a href='#!/url=./developer/Viewport-2-0-API/Shader-semantics-supported-by.html' title=''>Shader semantics supported by Viewport 2.0</a>.</p></li>
<li>Added new <span class='code'>DisplayStyle</span> enums <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext::kFlatShaded" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#a1b68f8823b8e275a4b548fdd27263e8aa7914d385424ca72fdf84654b735a5a50&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext::kFlatShaded</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext::kShadeActiveOnly" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#a1b68f8823b8e275a4b548fdd27263e8aaafc1312afe4b53aa0b4a0b818c377bfc&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext::kShadeActiveOnly</a></span> to <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext</a></span>, which can be returned by the <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext::getDisplayStyle()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#acd5ce60bbd3d03181b1ad681023ff44d&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext::getDisplayStyle()</a></span> function. They correspond to the Flat Shade All and Smooth Shade Selected Items and Flat Shade Selected Items viewport modes.</li>
<li><p>Added new <span class='code'>LightingMode</span> enums <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext::kNoLighting" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#a3cea85bd9127b51d9ff35de2ffc9ca33a23f675b8ac97f8350246910f2a586854&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext::kNoLighting</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext::kCustomLights" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#a3cea85bd9127b51d9ff35de2ffc9ca33afcd1e26ffe489f8430486075d15534f9&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext::kCustomLights</a></span> to <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_frame_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext</a></span>, which can be returned by the <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext::getLightingMode()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#a376f1eeaa26e24a893afacff7db169bc&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext::getLightingMode()</a></span> function. They refer to the Use No Lights viewport lighting mode, and custom lights that can be used in the Hypershade Material Viewer panel.</p></li>
</ul>
<p>MDrawContext Enhancements</p>
<ul>
<li>Added new pass semantic for selection: <span class='code'><a href="javascript:void(0)" data-symbol="MPassContext::kSelectionPassSemantic" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_pass_context.html#a728fc00f0764227a6f345c089058c998&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPassContext::kSelectionPassSemantic</a></span>. This pass only occurs during Viewport 2.0 selection and for <span class='code'><a href="javascript:void(0)" data-symbol="MRenderItem::OverrideNonMaterialItem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49ea1fcf574a73eba1a959c51838083573e4&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderItem::OverrideNonMaterialItem</a></span>s, so that the <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride</a></span> can select the proper effect/pass.</li>
</ul>
<p>MRenderOverride Enhancements</p>
<ul>
<li>If an override has defined custom <span class='code'><a href="javascript:void(0)" data-symbol="MUserRenderOperation" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_user_render_operation.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUserRenderOperation</a></span>s, any previously bound vertex buffers are now unbound before the user operation is invoked. Previously, it was up to the user operation to perform this unbind.</li>
<li><p>Previously, when an <span class='code'><a href="javascript:void(0)" data-symbol="MRenderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderOverride</a></span> does not set override render targets, the targets that were used were of a preset (fixed) format.</p>
<p>This behavior has been changed to use instead the Viewport 2.0 rendering options for Float Point Render Target and Multisample Anti-aliasing. You can find these settings by selecting Renderer &gt; Viewport 2.0 &gt; <img src='developer/images/optbox.png' title=''> to open the Hardware Renderer 2.0 Settings window, and expanding the Anti-aliasing and Floating Point Render Target categories; or, by selecting Render &gt; Render Settings to open the Render Settings window and clicking the Maya Hardware 2.0 tab, then expanding the Anti-aliasing and Floating Point Render Target categories.</p>
<p>For example, if a floating point format of R32G32B32A32_FLOAT is chosen, then the color render target will attempt to use the same floating point format.</p>
<p>If a plug-in wishes to use the previous fixed format, than it can define a single color target with format MHWRender::kR8G8B8A8_UNORM, and a single depth target with format MHWRender::D42S8.</p></li>
<li><p>The <em>viewRenderOverrideFrameCache</em> developer kit plug-in has been modified to output floating point EXR images which can be used in conjunction with setting a floating point format to get unclamped color image output.</p></li>
<li>Added <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::kNoLight" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#afbcfbcd49fe6e70be75e490e66514acaa7a55544fd7212e394647e2cb1588b072&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::kNoLight</a></span> to <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::MLightingMode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#afbcfbcd49fe6e70be75e490e66514aca&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::MLightingMode</a></span> that allows the user to set Use No Lights mode in a scene render override.</li>
<li><p>Added <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::kFlatShaded" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#ab8a13d92b9d32fb0cc8309b66e0f05b9a7914d385424ca72fdf84654b735a5a50&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::kFlatShaded</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::kShadeActiveOnly" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#ab8a13d92b9d32fb0cc8309b66e0f05b9aafc1312afe4b53aa0b4a0b818c377bfc&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::kShadeActiveOnly</a></span> to <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::MDisplayMode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#ab8a13d92b9d32fb0cc8309b66e0f05b9&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::MDisplayMode</a></span>. <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::kTextured" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#ab8a13d92b9d32fb0cc8309b66e0f05b9a17e882561d8db0dedc215d0d4978e887&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::kTextured</a></span> is now an individual enum that can be used together with <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::kShaded" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#ab8a13d92b9d32fb0cc8309b66e0f05b9a3ba47eb2caff6eea24d37de5f572f769&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::kShaded</a></span> or <span class='code'><a href="javascript:void(0)" data-symbol="MSceneRender::kFlatShaded" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_scene_render.html#ab8a13d92b9d32fb0cc8309b66e0f05b9a7914d385424ca72fdf84654b735a5a50&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSceneRender::kFlatShaded</a></span>. These changes allow more control over the display modes the user can set in a scene render override.</p>
<p>Updated the function <span class='code'>viewRenderSceneRender::displayModeOverride()</span> in the <em>viewRenderOverride</em> developer kit example (<span class='code'>viewRenderOverrideOperations.cpp</span>) to show the use of <span class='code'>kFlatShaded</span> and <span class='code'>kShadeActiveOnly</span>.</p></li>
</ul>
<p>MRenderOperation Enhancements</p>
<ul>
<li>The return type of <span class='code'><a href="javascript:void(0)" data-symbol="MRenderOperation::targetOverrideList()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_operation.html#a6e61af973ca8990c8c1a389f60a31798&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderOperation::targetOverrideList()</a></span> has been changed from <span class='code'><a href="javascript:void(0)" data-symbol="MRenderTarget" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderTarget</a>**</span> to <span class='code'><a href="javascript:void(0)" data-symbol="MRenderTarget" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderTarget</a>* const*</span>. Maya will not change the individual <span class='code'><a href="javascript:void(0)" data-symbol="MRenderTarget" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_target.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderTarget</a>*</span> pointers in the returned list.</li>
</ul>
<p>MRenderUtilities Enhancements</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtilities::acquireSwatchDrawContext()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_utilities.html#a740208508edba7934a27816decbb9570&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtilities::acquireSwatchDrawContext()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtilities::acquireUVTextureDrawContext()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_utilities.html#ab9589288e0f14cffca1b6da7d262631d&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtilities::acquireUVTextureDrawContext()</a></span> now take color and depth targets as optional parameters. Passing valid targets also ensures that the correct GL context is made active on GL and core profile Viewport 2.0 devices.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtilities::releaseDrawContext()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_utilities.html#a5222892109760efc845e37469b0f6cb4&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtilities::releaseDrawContext()</a></span> now takes an optional parameter that releases the draw targets previously used in the <span class='code'>acquireSwatchDrawContext()</span> and <span class='code'>acquireUVTextureDrawContext()</span> functions mentioned above.</li>
<li><p>New <span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtilities::renderMaterialViewerGeometry()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_utilities.html#a73c521cb743ed9cc5a595f29d7428e91&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtilities::renderMaterialViewerGeometry()</a></span> method has been added that allows swatch rendering to be drawn by leveraging the Viewport 2.0 implementation of the Material Viewer in the Hypershade.</p>
<p>There are 3 ways to implement swatch rendering using the new API:</p>
<ol>
<li><p>Call <span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtilities::renderMaterialViewerGeometry()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_utilities.html#a73c521cb743ed9cc5a595f29d7428e91&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtilities::renderMaterialViewerGeometry()</a></span> from <span class='code'><a href="javascript:void(0)" data-symbol="MPxHardwareShader::renderSwatchImage()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hardware_shader.html#a765f8d7c0499e87180ff884b6967550e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxHardwareShader::renderSwatchImage()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxHwShaderNode::renderSwatchImage()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html#a765f8d7c0499e87180ff884b6967550e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxHwShaderNode::renderSwatchImage()</a></span> with <span class='code'>meshSphere</span> as the <span class='code'>shape</span> parameter, <span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtilities::kPerspectiveCamera" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_utilities.html#af9563ae2bd890aa0fb7782f626e35bc7a2cec741abb80798c163d0aea01676163&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtilities::kPerspectiveCamera</a></span> as the <span class='code'>cameraMode</span> parameter, and <span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtilities::kSwatchLight" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_utilities.html#ad15b3d1fb21d3d61911ada0e2bc9b12bab22f7d3eb3e3131a6e8876dccaf3e934&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtilities::kSwatchLight</a></span> as the <span class='code'>lightRig</span> parameter to render a swatch.</p>
<p>You can also use <span class='code'>meshPlane</span> as the <span class='code'>shape</span> parameter and <span class='code'>kOrthogonalCameraCloseUp</span> as the <span class='code'>cameraMode</span> to generate UV editor images from <span class='code'><a href="javascript:void(0)" data-symbol="MPxHardwareShader::renderImage()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hardware_shader.html#afc0b543d630b77f3019e3759323673f8&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxHardwareShader::renderImage()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxHwShaderNode::renderImage()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_hw_shader_node.html#a6b406fc429c85d0cda4dfb62e1177ea5&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxHwShaderNode::renderImage()</a></span>.</p></li>
<li>Leave <span class='code'>renderSwatchImage()</span> unimplemented.</li>
<li><p>Return <span class='code'><a href="javascript:void(0)" data-symbol="MStatus::kNotImplemented" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a598e4c5d4c234c1bf09367d64487519c&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus::kNotImplemented</a></span> with the implementation of <span class='code'>renderSwatchImage()</span>.</p>
<p>In cases 2 and 3, Maya uses this API to render a default swatch.</p>
<p>The following developer kit example plug-ins have been updated accordingly:</p>
<ul>
<li>Rendering a default swatch: <em>glslShader</em></li>
<li>Explicit calling <span class='code'>renderMaterialViewerGeometry()</span>: <em>hwPhongShader</em>, <em>hwColorPerVertexShader</em>, <em>pyHwColorPerVertexShader</em></li>
</ul></li>
</ol></li>
</ul>
<p>MPxSubSceneOverride Enhancements</p>
<ul>
<li>Setting of user defined buffers via the <span class='code'><a href="javascript:void(0)" data-symbol="MVertexBuffer::resourceHandle()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MVertexBuffer::resourceHandle()</a></span> interface has been fixed.</li>
<li>Added <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride::hasUIDrawables()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html#a05c70618c28196399681a784a3686b50&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSubSceneOverride::hasUIDrawables()</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride::areUIDrawablesDirty()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html#a1a45ac429d66ab11ed4711b1883c14cb&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSubSceneOverride::areUIDrawablesDirty()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride::addUIDrawables()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html#a51c18131d1daa15aa761a09d622d9061&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSubSceneOverride::addUIDrawables()</a></span> to draw simple UI shapes such as lines, circles, text, and so forth.
<ul>
<li>If <span class='code'>addUIDrawables()</span> is overridden, then <span class='code'>hasUIDrawables()</span> must also be overridden to return true.</li>
<li>If <span class='code'>areUIDrawablesDirty()</span> returns true, then UI drawables are cleared and re-added every refresh. If the method returns false, then UI drawables persist and are preserved until either the DAG object associated with the override is destroyed or the override is deregistered.</li>
<li>The UI drawables do not support instancing draw and transform instances.</li>
<li>The <em>apiMeshShape</em> developer kit example (<span class='code'>apiMeshSubSceneOverride.cpp</span>) demonstrates use of these functions.</li>
</ul></li>
</ul>
<p>MRenderTarget Enhancements</p>
<ul>
<li>Static method <span class='code'><a href="javascript:void(0)" data-symbol="MRenderTarget::freeRawData()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target.html#a6b4905a078e2df36267243846cd7d8aa&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderTarget::freeRawData()</a></span> has been added to allow for plug-ins which are compiled in debug mode to safely free the memory allocated by <span class='code'><a href="javascript:void(0)" data-symbol="MRenderTarget::rawData()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_target.html#a8056533f17e149f6113c5b6c72e55c5f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderTarget::rawData()</a></span>.</li>
</ul>
<p>MTexture Enhancements</p>
<ul>
<li>Static method <span class='code'><a href="javascript:void(0)" data-symbol="MTexture::freeRawData()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html#a2a951b968863961b1681e894d24ed4ee&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture::freeRawData()</a></span> has been added to allow for plug-ins which are compiled in debug mode to safely free the memory allocated by <span class='code'><a href="javascript:void(0)" data-symbol="MTexture::rawData()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture.html#ae99c4e325062e162a32dfd435d81725c&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTexture::rawData()</a></span>.</li>
</ul>
<p>MTextureManager Enhancements</p>
<ul>
<li><p>A new version of <span class='code'><a href="javascript:void(0)" data-symbol="MTextureManager::acquireTexture()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a04aa3cfef217948abc8edd0f19565f95&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTextureManager::acquireTexture()</a></span> has been added that acquires a texture from a file on disk.</p>
<p><span class='code'>MTextureManager::acquireTexture(const MTextureArgments&amp; args)</span> takes the new class <span class='code'><a href="javascript:void(0)" data-symbol="MTextureArguments" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_arguments.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTextureArguments</a></span> as its input parameter. Using <span class='code'><a href="javascript:void(0)" data-symbol="MTextureArguments" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_arguments.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTextureArguments</a></span>, you can provide the arguments (such as file path and mip map levels) for the texture that needs to be obtained.</p>
<p>Essentially, the new <span class='code'>MTextureManager::acquireTexture(const MTextureArgments&amp; args)</span> is almost identical to the existing <span class='code'>MHWRender::MTextureManager::acquireTexture (const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> &amp; textureName, const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> &amp; contextNodeFullName, int mipmapLevels = 0, bool useExposureControl = true, const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> &amp; layerName = MString(), int alphaChannelIdx = -1)</span> . However, it has added one functionality. It can accept a file texture node that is required if you want to activate texture background loading. You can set the file texture node through the constructor of <span class='code'><a href="javascript:void(0)" data-symbol="MTextureArguments" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_arguments.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTextureArguments</a></span> or through the method <span class='code'><a href="javascript:void(0)" data-symbol="MTextureArguments::setFileTextureNode()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_texture_arguments.html#ac1ef5310e158fc1056d346afc434af94&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTextureArguments::setFileTextureNode()</a></span>.</p>
<p>See the <em>Parallel mode</em> description in the <em>Material Loading Mode</em> documentation in the <em>Display preferences</em> topic of the <em>Maya User Guide</em> for more information.</p></li>
</ul>
<p>MPxDrawOverride Enhancements</p>
<ul>
<li>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxDrawOverride::boundingBox()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_draw_override.html#ae897c759784349c81707df07c34e0846&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxDrawOverride::boundingBox()</a></span> function has been changed from a pure virtual function to a virtual function, so that users are not required to always provide an override implementation. The default implementation returns a huge bounding box that will never be culled.</li>
</ul>
<p>MPxShaderOverride Enhancements</p>
<p>The following new method allows plug-in writers to supply a shader to be used in non-textured mode. If this method is not specified, then a fixed grey shader is always used:</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MHWRender::MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHWRender::MShaderInstance</a> * MHWRender::MPxShaderOverride::nonTexturedShaderInstance ( bool &amp; monitorNode )</span></li>
<li>This <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride::nonTexturedShaderInstance()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#addc154cb86dafb4b95301938d97659d8&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride::nonTexturedShaderInstance()</a></span> method returns an override shader instance to be used when drawing in non-textured mode. If NULL is returned, then an internally defined, non-modifiable shader instance is used. Setting the <span class='code'>monitorNode</span> parameter on the method to return true indicates that the associated shader node requires monitoring to call back to the override during the update phase.</li>
<li>See <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Effect-Overrides.html' title=''>Effect Overrides</a> for more information.</li>
<li>New function <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride::overridesNonMaterialItems()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html#a09c032b89513ada1a3c21260c42ea0da&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride::overridesNonMaterialItems()</a></span> that allows the shader to replace the default effect for a non material item (that is, wireframe, edge/vertex components, and so forth). This can be useful for shader overrides that have displacement.</li>
</ul>
<p>MVertexBuffer and MIndexBuffer Enhancements</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MVertexBuffer::resourceHandle()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MVertexBuffer::resourceHandle()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MIndexBuffer::resourceHandle()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MIndexBuffer::resourceHandle()</a></span> are now supported in DirectX11 mode in Viewport 2.0</li>
<li><p>The SubSceneOverride version of the <em>apiMeshShape</em> developer kit example has been updated to demonstrate use of these methods.</p>
<p>You can test the SubSceneOverride version of the plug-in by following these steps:</p>
<ol>
<li>In line 2289 of <span class='code'>apiMeshShape.cpp</span>, set <span class='code'>sUseSubSceneOverride</span> to true</li>
<li>Re-compile the plug-in.</li>
<li>Start Maya in DirectX 11 mode in Viewport 2.0. (Select this option in the Display section of the Preferences window). Ensure that <span class='code'>apiMeshShape.mll</span> is located within the folders specified in the MAYA_PLUG_IN_PATH environment variable.</li>
<li><p>Run following MEL commands</p>
<div class="codeBlock"><pre class="prettyprint">loadPlugin apiMeshShape;
createNode apiMesh;
createNode apiMeshCreator;
connectAttr apiMeshCreator1.outputSurface apiMesh1.inputSurface ;
sets -edit -forceElement initialShadingGroup |transform1|apiMesh1;</pre></div></li>
<li><p>Switch Viewport 2.0 to bounding box mode, and you will see that the bounding box displays correctly.</p></li>
</ol></li>
</ul>
<div class='section'><a id="component-selection"></a><h3 id="component-selection">Component selection</h3></div>
<p>MPxGeometryOverride Enhancements</p>
<ul>
<li>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride::refineSelectionPath()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#a134d9274d060a8deb679db8408419cab&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride::refineSelectionPath()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride::updateSelectionGranularity()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#a35db327011e850bc4f290c65fdc8d8fd&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride::updateSelectionGranularity()</a></span> functions have been added to support component selection in Viewport 2.0.</li>
</ul>
<p>MDrawRegistry Enhancements</p>
<ul>
<li>The <span class='code'><a href="javascript:void(0)" data-symbol="MDrawRegistry::registerComponentConverter()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_registry.html#ac76651be69e4645ee8e741049dd183ed&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawRegistry::registerComponentConverter()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MDrawRegistry::deregisterComponentConverter()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_registry.html#a56780f99f287625aef1d60eb5c6a0e03&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawRegistry::deregisterComponentConverter()</a></span> functions have been added to support component selection in Viewport 2.0</li>
</ul>
<p>MPxSubSceneOverride Enhancements</p>
<ul>
<li>Added <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride::updateSelectionGranularity()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html#a35db327011e850bc4f290c65fdc8d8fd&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSubSceneOverride::updateSelectionGranularity()</a></span> for component selection in Viewport 2.0</li>
</ul>
<p>New classes: <span class='code'><a href="javascript:void(0)" data-symbol="MSelectionContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_selection_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_selection_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSelectionContext</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MIntersection" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_intersection.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_intersection.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MIntersection</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MSelectionInfo" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_selection_info.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_selection_info.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSelectionInfo</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxComponentConverter" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_component_converter.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_component_converter.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxComponentConverter</a></span> were added to support component selection in Viewport 2.0.</p>
<p>Note: The new component selection classes and interfaces only take into effect if either of the following conditions are true, in which case hardware selection is enabled:</p>
<ul>
<li>If you are running Maya in core profile mode</li>
<li>If you have set the environment variable MAYA_USE_HARDWARE_SELECTION = 1</li>
</ul>
<div class='section'><a id="utilities-enhancements"></a><h3 id="utilities-enhancements">Utilities Enhancements</h3></div>
<ul>
<li><p>Several methods have been added to <span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtil" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_render_util.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtil</a></span> for accessing the constant noise lookup table that Maya uses to compute many built in procedural textures (for example, Noise, Fractal, Volume Noise, Solid Fractal, and so forth).</p></li>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MGeometryUtilities::acquireReferenceGeometry()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#ac0ef7cdb96768bdde887e4720419ee62&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGeometryUtilities::acquireReferenceGeometry()</a></span> has been fixed so that when <span class='code'><a href="javascript:void(0)" data-symbol="MGeometryUtilities::releaseReferenceGeometry()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_utilities.html#ab050d473690fac85ffa49ebea3aef7ff&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGeometryUtilities::releaseReferenceGeometry()</a></span> is called, the memory will be properly freed.</p></li>
</ul>
<div class='section'><a id="manipulators-enhancements"></a><h3 id="manipulators-enhancements">Manipulators Enhancements</h3></div>
<ul>
<li><p>Added a new variation of the <span class='code'><a href="javascript:void(0)" data-symbol="MUIDrawManager::beginDrawable()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_u_i_draw_manager.html#a9008ebfa63c02670625076230d77c3f9&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUIDrawManager::beginDrawable()</a></span> method: <span class='code'>beginDrawable(unsigned int name, bool nameIsPickable)</span> which allows manipulator picking in a manner similar to <span class='code'><a href="javascript:void(0)" data-symbol="MPxManipulatorNode::colorAndName()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manipulator_node.html#af6847ca152390a76463fb8437e449971&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipulatorNode::colorAndName()</a></span>.</p></li>
<li><p>Added new method <span class='code'><a href="javascript:void(0)" data-symbol="MPxManipulatorNode::shouldDrawHandleAsSelected()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_manipulator_node.html#a914c7fe5a8fc9cc7bf2b565f094fc140&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxManipulatorNode::shouldDrawHandleAsSelected()</a></span> which queries if a manipulator handle should be drawn as selected/highlighted in Viewport 2.0.</p></li>
</ul>
<div class='section'><a id="varying-parameters-enhancements"></a><h3 id="varying-parameters-enhancements">Varying parameters Enhancements</h3></div>
<ul>
<li>Added new <span class='code'>colorset</span> semantic to shading node override fragment. A 4-float <span class='code'>colorset</span> varying parameter represents the vertex color. It is identical to the semantic <span class='code'>fcolor</span>, except that multiple <span class='code'>colorset</span> varying parameters are supported. See <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Shading-Node-Overrides.html' title=''>Shading Node Overrides</a>.</li>
</ul>
<div class='section'><a id="implement-a-3rd-party-renderer-in-the-hypershade"></a><h3 id="implement-a-3rd-party-renderer-in-the-hypershade">Implement a 3rd party renderer in the Hypershade</h3></div>
<ul>
<li>Added new class <span class='code'><a href="javascript:void(0)" data-symbol="MPxRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxRenderer</a></span> that allows plug-ins to implement a 3rd party renderer for rendering in the Material Viewer in the Hypershade.</li>
</ul>
<div class='section'><a id="renderer-enhancements"></a><h3 id="renderer-enhancements">Renderer Enhancements</h3></div>
<div class='section'><a id="renderer-notifications"></a><h4 id="renderer-notifications">Renderer notifications</h4></div>
<ul>
<li><p>It is now possible for plug-ins to add in pre and post render notifications similar to the interface provided in <span class='code'><a href="javascript:void(0)" data-symbol="MUiMessage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_ui_message.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_ui_message.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUiMessage</a></span>.</p></li>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MHWRender::MRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHWRender::MRenderer</a></span> has the following new interfaces:</p>
<ul>
<li>A notification callback type:
<ul>
<li><span class='code'>typedef void (*NotificationCallback)(<a href="javascript:void(0)" data-symbol="MDrawContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext</a>&amp; context, void* clientData);</span></li>
</ul></li>
<li>A way to add in a notification at a specific semantic point in the rendering pipeline.
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> addNotification(NotificationCallback notification, const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>&amp; name, const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> semanticLocation, void* clientData);</span></li>
<li>Currently only pre and post rendering and pre and post scene passes are supported as input to the <span class='code'>semanticLocation</span> parameter.</li>
<li>The string enumerators are:
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MPassContext::kBeginRenderSemantic" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_pass_context.html#ad934a68929f94a0353d31cf5037edebf&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPassContext::kBeginRenderSemantic</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPassContext::kEndRenderSemantic" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_pass_context.html#a780076ccaa2af55f6023c67eaed79fae&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPassContext::kEndRenderSemantic</a></span>: pre and post render, respectively.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MPassContext::kBeginSceneRenderSemantic" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_pass_context.html#ac014667cd1015f6ed2723003b2a8573e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPassContext::kBeginSceneRenderSemantic</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MPassContext::kEndSceneRenderSemantic" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_pass_context.html#a73be45b2fb0d7ad17652f9a0f98baa67&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPassContext::kEndSceneRenderSemantic</a></span>: pre and post scene passes, respectively.</li>
</ul></li>
</ul></li>
<li>A way to remove a notification which has been added:
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> removeNotification(const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>&amp; name, const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>&amp; semanticLocation);</span></li>
</ul></li>
<li><p>The ability to query the number of notifications that exist:</p>
<ul>
<li><span class='code'>unsigned int notificationCount(const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>&amp; semanticLocation) const;</span></li>
</ul>
<p>One key advantage is that it is now possible to directly obtain the offscreen buffer / target used for rendering, while previously it depended mostly on guess-work to find the correct buffer to access. In general, this would be the back buffer for OpenGL; however, this does not work with unified back buffers on Linux. The new interface allows for platform and draw API agnostic access.</p></li>
</ul></li>
</ul>
<div class='section'><a id="renderer-output-target-size-override"></a><h4 id="renderer-output-target-size-override">Renderer output target size override</h4></div>
<ul>
<li>It is now possible to override the output target size used for rendering in the viewport via the API. This can be used to capture images which are not directly tied to the viewport size; that is, the viewport size does not need to match the capture size.</li>
<li>The following new API entry points have need added to <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_renderer.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer</a></span>:
<ul>
<li><p><span class='code'>void GPUmaximumOutputTargetSize(unsigned int&amp; w, unsigned int&amp; h) const</span></p>
<p>This allows the plug-in to query the maximum allowable output target size.</p></li>
<li><p><span class='code'>void setOutputTargetOverrideSize(unsigned int w, unsigned int h)</span></p>
<p>This allows the plug-in to set an override for the output target size.</p></li>
<li><p><span class='code'>void getOutputTargetOverrideSize(int &amp; w, int &amp; h)</span></p>
<p>This allows the plug-in to query the override size values. If none are set, then (-1,-1) is returned.</p></li>
<li><p><span class='code'>void unsetOutputTargetOverrideSize()</span></p>
<p>This allows the plug-in to unset/reset the override size (set back to -1,-1).</p></li>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> outputTargetSize(unsigned int&amp; w, unsigned int&amp; h) const</span></p>
<p>This method will now take into account any override output size. This is not a new method.</p></li>
</ul></li>
<li>Viewport 2.0 capture example for notifications and override size:
<ul>
<li>The new plug-in example <em>blast2Cmd</em> demonstrates the use of a post notification to capture images to disk. It is similar to the obsolete <em>blastCmd</em>. See Developer Kit examples below for more information.</li>
</ul></li>
</ul>
<p>The following convenience methods were added to <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_renderer.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer</a></span>:</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::useGradient()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a0a37f5441ac2ecc2683c434a77e93234&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::useGradient()</a></span> : returns whether or not a gradient background option is enabled.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::clearColor()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a1f60fa4b3321b445538ed712fa85f493&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::clearColor()</a></span> : returns the first color used for the gradient background, or the background color if not using a gradient</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::clearColor2()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#acd95ff3a7742eccf81c361a2a57761f8&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::clearColor2()</a></span> : returns the 2nd color used for the gradient background.</li>
</ul>
<div class='section'><a id="color-management-enhancements"></a><h3 id="color-management-enhancements">Color management enhancements</h3></div>
<ul>
<li>Added function <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance::createShaderInstanceWithColorManagementFragment()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#a8b4d20c10162d7709e4352a4503653ee&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance::createShaderInstanceWithColorManagementFragment()</a></span> to create a new shader instance with a color management fragment added.</li>
</ul>
<div class='section'><a id="shader-semantics-supported-by-viewport-2.0"></a><h3 id="shader-semantics-supported-by-viewport-2.0">Shader semantics supported by Viewport 2.0</h3></div>
<p>The list of <a href='#!/url=./developer/Viewport-2-0-API/Shader-semantics-supported-by.html' title=''>Semantics supported by Viewport 2.0</a> has been updated.</p>
<div class='section'><a id="developer-kit-examples"></a><h3 id="developer-kit-examples">Developer Kit examples</h3></div>
<ul>
<li>Python API 2.0 developer kit examples can be found in the <span class='code'>plug-ins\scripted</span> folder. Each shares the same name as its C++ counterpart, but with a <span class='code'>py</span> prefix.</li>
<li><p>A new <em>viewObjectSetOverride</em> developer kit example has been added, and a description of the example is provided in <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Render-Loop-Overrides.html#multiple-pass-scene-rendering' title=''>Multiple Pass Scene Rendering</a>.</p></li>
<li><p>A new plug-in <em>onbShader</em> has been added to the developer kit that creates a dependency node as a surface shader called onbShader in Maya.</p>
<p>In addition to implementing the dependency node, this plug-in also shows a complete implementation of a surface shader for Viewport 2.0.</p>
<p>It demonstrates how to define and register shading fragments and create a final fragment graph.</p>
<p>This example differs from the <em>lambertShader</em>/<em>phongShader</em> examples in that it does not re-use Maya&#39;s built-in fragments, but instead define its own via the plug-in.</p></li>
<li><p>A new plug-in <em>simpleNoiseShader</em> has been added to the developer kit that creates a dependency node as a texture shader called simpleNoise, that implements the Maya <em>wave</em> noise texture type.</p>
<p>In addition to implementing the dependency node, this plug-in also shows a complete implementation of a texture shader for Viewport 2.0.</p>
<p>It demonstrates how to define and register shading fragments to create a final fragment graph and associate it with the dependency node. In addition, this example also demonstrates how to create and access the noise lookup table that Maya uses for computing procedural textures.</p>
<p>The primary shading fragment defines a texture and sampler parameter pair for the noise lookup table. The noise lookup table is then used to build a 3d texture that the pixel shader can sample to compute the final wave noise result. New <span class='code'><a href="javascript:void(0)" data-symbol="MRenderUtil" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_render_util.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderUtil</a></span> methods: <span class='code'>noiseTableSize()</span> and <span class='code'>valueInNoiseTable()</span> are used to access the noise lookup table values. See the <em>simpleNoiseShader</em> developer kit example for more information.</p></li>
<li><p>The <em>footPrintNode</em> developer kit example is now made simpler and demonstrates how to use <span class='code'><a href="javascript:void(0)" data-symbol="MUIDrawManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUIDrawManager</a></span> to draw a simple locator in Viewport 2.0.</p>
<p>Plug-in code using <span class='code'><a href="javascript:void(0)" data-symbol="MUIDrawManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUIDrawManager</a></span> offers the following advantages:</p>
<ul>
<li>It works with Viewport 2.0 based selection that is new for Maya 2016</li>
<li>It can be written once and used on all platforms and all draw APIs, including OpenGL core profile</li>
</ul>
<p>The original sample is now renamed to <em>rawfootPrintNode</em> which demonstrates how to draw the locator with raw OpenGL/DX calls.</p>
<p>The <em>rawfootPrintNode</em> example has been updated to show how an <span class='code'><a href="javascript:void(0)" data-symbol="M3dView" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m3d_view.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">M3dView</a></span> can be obtained using the method <span class='code'><a href="javascript:void(0)" data-symbol="MFrameContext::renderingDestination()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_frame_context.html#a0df712533d76bdc96f2b49f4767ed85e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFrameContext::renderingDestination()</a></span> to find the destination name, and then how <span class='code'><a href="javascript:void(0)" data-symbol="M3dView::getM3dViewFromModelPanel()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html#a6f8dcac6993b14738fc6259cfd50a3b8&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">M3dView::getM3dViewFromModelPanel()</a></span> can be used to obtain a corresponding <span class='code'><a href="javascript:void(0)" data-symbol="M3dView" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m3d_view.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">M3dView</a></span> for a panel with the given destination name.</p></li>
<li><p>A new plug-in <em>footPrintNode_GeometryOverride</em> has been added that implements a locator using an <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride</a></span> to obtain good draw performance when a large number of locators needs to be displayed at the same time. A Python version is also available.</p></li>
<li><p>The <em>blast2Cmd</em> developer kit example is a new plug-in that performs video capture. It sets and overrides the output target size as well as attaches a renderer notification callback. The callback is called for each frame that the command wants to output. It uses existing interfaces to copy the render target back to a texture, and uses the built in texture saving functionality to save to disk. If the render target is fixed point, the plug-in will store the image in IFF format. Otherwise, if it is floating point, the plug-in will store it in EXR format.</p>
<p>The following roughly outlines the logic used in this example:</p>
<ol>
<li>Call <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::addNotification()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a837772824ffc712480bbd5e1d6fc355d&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::addNotification()</a></span> to add in a post render callback.</li>
<li>Call <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::setOutputTargetOverrideSize()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a589ed2a8ecd1f4bf2d7e53932ddd032d&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::setOutputTargetOverrideSize()</a></span> to set an override for the output target size.</li>
<li>Queue a refresh. A render occurs to a target of the override size.</li>
<li>The callback reads back the contents of the output target.</li>
<li>Call <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::unsetOutputTargetOverrideSize()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#af25fd0c611b5d859d7461de32f248f8c&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::unsetOutputTargetOverrideSize()</a></span> to unset the override for the output target size.</li>
<li>Call <span class='code'><a href="javascript:void(0)" data-symbol="MRenderer::removeNotification()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a77e2edb6cc80c86ac9531161ba7fbeec&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderer::removeNotification()</a></span> to remove the callback.</li>
</ol></li>
<li>The <em>vp2BlinnShader</em> is a simplified example of using an <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride</a></span>. The plug-in shows the usage of the basic interfaces for this type of override. The example uses an <span class='code'><a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance</a></span>, which is retrieved by asking the shader manager (<span class='code'><a href="javascript:void(0)" data-symbol="MShaderManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderManager</a></span>) for a stock Blinn shader. As such, the geometry requirements for the shader can be retrieved from the shader instance itself. It does not require an extra DX11 shader signature in this case. The internal method for drawing is also used. There is no additional light handling required as the stock shader has its light bindings automatically updated. The plug-in can run on all platforms and all currently supported drawing APIs (OpenGL, OpenGL Core Profile, DX11), as the implementations are internally provided. Therefore, no additional shading code is required.</li>
<li><p>The <em>apiMeshShape</em> plug-in (and its Python version <span class='code'>pyApiMeshShape.py</span>) were updated to perform component selection in Viewport 2.0 using an <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryOverride</a></span> and an <span class='code'><a href="javascript:void(0)" data-symbol="MPxSubSceneOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_sub_scene_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSubSceneOverride</a></span>. They were also updated to properly manage duplicate and unknown streams, allowing it to work with effects that request multiple UV streams, or ask for binormals and bitangents.</p>
<p>The SubSceneOverride version was updated to demonstrate support for DirectX11 mode. See the MVertexBuffer and MIndexBuffer Enhancements section above on this page for more information.</p></li>
<li>The <em>brickShader</em> plug-in (both C++ and Python versions) has been updated to support GLSL and therefore to run in OpenGL Core Profile mode in the Maya viewport. The shader fragment for GLSL was written based on the HLSL implementation.</li>
<li>The <em>viewOverrideSimple</em> sample plug-in has been added that demonstrates how to use <span class='code'><a href="javascript:void(0)" data-symbol="MRenderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_render_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MRenderOverride</a></span>, and is a simple example targeted towards beginners. It creates a render override that is listed as a renderer in the viewport menu, and it draws the scene and the HUD, and performs a background color override. The logic used in the sample to create the render override roughly matches that used in Mayas internal render pipeline.</li>
<li><p>In order to compile the DX11 Shader plug-in provided in the developer kit using Visual Studio 2012, you must first compile the Microsoft DirectX SDK Effects11 library using the Visual Studio 2012 project file (<span class='code'>Effects11_vs2012.vcxproj</span>) provided in the <span class='code'>devkit/plug-ins/dx11Shader</span> folder by doing the following:</p>
<ol>
<li>Copy the file to the <span class='code'>Effects11</span> folder (in most cases: <span class='code'>C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Samples\C++\Effects11</span>).</li>
<li>Load the <span class='code'>Effects11_vs2012.vcxproj</span> project file and compile the solution from the <span class='code'>Effects11</span> folder.</li>
</ol></li>
</ul>
<div class='section'><a id="documentation-updates"></a><h3 id="documentation-updates">Documentation updates</h3></div>
<ul>
<li>Sections <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Manipulators-1.html' title=''>Manipulators</a> and <a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Tool-Contexts.html' title=''>Tool Contexts</a> have been added to the <em>Maya Viewport 2.0 API Guide</em> to provide information on the interfaces used for drawing manipulators and for tool contexts in Viewport 2.0.</li>
<li><p><a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/API-constructs/Frame-and-draw-contexts.html' title=''>Frame and draw contexts</a> topic added.</p></li>
<li><a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Lighting-Interfaces.html#convert-light-information-from-world-to-view-space-for-fixed-function-lighting' title=''>Convert light information from world to view space for fixed function lighting</a> section added.</li>
<li><p><a href='#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Render-Loop-Overrides.html#multiple-pass-scene-rendering' title=''>Multiple pass scene rendering</a> section added.</p></li>
</ul>
<div class='section'><a id="animation"></a><h2 id="animation">Animation</h2></div>
<div class='section'><a id="openmaya"></a><h3 id="openmaya">OpenMaya</h3></div>
<ul>
<li>Added new <span class='code'><a href="javascript:void(0)" data-symbol="MEvaluationManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_evaluation_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvaluationManager</a></span> class that allows you to query Evaluation Manager states. The <em>simpleEvaluationNode</em> developer kit example demonstrates its use.</li>
<li>Added new <span class='code'>preEvaluation()</span> and <span class='code'>postEvaluation()</span> virtual methods to <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode</a></span></li>
<li>Added new <span class='code'><a href="javascript:void(0)" data-symbol="MEvaluationNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_evaluation_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_evaluation_node.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvaluationNode</a></span> class to provide access to the set of attributes and plugs that will be set dirty prior to evaluation by the Evaluation Manager.</li>
<li>Added new <span class='code'><a href="javascript:void(0)" data-symbol="MEvaluationNodeIterator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_evaluation_node_iterator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_evaluation_node_iterator.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvaluationNodeIterator</a></span> class that is used by <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode::preEvaluation()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html#ad40cff55ba4000788eda78c8b4258b3d&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode::preEvaluation()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode::postEvaluation()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html#a93e355c11a2c9a0f19f8d7cfa887af2b&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode::postEvaluation()</a></span> for support of threaded evaluation. This class is used to easily iterate over the set of attributes and plugs that will be set dirty prior to evaluation by the Evaluation Manager on a given <span class='code'><a href="javascript:void(0)" data-symbol="MEvaluationNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_evaluation_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_evaluation_node.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvaluationNode</a></span>.</li>
<li>Added developer kit example <em>simpleEvaluationNode</em> that shows use of <span class='code'>preEvaluation()</span> function</li>
<li><p>Added developer kit example <em>simpleEvaluationDraw</em> that shows use of <span class='code'>postEvaluation()</span> function</p></li>
<li><p>Plug-ins can now provide hints to the evaluation manager as to how they should be scheduled.</p>
<p>Scheduling of python plug-ins is now improved. Previously, Python nodes were run in parallel which could cause issues with lock contention, slowing down evaluation.</p>
<p>Python plug-ins are now globally serialized, avoiding issues with the GIL (global interpreter lock), and improving overall performance.</p>
<p>To provide scheduling of plug-in nodes, the following new enum and virtual method have been added to <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_node.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode</a></span>. They are as follows:</p>
<ul>
<li><span class='code'>::SchedulingType</span></li>
<li>Users can override the <span class='code'><a href="javascript:void(0)" data-symbol="MPxNode::schedulingType()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_node.html#a9c9e8bdcf0b5283a027a66a7671b7088&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxNode::schedulingType()</a></span> const function, which returns the desired scheduling type for the node.</li>
</ul></li>
</ul>
<p>Added the following new classes to support GPU override deformers:</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MOpenCLInfo" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_open_c_l_info.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MOpenCLInfo</a></span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MAutoCLEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_auto_c_l_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAutoCLEvent</a></span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MAutoCLKernel" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_auto_c_l_kernel.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAutoCLKernel</a></span></li>
<li><p><span class='code'><a href="javascript:void(0)" data-symbol="MAutoCLMem" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_auto_c_l_mem.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MAutoCLMem</a></span></p></li>
<li><p>Added new <span class='code'><a href="javascript:void(0)" data-symbol="MFnMatrixArrayData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_matrix_array_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_matrix_array_data.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnMatrixArrayData</a></span> class that allows your plug-ins to use <span class='code'><a href="javascript:void(0)" data-symbol="MMatrixArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_matrix_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_matrix_array.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MMatrixArray</a></span> attribute types. This can be used to generate more compact graphs instead of creating multis of <span class='code'><a href="javascript:void(0)" data-symbol="MMatrix" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_matrix.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_matrix.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MMatrix</a></span> types. One immediate use of this type is to read cached frame information computed by the new DeltaMush deformer.</p></li>
</ul>
<div class='section'><a id="mpxmotionpathnode"></a><h4 id="mpxmotionpathnode">MPxMotionPathNode</h4></div>
<p>A new <span class='code'><a href="javascript:void(0)" data-symbol="MPxMotionPathNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_motion_path_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxMotionPathNode</a></span> class has been added, and is the base class for user defined motionPath nodes. It allows you to create your own motion path classes by providing methods that specify how the position, orientation and other attributes of connected nodes transform based on the position along the path. You can follow either of these workflows to use the <span class='code'><a href="javascript:void(0)" data-symbol="MPxMotionPathNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_motion_path_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxMotionPathNode</a></span> class:</p>
<ul>
<li>Access the motionPath engine via -la-carte functions such as <span class='code'>position()</span>, <span class='code'>getVectors()</span> and <span class='code'>banking()</span> to compute your solution.</li>
<li>Use the <span class='code'>evaluatePath()</span> function to invoke the internal motionPath engine based on a predefined set of parameters that you set.</li>
</ul>
<p>The advantage of <span class='code'><a href="javascript:void(0)" data-symbol="MPxMotionPathNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_motion_path_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxMotionPathNode</a></span> over the built-in motionPath node is the ability to control how calculations are performed. Here are some examples of how you can create effects using the <span class='code'><a href="javascript:void(0)" data-symbol="MPxMotionPathNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_motion_path_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxMotionPathNode</a></span> node:</p>
<ul>
<li>Change how the range is interpreted, such as setting 0 at the start and 100 at the end of the path regardless of the underlying curve parameterization. Implement a wraparound when the parameter goes outside the range of the path, change the duration, implement cycling or add an oscillation effect. You can implement all of these simply by remapping the parameter value.</li>
<li>Enable your geometry to anticipate each corner by leaning into the curve. The banking calculation on the motionPath node is computed at the current location on the path, but with the <span class='code'><a href="javascript:void(0)" data-symbol="MPxMotionPathNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_motion_path_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxMotionPathNode</a></span> node and its -la-carte approach, you can easily call the <span class='code'>banking()</span> function on a position somewhere ahead of the current location.</li>
<li>Offset the result to a space away from the path curve by adding a translation along the computed vectors. This could be used to give a <em>slalom</em> effect to a skier moving along a simple path. You could even add banking based on the slalom path rather than the actual path curve.</li>
<li><p>Attach multiple outputs to the same custom motionPath node by creating a multi for your inputs and a multi for the outputs. To simulate multiple skiers in a line following the same path, simply specify a different relative offset along the path for each skier. To simulate a platoon of soldiers marching in a parade that turn corners smartly, specify offsets both along the path as well as horizontally.</p>
<p>See the <em>motionPathNode</em> developer kit example for an example of how to use the <span class='code'><a href="javascript:void(0)" data-symbol="MPxMotionPathNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_motion_path_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxMotionPathNode</a></span> class to create sophisticated path animation effects.</p></li>
</ul>
<div class='section'><a id="mpxanimcurveinterpolator"></a><h4 id="mpxanimcurveinterpolator">MPxAnimCurveInterpolator</h4></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxAnimCurveInterpolator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_anim_curve_interpolator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxAnimCurveInterpolator</a></span> is a new class that you can derive from to create user-defined animation curve interpolation types. It dictates how an animation curve evaluates between two keyframes.</p>
<div class='section'><a id="openmayaanim"></a><h3 id="openmayaanim">OpenMayaAnim</h3></div>
<p>Added the following new classes to support GPU override deformers:</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MPxGPUDeformer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_g_p_u_deformer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGPUDeformer</a></span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MGPUDeformerRegistry" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_g_p_u_deformer_registry.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGPUDeformerRegistry</a></span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MGPUDeformerRegistrationInfo" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_g_p_u_deformer_registration_info.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGPUDeformerRegistrationInfo</a></span></li>
</ul>
<p>Deformer classes have been re-organized. New classes:</p>
<ul>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryFilter" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_geometry_filter.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryFilter</a></span> - the new base class for deformers. This is equivalent to <span class='code'><a href="javascript:void(0)" data-symbol="MPxDeformerNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_deformer_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxDeformerNode</a></span> (which still exists), but without per-vertex weight lists.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MPxSkinCluster" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_skin_cluster.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSkinCluster</a></span> - extends <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryFilter" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_geometry_filter.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryFilter</a></span> with per-vertex skin weights. Custom nodes derived from this class are treated like the built-in skinCluster in the Maya UI.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MPxBlendShape" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_blend_shape.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxBlendShape</a></span> - extends <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryFilter" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_geometry_filter.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxGeometryFilter</a></span> with the input target. Custom nodes derived from this class are treated like the built-in blendShape in the Maya UI.</li>
</ul>
<div class='section'><a id="openmayaui"></a><h3 id="openmayaui">OpenMayaUI</h3></div>
<ul>
<li>A new <span class='code'><a href="javascript:void(0)" data-symbol="MGraphEditorInfo" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_graph_editor_info.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGraphEditorInfo</a></span> class has been added that allows you to query, for a given Graph Editor, UI information such as viewport bounds and animation curve nodes based on its current state.</li>
</ul>
<div class='section'><a id="developer-kit-examples-1"></a><h3 id="developer-kit-examples-1">Developer Kit examples</h3></div>
<ul>
<li><em>identityNode</em>: This example illustrates a simple possible deformer that copies inputs to outputs. It also provides a boilerplate that allows you get started on creating your own deformer.</li>
<li><em>offsetNode</em>: This example provides the CPU and GPU implementation of a non-trivial deformer.</li>
<li><em>basicBlendShape</em>: This example illustrates creating a basic deformer by inheriting from <span class='code'><a href="javascript:void(0)" data-symbol="MPxBlendShape" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_blend_shape.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxBlendShape</a></span>.</li>
<li><em>basicSkinCluster</em>: This example illustrates creating a basic deformer by inheriting from <span class='code'><a href="javascript:void(0)" data-symbol="MPxSkinCluster" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_skin_cluster.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxSkinCluster</a></span>.</li>
</ul>
<div class='section'><a id="modeling"></a><h2 id="modeling">Modeling</h2></div>
<div class='section'><a id="openmaya-1"></a><h3 id="openmaya-1">OpenMaya</h3></div>
<p>MPolyMessage enhancements:</p>
<ul>
<li>Added new <span class='code'><a href="javascript:void(0)" data-symbol="MPolyMessage::addUVSetChangedCallback()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_poly_message.html#ace91d017fa5f55d32db7efc657b70932&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPolyMessage::addUVSetChangedCallback()</a></span> method to register callbacks for UV set modification messages, including notifications for adding and deleting of a UV set, as well as the switching of the current UV set.</li>
</ul>
<p>MFnMesh enhancements</p>
<ul>
<li>Added a method <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh::setPinUVs()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html#a696b96be712e4cd8c8b383c6ce3a6f94&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnMesh::setPinUVs()</a></span> to set the specified UVs of the mesh as <em>pinned</em> UVs. A <em>pinned</em> UV is one which should not be modified. If the pin weight is set to 1.0, then it becomes fully pinned and UV tools should not modify that UV. If the pin weight is set to a value between 0.0 and 1.0, then UV tools should weigh their changes to that pin weight accordingly.</li>
<li><p>Added a method <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh::getPinUVs()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html#a9d819fc02dc71cf37f5aa45db4f7df69&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnMesh::getPinUVs()</a></span> to get the <em>pinned</em> UVs of the mesh, as well as the pin weights associated with those UVs.</p></li>
<li><p>Added <span class='code'>thickness</span> and <span class='code'>offset</span> options to the <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh::extrudeFaces()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html#ab15cb5975fdab32d083f0636266ca555&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnMesh::extrudeFaces()</a></span> and <span class='code'><a href="javascript:void(0)" data-symbol="MFnMesh::extrudeEdges()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_mesh.html#a35423618f98694bb2a6230e5430f4e5d&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnMesh::extrudeEdges()</a></span> functions. These parameters map directly to the attributes on the extrude face and edge nodes.</p></li>
</ul>
<div class='section'><a id="openmayaui-1"></a><h3 id="openmayaui-1">OpenMayaUI</h3></div>
<p>New context proxy class</p>
<ul>
<li>Added new <span class='code'><a href="javascript:void(0)" data-symbol="MPxTexContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tex_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxTexContext</a></span> context proxy class. This context proxy class provides a way to extend the function of the UV Texture Editor with user defined tools. Several functions for handling interactive events such as: mouse move, mouse press, mouse drag and mouse release are provided. You can override these functions to define the behavior of the new interactive tools for the UV Texture Editor.</li>
<li>Added new Qt sample plug-in <em>grabUV.pro</em>, which demonstrates how to use <span class='code'><a href="javascript:void(0)" data-symbol="MPxTexContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tex_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxTexContext</a></span> to implement a UV grab brush.</li>
</ul>
<p>New command proxy class</p>
<ul>
<li>Added new <span class='code'><a href="javascript:void(0)" data-symbol="MPxPolyTweakUVInteractiveCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_poly_tweak_u_v_interactive_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxPolyTweakUVInteractiveCommand</a></span> command proxy class. This tool command proxy class provides a simplified way to interactively edit UVs on polygonal objects within interactive contexts. A user can provide new UVs during an interactive command, and by finalizing the editing, all interactive updates are recorded as a single command, and can be undone together.</li>
</ul>
<p>MPxContext Enhancements</p>
<ul>
<li>Added new <span class='code'><a href="javascript:void(0)" data-symbol="MPxContext::drawFeedback()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_context.html#ad86a55c92f170b1578fb3fe6fa88cbb7&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxContext::drawFeedback()</a></span> method to draw primitives using <span class='code'><a href="javascript:void(0)" data-symbol="MUIDrawManager" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_u_i_draw_manager.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUIDrawManager</a></span> in Viewport 2.0 when the context tool is activated. This is useful for rendering context feedback, such as a brush ring.</li>
</ul>
<div class='section'><a id="profiler"></a><h2 id="profiler">Profiler</h2></div>
<p>When you instrument a procedure using <span class='code'><a href="javascript:void(0)" data-symbol="MProfilingScope" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_profiling_scope.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MProfilingScope</a></span>, you can also register an associated DG node. This way, when you select an instrumented event in your Profiler graph, its associated DG node is also selected and displayed in the Attribute Editor, Outliner or Node Editor.</p>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MProfilingScope::MProfilingScope()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_profiling_scope.html#ad980017ff0631e7ca146535092d2b26a&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MProfilingScope::MProfilingScope()</a></span> now accepts an optional input parameter: an <span class='code'><a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a></span> that points to the associated node of the procedure being instrumented.</p>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a></span> input parameter must point to a DG node and cannot point to an attribute or a component.</p>
<p>Example as follows:</p>
<div class="codeBlock"><pre class="prettyprint">import maya.OpenMaya as OpenMaya
import maya.cmds as cmds

testCategoryIndex = cmds.profiler(addCategory = &quot;testCategory&quot;)

def associatedNode():
    # Create a cone
    myCone = cmds.polyCone()
    mSelList = <a href="javascript:void(0)" data-symbol="OpenMaya.MSelectionList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_selection_list.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">OpenMaya.MSelectionList</a>()
    <a href="javascript:void(0)" data-symbol="OpenMaya.MGlobal.getActiveSelectionList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_global.html#a066fc800bd29827c3707102018d72ad9&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">OpenMaya.MGlobal.getActiveSelectionList</a>( mSelList)
        
    # Prepare the <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> to point to the cone.
    coneObj = <a href="javascript:void(0)" data-symbol="OpenMaya.MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_object.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">OpenMaya.MObject</a>()
    mSelList.getDependNode(0, coneObj)

    # Instrument the procedure and register its associated DG node; that is the cone node that was just created.
    profiler = OpenMaya.MProfilingScope(testCategoryIndex, OpenMaya.MProfiler.kColorE_L1, &quot;associatedNode&quot;, &quot;associatedNodeDesc&quot;, coneObj)
    cmds.select( myCone[0] )
    cmds.rotate( &#39;45deg&#39;, 0, 0, r=True )

cmds.profiler(sampling = True)
associatedNode()
cmds.profiler(sampling = False)
</pre></div><div class='section'><a id="bit-integer-support"></a><h2 id="bit-integer-support">64-bit integer support</h2></div>
<p>The Maya C++ API now supports 64-bit integers. The following interfaces have been added:</p>
<ul>
<li><p>New <span class='code'><a href="javascript:void(0)" data-symbol="MInt64Array" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_int64_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_int64_array.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MInt64Array</a></span> class added to the <span class='code'><a href="javascript:void(0)" data-symbol="OpenMaya" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;py_ref/namespace_open_maya.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">OpenMaya</a></span> library</p>
<p>This class is also available through Python API 2.0.</p></li>
<li><span class='code'>kInt64</span> has been added to the <span class='code'><a href="javascript:void(0)" data-symbol="MFnNumericData::Type" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericData::Type</a></span> enum</li>
<li><span class='code'>MFnNumericAttribute::getDefault(MInt64 &amp;def1)</span> and <span class='code'>setDefault(MInt64 def1)</span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MDataHandle::asInt64()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_data_handle.html#a80675a8d64af1da2c2b20c5219c0de68&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDataHandle::asInt64()</a></span>, <span class='code'>MDataHandle::setInt64(MInt64)</span>, <span class='code'>MDataHandle::set(MInt64)</span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MPlug::setInt64()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_plug.html#aa31ef56e031bbbc95c12a172ff0e7290&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPlug::setInt64()</a></span>, <span class='code'><a href="javascript:void(0)" data-symbol="MPlug::asInt64()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_plug.html#afe511b1a90dbf325ef6f4c8cfa431415&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPlug::asInt64()</a></span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> getValue (MInt64 &amp;, <a href="javascript:void(0)" data-symbol="MDGContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_d_g_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_d_g_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDGContext</a> &amp;ctx=MDGContext::fsNormal) const</span></li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> setValue (MInt64)</span></li>
<li><span class='code'>MDGModifier::newPlugValueInt64(const <a href="javascript:void(0)" data-symbol="MPlug" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_plug.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_plug.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPlug</a> &amp;plug, MInt64 plugValue)</span></li>
<li><span class='code'>MScriptUtil::MScriptUtil(const <a href="javascript:void(0)" data-symbol="MUint64Array" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_uint64_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_uint64_array.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUint64Array</a> &amp; array)</span></li>
<li><span class='code'>kInt64</span> and <span class='code'>kInt64Array</span> have been added to the <span class='code'><a href="javascript:void(0)" data-symbol="MCommandResult::Type" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_command_result.html#a1d1cfd8ffb84e947f82999c682b666a7&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MCommandResult::Type</a></span> enum</li>
<li><span class='code'>MCommandResult::getResult(MInt64 &amp;result) const</span> and <span class='code'>MCommandResult::getResult(<a href="javascript:void(0)" data-symbol="MInt64Array" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_int64_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_int64_array.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MInt64Array</a> &amp;result) const</span></li>
<li><p>MEL&#39;s int type can now handle 64-bit integers</p></li>
</ul>
<p>Limitations:</p>
<ul>
<li>Currently, Python API 2.0 does not fully support 64-bit integers.</li>
<li><span class='code'><a href="javascript:void(0)" data-symbol="MScriptUtil" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_script_util.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MScriptUtil</a></span> doesn&#39;t support 64-bit integers.</li>
<li>The <span class='code'>addAttr</span> command has not been extended to allow 64-bit integers to be added.</li>
</ul>
<div class='section'><a id="general"></a><h2 id="general">General</h2></div>
<div class='section'><a id="universally-unique-identifiers-uuids-for-nodes"></a><h3 id="universally-unique-identifiers-uuids-for-nodes">Universally Unique Identifiers (UUID&#39;s) for nodes</h3></div>
<ul>
<li>Added a new class <span class='code'><a href="javascript:void(0)" data-symbol="MUuid" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_uuid.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_uuid.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUuid</a></span> that is used with <span class='code'><a href="javascript:void(0)" data-symbol="MFnDependencyNode" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_dependency_node.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_fn_dependency_node.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnDependencyNode</a></span> when handling UUID&#39;s.</li>
<li>Added a new API callback <span class='code'><a href="javascript:void(0)" data-symbol="MDGMessage::addNodeChangeUuidCheckCallback()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_d_g_message.html#aa2e2edeb387466ee15a4fe1e61e07af6&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDGMessage::addNodeChangeUuidCheckCallback()</a></span> that allows users to modify the import/reference UUID policy.</li>
<li>Added a new method to <span class='code'><a href="javascript:void(0)" data-symbol="MSelectionList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_selection_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_selection_list.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSelectionList</a></span>, <span class='code'>MSelectionList::add( const <a href="javascript:void(0)" data-symbol="MUuid" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_uuid.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_uuid.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MUuid</a> &amp; uuid, bool mergeWithExisting = false )</span>, that adds a node matching the UUID to the selection list.</li>
</ul>
<div class='section'><a id="python-equivalent-to-mdgmodifiercommandtoexecute-added"></a><h3 id="python-equivalent-to-mdgmodifiercommandtoexecute-added">Python equivalent to MDGModifier::commandToExecute() added</h3></div>
<p>A new <span class='code'><a href="javascript:void(0)" data-symbol="MDGModifier::pythonCommandToExecute()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_d_g_modifier.html#a28d27ad5af5db5944fe8cc4d3dcf6244&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDGModifier::pythonCommandToExecute()</a></span> has been added that allows you to add an operation that executes a Python command/script to a dependency graph modifier.</p>
<p>This is the Python equivalent of the method <span class='code'><a href="javascript:void(0)" data-symbol="MDGModifier::commandToExecute()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_d_g_modifier.html#a8df68858b554bb4efd63ce16deec6aa0&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDGModifier::commandToExecute()</a></span>.</p>
<div class='section'><a id="removed-classes"></a><h2 id="removed-classes">Removed classes</h2></div>
<p>The obsolete classic cloth <span class='code'>MCloth</span> classes have been removed.</p>
<div class='section'><a id="net-api"></a><h2 id="net-api">.NET API</h2></div>
<p><span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxShaderOverride</a></span> non-virtual protected methods are now exposed in the .NET API, and you can use them to render your materials in Viewport 2.0:</p>
<ul>
<li><span class='code'>addGeometryRequirement (const <a href="javascript:void(0)" data-symbol="MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MVertexBufferDescriptor</a> &amp;desc)</span></li>
<li><span class='code'>addGeometryRequirements (const <a href="javascript:void(0)" data-symbol="MVertexBufferDescriptorList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer_descriptor_list.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MVertexBufferDescriptorList</a> &amp;list)</span></li>
<li><span class='code'>setGeometryRequirements (const <a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance</a> &amp;shaderInstance)</span></li>
<li><span class='code'>addShaderSignature (void *signature, size_t signatureSize)</span></li>
<li><span class='code'>addShaderSignature (const <a href="javascript:void(0)" data-symbol="MShaderInstance" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_shader_instance.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MShaderInstance</a> &amp;shaderInsance)</span></li>
<li><span class='code'>addIndexingRequirement (const <a href="javascript:void(0)" data-symbol="MIndexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MIndexBufferDescriptor</a> &amp;desc)</span></li>
<li><span class='code'>drawGeometry (const <a href="javascript:void(0)" data-symbol="MDrawContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_context.html&quot;,&quot;title&quot;:&quot;Maya Python API 2.0 Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawContext</a> &amp;context) const</span></li>
</ul>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

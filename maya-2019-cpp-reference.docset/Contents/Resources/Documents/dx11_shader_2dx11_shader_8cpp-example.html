<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><script src="../scripts/utils/adsk.redirect.js" type="text/javascript"></script>
<title>dx11Shader/dx11Shader.cpp</title>
<meta content="C++" name="topic-subtype"/></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"/><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('dx11_shader_2dx11_shader_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>dx11Shader/dx11Shader.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./files.html"><span>Files</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">dx11Shader/dx11Shader.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk license</span></div>
<div class="line"><span class="comment">// agreement provided at the time of installation or download, or which</span></div>
<div class="line"><span class="comment">// otherwise accompanies this software in either electronic or hard copy form.</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"><span class="preprocessor">#if _MSC_VER &gt;= 1700</span></div>
<div class="line"><span class="preprocessor">#pragma warning( disable: 4005 )</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "dx11Shader.h"</span></div>
<div class="line"><span class="preprocessor">#include "dx11ShaderStrings.h"</span></div>
<div class="line"><span class="preprocessor">#include "dx11ShaderCompileHelper.h"</span></div>
<div class="line"><span class="preprocessor">#include "dx11ShaderUniformParamBuilder.h"</span></div>
<div class="line"><span class="preprocessor">#include "dx11ConeAngleToHotspotConverter.h"</span></div>
<div class="line"><span class="preprocessor">#include "crackFreePrimitiveGenerator.h"</span></div>
<div class="line"><span class="preprocessor">#include "dx11ShaderSemantics.h"</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFileIO.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MString.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnAmbientLight.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDependencyNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MItDependencyNodes.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnTypedAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnStringData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMessageAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNumericAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnEnumAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnStringArrayData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDGModifier.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MEventMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MSceneMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPlugArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFileObject.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MModelMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAngle.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MImageFileInfo.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MRenderUtil.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAnimControl.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MVaryingParameter.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MUniformParameter.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MRenderProfile.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGeometryList.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPointArray.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MViewport2Renderer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDrawContext.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MTextureManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHWGeometryUtilities.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MRenderUtilities.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MRenderTargetManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MUIDrawManager.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHardwareRenderer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGLFunctionTable.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/M3dView.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef _DEBUG</span></div>
<div class="line"><span class="preprocessor">    #define _DEBUG_SHADER 1</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="comment">//#define PRINT_DEBUG_INFO</span></div>
<div class="line"><span class="comment">//#define PRINT_DEBUG_INFO_SHADOWS</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define M_CHECK(assertion)  if (assertion) ; else throw ((dx11Shader::InternalError*)__LINE__)</span></div>
<div class="line"><span class="keyword">namespace </span>dx11Shader</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">struct </span>InternalError</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">char</span>* message;</div>
<div class="line">    };</div>
<div class="line"> <span class="comment">//   throw (InternalError*)__LINE__;</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Input shader attributes</span></div>
<div class="line"> <span class="comment">// initialized in dx11ShaderNode::initializeNodeAttrs()</span></div>
<div class="line"> <span class="keyword">static</span> <a name="_a0"></a><a class="code" href="./class_m_object.html">MObject</a> sShader;</div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./class_m_object.html">MObject</a> sTechnique;</div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./class_m_object.html">MObject</a> sTechniques;</div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./class_m_object.html">MObject</a> sDescription;</div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./class_m_object.html">MObject</a> sDiagnostics;</div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./class_m_object.html">MObject</a> sEffectUniformParameters;</div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./class_m_object.html">MObject</a> sLightInfo;</div>
<div class="line"></div>
<div class="line"> <a name="_a1"></a><a class="code" href="./class_m_string.html">MString</a> MStringFromInt(<span class="keywordtype">int</span> value)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> str;</div>
<div class="line">        str.<a name="a2"></a><a class="code" href="./class_m_string.html#acee761fe098fc30a5ac1437e3aca5bc0">set</a>((<span class="keywordtype">double</span>)value, 0);</div>
<div class="line"> <span class="keywordflow">return</span> str;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> MStringFromUInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> str;</div>
<div class="line">        str.<a class="code" href="./class_m_string.html#acee761fe098fc30a5ac1437e3aca5bc0">set</a>((<span class="keywordtype">double</span>)value, 0);</div>
<div class="line"> <span class="keywordflow">return</span> str;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>MUniformParameterData</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> name;</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MUniformParameter::DataType</a> type;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numElements;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Sorting Functor for std::set&lt;MString&gt;</span></div>
<div class="line"> <span class="keyword">struct </span>MStringSorter</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; rhs)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> strcmp(lhs.<a name="a3"></a><a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(), rhs.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>()) &lt; 0;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> <span class="keyword">typedef</span> std::set&lt;MString, MStringSorter&gt; SetOfMString;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Convenient function to remove all non alpha-numeric characters from a string (remplaced by _ )</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> sanitizeName(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; dirtyName)</div>
<div class="line">    {</div>
<div class="line">        std::string retVal(dirtyName.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;retVal.size(); ++i)</div>
<div class="line"> <span class="keywordflow">if</span> (!isalnum(retVal[i]))</div>
<div class="line">                retVal.replace(i, 1, <span class="stringliteral">"_"</span>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_string.html">MString</a>(retVal.c_str());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> replaceAll(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; str_, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; from_, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; to_)</div>
<div class="line">    {</div>
<div class="line">        std::string str(str_.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line">        std::string from(from_.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line">        std::string to(to_.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line"></div>
<div class="line">        std::size_t start = str.find(from);</div>
<div class="line"> <span class="keywordflow">while</span>(start != std::string::npos)</div>
<div class="line">        {</div>
<div class="line">            std::size_t len = from.size();</div>
<div class="line">            std::size_t end = start + len;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if match the whole word</span></div>
<div class="line"> <span class="keywordflow">if</span>( ( start &gt; 0 &amp;&amp; isalnum(str.at(start-1)) ) ||</div>
<div class="line">                ( end &lt; (str.size() - 1) &amp;&amp; isalnum(str.at(end+1)) ) )</div>
<div class="line">            {</div>
<div class="line">                start = str.find(from, end);</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            str.replace(start, len, to);</div>
<div class="line">            start = str.find(from, start + to.size());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_string.html">MString</a>(str.c_str());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Adding and removing attributes while a scene is loading can lead</span></div>
<div class="line"> <span class="comment">// to issues, especially if there were connections between the shader</span></div>
<div class="line"> <span class="comment">// and a texture. To prevent these issues, we will wait until the scene</span></div>
<div class="line"> <span class="comment">// has finished loading before adding or removing the attributes that</span></div>
<div class="line"> <span class="comment">// manage connections between a scene light and its corresponding shader</span></div>
<div class="line"> <span class="comment">// parameters.</span></div>
<div class="line"> <span class="keyword">class </span>PostSceneUpdateAttributeRefresher</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> add(dx11ShaderNode* node)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (sInstance == NULL)</div>
<div class="line">                sInstance = <span class="keyword">new</span> PostSceneUpdateAttributeRefresher();</div>
<div class="line">            sInstance-&gt;mNodeSet.insert(node);</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">remove</span>(dx11ShaderNode* node)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (sInstance != NULL)</div>
<div class="line">                sInstance-&gt;mNodeSet.erase(node);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        PostSceneUpdateAttributeRefresher()</div>
<div class="line">        {</div>
<div class="line">            mSceneUpdateCallback = <a name="a4"></a><a class="code" href="./class_m_scene_message.html#a44771b834e9a0ad7291ecdcc880106fe">MSceneMessage::addCallback</a>(<a name="a5"></a><a class="code" href="./class_m_scene_message.html#a4f09127c805cc1f5ee20e67db7b45efaa3fed96219df72e729d0b7049c4754927">MSceneMessage::kSceneUpdate</a>, PostSceneUpdateAttributeRefresher::refresh );</div>
<div class="line">            mAfterCreateReference = <a class="code" href="./class_m_scene_message.html#a44771b834e9a0ad7291ecdcc880106fe">MSceneMessage::addCallback</a>(<a name="a6"></a><a class="code" href="./class_m_scene_message.html#a4f09127c805cc1f5ee20e67db7b45efaafeb8f82c3fc0b0ae71bb22e6ea8d79f5">MSceneMessage::kAfterCreateReference</a> , PostSceneUpdateAttributeRefresher::refresh );</div>
<div class="line">            mAfterImport = <a class="code" href="./class_m_scene_message.html#a44771b834e9a0ad7291ecdcc880106fe">MSceneMessage::addCallback</a>(<a name="a7"></a><a class="code" href="./class_m_scene_message.html#a4f09127c805cc1f5ee20e67db7b45efaa53fc8c2585483ca800500bb17bd25fdf">MSceneMessage::kAfterImport</a>, PostSceneUpdateAttributeRefresher::refresh );</div>
<div class="line">            mAfterLoadReference = <a class="code" href="./class_m_scene_message.html#a44771b834e9a0ad7291ecdcc880106fe">MSceneMessage::addCallback</a>(<a name="a8"></a><a class="code" href="./class_m_scene_message.html#a4f09127c805cc1f5ee20e67db7b45efaa54642484be67343c7c2d30c6911cc6a3">MSceneMessage::kAfterLoadReference</a>, PostSceneUpdateAttributeRefresher::refresh );</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        ~PostSceneUpdateAttributeRefresher()</div>
<div class="line">        {</div>
<div class="line"> <a name="a9"></a><a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MSceneMessage::removeCallback</a>( mSceneUpdateCallback );</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MSceneMessage::removeCallback</a>( mAfterCreateReference );</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MSceneMessage::removeCallback</a>( mAfterImport );</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MSceneMessage::removeCallback</a>( mAfterLoadReference );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> refresh(<span class="keywordtype">void</span>* data)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (sInstance)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">for</span> (TNodeSet::iterator itNode = sInstance-&gt;mNodeSet.begin();</div>
<div class="line">                                        itNode != sInstance-&gt;mNodeSet.end();</div>
<div class="line">                                        ++itNode )</div>
<div class="line">                {</div>
<div class="line">                    (*itNode)-&gt;refreshLightConnectionAttributes(<span class="keyword">true</span>);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">delete</span> sInstance;</div>
<div class="line">                sInstance = NULL;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">typedef</span> std::set&lt;dx11ShaderNode*&gt; TNodeSet;</div>
<div class="line">        TNodeSet mNodeSet;</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> mSceneUpdateCallback;</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> mAfterCreateReference;</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> mAfterImport;</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> mAfterLoadReference;</div>
<div class="line"> <span class="keyword">static</span> PostSceneUpdateAttributeRefresher *sInstance;</div>
<div class="line">    };</div>
<div class="line">    PostSceneUpdateAttributeRefresher *PostSceneUpdateAttributeRefresher::sInstance = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">class </span>AfterOpenErrorCB</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> addError(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; errorMsg)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>(sInstance == NULL)</div>
<div class="line">                sInstance = <span class="keyword">new</span> AfterOpenErrorCB;</div>
<div class="line"></div>
<div class="line">            sInstance-&gt;mErrorMsg += errorMsg;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        AfterOpenErrorCB()</div>
<div class="line">        {</div>
<div class="line">            mSceneOpenedCallback = <a class="code" href="./class_m_scene_message.html#a44771b834e9a0ad7291ecdcc880106fe">MSceneMessage::addCallback</a>(<a name="a10"></a><a class="code" href="./class_m_scene_message.html#a4f09127c805cc1f5ee20e67db7b45efaab937dff3e9eba2ea59018ed4b65dd018">MSceneMessage::kAfterOpen</a>, AfterOpenErrorCB::afterOpen );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        ~AfterOpenErrorCB()</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MSceneMessage::removeCallback</a>( mSceneOpenedCallback );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> afterOpen(<span class="keywordtype">void</span>*)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>(sInstance)</div>
<div class="line">            {</div>
<div class="line"> <a name="a11"></a><a class="code" href="./class_m_global.html#a4ddbe97e58a90e1ab05d45a62c006cf0">MGlobal::displayError</a>(sInstance-&gt;mErrorMsg);</div>
<div class="line"></div>
<div class="line"> <span class="keyword">delete</span> sInstance;</div>
<div class="line">                sInstance = NULL;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> mSceneOpenedCallback;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> mErrorMsg;</div>
<div class="line"> <span class="keyword">static</span> AfterOpenErrorCB *sInstance;</div>
<div class="line">    };</div>
<div class="line">    AfterOpenErrorCB *AfterOpenErrorCB::sInstance = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Implicit light bindings are done without generating a dirty</span></div>
<div class="line"> <span class="comment">// notification that the attribute editor can catch and use to</span></div>
<div class="line"> <span class="comment">// update the dropdown menus and text fields used to indicate</span></div>
<div class="line"> <span class="comment">// the current state of the light connections. This class</span></div>
<div class="line"> <span class="comment">// accumulates refresh requests, and sends a single MEL command</span></div>
<div class="line"> <span class="comment">// to refresh the AE when the app becomes idle.</span></div>
<div class="line"> <span class="keyword">class </span>IdleAttributeEditorImplicitRefresher</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> activate()</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (sInstance == NULL)</div>
<div class="line">                sInstance = <span class="keyword">new</span> IdleAttributeEditorImplicitRefresher();</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        IdleAttributeEditorImplicitRefresher()</div>
<div class="line">        {</div>
<div class="line">            mIdleCallback = <a name="a12"></a><a class="code" href="./class_m_event_message.html#a8d22c58b90484867755273c2f7ffc6ec">MEventMessage::addEventCallback</a>( <span class="stringliteral">"idle"</span>, IdleAttributeEditorImplicitRefresher::refresh );</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        ~IdleAttributeEditorImplicitRefresher()</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>( mIdleCallback );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> refresh(<span class="keywordtype">void</span>* data)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (sInstance)</div>
<div class="line">            {</div>
<div class="line"> <a name="a13"></a><a class="code" href="./class_m_global.html#a2c877a6e116f8fd3a6e76387403c023a">MGlobal::executeCommandOnIdle</a>(<span class="stringliteral">"if (exists(\"AEdx11Shader_lightConnectionUpdateAll\")) AEdx11Shader_lightConnectionUpdateAll;"</span>);</div>
<div class="line"> <span class="keyword">delete</span> sInstance;</div>
<div class="line">                sInstance = NULL;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> mIdleCallback;</div>
<div class="line"> <span class="keyword">static</span> IdleAttributeEditorImplicitRefresher *sInstance;</div>
<div class="line">    };</div>
<div class="line">    IdleAttributeEditorImplicitRefresher *IdleAttributeEditorImplicitRefresher::sInstance = NULL;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Convenient template functions to retrieve annotation from dx technique or dx resource variable</span></div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ResourceType&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getNumAnnotations(ResourceType *resource, uint32_t *numAnnotation)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Generic version does not know how to fetch that info</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> <span class="comment">// But there are a few specializations below:</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getNumAnnotations&lt;ID3DX11EffectVariable&gt;(ID3DX11EffectVariable *resource, uint32_t *numAnnotation)</div>
<div class="line">    {</div>
<div class="line">        D3DX11_EFFECT_VARIABLE_DESC varDesc;</div>
<div class="line">        memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_VARIABLE_DESC));</div>
<div class="line">        resource-&gt;GetDesc(&amp;varDesc);</div>
<div class="line">        *numAnnotation = varDesc.Annotations;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getNumAnnotations&lt;ID3DX11EffectShaderResourceVariable&gt;(ID3DX11EffectShaderResourceVariable *resource, uint32_t *numAnnotation)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> getNumAnnotations&lt;ID3DX11EffectVariable&gt;(resource, numAnnotation);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getNumAnnotations&lt;ID3DX11EffectPass&gt;(ID3DX11EffectPass *resource, uint32_t *numAnnotation)</div>
<div class="line">    {</div>
<div class="line">        D3DX11_PASS_DESC varDesc;</div>
<div class="line">        memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_PASS_DESC));</div>
<div class="line">        resource-&gt;GetDesc(&amp;varDesc);</div>
<div class="line">        *numAnnotation = varDesc.Annotations;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getNumAnnotations&lt;ID3DX11EffectTechnique&gt;(ID3DX11EffectTechnique *resource, uint32_t *numAnnotation)</div>
<div class="line">    {</div>
<div class="line">        D3DX11_TECHNIQUE_DESC varDesc;</div>
<div class="line">        memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_TECHNIQUE_DESC));</div>
<div class="line">        resource-&gt;GetDesc(&amp;varDesc);</div>
<div class="line">        *numAnnotation = varDesc.Annotations;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getNumAnnotations&lt;ID3DX11EffectGroup&gt;(ID3DX11EffectGroup *resource, uint32_t *numAnnotation)</div>
<div class="line">    {</div>
<div class="line">        D3DX11_GROUP_DESC varDesc;</div>
<div class="line">        memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_GROUP_DESC));</div>
<div class="line">        resource-&gt;GetDesc(&amp;varDesc);</div>
<div class="line">        *numAnnotation = varDesc.Annotations;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ResourceType&gt;</div>
<div class="line">    ID3DX11EffectVariable* findAnnotationByName(ResourceType *resource, <span class="keyword">const</span> <span class="keywordtype">char</span>* annotationName)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// The latest effect 11 library is very verbose when an annotation</span></div>
<div class="line"> <span class="comment">// is not found by name. This version will stay quiet if the</span></div>
<div class="line"> <span class="comment">// annotation is not found.</span></div>
<div class="line">        uint32_t numAnnotation = -1;</div>
<div class="line">        ID3DX11EffectVariable* retVal = NULL;</div>
<div class="line"> <span class="keywordflow">if</span> (getNumAnnotations(resource, &amp;numAnnotation))</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">for</span> (uint32_t idx = 0; idx &lt; numAnnotation; ++idx)</div>
<div class="line">            {</div>
<div class="line">                ID3DX11EffectVariable* var = resource-&gt;GetAnnotationByIndex(idx);</div>
<div class="line"> <span class="keywordflow">if</span> (var)</div>
<div class="line">                {</div>
<div class="line">                    D3DX11_EFFECT_VARIABLE_DESC varDesc;</div>
<div class="line">                    memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_VARIABLE_DESC));</div>
<div class="line"></div>
<div class="line">                    var-&gt;GetDesc(&amp;varDesc);</div>
<div class="line"> <span class="keywordflow">if</span> (varDesc.Name &amp;&amp; strcmp(varDesc.Name, annotationName) == 0)</div>
<div class="line">                    {</div>
<div class="line">                        retVal = var;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            retVal = resource-&gt;GetAnnotationByName(annotationName);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> retVal;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ResourceType&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getAnnotation(ResourceType *resource, <span class="keyword">const</span> <span class="keywordtype">char</span>* annotationName, <a class="code" href="./class_m_string.html">MString</a>&amp; annotationValue)</div>
<div class="line">    {</div>
<div class="line">        ID3DX11EffectVariable* annotation = findAnnotationByName(resource, annotationName);</div>
<div class="line"> <span class="keywordflow">if</span>(annotation &amp;&amp; annotation-&gt;IsValid())</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectStringVariable* strVariable = annotation-&gt;AsString();</div>
<div class="line"> <span class="keywordflow">if</span>(strVariable &amp;&amp; strVariable-&gt;IsValid())</div>
<div class="line">            {</div>
<div class="line">                LPCSTR value;</div>
<div class="line"> <span class="keywordflow">if</span>( SUCCEEDED ( strVariable-&gt;GetString( &amp;value ) ) )</div>
<div class="line">                {</div>
<div class="line">                    annotationValue = <a class="code" href="./class_m_string.html">MString</a>(value);</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ResourceType&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getAnnotation(ResourceType *resource, <span class="keyword">const</span> <span class="keywordtype">char</span>* annotationName, <span class="keywordtype">float</span>&amp; annotationValue)</div>
<div class="line">    {</div>
<div class="line">        ID3DX11EffectVariable* annotation = findAnnotationByName(resource, annotationName);</div>
<div class="line"> <span class="keywordflow">if</span>(annotation &amp;&amp; annotation-&gt;IsValid())</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectScalarVariable* scalarVariable = annotation-&gt;AsScalar();</div>
<div class="line"> <span class="keywordflow">if</span>(scalarVariable &amp;&amp; scalarVariable-&gt;IsValid())</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">float</span> value;</div>
<div class="line"> <span class="keywordflow">if</span>( SUCCEEDED ( scalarVariable-&gt;GetFloat( &amp;value ) ) )</div>
<div class="line">                {</div>
<div class="line">                    annotationValue = value;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ResourceType&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getAnnotation(ResourceType *resource, <span class="keyword">const</span> <span class="keywordtype">char</span>* annotationName, <span class="keywordtype">int</span>&amp; annotationValue)</div>
<div class="line">    {</div>
<div class="line">        ID3DX11EffectVariable* annotation = findAnnotationByName(resource, annotationName);</div>
<div class="line"> <span class="keywordflow">if</span>(annotation &amp;&amp; annotation-&gt;IsValid())</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectScalarVariable* scalarVariable = annotation-&gt;AsScalar();</div>
<div class="line"> <span class="keywordflow">if</span>(scalarVariable &amp;&amp; scalarVariable-&gt;IsValid())</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">int</span> value;</div>
<div class="line"> <span class="keywordflow">if</span>( SUCCEEDED ( scalarVariable-&gt;GetInt( &amp;value ) ) )</div>
<div class="line">                {</div>
<div class="line">                    annotationValue = value;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ResourceType&gt;</div>
<div class="line"> <span class="keywordtype">bool</span> getAnnotation(ResourceType *resource, <span class="keyword">const</span> <span class="keywordtype">char</span>* annotationName, <span class="keywordtype">bool</span>&amp; annotationValue)</div>
<div class="line">    {</div>
<div class="line">        ID3DX11EffectVariable* annotation = findAnnotationByName(resource, annotationName);</div>
<div class="line"> <span class="keywordflow">if</span>(annotation &amp;&amp; annotation-&gt;IsValid())</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectScalarVariable* scalarVariable = annotation-&gt;AsScalar();</div>
<div class="line"> <span class="keywordflow">if</span>(scalarVariable &amp;&amp; scalarVariable-&gt;IsValid())</div>
<div class="line">            {</div>
<div class="line"><span class="preprocessor">#if defined(USE_BOOL)</span></div>
<div class="line">                BOOL value;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> <span class="keywordtype">bool</span> value;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> <span class="keywordflow">if</span>( SUCCEEDED ( scalarVariable-&gt;GetBool( &amp;value ) ) )</div>
<div class="line">                {</div>
<div class="line">                    annotationValue = (value != 0);</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                ID3DX11EffectStringVariable* strVariable = annotation-&gt;AsString();</div>
<div class="line"> <span class="keywordflow">if</span>(strVariable &amp;&amp; strVariable-&gt;IsValid())</div>
<div class="line">                {</div>
<div class="line">                    LPCSTR value;</div>
<div class="line"> <span class="keywordflow">if</span>( SUCCEEDED ( strVariable-&gt;GetString( &amp;value ) ) )</div>
<div class="line">                    {</div>
<div class="line">                        annotationValue = (_stricmp(value, dx11ShaderAnnotationValue::kTrue) == 0);</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Convert varying parameter semantic to geometry semantic</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4">MHWRender::MGeometry::Semantic</a> getVertexBufferSemantic(<a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321">MVaryingParameter::MVaryingParameterSemantic</a> semantic)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">switch</span> (semantic) {</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a14"></a><a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321aa20581584e5f9447cb96afb4f2e10703">MVaryingParameter::kPosition</a>:  <span class="keywordflow">return</span> <a name="a15"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4aa20581584e5f9447cb96afb4f2e10703">MHWRender::MGeometry::kPosition</a>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a16"></a><a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a227e8416235cd3b43077ca91504a463f">MVaryingParameter::kNormal</a>:    <span class="keywordflow">return</span> <a name="a17"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a227e8416235cd3b43077ca91504a463f">MHWRender::MGeometry::kNormal</a>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a18"></a><a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a45b7096916b12a78e94c62bba9d50739">MVaryingParameter::kTexCoord</a>:  <span class="keywordflow">return</span> <a name="a19"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93">MHWRender::MGeometry::kTexture</a>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a20"></a><a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321afc0133ebaa6c307b2388ecf5f72f6fdf">MVaryingParameter::kColor</a>:     <span class="keywordflow">return</span> <a name="a21"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4afc0133ebaa6c307b2388ecf5f72f6fdf">MHWRender::MGeometry::kColor</a>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a22"></a><a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321ab90d6591156ad2cb2eea2cb5b75e77e0">MVaryingParameter::kTangent</a>:   <span class="keywordflow">return</span> <a name="a23"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4ab90d6591156ad2cb2eea2cb5b75e77e0">MHWRender::MGeometry::kTangent</a>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a24"></a><a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a7dd396b8135e53c57a88a0d466884e39">MVaryingParameter::kBinormal</a>:  <span class="keywordflow">return</span> <a name="a25"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4af6ed1c5faf6f0993971e8043ffa1a111">MHWRender::MGeometry::kBitangent</a>;</div>
<div class="line"> <span class="comment">//      case MVaryingParameter::kWeight:    return MGeometry::kInvalidSemantic;</span></div>
<div class="line"> <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <a name="a26"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a03ba792a88b3d83bfb00b11a23a50ba3">MHWRender::MGeometry::kInvalidSemantic</a>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> layerNameSeparator(L<span class="charliteral">'\r'</span>);</div>
<div class="line"> <span class="keywordtype">void</span> getTextureDesc(<span class="keyword">const</span> <a name="_a27"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context, <span class="keyword">const</span> <a name="_a28"></a><a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a>&amp; uniform, <a class="code" href="./class_m_string.html">MString</a> &amp;fileName, <a class="code" href="./class_m_string.html">MString</a> &amp;layerName, <span class="keywordtype">int</span> &amp;alphaChannelIdx)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span>(!uniform.<a name="a29"></a><a class="code" href="./class_m_uniform_parameter.html#a37357b066d4c628b1fae2f1ee08b2b12">isATexture</a>())</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">        fileName = uniform.<a name="a30"></a><a class="code" href="./class_m_uniform_parameter.html#ae9f61935fee5d55a0df8bd4b2013a679">getAsString</a>(context);</div>
<div class="line"> <span class="keywordflow">if</span>(fileName.<a name="a31"></a><a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0)  <span class="comment">// file name is empty no need to process the layer name</span></div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        layerName.<a name="a32"></a><a class="code" href="./class_m_string.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>();</div>
<div class="line">        alphaChannelIdx = -1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the file/layer separator .. texture name set for the uv editor .. cf dx11ShaderNode::renderImage()</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> idx = fileName.<a name="a33"></a><a class="code" href="./class_m_string.html#aaa76dfd27998dc2ff937d3690d11391c">indexW</a>(layerNameSeparator);</div>
<div class="line"> <span class="keywordflow">if</span>(idx &gt;= 0)</div>
<div class="line">        {</div>
<div class="line"> <a name="_a34"></a><a class="code" href="./class_m_string_array.html">MStringArray</a> splitData;</div>
<div class="line">            fileName.<a name="a35"></a><a class="code" href="./class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">split</a>(layerNameSeparator, splitData);</div>
<div class="line"> <span class="keywordflow">if</span>(splitData.<a name="a36"></a><a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 2)</div>
<div class="line">                alphaChannelIdx = splitData[2].asInt();</div>
<div class="line"> <span class="keywordflow">if</span>(splitData.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 1)</div>
<div class="line">                layerName = splitData[1];</div>
<div class="line">            fileName = splitData[0];</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Look for the layerSetName attribute</span></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> node = uniform.<a name="a37"></a><a class="code" href="./class_m_uniform_parameter.html#a000c434a3beb6c2cc9681d9e445cf0eb">getSource</a>().<a name="a38"></a><a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>();</div>
<div class="line"> <a name="_a39"></a><a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> dependNode;</div>
<div class="line">            dependNode.<a name="a40"></a><a class="code" href="./class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>(node);</div>
<div class="line"></div>
<div class="line"> <a name="_a41"></a><a class="code" href="./class_m_plug.html">MPlug</a> plug = dependNode.<a name="a42"></a><a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(<span class="stringliteral">"layerSetName"</span>);</div>
<div class="line"> <span class="keywordflow">if</span>(!plug.<a name="a43"></a><a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>()) {</div>
<div class="line">                plug.<a name="a44"></a><a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>(layerName);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Look for the alpha channel index :</span></div>
<div class="line"> <span class="comment">// - get the select alpha channel name</span></div>
<div class="line"> <span class="comment">// - get the list of all alpha channels</span></div>
<div class="line"> <span class="comment">// - resolve index</span></div>
<div class="line">            plug = dependNode.<a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(<span class="stringliteral">"alpha"</span>);</div>
<div class="line"> <span class="keywordflow">if</span>(!plug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>()) {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> alphaChannel;</div>
<div class="line">                plug.<a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>(alphaChannel);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(alphaChannel.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0) {</div>
<div class="line"> <span class="keywordflow">if</span>(alphaChannel == <span class="stringliteral">"Default"</span>) {</div>
<div class="line">                        alphaChannelIdx = 1;</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                        plug = dependNode.<a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(<span class="stringliteral">"alphaList"</span>);</div>
<div class="line"> <span class="keywordflow">if</span>(!plug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>()) {</div>
<div class="line"> <a name="_a45"></a><a class="code" href="./class_m_data_handle.html">MDataHandle</a> dataHandle;</div>
<div class="line">                            plug.<a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>(dataHandle);</div>
<div class="line"> <span class="keywordflow">if</span>(dataHandle.<a name="a46"></a><a class="code" href="./class_m_data_handle.html#aa7d5edae2cc3b032294d95ff3afb17cb">type</a>() == <a name="a47"></a><a class="code" href="./class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7a7f61c3f7033fde37de0e63f291c9e834">MFnData::kStringArray</a>) {</div>
<div class="line"> <a name="_a48"></a><a class="code" href="./class_m_fn_string_array_data.html">MFnStringArrayData</a> stringArrayData (dataHandle.<a name="a49"></a><a class="code" href="./class_m_data_handle.html#a31773b870681e1f6b3ad82ff58de33bc">data</a>());</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> allAlphaChannels;</div>
<div class="line">                                stringArrayData.copyTo(allAlphaChannels);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = allAlphaChannels.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; count; ++idx) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; channel = allAlphaChannels[idx];</div>
<div class="line"> <span class="keywordflow">if</span>(channel == alphaChannel) {</div>
<div class="line">                                        alphaChannelIdx = idx + 2;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                                    }</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Return only the file name (with or without extension) of a given file path</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> getFileName(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> &amp;filePath, <span class="keywordtype">bool</span> withExtension = <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a50"></a><a class="code" href="./class_m_file_object.html">MFileObject</a> file;</div>
<div class="line">        file.<a name="a51"></a><a class="code" href="./class_m_file_object.html#ac14aefbfe38c2711256eb8c14a3194ee">setRawFullName</a>(filePath);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> fileName = file.<a name="a52"></a><a class="code" href="./class_m_file_object.html#a614484d9028d9d09418b5e337c39b7a0">resolvedName</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(withExtension == <span class="keyword">false</span>)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">int</span> idx = fileName.<a name="a53"></a><a class="code" href="./class_m_string.html#a8b323761724ea9659348e33b0fea356b">rindexW</a>(L<span class="charliteral">'.'</span>);</div>
<div class="line"> <span class="keywordflow">if</span>(idx &gt; 0) fileName = fileName.<a name="a54"></a><a class="code" href="./class_m_string.html#ad748626e545fa6db3afc2f61644b5d62">substringW</a>( 0, idx-1 );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> fileName;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Return true if the file name (without path or extension) is the same</span></div>
<div class="line"> <span class="keywordtype">bool</span> isSameEffect(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> &amp;filePath1, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> &amp;filePath2)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Get only the file names</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> fileName1 = getFileName(filePath1);</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> fileName2 = getFileName(filePath2);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> (fileName1 == fileName2);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Convert Maya light type to dx11Shader light type</span></div>
<div class="line">    dx11ShaderNode::ELightType getLightType(<span class="keyword">const</span> <a name="_a55"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* lightParam)</div>
<div class="line">    {</div>
<div class="line">        dx11ShaderNode::ELightType type = dx11ShaderNode::eUndefinedLight;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> lightType = lightParam-&gt;<a name="a56"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a37c38ea0bd5da4c4f846f673a418be78">lightType</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The 3rd letter of the light name is a perfect hash,</span></div>
<div class="line"> <span class="comment">// so let's cut on the number of string comparisons.</span></div>
<div class="line"> <span class="keywordflow">if</span> (lightType.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 2) {</div>
<div class="line"> <span class="keywordflow">switch</span> (lightType.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>()[2])</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:</div>
<div class="line"> <span class="keywordflow">if</span> (::strcmp(lightType.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),<span class="stringliteral">"spotLight"</span>) == 0)</div>
<div class="line">                    type = dx11ShaderNode::eSpotLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:</div>
<div class="line"> <span class="keywordflow">if</span> (::strcmp(lightType.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),<span class="stringliteral">"directionalLight"</span>) == 0)</div>
<div class="line"> <span class="comment">// The headlamp used in the "Use default lighting" mode</span></div>
<div class="line"> <span class="comment">// does not have the same set of attributes as a regular</span></div>
<div class="line"> <span class="comment">// directional light, so we must disambiguate them</span></div>
<div class="line"> <span class="comment">// otherwise we might not know how to fetch shadow data</span></div>
<div class="line"> <span class="comment">// from the regular kind.</span></div>
<div class="line"> <span class="keywordflow">if</span> (lightParam-&gt;<a name="a57"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#ac8cc78537b5a5d66bd3cc96bf8ef506e">lightPath</a>().<a name="a58"></a><a class="code" href="./class_m_dag_path.html#a095ae34296e81703965265a42ee783ca">isValid</a>())</div>
<div class="line">                        type = dx11ShaderNode::eDirectionalLight;</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                        type = dx11ShaderNode::eDefaultLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:</div>
<div class="line"> <span class="keywordflow">if</span> (::strcmp(lightType.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),<span class="stringliteral">"pointLight"</span>) == 0)</div>
<div class="line">                    type = dx11ShaderNode::ePointLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:</div>
<div class="line"> <span class="keywordflow">if</span> (::strcmp(lightType.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),<span class="stringliteral">"ambientLight"</span>) == 0)</div>
<div class="line">                    type = dx11ShaderNode::eAmbientLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:</div>
<div class="line"> <span class="keywordflow">if</span> (::strcmp(lightType.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),<span class="stringliteral">"volumeLight"</span>) == 0)</div>
<div class="line">                    type = dx11ShaderNode::eVolumeLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:</div>
<div class="line"> <span class="keywordflow">if</span> (::strcmp(lightType.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),<span class="stringliteral">"areaLight"</span>) == 0)</div>
<div class="line">                    type = dx11ShaderNode::eAreaLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> type;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Determine if scene light is compatible with shader light</span></div>
<div class="line"> <span class="keywordtype">bool</span> isLightAcceptable(dx11ShaderNode::ELightType shaderLightType, dx11ShaderNode::ELightType sceneLightType)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// a Spot light is acceptable for any light types, providing both the direction and position properties.</span></div>
<div class="line"> <span class="keywordflow">if</span>(sceneLightType == dx11ShaderNode::eSpotLight)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// a Directional light only provides direction property.</span></div>
<div class="line"> <span class="keywordflow">if</span>(sceneLightType == dx11ShaderNode::eDirectionalLight || sceneLightType == dx11ShaderNode::eDefaultLight)</div>
<div class="line"> <span class="keywordflow">return</span> (shaderLightType == dx11ShaderNode::eDirectionalLight || shaderLightType == dx11ShaderNode::eAmbientLight);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// a Point light only provides position property, same for volume and area lights</span></div>
<div class="line"> <span class="keywordflow">if</span>(sceneLightType == dx11ShaderNode::ePointLight ||</div>
<div class="line">           sceneLightType == dx11ShaderNode::eAreaLight ||</div>
<div class="line">           sceneLightType == dx11ShaderNode::eVolumeLight)</div>
<div class="line"> <span class="keywordflow">return</span> (shaderLightType == dx11ShaderNode::ePointLight || shaderLightType == dx11ShaderNode::eAmbientLight);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// an Ambient light provides neither direction nor position properties.</span></div>
<div class="line"> <span class="keywordflow">if</span>(sceneLightType == dx11ShaderNode::eAmbientLight)</div>
<div class="line"> <span class="keywordflow">return</span> (shaderLightType == dx11ShaderNode::eAmbientLight);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The light information in the draw context has M attributes that we</span></div>
<div class="line"> <span class="comment">// want to match to the N attributes of the shader. In order to do so</span></div>
<div class="line"> <span class="comment">// in less than O(MxN) we create this static mapping between a light</span></div>
<div class="line"> <span class="comment">// semantic and the corresponding DC light attribute names whose value</span></div>
<div class="line"> <span class="comment">// needs to be fetched to refresh a shader parameter value.</span></div>
<div class="line"> <span class="keyword">typedef</span> std::vector&lt;MStringArray&gt; TNamesForSemantic;</div>
<div class="line"> <span class="keyword">typedef</span> std::vector&lt;TNamesForSemantic&gt; TSemanticNamesForLight;</div>
<div class="line"> <span class="keyword">static</span> TSemanticNamesForLight sSemanticNamesForLight(dx11ShaderNode::eLightCount);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> buildDrawContextParameterNames(dx11ShaderNode::ELightType lightType, <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* lightParam)</div>
<div class="line">    {</div>
<div class="line">        TNamesForSemantic&amp; namesForLight(sSemanticNamesForLight[lightType]);</div>
<div class="line">        namesForLight.resize(CUniformParameterBuilder::eLastParameterType);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> params;</div>
<div class="line">        lightParam-&gt;<a name="a59"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aec00be694fc8d654f1f7a8ea823a7cea">parameterList</a>(params);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; params.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); ++p)</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> pname = params[p];</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206">MHWRender::MLightParameterInformation::StockParameterSemantic</a> semantic = lightParam-&gt;<a name="a60"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a37a7621bc6d9453902d95132fbbe2101">parameterSemantic</a>( pname );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (semantic)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a61"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a3305693a0baf5df5ae2efc000aa9c017">MHWRender::MLightParameterInformation::kWorldPosition</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightPosition].append(pname);</div>
<div class="line"> <span class="keywordflow">if</span> (pname == <span class="stringliteral">"LP0"</span>)</div>
<div class="line">                    namesForLight[CUniformParameterBuilder::eLightAreaPosition0].append(pname);</div>
<div class="line"> <span class="keywordflow">if</span> (pname == <span class="stringliteral">"LP1"</span>)</div>
<div class="line">                    namesForLight[CUniformParameterBuilder::eLightAreaPosition1].append(pname);</div>
<div class="line"> <span class="keywordflow">if</span> (pname == <span class="stringliteral">"LP2"</span>)</div>
<div class="line">                    namesForLight[CUniformParameterBuilder::eLightAreaPosition2].append(pname);</div>
<div class="line"> <span class="keywordflow">if</span> (pname == <span class="stringliteral">"LP3"</span>)</div>
<div class="line">                    namesForLight[CUniformParameterBuilder::eLightAreaPosition3].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a62"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a4006a71da7e8283c7211624c49022eea">MHWRender::MLightParameterInformation::kWorldDirection</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightDirection].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a63"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206ae19f0601680f2872a292474ab3088b4f">MHWRender::MLightParameterInformation::kIntensity</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightIntensity].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a64"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206afc0133ebaa6c307b2388ecf5f72f6fdf">MHWRender::MLightParameterInformation::kColor</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightColor].append(pname);</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightAmbientColor].append(pname);</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightSpecularColor].append(pname);</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightDiffuseColor].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="comment">// Parameter type extraction for shadow maps</span></div>
<div class="line"> <span class="keywordflow">case</span> <a name="a65"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206aca46ea808cc9f011b3f4f014ec9040f3">MHWRender::MLightParameterInformation::kGlobalShadowOn</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a66"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a4852662e5cbf7f64d85133baa57386ab">MHWRender::MLightParameterInformation::kShadowOn</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightShadowOn].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a67"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206ae05ca22a699a25e0d2030a7a440ecbbe">MHWRender::MLightParameterInformation::kShadowViewProj</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightShadowViewProj].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a68"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a6053be989430b7fbd8b07f51528e8df4">MHWRender::MLightParameterInformation::kShadowMap</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightShadowOn].append(pname);</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightShadowMap].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a69"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206ac1cd724f83701837aee2364b308a9ed2">MHWRender::MLightParameterInformation::kShadowColor</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightShadowColor].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a70"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206ace22882d5498baf50154a878321e7953">MHWRender::MLightParameterInformation::kShadowBias</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightShadowMapBias].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a71"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a69b7eb958dd9600fc657a046524e2371">MHWRender::MLightParameterInformation::kCosConeAngle</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightHotspot].append(pname);</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eLightFalloff].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a72"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a0be6585329840971e20d964386187935">MHWRender::MLightParameterInformation::kDecayRate</a>:</div>
<div class="line">                namesForLight[CUniformParameterBuilder::eDecayRate].append(pname);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string_array.html">MStringArray</a>&amp; drawContextParameterNames(dx11ShaderNode::ELightType lightType, <span class="keywordtype">int</span> paramType, <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* lightParam)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (sSemanticNamesForLight[lightType].size() == 0)</div>
<div class="line">            buildDrawContextParameterNames(lightType, lightParam);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> sSemanticNamesForLight[lightType][paramType];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">        Get the valid primitive topology.</span></div>
<div class="line"><span class="comment">        If no hull shader, return simple topology based on primitive type (points, lines, triangles ...)</span></div>
<div class="line"><span class="comment">        If a hull shader is detected return the according patchlist based on the primitive type and primitive patch mode</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    D3D11_PRIMITIVE_TOPOLOGY getPrimitiveTopology(<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MHWRender::MGeometry::Primitive</a> primitiveType, <span class="keywordtype">int</span> primitiveStride, <span class="keywordtype">bool</span> containsHullShader)</div>
<div class="line">    {</div>
<div class="line">        D3D11_PRIMITIVE_TOPOLOGY topology = D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (primitiveType)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a73"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea57a311fc6dd7498f2339ab45af414377">MHWRender::MGeometry::kPoints</a>:</div>
<div class="line">            topology = (containsHullShader ? D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST : D3D11_PRIMITIVE_TOPOLOGY_POINTLIST);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <a name="a74"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea9808e481c6346dfc333afb4c52890ac9">MHWRender::MGeometry::kLines</a>:</div>
<div class="line">            topology = (containsHullShader ? D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST : D3D11_PRIMITIVE_TOPOLOGY_LINELIST);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <a name="a75"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea505d8b3b6fdcadeb908f49f661e66957">MHWRender::MGeometry::kLineStrip</a>:</div>
<div class="line">            topology = (containsHullShader ? D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST : D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <a name="a76"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1eaa2c70dd76c8172a9298334473c914304">MHWRender::MGeometry::kTriangles</a>:</div>
<div class="line">            topology = (containsHullShader ? D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST : D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <a name="a77"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea6f6fdd3e537134843d971d56257d1bfc">MHWRender::MGeometry::kTriangleStrip</a>:</div>
<div class="line">            topology = (containsHullShader ? D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST : D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> <a name="a78"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea23d4e011c2b72a286021ca9a5a121830">MHWRender::MGeometry::kPatch</a>:</div>
<div class="line"> <span class="keywordflow">if</span>(primitiveStride &gt;= 1 &amp;&amp; primitiveStride &lt;= 32)</div>
<div class="line">                topology = (D3D11_PRIMITIVE_TOPOLOGY)((<span class="keywordtype">int</span>)(D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST) + primitiveStride - 1);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> topology;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>MatchingParameter</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4">MHWRender::MGeometry::Semantic</a> semantic;</div>
<div class="line"> <span class="keywordtype">int</span> semanticIndex;</div>
<div class="line"> <span class="keywordtype">int</span> dimension;</div>
<div class="line"> <span class="keywordtype">int</span> elementSize;</div>
<div class="line">    };</div>
<div class="line"> <span class="keyword">typedef</span> std::vector&lt;MatchingParameter&gt; MatchingParameters;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> getDstSemanticsFromSrcVertexDescriptor( <span class="keyword">const</span> <a name="_a79"></a><a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>&amp; varyingParameters, <a name="_a80"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a> <span class="keyword">const</span> &amp;vertexDescription, MatchingParameters&amp; parameters)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4">MHWRender::MGeometry::Semantic</a>  vbSemantics = vertexDescription.<a name="a81"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> varId=0; varId &lt; varyingParameters.<a name="a82"></a><a class="code" href="./class_m_varying_parameter_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>(); ++varId)</div>
<div class="line">        {</div>
<div class="line"> <a name="_a83"></a><a class="code" href="./class_m_varying_parameter.html">MVaryingParameter</a>               varying             = varyingParameters.<a name="a84"></a><a class="code" href="./class_m_varying_parameter_list.html#afd7b2e4c7c40b34ef1c8e146c27fb059">getElement</a>(varId);</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4">MHWRender::MGeometry::Semantic</a>  varyingSemantics    = getVertexBufferSemantic( varying.<a name="a85"></a><a class="code" href="./class_m_varying_parameter.html#ad72ff2b3fb20052e4a2455dad5c10682">getSourceType</a>() );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (vbSemantics==varyingSemantics) {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> descriptionName     = vertexDescription.<a name="a86"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aca2cba4630391c78dcf1a828986160da">name</a>();</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> varyingName         = varying.<a name="a87"></a><a class="code" href="./class_m_varying_parameter.html#a45e2132632639698f9c4f668be933a70">getSourceSetName</a>();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>*     varyingMap          = strstr(varyingName.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),<span class="stringliteral">"map"</span>);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>*     descriptionMap      = strstr(descriptionName.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),<span class="stringliteral">"map"</span>);</div>
<div class="line"> <span class="keywordtype">int</span> varyingBufferIndex = 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> bMatchFound = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( varyingName.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0 ) {</div>
<div class="line">                    bMatchFound = (descriptionName==varyingName);</div>
<div class="line"> <span class="keywordflow">if</span> (bMatchFound) {</div>
<div class="line"> <span class="comment">// The srcName can be overwritten, so we cannot retrieve</span></div>
<div class="line"> <span class="comment">// varyingBufferIndex from there, but the destName still</span></div>
<div class="line"> <span class="comment">// contains the information we need:</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> varyingDestName = varying.<a name="a88"></a><a class="code" href="./class_m_varying_parameter.html#a3c6621d567f5ac0c682a6fe323169942">destinationSet</a>();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* firstDigit = varyingDestName.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line"> <span class="keywordflow">while</span> (*firstDigit &amp;&amp; !isdigit(*firstDigit))</div>
<div class="line">                            ++firstDigit;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Maya's 'colorSet' default naming scheme differs slightly from the 'map' default naming scheme:</span></div>
<div class="line"> <span class="keywordtype">bool</span> isColorSet = (varyingSemantics == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4afc0133ebaa6c307b2388ecf5f72f6fdf">MHWRender::MGeometry::kColor</a>);</div>
<div class="line"> <span class="keywordflow">if</span> (!isColorSet)</div>
<div class="line">                            varyingBufferIndex = *firstDigit ? atoi(firstDigit)-1 : 0;</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                            varyingBufferIndex = *firstDigit ? atoi(firstDigit) : 0;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    varyingBufferIndex  = varyingMap ? atoi(varyingMap+3)-1 : 0;</div>
<div class="line"> <span class="keywordtype">int</span> descriptionIndex    = descriptionMap ? atoi(descriptionMap+3)-1 : 0;</div>
<div class="line">                    bMatchFound = (descriptionIndex==varyingBufferIndex);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// we may have found the right Match let's match the source set</span></div>
<div class="line"> <span class="comment">// and make sure we count the occurences. for example we may have mapped both</span></div>
<div class="line"> <span class="comment">// normal and position on the position buffer so, the first time we will encounter</span></div>
<div class="line"> <span class="comment">// position it will refer to normal the second to position</span></div>
<div class="line"> <span class="keywordflow">if</span> (bMatchFound) {</div>
<div class="line"></div>
<div class="line">                    MatchingParameter param = { getVertexBufferSemantic( varying.<a name="a89"></a><a class="code" href="./class_m_varying_parameter.html#aa54f29a363de8795281d2e6e978e894c">semantic</a>() ), varyingBufferIndex, varying.<a name="a90"></a><a class="code" href="./class_m_varying_parameter.html#ae5acbe47d704ceb866e3717e2ac9422f">dimension</a>(), varying.<a name="a91"></a><a class="code" href="./class_m_varying_parameter.html#aa4a7975d9e4cdf0b0b6782bcfddc2223">getElementSize</a>() };</div>
<div class="line">                    parameters.push_back(param);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>dx11SemanticInfo</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>*                                     Name;</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321">MVaryingParameter::MVaryingParameterSemantic</a>    Type;</div>
<div class="line"> <span class="keywordtype">int</span>                                             MinElements;</div>
<div class="line"> <span class="keywordtype">int</span>                                             MaxElements;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">        Convert an effect variable to a varying parameter.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        Standard semantics are Position, Normal, TexCoord, Tangent, Binormal and Color,</span></div>
<div class="line"><span class="comment">        any other value will be considered as a custom semantic and given the textCoord type.</span></div>
<div class="line"><span class="comment">        A custom semantic should be associated with a vertex buffer generator to provide the desired content.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        Two hard-coded custom semantics are handled by the plugin and intended to work with</span></div>
<div class="line"><span class="comment">        the customPrimitiveGenerator plugin example.</span></div>
<div class="line"><span class="comment">        When the customPositionStream and customNormalStream semantics are identified, they are given</span></div>
<div class="line"><span class="comment">        the position and normal types respectively, and the custom primitive name customPrimitiveTest.</span></div>
<div class="line"><span class="comment">        The customPrimitiveGenerator plugin implements two vertex buffer generators and a primitive generator.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> appendVaryingParameter(<span class="keyword">const</span> D3D11_SIGNATURE_PARAMETER_DESC &amp;paramDesc, <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>&amp; varyingParameters, <a class="code" href="./class_m_string.html">MString</a> &amp;errorLog, <a class="code" href="./class_m_string.html">MString</a> &amp;warningLog, <a class="code" href="./class_m_string.html">MString</a> &amp;customIndexBufferType)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> dx11SemanticInfo gDx11SemanticInfo[] =</div>
<div class="line">        {</div>
<div class="line">            { dx11ShaderSemantic::kPosition,    <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321aa20581584e5f9447cb96afb4f2e10703">MVaryingParameter::kPosition</a>,   3, 4 } ,</div>
<div class="line">            { dx11ShaderSemantic::kNormal,      <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a227e8416235cd3b43077ca91504a463f">MVaryingParameter::kNormal</a>,     3, 4 } ,</div>
<div class="line">            { dx11ShaderSemantic::kTexCoord,    <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a45b7096916b12a78e94c62bba9d50739">MVaryingParameter::kTexCoord</a>,   2, 2 } ,</div>
<div class="line">            { dx11ShaderSemantic::kTangent,     <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321ab90d6591156ad2cb2eea2cb5b75e77e0">MVaryingParameter::kTangent</a>,    3, 4 } ,</div>
<div class="line">            { dx11ShaderSemantic::kBinormal,    <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a7dd396b8135e53c57a88a0d466884e39">MVaryingParameter::kBinormal</a>,   3, 4 } ,</div>
<div class="line">            { dx11ShaderSemantic::kColor,       <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321afc0133ebaa6c307b2388ecf5f72f6fdf">MVaryingParameter::kColor</a>,      4, 4 }</div>
<div class="line">        };</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">int</span> dx11SemanticInfoCount = <span class="keyword">sizeof</span>(gDx11SemanticInfo) / <span class="keyword">sizeof</span>(dx11SemanticInfo);</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">int</span> dx11SemanticTextCoordId = 2;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> semanticInfoId = 0;</div>
<div class="line"> <span class="keywordflow">for</span> (; semanticInfoId &lt; dx11SemanticInfoCount; ++semanticInfoId) {</div>
<div class="line"> <span class="keywordflow">if</span> (::_stricmp(paramDesc.SemanticName, gDx11SemanticInfo[semanticInfoId].Name ) == 0) <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> isCustomSemantic = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">if</span>(semanticInfoId &gt;= dx11SemanticInfoCount)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// This is a custom named input.</span></div>
<div class="line">            isCustomSemantic = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">bool</span> enableCustomPrimitiveGenerator = (getenv(<span class="stringliteral">"MAYA_USE_CUSTOMPRIMITIVEGENERATOR"</span>) != NULL);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(enableCustomPrimitiveGenerator &amp;&amp; ::_stricmp(paramDesc.SemanticName, dx11ShaderSemanticValue::kCustomPositionStream) == 0) {</div>
<div class="line">                semanticInfoId = 0; <span class="comment">// Position</span></div>
<div class="line">                customIndexBufferType = dx11ShaderSemanticValue::kCustomPrimitiveTest;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>(enableCustomPrimitiveGenerator &amp;&amp; ::_stricmp(paramDesc.SemanticName, dx11ShaderSemanticValue::kCustomNormalStream) == 0) {</div>
<div class="line">                semanticInfoId = 1; <span class="comment">// Normal</span></div>
<div class="line">                customIndexBufferType = dx11ShaderSemanticValue::kCustomPrimitiveTest;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// Treat it as a texture but retain the semantic name.</span></div>
<div class="line">                semanticInfoId = dx11SemanticTextCoordId;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321">MVaryingParameter::MVaryingParameterSemantic</a> fieldType = gDx11SemanticInfo[semanticInfoId].Type;</div>
<div class="line"> <span class="keywordtype">int</span> minWidth = gDx11SemanticInfo[semanticInfoId].MinElements;</div>
<div class="line"> <span class="keywordtype">int</span> maxWidth = gDx11SemanticInfo[semanticInfoId].MaxElements;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* semanticName = isCustomSemantic ? paramDesc.SemanticName : gDx11SemanticInfo[semanticInfoId].Name;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> fieldWidth = 0;</div>
<div class="line"> <span class="keywordflow">switch</span> (paramDesc.Mask)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">case</span> 15:    fieldWidth = 4; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> 7:     fieldWidth = 3; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> 3:     fieldWidth = 2; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> 1:     fieldWidth = 1; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:    fieldWidth = 0; <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html#a4ea19e67748f44a8d29cf34474b0a7d3">MVaryingParameter::MVaryingParameterType</a> dataType = <a name="a92"></a><a class="code" href="./class_m_varying_parameter.html#a4ea19e67748f44a8d29cf34474b0a7d3af8c5f748892ec74b32719c8fba7767e1">MVaryingParameter::kInvalidParameter</a>;</div>
<div class="line"> <span class="keywordflow">switch</span> (paramDesc.ComponentType)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">case</span> D3D10_REGISTER_COMPONENT_FLOAT32:  dataType = <a name="a93"></a><a class="code" href="./class_m_varying_parameter.html#a4ea19e67748f44a8d29cf34474b0a7d3a5686197bafb177bdc82550848416a1ad">MVaryingParameter::kFloat</a>; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> D3D10_REGISTER_COMPONENT_SINT32:   dataType = <a name="a94"></a><a class="code" href="./class_m_varying_parameter.html#a4ea19e67748f44a8d29cf34474b0a7d3ae3e576e62ae36818ff6edced2065c36e">MVaryingParameter::kInt32</a>; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> D3D10_REGISTER_COMPONENT_UINT32:   dataType = <a name="a95"></a><a class="code" href="./class_m_varying_parameter.html#a4ea19e67748f44a8d29cf34474b0a7d3aa93f90f58b3077bdbedeb9506e0143fd">MVaryingParameter::kUnsignedInt32</a>; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:                                dataType = <a class="code" href="./class_m_varying_parameter.html#a4ea19e67748f44a8d29cf34474b0a7d3af8c5f748892ec74b32719c8fba7767e1">MVaryingParameter::kInvalidParameter</a>; <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        std::ostringstream destinationSet;</div>
<div class="line">        std::ostringstream name;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (fieldType)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a45b7096916b12a78e94c62bba9d50739">MVaryingParameter::kTexCoord</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321ab90d6591156ad2cb2eea2cb5b75e77e0">MVaryingParameter::kTangent</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a7dd396b8135e53c57a88a0d466884e39">MVaryingParameter::kBinormal</a>:</div>
<div class="line">            {</div>
<div class="line">                destinationSet &lt;&lt; <span class="stringliteral">"map"</span> &lt;&lt; (paramDesc.SemanticIndex+1);</div>
<div class="line">                name &lt;&lt; semanticName &lt;&lt; int(paramDesc.SemanticIndex);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321afc0133ebaa6c307b2388ecf5f72f6fdf">MVaryingParameter::kColor</a>:</div>
<div class="line">            {</div>
<div class="line">                destinationSet &lt;&lt; <span class="stringliteral">"colorSet"</span>;</div>
<div class="line"> <span class="keywordflow">if</span> ( paramDesc.SemanticIndex &gt; 0 )</div>
<div class="line">                    destinationSet &lt;&lt; paramDesc.SemanticIndex;</div>
<div class="line"></div>
<div class="line">                name &lt;&lt; semanticName &lt;&lt; int(paramDesc.SemanticIndex);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line">            {</div>
<div class="line">                name &lt;&lt; semanticName;</div>
<div class="line"> <span class="keywordflow">if</span> (paramDesc.SemanticIndex &gt; 0)</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> args;</div>
<div class="line">                    args.<a name="a96"></a><a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( semanticName );</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> msg = dx11ShaderStrings::getString( dx11ShaderStrings::kErrorIndexVaryingParameter, args );</div>
<div class="line">                    errorLog += msg;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html">MVaryingParameter</a> varying(</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a>(name.str().c_str()),</div>
<div class="line">            dataType,</div>
<div class="line">            minWidth,</div>
<div class="line">            maxWidth,</div>
<div class="line">            fieldWidth,</div>
<div class="line">            fieldType,</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a>(destinationSet.str().c_str()),</div>
<div class="line"> <span class="keyword">false</span>,</div>
<div class="line">            (isCustomSemantic ? <a class="code" href="./class_m_string.html">MString</a>(semanticName) : <a class="code" href="./class_m_string.html">MString</a>())</div>
<div class="line">            );</div>
<div class="line"></div>
<div class="line">        varyingParameters.<a name="a97"></a><a class="code" href="./class_m_varying_parameter_list.html#a5dca32aa8a764505aba6f29d1acf37c4">append</a>(varying);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!isCustomSemantic)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// We have a few cases of 3rd party effects that declare a float4 TexCoord</span></div>
<div class="line"> <span class="comment">// try to tell the user why the shader will not render correctly:</span></div>
<div class="line"> <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>(fieldWidth)&lt;gDx11SemanticInfo[semanticInfoId].MinElements) || (<span class="keywordtype">int</span>(fieldWidth)&gt;gDx11SemanticInfo[semanticInfoId].MaxElements) ) {</div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> args;</div>
<div class="line">                args.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( paramDesc.SemanticName );</div>
<div class="line">                args.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( MStringFromUInt(paramDesc.SemanticIndex) );</div>
<div class="line">                args.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( MStringFromInt(gDx11SemanticInfo[semanticInfoId].MinElements) );</div>
<div class="line">                args.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( MStringFromInt(gDx11SemanticInfo[semanticInfoId].MaxElements) );</div>
<div class="line">                args.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( MStringFromInt(fieldWidth) );</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> msg = dx11ShaderStrings::getString( dx11ShaderStrings::kErrorVertexRequirement, args );</div>
<div class="line">                errorLog += msg;</div>
<div class="line">            } <span class="comment">/*else if ( int(fieldWidth)!=gDx11SemanticInfo[semanticInfoId].MayaSize) {</span></div>
<div class="line"><span class="comment">                MStringArray args;</span></div>
<div class="line"><span class="comment">                args.append( semanticName );</span></div>
<div class="line"><span class="comment">                args.append( MStringFromInt(gDx11SemanticInfo[semanticInfoId].MayaSize) );</span></div>
<div class="line"><span class="comment">                args.append( MStringFromInt(fieldWidth) );</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">                MString msg = dx11ShaderStrings::getString( dx11ShaderStrings::kWarningVertexRequirement, args );</span></div>
<div class="line"><span class="comment">                warningLog += msg;</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">            */</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">        Convenient function to create the list of varying parameter for a specified technique.</span></div>
<div class="line"><span class="comment">        This is used when loading an effect to the dx11shader and also when creating a temporary</span></div>
<div class="line"><span class="comment">        effect for the swatch and uv editor render.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"> <span class="keywordtype">void</span> buildVaryingParameterList(dx11ShaderDX11EffectTechnique* dxTechnique, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPasses, <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>&amp; varyingParameters, <a class="code" href="./class_m_string.html">MString</a> &amp;errorLog, <a class="code" href="./class_m_string.html">MString</a> &amp;warningLog, <a class="code" href="./class_m_string.html">MString</a> &amp;customIndexBufferType)</div>
<div class="line">    {</div>
<div class="line">        SetOfMString registeredSemantics;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passId = 0; passId &lt; numPasses; ++passId)</div>
<div class="line">        {</div>
<div class="line">            dx11ShaderDX11Pass* dxPass = dxTechnique-&gt;GetPassByIndex(passId);</div>
<div class="line"> <span class="keywordflow">if</span>(dxPass == NULL || dxPass-&gt;IsValid() == <span class="keyword">false</span>)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            D3DX11_PASS_SHADER_DESC vertexShaderDesc;</div>
<div class="line">            memset(&amp;vertexShaderDesc, 0, <span class="keyword">sizeof</span>(D3DX11_PASS_SHADER_DESC));</div>
<div class="line">            dxPass-&gt;GetVertexShaderDesc(&amp;vertexShaderDesc);</div>
<div class="line"></div>
<div class="line">            ID3DX11EffectShaderVariable* shaderVar = vertexShaderDesc.pShaderVariable;</div>
<div class="line"> <span class="keywordflow">if</span>(shaderVar == NULL)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shaderIndex = vertexShaderDesc.ShaderIndex;</div>
<div class="line">            D3DX11_EFFECT_SHADER_DESC shaderDesc;</div>
<div class="line">            memset(&amp;shaderDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_SHADER_DESC));</div>
<div class="line">            shaderVar-&gt;GetShaderDesc(shaderIndex, &amp;shaderDesc);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> varId = 0; varId &lt; shaderDesc.NumInputSignatureEntries; ++varId)</div>
<div class="line">            {</div>
<div class="line">                D3D11_SIGNATURE_PARAMETER_DESC paramDesc;</div>
<div class="line">                shaderVar-&gt;GetInputSignatureElementDesc(shaderIndex, varId, &amp;paramDesc);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Build a unique name based on semantic name + semantic index</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> uniqueName;</div>
<div class="line">                uniqueName.<a class="code" href="./class_m_string.html#acee761fe098fc30a5ac1437e3aca5bc0">set</a>( (<span class="keywordtype">double</span>)paramDesc.SemanticIndex, 0 );</div>
<div class="line">                uniqueName = <a class="code" href="./class_m_string.html">MString</a>(paramDesc.SemanticName) + <a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">"_"</span>) + uniqueName;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( registeredSemantics.count(uniqueName) == 0 )</div>
<div class="line">                {</div>
<div class="line">                    appendVaryingParameter(paramDesc, varyingParameters, errorLog, warningLog, customIndexBufferType);</div>
<div class="line">                    registeredSemantics.insert(uniqueName);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">        Create a temporary effect and build the associated varying and uniform parameters list</span></div>
<div class="line"><span class="comment">        Used for the swatch and uv editor render.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"> <span class="keywordtype">bool</span> buildTemporaryEffect(dx11ShaderNode *shaderNode, dx11ShaderDX11Device *dxDevice, <span class="keyword">const</span> <span class="keywordtype">char</span>* bufferData, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufferSize,</div>
<div class="line">                    dx11ShaderDX11Effect*&amp; dxEffect, dx11ShaderDX11EffectTechnique*&amp; dxTechnique, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; numPasses,</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>*&amp; varyingParameters, <a name="_a98"></a><a class="code" href="./class_m_uniform_parameter_list.html">MUniformParameterList</a>*&amp; uniformParameters, <a class="code" href="./class_m_string.html">MString</a> &amp;customIndexBufferType)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> errorLog;</div>
<div class="line">        dxEffect = CDX11EffectCompileHelper::build(shaderNode, dxDevice, bufferData, bufferSize, errorLog);</div>
<div class="line"> <span class="keywordflow">if</span>(dxEffect == NULL)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Only use first technique</span></div>
<div class="line">        dxTechnique = dxEffect-&gt;GetTechniqueByIndex(0);</div>
<div class="line"> <span class="keywordflow">if</span>(dxTechnique != NULL &amp;&amp; dxTechnique-&gt;IsValid())</div>
<div class="line">        {</div>
<div class="line">            D3DX11_TECHNIQUE_DESC desc;</div>
<div class="line">            memset(&amp;desc, 0, <span class="keyword">sizeof</span>(D3DX11_TECHNIQUE_DESC));</div>
<div class="line">            dxTechnique-&gt;GetDesc(&amp;desc);</div>
<div class="line">            numPasses = desc.Passes;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Invalid effect</span></div>
<div class="line"> <span class="keywordflow">if</span>(numPasses == 0)</div>
<div class="line">        {</div>
<div class="line">            CDX11EffectCompileHelper::releaseEffect(shaderNode, dxEffect, <span class="stringliteral">"TemporaryEffect"</span>);</div>
<div class="line">            dxEffect = NULL;</div>
<div class="line">            dxTechnique = NULL;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create a new uniform parameters list and fill it from the effect</span></div>
<div class="line">        {</div>
<div class="line">            uniformParameters = <span class="keyword">new</span> <a class="code" href="./class_m_uniform_parameter_list.html">MUniformParameterList</a>;</div>
<div class="line"></div>
<div class="line">            D3DX11_EFFECT_DESC effectDesc;</div>
<div class="line">            memset(&amp;effectDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_DESC));</div>
<div class="line">            dxEffect-&gt;GetDesc(&amp;effectDesc);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> varId = 0; varId &lt; effectDesc.GlobalVariables; ++varId)</div>
<div class="line">            {</div>
<div class="line">                ID3DX11EffectVariable* dxVar = dxEffect-&gt;GetVariableByIndex(varId);</div>
<div class="line">                CUniformParameterBuilder builder;</div>
<div class="line">                builder.init(dxVar, shaderNode, varId);</div>
<div class="line"> <span class="keywordflow">if</span>(builder.build())</div>
<div class="line">                    uniformParameters-&gt;<a name="a99"></a><a class="code" href="./class_m_uniform_parameter_list.html#ab49f12c5c37333775619cb4ddf971acf">append</a>(builder.getParameter());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create a new varying parameters list and fill it from the passes</span></div>
<div class="line">        {</div>
<div class="line">            varyingParameters = <span class="keyword">new</span> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> warningLog;</div>
<div class="line">            buildVaryingParameterList(dxTechnique, numPasses, *varyingParameters, errorLog, warningLog, customIndexBufferType);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">        Acquire a reference geometry with geometry requirements extracted from the varying parameters list</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"> <a name="_a100"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>* acquireReferenceGeometry( <a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#a5f45789e2294fc128af5b04595d96505">MHWRender::MGeometryUtilities::GeometricShape</a> shape, <span class="keyword">const</span> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>&amp; varyingParameters)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a101"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html">MHWRender::MGeometryRequirements</a> requirements;</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">typedef</span> std::map&lt;MHWRender::MGeometry::Semantic, SetOfMString&gt; RegisteredVaryingParameters;</div>
<div class="line">            RegisteredVaryingParameters registeredVaryingParameters;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">int</span> paramId = 0; paramId &lt; varyingParameters.<a class="code" href="./class_m_varying_parameter_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>(); ++paramId)</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html">MVaryingParameter</a> varying = varyingParameters.<a class="code" href="./class_m_varying_parameter_list.html#afd7b2e4c7c40b34ef1c8e146c27fb059">getElement</a>(paramId);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4">MHWRender::MGeometry::Semantic</a> sourceSemantic = getVertexBufferSemantic(varying.<a class="code" href="./class_m_varying_parameter.html#ad72ff2b3fb20052e4a2455dad5c10682">getSourceType</a>());</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> sourceSetName = varying.<a class="code" href="./class_m_varying_parameter.html#a45e2132632639698f9c4f668be933a70">getSourceSetName</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(registeredVaryingParameters[sourceSemantic].count(sourceSetName) &gt; 0)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                registeredVaryingParameters[sourceSemantic].insert(sourceSetName);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a> desc(</div>
<div class="line">                    sourceSetName,</div>
<div class="line">                    sourceSemantic,</div>
<div class="line">                    (<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MHWRender::MGeometry::DataType</a>) varying.<a name="a102"></a><a class="code" href="./class_m_varying_parameter.html#ac5bc75c68e4af65e137a099a49e299af">type</a>(),</div>
<div class="line">                    varying.<a class="code" href="./class_m_varying_parameter.html#ae5acbe47d704ceb866e3717e2ac9422f">dimension</a>() );</div>
<div class="line">                desc.<a name="a103"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#a1d51bb626fca50378067f40d1d1ce89e">setSemanticName</a>(varying.<a name="a104"></a><a class="code" href="./class_m_varying_parameter.html#a0ad0ec4f7ace0e9abc7efc5853bf82b6">semanticName</a>());</div>
<div class="line"></div>
<div class="line">                requirements.<a name="a105"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#a701ff08a8e58c9451fe6a3794e577027">addVertexRequirement</a>( desc );</div>
<div class="line">            }</div>
<div class="line">            {</div>
<div class="line"> <a name="_a106"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer_descriptor.html">MHWRender::MIndexBufferDescriptor</a> desc(</div>
<div class="line">                    MHWRender::MIndexBufferDescriptor::kTriangle,</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a>(),</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1eaa2c70dd76c8172a9298334473c914304">MHWRender::MGeometry::kTriangles</a> );</div>
<div class="line">                requirements.<a name="a107"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#ade8935319d3d2463ab9ff0499580e5a0">addIndexingRequirement</a>( desc );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a108"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#ac0ef7cdb96768bdde887e4720419ee62">MHWRender::MGeometryUtilities::acquireReferenceGeometry</a>( shape, requirements );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_GL_TEXTURE_CACHING</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> createGLTextureFromTarget(<a name="_a109"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target.html">MHWRender::MRenderTarget</a>* textureTarget, <span class="keywordtype">float</span> &amp;scaleU, <span class="keywordtype">float</span> &amp;scaleV)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a110"></a><a class="code" href="./class_m_g_l_function_table.html">MGLFunctionTable</a> *_GLFT = <a name="a111"></a><a class="code" href="./class_m_hardware_renderer.html#a93fef222f7278c123e8df750f7f0ea5b">MHardwareRenderer::theRenderer</a>()-&gt;<a name="a112"></a><a class="code" href="./class_m_hardware_renderer.html#ae661000714d15915ccc58949842f4c57">glFunctionTable</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(_GLFT == NULL)</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(textureTarget == NULL)</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <a name="_a113"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target_description.html">MHWRender::MRenderTargetDescription</a> targetDesc;</div>
<div class="line">        textureTarget-&gt;<a name="a114"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target.html#aa7073988ff86d081d3b457d2837517ad">targetDescription</a>(targetDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(targetDesc.<a name="a115"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target_description.html#a068df54dce9f796e6d271677f670879b">rasterFormat</a>() != <a name="a116"></a><a class="code" href="./namespace_m_h_w_render.html#ab8dcc38685c6e5601a32fb70764742dca0e33962255b311165cb5d31c43ff576e">MHWRender::kR8G8B8A8_UNORM</a>)</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> targetRowPitch = 0;</div>
<div class="line"> <span class="keywordtype">size_t</span> targetSlicePitch = 0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* targetData = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)(textureTarget-&gt;<a name="a117"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target.html#a8056533f17e149f6113c5b6c72e55c5f">rawData</a>(targetRowPitch, targetSlicePitch));</div>
<div class="line"> <span class="keywordflow">if</span>(targetData == NULL)</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> targetWidth = targetDesc.<a name="a118"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target_description.html#a7b736ec9a05be5c498760d35a0406ed3">width</a>();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> targetHeight = targetDesc.<a name="a119"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target_description.html#aa420a28166e708e3f8b9ecc8e527fc09">height</a>();</div>
<div class="line"></div>
<div class="line">        MGLsizei textureWidth = targetWidth;</div>
<div class="line">        MGLsizei textureHeight = targetHeight;</div>
<div class="line">        scaleU = scaleV = 1.0f;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> bytesPerPixel = 4;  <span class="comment">// the target is MHWRender::kR8G8B8A8_UNORM</span></div>
<div class="line"> <span class="keywordtype">int</span> realTargetRowPitch = bytesPerPixel * targetWidth;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(_GLFT-&gt;<a name="a120"></a><a class="code" href="./class_m_g_l_function_table.html#a010f1c71e241e3a39339087e706072c7">extensionExists</a>(kMGLext_ARB_texture_non_power_of_two) == <span class="keyword">false</span> || realTargetRowPitch != targetRowPitch)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">int</span> pow2Width = 1;</div>
<div class="line"> <span class="keywordflow">while</span>(pow2Width &lt; textureWidth)</div>
<div class="line">                pow2Width &lt;&lt;= 1;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> pow2Height = 1;</div>
<div class="line"> <span class="keywordflow">while</span>(pow2Height &lt; textureHeight)</div>
<div class="line">                pow2Height &lt;&lt;= 1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If the device doesn't support non-powered of 2 texture size, we need to rearrange the image.</span></div>
<div class="line"> <span class="comment">// And we also need to rearrange image when row pitch is different from the 'real/calculated' row pitch</span></div>
<div class="line"> <span class="keywordflow">if</span>(pow2Width != textureWidth || pow2Height != textureHeight || realTargetRowPitch != targetRowPitch )</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">int</span> pow2RowPitch = bytesPerPixel * pow2Width;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pow2DataSize = pow2RowPitch * pow2Height;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pow2Data = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[pow2DataSize];</div>
<div class="line">                memset(pow2Data, 0, pow2DataSize);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> targetOffset = 0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pow2DataOffset = 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row = 0; row &lt; targetHeight; ++row)</div>
<div class="line">                {</div>
<div class="line">                    memcpy(pow2Data + pow2DataOffset, targetData + targetOffset, realTargetRowPitch);</div>
<div class="line"></div>
<div class="line">                    pow2DataOffset += pow2RowPitch;</div>
<div class="line">                    targetOffset += targetRowPitch;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                scaleU = (float) textureWidth / (<span class="keywordtype">float</span>) pow2Width;</div>
<div class="line">                scaleV = (float) textureHeight / (<span class="keywordtype">float</span>) pow2Height;</div>
<div class="line">                textureWidth = pow2Width;</div>
<div class="line">                textureHeight = pow2Height;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">delete</span> [] targetData;</div>
<div class="line">                targetData = pow2Data;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        MGLuint glTextureId = 0;</div>
<div class="line"> <span class="comment">// Create GL texture</span></div>
<div class="line">        _GLFT-&gt;<a name="a121"></a>glGenTextures(1, &amp;glTextureId);</div>
<div class="line"></div>
<div class="line"> <span class="comment">//_GLFT-&gt;glEnable(_kGL_TEXTURE_2D);</span></div>
<div class="line">        _GLFT-&gt;<a name="a122"></a>glBindTexture(MGL_TEXTURE_2D, glTextureId);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>((_GLFT-&gt;<a class="code" href="./class_m_g_l_function_table.html#a010f1c71e241e3a39339087e706072c7">extensionExists</a>(kMGLext_SGIS_generate_mipmap)))</div>
<div class="line">            _GLFT-&gt;<a name="a123"></a>glTexParameteri(MGL_TEXTURE_2D, MGL_GENERATE_MIPMAP_SGIS, MGL_TRUE);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// the target is MHWRender::kR8G8B8A8_UNORM</span></div>
<div class="line">        _GLFT-&gt;<a name="a124"></a>glTexImage2D(MGL_TEXTURE_2D, 0, MGL_RGBA, textureWidth, textureHeight, 0, MGL_RGBA, MGL_UNSIGNED_BYTE, targetData);</div>
<div class="line"></div>
<div class="line"> <span class="keyword">delete</span> [] targetData;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> glTextureId;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> releaseGLTexture(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> textId)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_g_l_function_table.html">MGLFunctionTable</a> *_GLFT = <a class="code" href="./class_m_hardware_renderer.html#a93fef222f7278c123e8df750f7f0ea5b">MHardwareRenderer::theRenderer</a>()-&gt;<a class="code" href="./class_m_hardware_renderer.html#ae661000714d15915ccc58949842f4c57">glFunctionTable</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(_GLFT == NULL)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(textId == 0)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        MGLuint glTextureId = textId;</div>
<div class="line">        glDeleteTextures(1, &amp;glTextureId);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> renderGLTexture(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> textId, <span class="keywordtype">float</span> scaleU, <span class="keywordtype">float</span> scaleV, floatRegion region, <span class="keywordtype">bool</span> unfiltered)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_g_l_function_table.html">MGLFunctionTable</a> *_GLFT = <a class="code" href="./class_m_hardware_renderer.html#a93fef222f7278c123e8df750f7f0ea5b">MHardwareRenderer::theRenderer</a>()-&gt;<a class="code" href="./class_m_hardware_renderer.html#ae661000714d15915ccc58949842f4c57">glFunctionTable</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(_GLFT == NULL)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(textId == 0)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        MGLuint glTextureId = textId;</div>
<div class="line"></div>
<div class="line">        _GLFT-&gt;<a name="a125"></a>glPushAttrib(MGL_TEXTURE_BIT | MGL_COLOR_BUFFER_BIT | MGL_ENABLE_BIT);</div>
<div class="line">        _GLFT-&gt;<a name="a126"></a>glPushClientAttrib(MGL_CLIENT_VERTEX_ARRAY_BIT);</div>
<div class="line"></div>
<div class="line">        _GLFT-&gt;<a name="a127"></a>glEnable(MGL_TEXTURE_2D);</div>
<div class="line">        _GLFT-&gt;glBindTexture(MGL_TEXTURE_2D, glTextureId);</div>
<div class="line"></div>
<div class="line">        _GLFT-&gt;glTexParameteri(MGL_TEXTURE_2D, MGL_TEXTURE_WRAP_S, MGL_REPEAT);</div>
<div class="line">        _GLFT-&gt;glTexParameteri(MGL_TEXTURE_2D, MGL_TEXTURE_WRAP_T, MGL_REPEAT);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(unfiltered)</div>
<div class="line">            _GLFT-&gt;glTexParameteri(MGL_TEXTURE_2D, MGL_TEXTURE_MAG_FILTER, MGL_NEAREST);</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            _GLFT-&gt;glTexParameteri(MGL_TEXTURE_2D, MGL_TEXTURE_MAG_FILTER, MGL_LINEAR);</div>
<div class="line"></div>
<div class="line">        _GLFT-&gt;<a name="a128"></a>glBlendFunc(MGL_SRC_ALPHA, MGL_ONE_MINUS_SRC_ALPHA);</div>
<div class="line">        _GLFT-&gt;glEnable(MGL_BLEND);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Draw</span></div>
<div class="line">        _GLFT-&gt;<a name="a129"></a>glBegin(MGL_QUADS);</div>
<div class="line">        _GLFT-&gt;<a name="a130"></a>glTexCoord2f(region[0][0] * scaleU, region[0][1] * scaleV);</div>
<div class="line">        _GLFT-&gt;<a name="a131"></a>glVertex2f(region[0][0], region[0][1]);</div>
<div class="line">        _GLFT-&gt;glTexCoord2f(region[0][0] * scaleU, region[1][1] * scaleV);</div>
<div class="line">        _GLFT-&gt;glVertex2f(region[0][0], region[1][1]);</div>
<div class="line">        _GLFT-&gt;glTexCoord2f(region[1][0] * scaleU, region[1][1] * scaleV);</div>
<div class="line">        _GLFT-&gt;glVertex2f(region[1][0], region[1][1]);</div>
<div class="line">        _GLFT-&gt;glTexCoord2f(region[1][0] * scaleU, region[0][1] * scaleV);</div>
<div class="line">        _GLFT-&gt;glVertex2f(region[1][0], region[0][1]);</div>
<div class="line">        _GLFT-&gt;<a name="a132"></a>glEnd();</div>
<div class="line"></div>
<div class="line">        _GLFT-&gt;glBindTexture(MGL_TEXTURE_2D, 0);</div>
<div class="line"></div>
<div class="line">        _GLFT-&gt;<a name="a133"></a>glPopClientAttrib();</div>
<div class="line">        _GLFT-&gt;<a name="a134"></a>glPopAttrib();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif //USE_GL_TEXTURE_CACHING</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Always good to reuse attributes whenever possible.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// In order to fully reuse the technique enum attribute, we need to</span></div>
<div class="line"> <span class="comment">// clear it of its previous contents, which is something that is not</span></div>
<div class="line"> <span class="comment">// yet possible with the MFnEnumAttribute function set. We still can</span></div>
<div class="line"> <span class="comment">// achieve the required result with a proper MEL command to reset the</span></div>
<div class="line"> <span class="comment">// enum strings.</span></div>
<div class="line"> <span class="keywordtype">bool</span> resetTechniqueEnumAttribute(<span class="keyword">const</span> dx11ShaderNode&amp; shader)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a135"></a><a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> node(shader.thisMObject(), &amp;stat);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Reset the .techniqueEnum attribute if exists</span></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> attr = node.attribute(<span class="stringliteral">"techniqueEnum"</span>, &amp;stat);</div>
<div class="line"> <span class="keywordflow">if</span> (stat &amp;&amp; !attr.<a name="a136"></a><a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>() &amp;&amp; attr.<a name="a137"></a><a class="code" href="./class_m_object.html#a7e5fd5d37dde6df8c0cf350e00ca0a75">apiType</a>() == <a name="a138"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ad68d8aedd6c8e61a3b259d6984b47d6f">MFn::kEnumAttribute</a>)</div>
<div class="line">        {</div>
<div class="line"> <a name="_a139"></a><a class="code" href="./class_m_fn_enum_attribute.html">MFnEnumAttribute</a> enumAttr(attr);</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> addAttrCmd = enumAttr.getAddAttrCmd();</div>
<div class="line"> <span class="keywordflow">if</span> (addAttrCmd.<a class="code" href="./class_m_string.html#aaa76dfd27998dc2ff937d3690d11391c">indexW</a>(<span class="stringliteral">" -en "</span>) &gt;= 0)</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> techniquePlug = node.findPlug(attr, <span class="keyword">false</span>);</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> resetCmd = <span class="stringliteral">"addAttr -e -en \"\" "</span>;</div>
<div class="line"> <a name="a140"></a><a class="code" href="./class_m_global.html#a09e405631e7cf680f8ac9d934ad73434">MGlobal::executeCommand</a>(resetCmd + techniquePlug.<a name="a141"></a><a class="code" href="./class_m_plug.html#a58e7cf126b4fe51e9705cee4faaf59fc">name</a>(), <span class="keyword">false</span>, <span class="keyword">false</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> buildTechniqueEnumAttribute(<span class="keyword">const</span> dx11ShaderNode&amp; shader)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat;</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> node(shader.thisMObject(), &amp;stat);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat) <span class="keywordflow">return</span> <a name="a142"></a><a class="code" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Reset the .techniqueEnum attribute</span></div>
<div class="line">        resetTechniqueEnumAttribute(shader);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create the new .techniqueEnum attribute</span></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> attr = node.attribute(<span class="stringliteral">"techniqueEnum"</span>, &amp;stat);</div>
<div class="line"> <span class="keywordflow">if</span> (attr.<a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>())</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_fn_enum_attribute.html">MFnEnumAttribute</a> enumAttr;</div>
<div class="line">            attr = enumAttr.<a name="a143"></a><a class="code" href="./class_m_fn_enum_attribute.html#a6bbfd35f997fda13f9a5824bc1fc6af7">create</a>(<span class="stringliteral">"techniqueEnum"</span>, <span class="stringliteral">"te"</span>, 0, &amp;stat);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat || attr.<a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>()) <span class="keywordflow">return</span> <a class="code" href="./class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set attribute flags</span></div>
<div class="line">            enumAttr.<a name="a144"></a><a class="code" href="./class_m_fn_attribute.html#ae27cf2fd28a3c69b880b1096ea9e0103">setInternal</a>( <span class="keyword">true</span> );</div>
<div class="line">            enumAttr.<a name="a145"></a><a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>( <span class="keyword">false</span> );</div>
<div class="line">            enumAttr.<a name="a146"></a><a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>( <span class="keyword">true</span> );  <span class="comment">// show in Channel Box</span></div>
<div class="line">            enumAttr.<a name="a147"></a><a class="code" href="./class_m_fn_attribute.html#a0810da59cbaac7ecbd26ba0a43d0ac35">setAffectsAppearance</a>( <span class="keyword">true</span> );</div>
<div class="line">            enumAttr.<a name="a148"></a><a class="code" href="./class_m_fn_attribute.html#a0189811f6fd4bb70f002e07e06717556">setNiceNameOverride</a>(<span class="stringliteral">"Technique"</span>);</div>
<div class="line">            enumAttr.<a name="a149"></a><a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>(<span class="stringliteral">"HW_shader_parameter"</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add the attribute to the node</span></div>
<div class="line">            node.addAttribute(attr);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set attribute fields</span></div>
<div class="line"> <a class="code" href="./class_m_fn_enum_attribute.html">MFnEnumAttribute</a> enumAttr(attr);</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string_array.html">MStringArray</a>&amp; techniques = shader.techniques();</div>
<div class="line">        M_CHECK(techniques.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &lt; (<span class="keywordtype">unsigned</span> int)std::numeric_limits&lt;short&gt;::max());</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; techniques.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++)</div>
<div class="line">        {</div>
<div class="line">            enumAttr.<a name="a150"></a><a class="code" href="./class_m_fn_enum_attribute.html#a8f286e4714934d59d15bc79ba923e8f1">addField</a>(techniques[i], (<span class="keywordtype">short</span>)i);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> attr;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ID3DX11EffectVariable* findEffectVariable(<span class="keyword">const</span> <a class="code" href="./class_m_uniform_parameter_list.html">MUniformParameterList</a>&amp; parameters, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; parameterName, <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MUniformParameter::DataType</a> uniformType, D3D10_SHADER_VARIABLE_CLASS variableClass)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; parameters.<a name="a151"></a><a class="code" href="./class_m_uniform_parameter_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>(); ++i )</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> parameter = parameters.<a name="a152"></a><a class="code" href="./class_m_uniform_parameter_list.html#a6a79ec55a70b556044955e86cb48d609">getElement</a>(i);</div>
<div class="line"> <span class="keywordflow">if</span>( ::_stricmp(parameter.<a name="a153"></a><a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>().<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(), parameterName.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>()) == 0 )</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">if</span>( parameter.<a name="a154"></a><a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a name="a155"></a><a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a> )</div>
<div class="line">                {</div>
<div class="line">                    ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)parameter.<a name="a156"></a><a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span>( effectVariable )</div>
<div class="line">                    {</div>
<div class="line">                        D3DX11_EFFECT_TYPE_DESC descType;</div>
<div class="line">                        memset(&amp;descType, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_TYPE_DESC));</div>
<div class="line">                        effectVariable-&gt;GetType()-&gt;GetDesc(&amp;descType);</div>
<div class="line"> <span class="keywordflow">if</span>( descType.Class == variableClass)</div>
<div class="line">                        {</div>
<div class="line"> <span class="keywordflow">return</span> effectVariable;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> NULL;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Only handle color passes if there isn't a global shader override, otherwise</span></div>
<div class="line"> <span class="comment">// some passes included in color pass, e.g. shadow pass, would be handled as</span></div>
<div class="line"> <span class="comment">// a color pass incorrectly. This is the same as the default logic in</span></div>
<div class="line"> <span class="comment">// MPxShaderOverride::handlesDraw.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> getPassSemanticsRemovingColorPassIfNecessary(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <a name="_a157"></a><a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html">MHWRender::MPassContext</a>&amp; passCtx = context.<a name="a158"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#ad3f9422688a9ffbe815c374ece46c1ea">getPassContext</a>();</div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> passSemantics = passCtx.<a name="a159"></a><a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a9737189d5cfffd795336d711a678d627">passSemantics</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (passCtx.<a name="a160"></a><a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a54cb1ff5e4a10ffc51cb05ddab8e69ab">hasShaderOverride</a>())</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; passSemantics.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); )</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">if</span> (passSemantics[i] == <a name="a161"></a><a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a97ffcfc5e6c4bd512eab6727c58a9ae8">MHWRender::MPassContext::kColorPassSemantic</a>)</div>
<div class="line">                {</div>
<div class="line">                    passSemantics.<a name="a162"></a><a class="code" href="./class_m_string_array.html#af05b9926a5e8e7b8e7a9e98a13c839b6">remove</a>(i);</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">                ++i;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> passSemantics;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">dx11ShaderNode::LightParameterInfo::LightParameterInfo(ELightType lightType, <span class="keywordtype">bool</span> hasLightTypeSemantics)</div>
<div class="line">    : fLightType(lightType)</div>
<div class="line">    , fHasLightTypeSemantics(hasLightTypeSemantics)</div>
<div class="line">    , fIsDirty(true)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">dx11ShaderNode::ELightType dx11ShaderNode::LightParameterInfo::lightType()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    ELightType type = fLightType;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If the type is undefined - the light annotation was not helpful -</span></div>
<div class="line"> <span class="comment">// find out the type based of position and direction requirements</span></div>
<div class="line"> <span class="keywordflow">if</span>( type == dx11ShaderNode::eUndefinedLight )</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">bool</span> requiresPosition = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> requiresSquarePosition = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> requiresDirection = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        LightParameterInfo::TConnectableParameters::const_iterator it    = fConnectableParameters.begin();</div>
<div class="line">        LightParameterInfo::TConnectableParameters::const_iterator itEnd = fConnectableParameters.end();</div>
<div class="line"> <span class="keywordflow">for</span> (; it != itEnd; ++it)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> parameterType = it-&gt;second;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( parameterType == CUniformParameterBuilder::eLightPosition )</div>
<div class="line">                requiresPosition = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">if</span>( parameterType == CUniformParameterBuilder::eLightAreaPosition0 )</div>
<div class="line">                requiresSquarePosition = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( parameterType == CUniformParameterBuilder::eLightDirection )</div>
<div class="line">                requiresDirection = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( requiresPosition &amp;&amp; requiresDirection )</div>
<div class="line">            type = dx11ShaderNode::eSpotLight;</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (requiresSquarePosition)</div>
<div class="line">            type = dx11ShaderNode::eAreaLight;</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( requiresPosition )</div>
<div class="line">            type = dx11ShaderNode::ePointLight;</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( requiresDirection )</div>
<div class="line">            type = dx11ShaderNode::eDirectionalLight;</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            type = dx11ShaderNode::eAmbientLight;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Assign the type back</span></div>
<div class="line">        (<span class="keyword">const_cast&lt;</span>LightParameterInfo*<span class="keyword">&gt;</span>(<span class="keyword">this</span>))-&gt;fLightType = type;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> type;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//--------------------------------------------------------------------//</span></div>
<div class="line"><span class="comment">// Constructor:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">dx11ShaderNode::dx11ShaderNode()</div>
<div class="line">    : fGeometryVersionId(0)</div>
<div class="line">    , fLastFrameStamp((MUint64)-1)</div>
<div class="line">    , fDuplicateNodeSource(NULL)</div>
<div class="line">    , fPostDuplicateCallBackId(NULL)</div>
<div class="line">    , fEffect(NULL)</div>
<div class="line">    , fTechniqueTextureMipMapLevels(1)</div>
<div class="line">    , fTechniqueIndexBufferType()</div>
<div class="line">    , fVaryingParametersUpdateId(0)</div>
<div class="line">    , fVaryingParametersGeometryVersionId(size_t(-1))</div>
<div class="line">    , fForceUpdateTexture(true)</div>
<div class="line">    , fFixedTextureMipMapLevels(-1)</div>
<div class="line">    , fUVEditorTexture(NULL)</div>
<div class="line">#ifdef USE_GL_TEXTURE_CACHING</div>
<div class="line">    , fUVEditorLastAlphaChannel(-1)</div>
<div class="line">    , fUVEditorGLTextureId(0)</div>
<div class="line">#endif <span class="comment">//USE_GL_TEXTURE_CACHING</span></div>
<div class="line">    , fBBoxExtraScalePlugName()</div>
<div class="line">    , fBBoxExtraScaleValue(0.0f)</div>
<div class="line">    , fMayaSwatchRenderVar(NULL)</div>
<div class="line">    , fErrorCount(0)</div>
<div class="line">    , fShaderChangesGeo(false)</div>
<div class="line">    , fIgnoreLightLimits(true)</div>
<div class="line">    , fLastTime(0)</div>
<div class="line">    , fVariableNameAsAttributeName(true)</div>
<div class="line">    , fMayaGammaCorrectVar(NULL)</div>
<div class="line">    , fMayaHwFogEnabled(NULL)</div>
<div class="line">    , fMayaHwFogMode(NULL)</div>
<div class="line">    , fMayaHwFogStart(NULL)</div>
<div class="line">    , fMayaHwFogEnd(NULL)</div>
<div class="line">    , fMayaHwFogDensity(NULL)</div>
<div class="line">    , fMayaHwFogColor(NULL)</div>
<div class="line">    , fDepthRange(NULL)</div>
<div class="line">    , fImplicitAmbientLight(-1)</div>
<div class="line">{</div>
<div class="line">    resetData();</div>
<div class="line">    fErrorLog.clear();</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">bool</span> addedResourcePath = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (!addedResourcePath)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a163"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MHWRender::MRenderer</a>* theRenderer = <a name="a164"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MHWRender::MRenderer::theRenderer</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (theRenderer)</div>
<div class="line">        {</div>
<div class="line"> <a name="_a165"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture_manager.html">MHWRender::MTextureManager</a>* txtManager = theRenderer-&gt;<a name="a166"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#aa3f2ec2984800e2cd8ea09b4ad9f072e">getTextureManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (txtManager)</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> resourceLocation(<a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">"${MAYA_LOCATION}\\presets\\HLSL11\\examples"</span>).expandEnvironmentVariablesAndTilde());</div>
<div class="line">                txtManager-&gt;<a name="a167"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture_manager.html#a96a66b439082bd98a67d92eeac95f6fe">addImagePath</a>(resourceLocation);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        addedResourcePath = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Destructor:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">dx11ShaderNode::~dx11ShaderNode()</div>
<div class="line">{</div>
<div class="line">    PostSceneUpdateAttributeRefresher::remove(<span class="keyword">this</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (fPostDuplicateCallBackId) <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>( fPostDuplicateCallBackId );</div>
<div class="line">    resetData();</div>
<div class="line">    fErrorLog.clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* static */</span></div>
<div class="line"><a name="_a168"></a><a class="code" href="./class_m_type_id.html">MTypeId</a> dx11ShaderNode::typeId()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// This typeid must be unique across the universe of Maya plug-ins.</span></div>
<div class="line"> <span class="comment">// The typeid is a unique 32bit indentifier that describes this node.</span></div>
<div class="line"> <span class="comment">// It is used to save and retrieve nodes of this type from the binary</span></div>
<div class="line"> <span class="comment">// file format.  If it is not unique, it will cause file IO problems.</span></div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./class_m_type_id.html">MTypeId</a> sId( 0x00081054 );</div>
<div class="line"> <span class="keywordflow">return</span> sId;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ========== dx11ShaderNode::creator ==========</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Description:</span></div>
<div class="line"><span class="comment">//      this method exists to give Maya a way to create new objects</span></div>
<div class="line"><span class="comment">//      of this type.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Return Value:</span></div>
<div class="line"><span class="comment">//      a new object of this type.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">/* static */</span></div>
<div class="line"><span class="keywordtype">void</span>* dx11ShaderNode::creator()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">new</span> dx11ShaderNode();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ========== dx11ShaderNode::initialize ==========</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Description:</span></div>
<div class="line"><span class="comment">//      This method is called to create and initialize all of the attributes</span></div>
<div class="line"><span class="comment">//      and attribute dependencies for this node type.  This is only called</span></div>
<div class="line"><span class="comment">//      once when the node type is registered with Maya.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Return Values:</span></div>
<div class="line"><span class="comment">//      MS::kSuccess</span></div>
<div class="line"><span class="comment">//      MS::kFailure</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">/* static */</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> dx11ShaderNode::initialize()</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> ms;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        initializeNodeAttrs();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">catch</span> ( ... )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_global.html#a4ddbe97e58a90e1ab05d45a62c006cf0">MGlobal::displayError</a>( <span class="stringliteral">"dx11Shader internal error: Unhandled exception in initialize"</span> );</div>
<div class="line">        ms = MS::kFailure;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> ms;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Create common static attributes which will always appear regardless of the shader</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment">/* static */</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::initializeNodeAttrs()</div>
<div class="line">{</div>
<div class="line"> <a name="_a169"></a><a class="code" href="./class_m_fn_typed_attribute.html">MFnTypedAttribute</a>   typedAttr;</div>
<div class="line"> <a name="_a170"></a><a class="code" href="./class_m_fn_numeric_attribute.html">MFnNumericAttribute</a> numAttr;</div>
<div class="line"> <a name="_a171"></a><a class="code" href="./class_m_fn_string_data.html">MFnStringData</a>       stringData;</div>
<div class="line"> <a class="code" href="./class_m_fn_string_array_data.html">MFnStringArrayData</a>  stringArrayData;</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a>             stat, stat2;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The shader attribute holds the name of the .fx file that defines</span></div>
<div class="line"> <span class="comment">// the shader</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    sShader = typedAttr.<a name="a172"></a><a class="code" href="./class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">"shader"</span>, <span class="stringliteral">"s"</span>, <a name="a173"></a><a class="code" href="./class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7afab53ea4a643325262b9c140af093279">MFnData::kString</a>, stringData.<a name="a174"></a><a class="code" href="./class_m_fn_string_data.html#a2a76d6e5a305b483c5d9b8444fb79126">create</a>(&amp;stat2), &amp;stat);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ae27cf2fd28a3c69b880b1096ea9e0103">setInternal</a>( <span class="keyword">true</span>);</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a0810da59cbaac7ecbd26ba0a43d0ac35">setAffectsAppearance</a>( <span class="keyword">true</span> );</div>
<div class="line">    typedAttr.<a name="a175"></a><a class="code" href="./class_m_fn_attribute.html#ab8fc03c313bed1f43387ad04e31bc87d">setUsedAsFilename</a>( <span class="keyword">true</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>( <span class="stringliteral">"HW_shader_parameter"</span> );</div>
<div class="line">    stat = addAttribute(sShader);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Effect Uniform Parameters</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    sEffectUniformParameters = typedAttr.<a class="code" href="./class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">"EffectParameters"</span>, <span class="stringliteral">"ep"</span>, <a class="code" href="./class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7afab53ea4a643325262b9c140af093279">MFnData::kString</a>, stringData.<a class="code" href="./class_m_fn_string_data.html#a2a76d6e5a305b483c5d9b8444fb79126">create</a>(&amp;stat2), &amp;stat);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ae27cf2fd28a3c69b880b1096ea9e0103">setInternal</a>( <span class="keyword">true</span>);</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>( <span class="keyword">false</span>);</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a0810da59cbaac7ecbd26ba0a43d0ac35">setAffectsAppearance</a>( <span class="keyword">true</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>( <span class="stringliteral">"HW_shader_parameter"</span> );</div>
<div class="line">    stat = addAttribute(sEffectUniformParameters);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// technique</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    sTechnique = typedAttr.<a class="code" href="./class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">"technique"</span>, <span class="stringliteral">"t"</span>, <a class="code" href="./class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7afab53ea4a643325262b9c140af093279">MFnData::kString</a>, stringData.<a class="code" href="./class_m_fn_string_data.html#a2a76d6e5a305b483c5d9b8444fb79126">create</a>(&amp;stat2), &amp;stat);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ae27cf2fd28a3c69b880b1096ea9e0103">setInternal</a>( <span class="keyword">true</span>);</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>( <span class="keyword">true</span>);</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a0810da59cbaac7ecbd26ba0a43d0ac35">setAffectsAppearance</a>( <span class="keyword">true</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>( <span class="stringliteral">"HW_shader_parameter"</span> );</div>
<div class="line">    stat = addAttribute(sTechnique);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// technique list</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    sTechniques = typedAttr.<a class="code" href="./class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">"techniques"</span>, <span class="stringliteral">"ts"</span>, <a class="code" href="./class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7a7f61c3f7033fde37de0e63f291c9e834">MFnData::kStringArray</a>, stringArrayData.<a name="a176"></a><a class="code" href="./class_m_fn_string_array_data.html#af1adb4abaf5243c6c0749bcca7b5c418">create</a>(&amp;stat2), &amp;stat);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ae27cf2fd28a3c69b880b1096ea9e0103">setInternal</a>( <span class="keyword">true</span>);</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>( <span class="keyword">false</span>);</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>( <span class="keyword">false</span>);</div>
<div class="line">    typedAttr.<a name="a177"></a><a class="code" href="./class_m_fn_attribute.html#a98bb3089ec3b7442383da68a5ef424c7">setWritable</a>( <span class="keyword">false</span>);</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a0810da59cbaac7ecbd26ba0a43d0ac35">setAffectsAppearance</a>( <span class="keyword">true</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>( <span class="stringliteral">"HW_shader_parameter"</span> );</div>
<div class="line">    stat = addAttribute(sTechniques);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The description field where we pass compile errors etc back for the user to see</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    sDescription = typedAttr.<a class="code" href="./class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">"description"</span>, <span class="stringliteral">"desc"</span>, <a class="code" href="./class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7afab53ea4a643325262b9c140af093279">MFnData::kString</a>, stringData.<a class="code" href="./class_m_fn_string_data.html#a2a76d6e5a305b483c5d9b8444fb79126">create</a>(&amp;stat2), &amp;stat);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a98bb3089ec3b7442383da68a5ef424c7">setWritable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>( <span class="stringliteral">"HW_shader_parameter"</span> );</div>
<div class="line">    stat = addAttribute(sDescription);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The feedback field where we pass compile errors etc back for the user to see</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    sDiagnostics = typedAttr.<a class="code" href="./class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">"diagnostics"</span>, <span class="stringliteral">"diag"</span>, <a class="code" href="./class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7afab53ea4a643325262b9c140af093279">MFnData::kString</a>, stringData.<a class="code" href="./class_m_fn_string_data.html#a2a76d6e5a305b483c5d9b8444fb79126">create</a>(&amp;stat2), &amp;stat);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a98bb3089ec3b7442383da68a5ef424c7">setWritable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>( <span class="stringliteral">"HW_shader_parameter"</span> );</div>
<div class="line">    stat = addAttribute(sDiagnostics);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The description field where we pass compile errors etc back for the user to see</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    sLightInfo = typedAttr.<a class="code" href="./class_m_fn_typed_attribute.html#af785af0a66bd4a4da1d9f7bd74d4de0a">create</a>(<span class="stringliteral">"lightInfo"</span>, <span class="stringliteral">"linfo"</span>, <a class="code" href="./class_m_fn_data.html#a1d1cfd8ffb84e947f82999c682b666a7afab53ea4a643325262b9c140af093279">MFnData::kString</a>, stringData.<a class="code" href="./class_m_fn_string_data.html#a2a76d6e5a305b483c5d9b8444fb79126">create</a>(&amp;stat2), &amp;stat);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a98bb3089ec3b7442383da68a5ef424c7">setWritable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>( <span class="keyword">false</span> );</div>
<div class="line">    typedAttr.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>( <span class="stringliteral">"HW_shader_parameter"</span> );</div>
<div class="line">    stat = addAttribute(sLightInfo);</div>
<div class="line">    M_CHECK( stat );</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Specify our dependencies</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    attributeAffects( sShader, sTechniques);</div>
<div class="line">    attributeAffects( sShader, sTechnique);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Query the renderers supported by this shader</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">const</span> <a name="_a178"></a><a class="code" href="./class_m_render_profile.html">MRenderProfile</a>&amp; dx11ShaderNode::profile()</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./class_m_render_profile.html">MRenderProfile</a> sProfile;</div>
<div class="line"> <span class="keywordflow">if</span>(sProfile.<a name="a179"></a><a class="code" href="./class_m_render_profile.html#af6c112eae09921cee69dea8d0d4c6251">numberOfRenderers</a>() == 0)</div>
<div class="line">        sProfile.<a name="a180"></a><a class="code" href="./class_m_render_profile.html#aa4a8e8280aca6457ddb2961cedb4e228">addRenderer</a>(<a name="a181"></a><a class="code" href="./class_m_render_profile.html#a7f20c37a8a7dba81b35df0f8d841129bae12eb740b1bc240732c93a4cebef3935">MRenderProfile::kMayaOpenGL</a>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> sProfile;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Handle when a node is duplicated or copied.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Store the minimum data required (the shader file path, the current technique name and id)</span></div>
<div class="line"><span class="comment">    and install a callback on when the duplicate operation is completed.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The callback is mandatory because copyInternalData() is called too soon during the duplicate process:</span></div>
<div class="line"><span class="comment">    the node is not yet added to the dependency graph,</span></div>
<div class="line"><span class="comment">    but we need it to be when updating the uniform parameters list (initialization of plugs).</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::copyInternalData( <a name="_a182"></a><a class="code" href="./class_m_px_node.html">MPxNode</a>* pSrc )</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">const</span> dx11ShaderNode &amp; src = *(dx11ShaderNode*)pSrc;</div>
<div class="line">    fEffectName = src.fEffectName;</div>
<div class="line">    fTechniqueIdx = src.fTechniqueIdx;</div>
<div class="line">    fTechniqueName = src.fTechniqueName;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Only setup the call back if a valid effect is loaded</span></div>
<div class="line"> <span class="keywordflow">if</span>(src.fEffect != NULL &amp;&amp; src.fEffect-&gt;IsValid())</div>
<div class="line">    {</div>
<div class="line">        fDuplicateNodeSource = (dx11ShaderNode*)pSrc;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Install callback to initialize the node once added to the dependency graph.</span></div>
<div class="line">        fPostDuplicateCallBackId = <a name="a183"></a><a class="code" href="./class_m_model_message.html#a74cd7260902a3dd9aa27950385408735">MModelMessage::addAfterDuplicateCallback</a>( dx11ShaderNode::postDuplicateCB, <span class="keyword">this</span>, NULL );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a name="a184"></a><a class="code" href="./class_m_px_node.html#aca0f48b1467c0e3dc8643a18b0b855da">MPxHardwareShader::copyInternalData</a>(pSrc);</div>
<div class="line">}</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Initialize the node after it has been duplicated and added to the dependency graph.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment">/*static*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::postDuplicateCB( <span class="keywordtype">void</span>* data )</div>
<div class="line">{</div>
<div class="line">    dx11ShaderNode* shader = (dx11ShaderNode*)data;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// De install the callback</span></div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>( shader-&gt;fPostDuplicateCallBackId );</div>
<div class="line">    shader-&gt;fPostDuplicateCallBackId = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The duplicate command comes in 3 flavors :</span></div>
<div class="line"> <span class="comment">// - Duplicate Without Network</span></div>
<div class="line"> <span class="comment">//      No nodes is duplicated (no textures will be linked to the shader)</span></div>
<div class="line"> <span class="comment">// - Duplicate Shading Network</span></div>
<div class="line"> <span class="comment">//      Nodes (textures) are duplicated and linked to the new shader</span></div>
<div class="line"> <span class="comment">//      ie. the original shader is linked to texture node file1, the duplicated shader will be linked to a new texture node file2.</span></div>
<div class="line"> <span class="comment">// - Duplicate With Connections to Network</span></div>
<div class="line"> <span class="comment">//      Nodes are linked as is to the new shader</span></div>
<div class="line"> <span class="comment">//      ie. the orginal shader is linked to texture node file1, the duplicated shader will be linked to the same texture node file1.</span></div>
<div class="line"> <span class="comment">// In the last two modes, the plugs and attributes will be created and connected internally.</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// The dx11Shader uses a uniform parameters list to create its own attributes based on the list of parameters of the shader file.</span></div>
<div class="line"> <span class="comment">// To mimic the same behaviour that occurs when duplicating internal shader nodes (blinn, lambert ..) for the different duplicate modes,</span></div>
<div class="line"> <span class="comment">// we perform the following actions :</span></div>
<div class="line"> <span class="comment">// - Keep track of the connections done internally on the duplicated node (see dx11ShaderNode::connectionMade())</span></div>
<div class="line"> <span class="comment">// - Don't connect any texture parameter (see dx11ShaderNode::getTextureFile())</span></div>
<div class="line"> <span class="comment">// - From the connections we build a mapping of which attributes was linked to which uniform parameter</span></div>
<div class="line"> <span class="comment">//   and eventually break the connection that we won't used (STEP ONE below).</span></div>
<div class="line"> <span class="comment">// - Finally, once the uniform parameters list is built for the new duplicated shader, we link the duplicated attributes to the proper</span></div>
<div class="line"> <span class="comment">//   uniform parameters (STEP TWO below).</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// ------------------</span></div>
<div class="line"> <span class="comment">// STEP ONE</span></div>
<div class="line"> <span class="comment">// Plugs and attributes are driven by the uniformParameters list.</span></div>
<div class="line"> <span class="comment">// Having plug duplicated will create unused connection</span></div>
<div class="line"> <span class="comment">// -&gt; Break all duplicated connections</span></div>
<div class="line">    std::vector&lt; std::pair&lt; MPlug, MUniformParameterData &gt; &gt; attributesToConnect;</div>
<div class="line">    std::vector&lt; std::pair&lt; MPlug, unsigned int &gt; &gt; lightAttributesToConnect;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plugCount = shader-&gt;fDuplicatedConnections.length();</div>
<div class="line"> <span class="keywordflow">if</span>(plugCount &gt; 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_uniform_parameter_list.html">MUniformParameterList</a>&amp; uniformParameters = shader-&gt;fDuplicateNodeSource-&gt;fUniformParameters;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nUniform = uniformParameters.<a class="code" href="./class_m_uniform_parameter_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> LightParameterInfoVec&amp; lightParameters = shader-&gt;fDuplicateNodeSource-&gt;fLightParameters;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nLight = (<span class="keywordtype">unsigned</span> int)lightParameters.size();</div>
<div class="line"></div>
<div class="line"> <a name="_a185"></a><a class="code" href="./class_m_d_g_modifier.html">MDGModifier</a> dgModifier;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; plugCount; )</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug = shader-&gt;fDuplicatedConnections[i++];</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; dstPlug = shader-&gt;fDuplicatedConnections[i++];</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the uniform parameter this duplicated plug comes from</span></div>
<div class="line"> <a name="_a186"></a><a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> dstPlugAttr(dstPlug.<a name="a187"></a><a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>());</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> dstPlugAttrName = dstPlugAttr.name();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> isConnectedLightAttr = ( dstPlugAttrName.indexW(<span class="stringliteral">"_connected_light"</span>) &gt; -1 );</div>
<div class="line"> <span class="keywordflow">if</span>(isConnectedLightAttr)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l = 0; l &lt; nLight; ++l )</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; lightInfo = lightParameters[l];</div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> connectedLightAttr(lightInfo.fAttrConnectedLight);</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> connectedLightAttrName = connectedLightAttr.name();</div>
<div class="line"> <span class="keywordflow">if</span>(connectedLightAttrName == dstPlugAttrName)</div>
<div class="line">                    {</div>
<div class="line">                        lightAttributesToConnect.push_back( std::make_pair( plug, l ) );</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u = 0; u &lt; nUniform; ++u )</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> elem = uniformParameters.<a class="code" href="./class_m_uniform_parameter_list.html#a6a79ec55a70b556044955e86cb48d609">getElement</a>(u);</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> elemPlug = elem.<a name="a188"></a><a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(elemPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() == <span class="keyword">false</span>)</div>
<div class="line">                    {</div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> elemPlugAttr(elemPlug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>());</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> elemPlugAttrName = elemPlugAttr.name();</div>
<div class="line"> <span class="keywordflow">if</span>(elemPlugAttrName == dstPlugAttrName)</div>
<div class="line">                        {</div>
<div class="line">                            MUniformParameterData param = { elem.<a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>(), elem.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>(), elem.<a name="a189"></a><a class="code" href="./class_m_uniform_parameter.html#ac7fba35931cc9a520837b0a752352e16">numElements</a>() };</div>
<div class="line">                            attributesToConnect.push_back( std::make_pair( plug, param ) );</div>
<div class="line">                            printf(<span class="stringliteral">"  uniform &lt;&lt;%s&gt;&gt;\n"</span>, param.name.asChar());</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            dgModifier.<a name="a190"></a><a class="code" href="./class_m_d_g_modifier.html#aee585c763e12aa6277000a028dbfa619">disconnect</a>(plug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), plug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>(), dstPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), dstPlug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        dgModifier.<a name="a191"></a><a class="code" href="./class_m_d_g_modifier.html#a984345cd272bc1a32a9fc2e93a6678b2">doIt</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The effect name and technique were set by copyInternalData.</span></div>
<div class="line"> <span class="comment">// load the effect and create the parameters.</span></div>
<div class="line">    shader-&gt;reload();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// ------------------</span></div>
<div class="line"> <span class="comment">// STEP TWO</span></div>
<div class="line"> <span class="comment">// The uniform parameters list is now built</span></div>
<div class="line"> <span class="comment">// Reconnect broken connections with corresponding uniform parameters</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> attributesToConnectCount = (<span class="keywordtype">unsigned</span> int)attributesToConnect.size();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lightAttributesToConnectCount = (<span class="keywordtype">unsigned</span> int)lightAttributesToConnect.size();</div>
<div class="line"> <span class="keywordflow">if</span>(attributesToConnectCount &gt; 0 || lightAttributesToConnectCount &gt; 0)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_d_g_modifier.html">MDGModifier</a> dgModifier;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter_list.html">MUniformParameterList</a>&amp; uniformParameters = shader-&gt;fUniformParameters;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nUniform = uniformParameters.<a class="code" href="./class_m_uniform_parameter_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; attributesToConnectCount; ++i)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; srcPlug = attributesToConnect[i].first;</div>
<div class="line"> <span class="keyword">const</span> MUniformParameterData&amp; duplicatedElement = attributesToConnect[i].second;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the uniform which correspond to the original duplicated element</span></div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u = 0; u &lt; nUniform; ++u )</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> elem = uniformParameters.<a class="code" href="./class_m_uniform_parameter_list.html#a6a79ec55a70b556044955e86cb48d609">getElement</a>(u);</div>
<div class="line"> <span class="keywordflow">if</span>( elem.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>()         == duplicatedElement.type &amp;&amp;</div>
<div class="line">                    elem.<a class="code" href="./class_m_uniform_parameter.html#ac7fba35931cc9a520837b0a752352e16">numElements</a>()  == duplicatedElement.numElements &amp;&amp;</div>
<div class="line">                    elem.<a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>()         == duplicatedElement.name )</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> elemPlug = elem.<a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>();</div>
<div class="line">                    dgModifier.<a name="a192"></a><a class="code" href="./class_m_d_g_modifier.html#afbd18f066f70fcd1864ddb4af91f3c7b">connect</a>(srcPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), srcPlug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>(), elemPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), elemPlug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>());</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        LightParameterInfoVec&amp; lightParameters = shader-&gt;fLightParameters;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nLight = (<span class="keywordtype">unsigned</span> int)lightParameters.size();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; lightAttributesToConnectCount; ++i)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; srcPlug = lightAttributesToConnect[i].first;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l = lightAttributesToConnect[i].second;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(l &lt; nLight)</div>
<div class="line">            {</div>
<div class="line">                LightParameterInfo&amp; lightInfo = lightParameters[l];</div>
<div class="line">                dgModifier.<a class="code" href="./class_m_d_g_modifier.html#afbd18f066f70fcd1864ddb4af91f3c7b">connect</a>(srcPlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), srcPlug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>(), shader-&gt;thisMObject(), lightInfo.fAttrConnectedLight);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        dgModifier.<a class="code" href="./class_m_d_g_modifier.html#a984345cd272bc1a32a9fc2e93a6678b2">doIt</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    shader-&gt;fDuplicateNodeSource = NULL;</div>
<div class="line">    shader-&gt;fDuplicatedConnections.clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::setInternalValue( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <span class="keyword">const</span> <a class="code" href="./class_m_data_handle.html">MDataHandle</a>&amp; handle)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span> retVal = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (plug == sShader)</div>
<div class="line">        {</div>
<div class="line">            loadEffect ( handle.<a name="a193"></a><a class="code" href="./class_m_data_handle.html#a858b071eda071f265c130e30d0b98622">asString</a>() );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug == sTechnique)</div>
<div class="line">        {</div>
<div class="line">            setTechnique( handle.<a class="code" href="./class_m_data_handle.html#a858b071eda071f265c130e30d0b98622">asString</a>() );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug == fTechniqueEnumAttr)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">int</span> index = handle.<a name="a194"></a><a class="code" href="./class_m_data_handle.html#ab4cfc0fe402e4a52cf87b8acc6a29861">asShort</a>();</div>
<div class="line">            M_CHECK(fTechniqueNames.length() &lt; (<span class="keywordtype">unsigned</span> int)std::numeric_limits&lt;int&gt;::max());</div>
<div class="line"> <span class="keywordflow">if</span> (index &gt;= 0 &amp;&amp; index &lt; (<span class="keywordtype">int</span>)fTechniqueNames.length() &amp;&amp; index != fTechniqueIdx)</div>
<div class="line">            {</div>
<div class="line">                setTechnique(index);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (fBBoxExtraScalePlugName.length() &gt; 0)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> plugName = plug.<a class="code" href="./class_m_plug.html#a58e7cf126b4fe51e9705cee4faaf59fc">name</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (plugName == fBBoxExtraScalePlugName)</div>
<div class="line">                {</div>
<div class="line">                    fBBoxExtraScaleValue = handle.<a name="a195"></a><a class="code" href="./class_m_data_handle.html#a43df510424a7de372dd130315d9f223c">asFloat</a>();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cannot check the varying input update id at this point</span></div>
<div class="line"> <span class="comment">// as they are not yet modified.</span></div>
<div class="line">            retVal = <a name="a196"></a><a class="code" href="./class_m_px_node.html#a6caab4434e836748680958883564af35">MPxHardwareShader::setInternalValue</a>( plug, handle);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">catch</span>( ... )</div>
<div class="line">    {</div>
<div class="line">        reportInternalError( __FILE__, __LINE__ );</div>
<div class="line">        retVal = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> retVal;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* virtual */</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::getInternalValue( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <a class="code" href="./class_m_data_handle.html">MDataHandle</a>&amp; handle)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">bool</span> retVal = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (plug == sShader)</div>
<div class="line">        {</div>
<div class="line">            handle.<a name="a197"></a><a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( fEffectName );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug == sTechnique)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> tname = activeTechniqueName();</div>
<div class="line">            handle.<a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( tname );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug == fTechniqueEnumAttr)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (fTechniqueIdx &gt;= 0)</div>
<div class="line">            {</div>
<div class="line">                handle.<a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>((<span class="keywordtype">short</span>)fTechniqueIdx);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug == sTechniques)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string_array.html">MStringArray</a>* tlist = &amp;techniques();</div>
<div class="line"> <span class="keywordflow">if</span> (tlist)</div>
<div class="line">                handle.<a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( <a class="code" href="./class_m_fn_string_array_data.html">MFnStringArrayData</a>().create( *tlist ));</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                handle.<a class="code" href="./class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>( <a class="code" href="./class_m_fn_string_array_data.html">MFnStringArrayData</a>().create() );</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            retVal = <a name="a198"></a><a class="code" href="./class_m_px_node.html#aa88f4dd4cfd3e964e0806d6e5b253347">MPxHardwareShader::getInternalValue</a>( plug, handle);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">catch</span> ( ... )</div>
<div class="line">    {</div>
<div class="line">        reportInternalError( __FILE__, __LINE__ );</div>
<div class="line">        retVal = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> retVal;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* virtual */</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> dx11ShaderNode::connectionMade( <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; otherPlug, <span class="keywordtype">bool</span> asSrc )</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span>( fDuplicateNodeSource != NULL &amp;&amp; asSrc == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// push source plug first</span></div>
<div class="line">        fDuplicatedConnections.append(otherPlug);</div>
<div class="line">        fDuplicatedConnections.append(plug);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> MS::kUnknownParameter;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* virtual */</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> dx11ShaderNode::dependsOn(<span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a>&amp; otherPlug, <span class="keywordtype">bool</span>&amp; depends)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>( plug == outColor )</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> paramCount = fUniformParameters.length();</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; paramCount; ++i )</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> param = fUniformParameters.getElement(i);</div>
<div class="line"> <span class="keywordflow">if</span>( param.<a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>() == otherPlug )</div>
<div class="line">            {</div>
<div class="line">                depends = param.<a class="code" href="./class_m_uniform_parameter.html#a37357b066d4c628b1fae2f1ee08b2b12">isATexture</a>();</div>
<div class="line"> <span class="keywordflow">return</span> MS::kSuccess;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> MS::kUnknownParameter;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set the dirty flag on a specific shader light when the user changes</span></div>
<div class="line"><span class="comment">// the light connection settings in order to refresh the shader light</span></div>
<div class="line"><span class="comment">// bindings at the next redraw.</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> dx11ShaderNode::setDependentsDirty(<span class="keyword">const</span> <a class="code" href="./class_m_plug.html">MPlug</a> &amp; plugBeingDirtied, <a name="_a199"></a><a class="code" href="./class_m_plug_array.html">MPlugArray</a> &amp; affectedPlugs)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> shaderLightIndex = 0; shaderLightIndex &lt; fLightParameters.size(); ++shaderLightIndex )</div>
<div class="line">    {</div>
<div class="line">        LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> implicitLightPlug(thisMObject(), shaderLightInfo.fAttrUseImplicit);</div>
<div class="line"> <span class="keywordflow">if</span> ( implicitLightPlug == plugBeingDirtied )</div>
<div class="line">            shaderLightInfo.fIsDirty = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> connectedLightPlug(thisMObject(), shaderLightInfo.fAttrConnectedLight);</div>
<div class="line"> <span class="keywordflow">if</span> ( connectedLightPlug == plugBeingDirtied )</div>
<div class="line">            shaderLightInfo.fIsDirty = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a200"></a><a class="code" href="./class_m_px_node.html#abd7d1dad4e4f0b922bf5ac4fc9c0230a">MPxHardwareShader::setDependentsDirty</a>(plugBeingDirtied, affectedPlugs);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Topology Management</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::hasUpdatedVaryingInput()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="comment">// Test if Varying parameters have changed</span></div>
<div class="line"> <span class="comment">// increate DataVersionId so that lists are rebuilt</span></div>
<div class="line"> <span class="comment">// ---------------------------------------------</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> varyingUpdateId = 0;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; fVaryingParameters.length(); ++i)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html">MVaryingParameter</a> varying = fVaryingParameters.<a name="a201"></a><a class="code" href="./class_m_varying_parameter.html#a40cde1a792fb9a978d3a3a68414fb865">getElement</a>(i);</div>
<div class="line">        varyingUpdateId += varying.<a name="a202"></a><a class="code" href="./class_m_varying_parameter.html#ac38803dedbdc3cbb9862e7f3577b34b4">getUpdateId</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fVaryingParametersUpdateId != varyingUpdateId)</div>
<div class="line">    {</div>
<div class="line">        dx11ShaderNode* nonConstThis = <span class="keyword">const_cast&lt;</span>dx11ShaderNode*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);</div>
<div class="line">        nonConstThis-&gt;fVaryingParametersUpdateId = varyingUpdateId;</div>
<div class="line">        nonConstThis-&gt;setTopoDirty();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setTopoDirty()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Will be interpreted as a topo change at next redraw</span></div>
<div class="line"> <span class="comment">// via dx11ShaderOverride::rebuildAlways</span></div>
<div class="line">    ++fGeometryVersionId;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Effect Management</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Reload all the nodes that shared the same specified effect</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::reloadAll(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; effectName)</div>
<div class="line">{</div>
<div class="line">    CDX11EffectCompileHelper::ShaderNodeList nodes;</div>
<div class="line">    CDX11EffectCompileHelper::getNodesUsingEffect(effectName, nodes);</div>
<div class="line">    CDX11EffectCompileHelper::ShaderNodeList::const_iterator it = nodes.begin();</div>
<div class="line">    CDX11EffectCompileHelper::ShaderNodeList::const_iterator itEnd = nodes.end();</div>
<div class="line"> <span class="keywordflow">if</span> (it != itEnd)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(; it != itEnd; ++it)</div>
<div class="line">        {</div>
<div class="line">            dx11ShaderNode* node = *it;</div>
<div class="line">            node-&gt;reload();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Shaders that failed to load will not be registered</span></div>
<div class="line"> <span class="comment">// in the compiler helper. Iterate the scene to find them.</span></div>
<div class="line"> <a name="_a203"></a><a class="code" href="./class_m_it_dependency_nodes.html">MItDependencyNodes</a> it(<a name="a204"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7aeeb4c59c6a7c94970cb5df4ddd0fa7e5">MFn::kPluginHardwareShader</a>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">while</span>(!it.isDone())</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> fn(it.item());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( fn.typeId() == typeId() ) {</div>
<div class="line">                dx11ShaderNode* shaderNode = (dx11ShaderNode*)(fn.userNode());</div>
<div class="line"> <span class="keywordflow">if</span>(shaderNode &amp;&amp; shaderNode-&gt;effectName() == effectName)</div>
<div class="line">                {</div>
<div class="line">                    shaderNode-&gt;reload();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            it.next();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Reload the effect from the current file</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::reload()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">int</span> currTechnique = fTechniqueIdx; <span class="comment">//activeTechnique();</span></div>
<div class="line"></div>
<div class="line">    loadEffect(fEffectName);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(currTechnique &gt;= 0 &amp;&amp; currTechnique &lt; techniqueCount())</div>
<div class="line">    {</div>
<div class="line">        setTechnique(currTechnique);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Allow implicit rebinding:</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; fLightParameters.size(); ++i) {</div>
<div class="line">        fLightParameters[i].fCachedImplicitLight = <a class="code" href="./class_m_object.html">MObject</a>();</div>
<div class="line">        setLightParameterLocking(fLightParameters[i], <span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// Refresh any AE that monitors implicit lights:</span></div>
<div class="line">    IdleAttributeEditorImplicitRefresher::activate();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Set the shader</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::loadEffect( <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; shader)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (shader.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0)</div>
<div class="line">    {</div>
<div class="line">        clearParameters();</div>
<div class="line">        resetData(<span class="keyword">true</span>);</div>
<div class="line">        setUniformParameters( fUniformParameters, <span class="keyword">true</span> );</div>
<div class="line">        setVaryingParameters( fVaryingParameters, <span class="keyword">true</span> );</div>
<div class="line">        resetTechniqueEnumAttribute(*<span class="keyword">this</span>);</div>
<div class="line">        fEffectName = shader;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> loadedEffect = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> fileExits = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (<a name="a205"></a><a class="code" href="./class_m_file_i_o.html#accbcaffc37fcbee9f7974aae80c8014b">MFileIO::isReadingFile</a>() || <a name="a206"></a><a class="code" href="./class_m_file_i_o.html#a30bf5678402012d5607a6b0f22d2c2a5">MFileIO::isOpeningFile</a>()) {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> resolvedFileName = CDX11EffectCompileHelper::resolveShaderFileName(shader, &amp;fileExits);</div>
<div class="line"> <span class="keywordflow">if</span>(!fileExits)</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> msg = dx11ShaderStrings::getString( dx11ShaderStrings::kErrorFileNotFound, resolvedFileName );</div>
<div class="line">            fErrorLog += msg;</div>
<div class="line">            displayErrorAndWarnings();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MHWRender::MRenderer</a> *theRenderer = <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MHWRender::MRenderer::theRenderer</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (theRenderer &amp;&amp; theRenderer-&gt;<a name="a207"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#aac2a5827e6a0ce3333e62ffa7751ba5e">drawAPIIsOpenGL</a>() == <span class="keyword">false</span> &amp;&amp; fileExits)</div>
<div class="line">    {</div>
<div class="line">        ID3D11Device* dxDevice = (ID3D11Device*)theRenderer-&gt;<a name="a208"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a637ec8cc3cc0e631f1d134f6891f89f0">GPUDeviceHandle</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (dxDevice)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">//Clear errors and warning which might be linked to another effect</span></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> diagnosticsPlug( thisMObject(), sDiagnostics);</div>
<div class="line">            diagnosticsPlug.setValue(<a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">""</span>));</div>
<div class="line"></div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// do an early check to see if this file exists to avoid attributes getting reset in loadFromFile() if user</span></div>
<div class="line"> <span class="comment">// makes a typo in file path.</span></div>
<div class="line"> <span class="keywordtype">bool</span> fileExits = <span class="keyword">false</span>;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> resolvedFileName = CDX11EffectCompileHelper::resolveShaderFileName(shader, &amp;fileExits);</div>
<div class="line"> <span class="keywordflow">if</span>(fileExits == <span class="keyword">false</span>)</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> msg = dx11ShaderStrings::getString( dx11ShaderStrings::kErrorFileNotFound, resolvedFileName );</div>
<div class="line">                    fErrorLog += msg;</div>
<div class="line">                    displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// exit early so we do not store 'shader' as fEffectName in case the user saves the file at this point we don't want to save invalid fx filename</span></div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Do not clear the effect. This allows reusing attributes whenever</span></div>
<div class="line"> <span class="comment">// possible. MPxHardwareShader will take care of updating metadata</span></div>
<div class="line"> <span class="comment">// like default values and slider limits when re-using an attribute.</span></div>
<div class="line"></div>
<div class="line">                loadedEffect = loadFromFile( shader, dxDevice );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// increment version id</span></div>
<div class="line"> <span class="keywordflow">if</span> (loadedEffect)</div>
<div class="line">                {</div>
<div class="line">                    fEffectName = CDX11EffectCompileHelper::resolveShaderFileName(shader);</div>
<div class="line"> <span class="keywordflow">if</span> (techniqueCount() &gt; 0) {</div>
<div class="line"> <span class="comment">// default to first technique:</span></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> techniquePlug( thisMObject(), sTechnique);</div>
<div class="line">                        techniquePlug.setValue( techniques()[0] );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update our shader info attributes</span></div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> descriptionPlug( thisMObject(), sDescription);</div>
<div class="line">                descriptionPlug.setValue( <span class="stringliteral">""</span> );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(loadedEffect) {</div>
<div class="line">                setTopoDirty();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(loadedEffect == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Always keep the effect name, especially in OpenGL mode.</span></div>
<div class="line">        fEffectName = shader;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> loadedEffect;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Load an effect from file.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::loadFromFile( <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> &amp;fileName, dx11ShaderDX11Device* dxDevice )</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!dxDevice)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    resetData();</div>
<div class="line"></div>
<div class="line">    fEffect = CDX11EffectCompileHelper::build(<span class="keyword">this</span>, dxDevice, fileName, fErrorLog);</div>
<div class="line"> <span class="keywordflow">if</span>( fEffect == NULL )</div>
<div class="line">    {</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Try to initialize the effect</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (!initializeEffect())</div>
<div class="line">    {</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line">        resetData();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Keep track of file name as effect name. We</span></div>
<div class="line"> <span class="comment">// don't store the full filename since that contains the</span></div>
<div class="line"> <span class="comment">// full path resolved using shader search paths.</span></div>
<div class="line"> <span class="comment">// It is assumed that on every load we must re-resolve.</span></div>
<div class="line">    fEffectName = fileName;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Load an effect from a system memory buffer.</span></div>
<div class="line"><span class="comment">    A unique identifier should be supplied</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::loadFromBuffer( <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> &amp;identifier, <span class="keyword">const</span> <span class="keywordtype">void</span> *pData, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dataSize, dx11ShaderDX11Device* dxDevice )</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!dxDevice || !pData || dataSize == 0)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    resetData();</div>
<div class="line"></div>
<div class="line">    fEffect = CDX11EffectCompileHelper::build(<span class="keyword">this</span>, dxDevice, pData, dataSize, fErrorLog);</div>
<div class="line"> <span class="keywordflow">if</span>( fEffect == NULL )</div>
<div class="line">    {</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Try to initialize the effect</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span> (!initializeEffect())</div>
<div class="line">    {</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line">        resetData();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Keep track of identifier as effect name</span></div>
<div class="line">    fEffectName = identifier;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Parse the effect to pull of information</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::initializeEffect()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Clear out all other data but not the effect</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    resetData( <span class="keyword">false</span> );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!fEffect)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Initialize the list of techniques.  If there are no valid techniques, the D3D effect cannot</span></div>
<div class="line"> <span class="comment">// be used and the function returns false.</span></div>
<div class="line">    initializeTechniques();</div>
<div class="line"> <span class="keywordflow">if</span> (techniqueCount() == 0)</div>
<div class="line">    {</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Reset data members. Optionally delete</span></div>
<div class="line"><span class="comment">    any existing effect.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::resetData(<span class="keywordtype">bool</span> clearEffect)</div>
<div class="line">{</div>
<div class="line">    fMayaSwatchRenderVar = NULL;</div>
<div class="line">    fMayaGammaCorrectVar = NULL;</div>
<div class="line">    fMayaHwFogEnabled = NULL;</div>
<div class="line">    fMayaHwFogMode = NULL;</div>
<div class="line">    fMayaHwFogStart = NULL;</div>
<div class="line">    fMayaHwFogEnd = NULL;</div>
<div class="line">    fMayaHwFogDensity = NULL;</div>
<div class="line">    fMayaHwFogColor = NULL;</div>
<div class="line">    fDepthRange = NULL;</div>
<div class="line">    fTechnique = NULL;</div>
<div class="line"> <span class="keywordflow">if</span> (clearEffect &amp;&amp; fEffect)</div>
<div class="line">    {</div>
<div class="line">        CDX11EffectCompileHelper::releaseEffect(<span class="keyword">this</span>, fEffect, fEffectName);</div>
<div class="line">        fEffect = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Release textures</span></div>
<div class="line">        releaseAllTextures();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fTechniqueIdx = -1;</div>
<div class="line">    fTechniqueName.clear();</div>
<div class="line">    fTechniqueNames.clear();</div>
<div class="line">    fTechniquePassCount = 0;</div>
<div class="line">    fTechniquePassSpecs.clear();</div>
<div class="line"></div>
<div class="line">    clearLightConnectionData();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Should Clear the uniform parameters</span></div>
<div class="line"> <span class="comment">// ------------------------------------------</span></div>
<div class="line">    fUniformParameters.setLength(0);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Should Clear the varying parameters</span></div>
<div class="line"> <span class="comment">// ------------------------------------------</span></div>
<div class="line">    fVaryingParametersUpdateId = 0;</div>
<div class="line">    fVaryingParameters.setLength(0);</div>
<div class="line">    fVaryingParametersVertexDescriptorList.clear();</div>
<div class="line"></div>
<div class="line">    fTechniqueIndexBufferType.clear();</div>
<div class="line">    fTechniqueTextureMipMapLevels = 1;</div>
<div class="line">    fTechniqueIsTransparent = eOpaque;</div>
<div class="line">    fOpacityPlugName = <span class="stringliteral">""</span>;</div>
<div class="line">    fTransparencyTestProcName = <span class="stringliteral">""</span>;</div>
<div class="line">    fTechniqueSupportsAdvancedTransparency = <span class="keyword">false</span>;</div>
<div class="line">    fTechniqueOverridesNonMaterialItems = <span class="keyword">false</span>;</div>
<div class="line">    fTechniqueHandlesConsolidatedGeometry = <span class="keyword">false</span>;</div>
<div class="line">    fTechniqueIsSelectable = <span class="keyword">false</span>;</div>
<div class="line">    fTechniqueOverridesDrawState = <span class="keyword">false</span>;</div>
<div class="line">    fForceUpdateTexture = <span class="keyword">true</span>;</div>
<div class="line">    fFixedTextureMipMapLevels = -1;</div>
<div class="line">    releaseTexture(fUVEditorTexture);</div>
<div class="line">    fUVEditorTexture = NULL;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_GL_TEXTURE_CACHING</span></div>
<div class="line">    fUVEditorLastTexture.clear();</div>
<div class="line">    fUVEditorLastLayer.clear();</div>
<div class="line">    fUVEditorLastAlphaChannel = -1;</div>
<div class="line">    fUVEditorBaseColor[0] = fUVEditorBaseColor[1] = fUVEditorBaseColor[2] = fUVEditorBaseColor[3] = 0;</div>
<div class="line">    fUVEditorShowAlphaMask = <span class="keyword">false</span>;</div>
<div class="line">    releaseGLTexture(fUVEditorGLTextureId);</div>
<div class="line">    fUVEditorGLTextureId = 0;</div>
<div class="line">    fUVEditorGLTextureScaleU = fUVEditorGLTextureScaleV = 1.0f;</div>
<div class="line"><span class="preprocessor">#endif //USE_GL_TEXTURE_CACHING</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// clear has hull shader map cache</span></div>
<div class="line">    fPassHasHullShaderMap.clear();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clear and release input layout cache</span></div>
<div class="line">    {</div>
<div class="line">        PassInputLayoutMap::iterator it = fPassInputLayoutMap.begin();</div>
<div class="line">        PassInputLayoutMap::iterator itEnd = fPassInputLayoutMap.end();</div>
<div class="line"> <span class="keywordflow">for</span>(; it != itEnd; ++it)</div>
<div class="line">        {</div>
<div class="line">            InputLayoutData&amp; data = it-&gt;second;</div>
<div class="line">            data.inputLayout-&gt;Release();</div>
<div class="line"> <span class="keyword">delete</span> [] data.layoutDesc;</div>
<div class="line">        }</div>
<div class="line">        fPassInputLayoutMap.clear();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Techniques Management</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Effects can now use multi-pass drawing to achieve interesting</span></div>
<div class="line"><span class="comment">    looks by specifying for each DX11EffectPass if it should be</span></div>
<div class="line"><span class="comment">    rendered in the current context. This is done by matching the</span></div>
<div class="line"><span class="comment">    context string with an annotation named "drawContext" on the</span></div>
<div class="line"><span class="comment">    effect pass. For example, an effect with displacement can provide</span></div>
<div class="line"><span class="comment">    a special shadow pass to cast correct shadows on nearby geometries.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::techniqueHandlesContext(<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> passSemantics = getPassSemanticsRemovingColorPassIfNecessary(context);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passIndex = 0; passIndex &lt; fTechniquePassCount; ++passIndex)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span>( passHandlesContext(passSemantics, passIndex, RENDER_SCENE) )</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::passHandlesContext(<span class="keyword">const</span> <a class="code" href="./class_m_string_array.html">MStringArray</a>&amp; passSemantics, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passIndex, ERenderType renderType, <span class="keyword">const</span> RenderItemDesc* renderItemDesc)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    PassSpecMap::const_iterator it = fTechniquePassSpecs.find(passIndex);</div>
<div class="line"> <span class="keywordflow">if</span> (it == fTechniquePassSpecs.end())</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> <span class="keyword">const</span> PassSpec&amp; passSpec = it-&gt;second;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> isHandled = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passSemIdx = 0; passSemIdx &lt; passSemantics.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &amp;&amp; !isHandled; ++passSemIdx)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; semantic = passSemantics[passSemIdx];</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (semantic == <a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a97ffcfc5e6c4bd512eab6727c58a9ae8">MHWRender::MPassContext::kColorPassSemantic</a>)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>(isRenderNonMaterialItem(renderType))</div>
<div class="line">            {</div>
<div class="line">                isHandled = (::_stricmp(passSpec.drawContext.asChar(), dx11ShaderAnnotation::kNonMaterialItemsPass) == 0);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                isHandled = (passSpec.drawContext.length() == 0) || (::_stricmp(semantic.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(), passSpec.drawContext.asChar()) == 0);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            isHandled = (::_stricmp(semantic.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(), passSpec.drawContext.asChar()) == 0);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (isHandled &amp;&amp; isRenderNonMaterialItem(renderType))</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (renderItemDesc &amp;&amp; renderItemDesc-&gt;isFatLine)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">if</span> (!passSpec.forFatLine)</div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// This pass is not meant for fat line,</span></div>
<div class="line"> <span class="comment">// accept only if there is no pass with the same drawContext which handles fat line</span></div>
<div class="line"> <span class="keyword">const</span> PassSpec passSpecTest = { passSpec.drawContext, <span class="keyword">true</span>, <span class="keyword">false</span> };</div>
<div class="line">                    isHandled = (findMatchingPass(passSpecTest) == (<span class="keywordtype">unsigned</span> int)-1);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renderItemDesc &amp;&amp; renderItemDesc-&gt;isFatPoint)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">if</span> (!passSpec.forFatPoint)</div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// This pass is not meant for fat point,</span></div>
<div class="line"> <span class="comment">// accept only if there is no pass with the same drawContext which handles fat point</span></div>
<div class="line"> <span class="keyword">const</span> PassSpec passSpecTest = { passSpec.drawContext, <span class="keyword">false</span>, <span class="keyword">true</span> };</div>
<div class="line">                    isHandled = (findMatchingPass(passSpecTest) == (<span class="keywordtype">unsigned</span> int)-1);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                isHandled = (!passSpec.forFatLine &amp;&amp; !passSpec.forFatPoint);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> isHandled;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dx11ShaderNode::findMatchingPass(<span class="keyword">const</span> PassSpec&amp; passSpecTest)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    PassSpecMap::const_iterator it = fTechniquePassSpecs.<a name="a209"></a><a class="code" href="./class_m_string_array.html#a1ebac8c16ac95b2b81d78055841992f3">begin</a>();</div>
<div class="line">    PassSpecMap::const_iterator itEnd = fTechniquePassSpecs.end();</div>
<div class="line"> <span class="keywordflow">for</span>(; it != itEnd; ++it)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> PassSpec&amp; passSpec = it-&gt;second;</div>
<div class="line"> <span class="keywordflow">if</span>( passSpec.forFatLine == passSpecTest.forFatLine &amp;&amp;</div>
<div class="line">            passSpec.forFatPoint == passSpecTest.forFatPoint &amp;&amp;</div>
<div class="line">            ::_stricmp(passSpec.drawContext.asChar(), passSpecTest.drawContext.asChar()) == 0)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">return</span> it-&gt;first;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) -1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Parse the effect to find all of the techniques.</span></div>
<div class="line"><span class="comment">    If none found then return false.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::initializeTechniques()</div>
<div class="line">{</div>
<div class="line">    fTechnique = NULL;</div>
<div class="line">    fTechniqueIdx = -1;</div>
<div class="line">    fTechniqueName.clear();</div>
<div class="line">    fTechniqueNames.clear();</div>
<div class="line"></div>
<div class="line">    resetTechniqueEnumAttribute(*<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!fEffect)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the description of the D3D effect.</span></div>
<div class="line">    D3DX11_EFFECT_DESC descEffect;</div>
<div class="line">    memset(&amp;descEffect, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_DESC));</div>
<div class="line">    HRESULT hr = fEffect-&gt;GetDesc(&amp;descEffect);</div>
<div class="line"> <span class="keywordflow">if</span> (FAILED(hr) || descEffect.Techniques == 0)</div>
<div class="line">    {</div>
<div class="line">        fErrorLog += dx11ShaderStrings::getString( dx11ShaderStrings::kErrorNoValidTechniques );</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Search the D3D effect for valid techniques, adding each one to the technique list.</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; descEffect.Techniques; ++i)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Check whether the technique with the current index is valid.</span></div>
<div class="line">        ID3DX11EffectTechnique* dxTechnique = fEffect-&gt;GetTechniqueByIndex(i);</div>
<div class="line"> <span class="keywordflow">if</span> (!dxTechnique-&gt;IsValid()) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add the technique's name to the technique list.</span></div>
<div class="line">        D3DX11_TECHNIQUE_DESC desc;</div>
<div class="line">        memset(&amp;desc, 0, <span class="keyword">sizeof</span>(D3DX11_TECHNIQUE_DESC));</div>
<div class="line">        dxTechnique-&gt;GetDesc(&amp;desc);</div>
<div class="line">        fTechniqueNames.append( desc.Name );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set up techniqueEnum attribute. It will show up in ChannelBox</span></div>
<div class="line">    fTechniqueEnumAttr = buildTechniqueEnumAttribute(*<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set the first technique, if any.</span></div>
<div class="line"> <span class="keywordflow">if</span> (techniqueCount() == 0)</div>
<div class="line">    {</div>
<div class="line">        fErrorLog += dx11ShaderStrings::getString( dx11ShaderStrings::kErrorNoValidTechniques );</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::setTechnique( <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> &amp; techniqueName )</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!fEffect &amp;&amp; fEffectName.length() &gt; 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Keep the name, we are in OpenGL and could not compile the effect,</span></div>
<div class="line"> <span class="comment">// or in DX but could not find or compile the shader file.</span></div>
<div class="line">        fTechniqueName = techniqueName;</div>
<div class="line"> <span class="comment">// We have no idea if other techniques are available, but</span></div>
<div class="line"> <span class="comment">// still show something in the techniques dropdown in the</span></div>
<div class="line"> <span class="comment">// attribute editor. We know at least this one exists.</span></div>
<div class="line">        fTechniqueNames.append( techniqueName );</div>
<div class="line">        fTechniqueEnumAttr = buildTechniqueEnumAttribute(*<span class="keyword">this</span>);</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!fEffect)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// MStringArray has no find method. Do a linear search...</span></div>
<div class="line"> <span class="keywordtype">int</span> numTechniques = techniqueCount();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;numTechniques; ++i) {</div>
<div class="line"> <span class="keywordflow">if</span> (fTechniqueNames[i] == techniqueName) {</div>
<div class="line"> <span class="keywordflow">return</span> setTechnique(i);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    fErrorLog += dx11ShaderStrings::getString( dx11ShaderStrings::kErrorSetTechniqueByName, techniqueName );</div>
<div class="line">    displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Set the current active technique by number.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::setTechnique( <span class="keywordtype">int</span> techniqueNumber )</div>
<div class="line">{</div>
<div class="line">    setTopoDirty();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!fEffect)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Invalid technique number return failure</span></div>
<div class="line"> <span class="keywordflow">if</span> (techniqueNumber &lt; 0 || techniqueNumber &gt;= techniqueCount())</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> techniqueNumberStr = MStringFromInt(techniqueNumber);</div>
<div class="line">        fErrorLog += dx11ShaderStrings::getString( dx11ShaderStrings::kErrorSetTechniqueByIndex, techniqueNumberStr );</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Do nothing if the technique is already active.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fTechniqueIdx == techniqueNumber)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the technique by name, and record it as the active technique.</span></div>
<div class="line">    fTechnique = fEffect-&gt;GetTechniqueByName( fTechniqueNames[techniqueNumber].asChar() );</div>
<div class="line"> <span class="keywordflow">if</span> (!fTechnique)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> techniqueNumberStr = MStringFromInt(techniqueNumber);</div>
<div class="line">        fErrorLog += dx11ShaderStrings::getString( dx11ShaderStrings::kErrorSetTechniqueByIndex, techniqueNumberStr );</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Keep track of the active technique and technique number</span></div>
<div class="line">    fTechniqueIdx = techniqueNumber;</div>
<div class="line">    fTechniqueName = fTechniqueNames[fTechniqueIdx];</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Record the number of passes for the active technique.</span></div>
<div class="line"> <span class="comment">// Set no active pass.</span></div>
<div class="line">    D3DX11_TECHNIQUE_DESC desc;</div>
<div class="line">    memset(&amp;desc, 0, <span class="keyword">sizeof</span>(D3DX11_TECHNIQUE_DESC));</div>
<div class="line">    fTechnique-&gt;GetDesc(&amp;desc);</div>
<div class="line">    fTechniquePassCount = desc.Passes;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Build list of techniques pass specs and determine Selectable status</span></div>
<div class="line">    fTechniquePassSpecs.clear();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passIndex = 0; passIndex &lt; fTechniquePassCount; ++passIndex)</div>
<div class="line">    {</div>
<div class="line">        ID3DX11EffectPass *dxPass = fTechnique-&gt;GetPassByIndex(passIndex);</div>
<div class="line"> <span class="keywordflow">if</span>(dxPass &amp;&amp; dxPass-&gt;IsValid())</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> passDrawContext;</div>
<div class="line">            getAnnotation(dxPass, dx11ShaderAnnotation::kDrawContext, passDrawContext);</div>
<div class="line"> <span class="keywordflow">if</span> (::_stricmp(passDrawContext.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),  <a name="a210"></a><a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a728fc00f0764227a6f345c089058c998">MHWRender::MPassContext::kSelectionPassSemantic</a>.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>()) == 0)</div>
<div class="line">                fTechniqueIsSelectable = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> passPrimitiveFilter;</div>
<div class="line">            getAnnotation(dxPass, dx11ShaderAnnotation::kPrimitiveFilter, passPrimitiveFilter);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> passIsForFatLine  = (::_stricmp(passPrimitiveFilter.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(), dx11ShaderAnnotationValue::kFatLine) == 0);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> passIsForFatPoint = (::_stricmp(passPrimitiveFilter.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(), dx11ShaderAnnotationValue::kFatPoint) == 0);</div>
<div class="line"></div>
<div class="line">            PassSpec spec = { passDrawContext, passIsForFatLine, passIsForFatPoint };</div>
<div class="line">            fTechniquePassSpecs.insert( std::make_pair(passIndex, spec) );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Light names are affected by the chosen technique:</span></div>
<div class="line"> <span class="comment">// -------------------------------------------------</span></div>
<div class="line">    clearLightConnectionData();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// must now update and create the attribute of the node</span></div>
<div class="line"> <span class="comment">// relative to the shader effect specific parameters</span></div>
<div class="line"> <span class="comment">// ----------------------------------------------------</span></div>
<div class="line">    buildUniformParameterList();</div>
<div class="line">    setUniformParameters( fUniformParameters );</div>
<div class="line"></div>
<div class="line">    initMayaParameters();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the varying parameters</span></div>
<div class="line"> <span class="comment">// update the required buffers from</span></div>
<div class="line"> <span class="comment">// -------------------------------------------------------</span></div>
<div class="line">    storeDefaultTextureNames();</div>
<div class="line"></div>
<div class="line">    buildVaryingParameterList();</div>
<div class="line">    setVaryingParameters(fVaryingParameters);</div>
<div class="line"></div>
<div class="line">    initTechniqueParameters();</div>
<div class="line"></div>
<div class="line">    restoreDefaultTextureNames();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Store the default textures for the UV editor to</span></div>
<div class="line"><span class="comment">    preserve them when the user switches techniques</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::storeDefaultTextureNames()</div>
<div class="line">{</div>
<div class="line">    fDefaultTextureNames.clear();</div>
<div class="line">    fDefaultTextureNames.setLength( fVaryingParameters.length() );</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> depFn( thisMObject() );</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iVar = 0; iVar &lt; fVaryingParameters.length(); ++iVar)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html">MVaryingParameter</a> elem = fVaryingParameters.getElement(iVar);</div>
<div class="line"> <span class="keywordflow">if</span>( elem.<a class="code" href="./class_m_varying_parameter.html#ad72ff2b3fb20052e4a2455dad5c10682">getSourceType</a>() != <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a45b7096916b12a78e94c62bba9d50739">MVaryingParameter::kTexCoord</a> )</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> attrName( elem.<a name="a211"></a><a class="code" href="./class_m_varying_parameter.html#a2e8d4c38a60806df8c2ffd6d09e70b96">name</a>() );</div>
<div class="line">        attrName += <span class="stringliteral">"_DefaultTexture"</span>;</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> defaultTexPlug = depFn.findPlug( attrName );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( defaultTexPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() )</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> texName;</div>
<div class="line">        defaultTexPlug.<a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>( texName );</div>
<div class="line">        fDefaultTextureNames[iVar] = texName;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Restore the default textures for the UV editor after</span></div>
<div class="line"><span class="comment">    user has switched techniques</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::restoreDefaultTextureNames()</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> depFn( thisMObject() );</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iVar = 0; iVar &lt; fVaryingParameters.length(); ++iVar)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (iVar &gt;= (<span class="keywordtype">int</span>)fDefaultTextureNames.length())</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html">MVaryingParameter</a> elem = fVaryingParameters.<a class="code" href="./class_m_varying_parameter.html#a40cde1a792fb9a978d3a3a68414fb865">getElement</a>(iVar);</div>
<div class="line"> <span class="keywordflow">if</span>( elem.<a class="code" href="./class_m_varying_parameter.html#ad72ff2b3fb20052e4a2455dad5c10682">getSourceType</a>() != <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a45b7096916b12a78e94c62bba9d50739">MVaryingParameter::kTexCoord</a> )</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// checking for no string here makes sure that in initTechniqueParameters() the</span></div>
<div class="line"> <span class="comment">// "UVEditorOrder" semantic is respected when the user loads a new shader, because</span></div>
<div class="line"> <span class="comment">// we default to an empty string in the texture data group in AE.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fDefaultTextureNames[iVar].length() == 0)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> attrName( elem.<a class="code" href="./class_m_varying_parameter.html#a2e8d4c38a60806df8c2ffd6d09e70b96">name</a>() );</div>
<div class="line">        attrName += <span class="stringliteral">"_DefaultTexture"</span>;</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> defaultTexPlug = depFn.findPlug( attrName );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( defaultTexPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() )</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">        defaultTexPlug.<a name="a212"></a><a class="code" href="./class_m_plug.html#aec7c3792a53d27a61ece4f7b81cc123b">setValue</a>( fDefaultTextureNames[iVar] );</div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> defaultTexAttr(defaultTexPlug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>());</div>
<div class="line">        defaultTexAttr.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>(<span class="stringliteral">"HW_shader_parameter"</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Initialize any parameter that will change the behaviour of the new selected technique:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    kIndexBufferType - defines the name of the generator that can produce the proper geometry indexing for this technique.</span></div>
<div class="line"><span class="comment">    kTextureMipmaplevels - controls the mipmap levels of the textures loaded/used by this technique</span></div>
<div class="line"><span class="comment">    kOverridesDrawState/kIsTransparent - affect how the material will be rendered.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::initTechniqueParameters()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Query technique for index buffer type (ie. crackFree indexing - PNAEN9 or PNAEN18)</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> newIndexBufferType;</div>
<div class="line">    getAnnotation(fTechnique, dx11ShaderAnnotation::kIndexBufferType, newIndexBufferType);</div>
<div class="line"> <span class="keywordflow">if</span>(fTechniqueIndexBufferType != newIndexBufferType)</div>
<div class="line">    {</div>
<div class="line">        fTechniqueIndexBufferType = newIndexBufferType;</div>
<div class="line">        setTopoDirty();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Query technique for mipmap levels to use for when loading textures</span></div>
<div class="line"> <span class="keywordtype">int</span> mipmapLevels = 1;</div>
<div class="line">    getAnnotation(fTechnique, dx11ShaderAnnotation::kTextureMipmaplevels, mipmapLevels);</div>
<div class="line"> <span class="keywordflow">if</span>(fTechniqueTextureMipMapLevels != mipmapLevels)</div>
<div class="line">    {</div>
<div class="line">        fTechniqueTextureMipMapLevels = mipmapLevels;</div>
<div class="line">        fForceUpdateTexture = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Query technique if it should follow the maya transparent object rendering or is self-managed (multi-passes)</span></div>
<div class="line">    fTechniqueOverridesDrawState = <span class="keyword">false</span>;</div>
<div class="line">    getAnnotation(fTechnique, dx11ShaderAnnotation::kOverridesDrawState, fTechniqueOverridesDrawState);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Query technique if it supports advanced transparency algorithm.</span></div>
<div class="line">    fTechniqueSupportsAdvancedTransparency = <span class="keyword">false</span>;</div>
<div class="line">    getAnnotation(fTechnique, dx11ShaderAnnotation::kSupportsAdvancedTransparency, fTechniqueSupportsAdvancedTransparency);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Query technique if it overrides non material items items</span></div>
<div class="line">    fTechniqueOverridesNonMaterialItems = <span class="keyword">false</span>;</div>
<div class="line">    getAnnotation(fTechnique, dx11ShaderAnnotation::kOverridesNonMaterialItems, fTechniqueOverridesNonMaterialItems);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Query technique if it should enable the consolidation for the geometry it is applied to</span></div>
<div class="line">    fTechniqueHandlesConsolidatedGeometry = <span class="keyword">true</span>;</div>
<div class="line">    getAnnotation(fTechnique, dx11ShaderAnnotation::kHandlesConsolidatedGeometry, fTechniqueHandlesConsolidatedGeometry);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Query technique if it has transparency</span></div>
<div class="line">    fTechniqueIsTransparent = eOpaque;</div>
<div class="line"> <span class="keywordtype">int</span> techniqueTransparentAnnotation = 0;</div>
<div class="line"> <span class="keywordflow">if</span>( getAnnotation(fTechnique, dx11ShaderAnnotation::kIsTransparent, techniqueTransparentAnnotation) == <span class="keyword">false</span> )</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// If the annotation is not found we need to check if</span></div>
<div class="line"> <span class="comment">// the effect modifies the blend state when activating</span></div>
<div class="line"> <span class="comment">// its passes:</span></div>
<div class="line">        ID3D11Device *device;</div>
<div class="line"> <span class="keywordflow">if</span>( S_OK == fEffect-&gt;GetDevice(&amp;device) )</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Acquire a temporary context to apply the pass on</span></div>
<div class="line">            ID3D11DeviceContext *deviceContext;</div>
<div class="line"> <span class="keywordflow">if</span>( S_OK == device-&gt;CreateDeferredContext(0, &amp;deviceContext) )</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passId = 0; passId &lt; fTechniquePassCount; ++passId)</div>
<div class="line">                {</div>
<div class="line">                    ID3DX11EffectPass *dxPass = fTechnique-&gt;GetPassByIndex(passId);</div>
<div class="line"> <span class="keywordflow">if</span>( dxPass == NULL || dxPass-&gt;IsValid() == false )</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( S_OK == dxPass-&gt;Apply(0, deviceContext) == false )</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">                    ID3D11BlendState *blendState;</div>
<div class="line">                    FLOAT blendFactor[4];</div>
<div class="line">                    UINT sampleMask;</div>
<div class="line">                    deviceContext-&gt;OMGetBlendState(&amp;blendState, blendFactor, &amp;sampleMask);</div>
<div class="line"> <span class="keywordflow">if</span>(blendState)</div>
<div class="line">                    {</div>
<div class="line">                        D3D11_BLEND_DESC blendDesc;</div>
<div class="line">                        blendState-&gt;GetDesc(&amp;blendDesc);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check first renderTarget only</span></div>
<div class="line"> <span class="keywordflow">if</span>( blendDesc.RenderTarget[0].BlendEnable != FALSE )</div>
<div class="line">                        {</div>
<div class="line"> <span class="keywordflow">if</span>( blendDesc.RenderTarget[0].SrcBlend  &gt; D3D11_BLEND_ONE ||</div>
<div class="line">                                blendDesc.RenderTarget[0].DestBlend &gt; D3D11_BLEND_ONE )</div>
<div class="line">                            {</div>
<div class="line">                                fTechniqueIsTransparent = eTransparent;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Release temporary context</span></div>
<div class="line">                deviceContext-&gt;Release();</div>
<div class="line">            }</div>
<div class="line">            device-&gt;Release();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">/*  This annotation helps Maya find out if the effect is currently</span></div>
<div class="line"><span class="comment">            transparent or not. There are 4 possible cases:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">            eOpaque: Effect is fully opaque</span></div>
<div class="line"><span class="comment">            eTransparent: Effect is not perfectly opaque</span></div>
<div class="line"><span class="comment">            eScriptedTest: The opacity of the effect can be found by executing</span></div>
<div class="line"><span class="comment">                           the script provided in the transparencyTest annotation</span></div>
<div class="line"><span class="comment">            eTestOpacitySemantics: The opacity of the effect is driven by a single</span></div>
<div class="line"><span class="comment">                                   float parameter that has the "opacity" semantics</span></div>
<div class="line"><span class="comment">        */</span></div>
<div class="line"> <span class="keywordflow">switch</span> (techniqueTransparentAnnotation)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">case</span> eOpaque:</div>
<div class="line">            fTechniqueIsTransparent = eOpaque;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> eTransparent:</div>
<div class="line">            fTechniqueIsTransparent = eTransparent;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> eScriptedTest:</div>
<div class="line">            fTechniqueIsTransparent = eScriptedTest;</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// Need to find script info</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> procBody;</div>
<div class="line"> <span class="keywordflow">if</span> (getAnnotation(fTechnique, dx11ShaderAnnotation::kTransparencyTest, procBody) &amp;&amp;</div>
<div class="line">                    procBody.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0)</div>
<div class="line">                {</div>
<div class="line"><span class="preprocessor">#ifdef _DEBUG_SHADER</span></div>
<div class="line">                    printf(<span class="stringliteral">"-- transparencyTest &lt;&lt;%s&gt;&gt;.\n"</span>, procBody.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> paramCount = fUniformParameters.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; paramCount; ++i )</div>
<div class="line">                    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> param = fUniformParameters.getElement(i);</div>
<div class="line">                        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)param.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(effectVariable)</div>
<div class="line">                        {</div>
<div class="line">                            D3DX11_EFFECT_VARIABLE_DESC varDesc;</div>
<div class="line">                            memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_VARIABLE_DESC));</div>
<div class="line">                            effectVariable-&gt;GetDesc(&amp;varDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> varName(varDesc.Name);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> attr(param.<a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>().<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>());</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> attrName = attr.name();</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> queryFormat ( <span class="stringliteral">"`getAttr($shader + \".^1s\")`"</span> );</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> query;</div>
<div class="line">                            query.<a name="a213"></a><a class="code" href="./class_m_string.html#a07ae464181c795f43fa1bcc288acff91">format</a>( queryFormat, attrName );</div>
<div class="line"></div>
<div class="line">                            procBody = replaceAll(procBody, varName, query);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> procNameFormat ( <span class="stringliteral">"dx11Shader^1sTransparencyTest"</span> );</div>
<div class="line">                    fTransparencyTestProcName = getFileName(fEffectName);</div>
<div class="line">                    fTransparencyTestProcName = sanitizeName(fTransparencyTestProcName);</div>
<div class="line">                    fTransparencyTestProcName.format( procNameFormat, fTransparencyTestProcName );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> procBodyFormat ( <span class="stringliteral">"global proc int ^1s(string $shader) { return (^2s); }"</span> );</div>
<div class="line">                    procBody.<a class="code" href="./class_m_string.html#a07ae464181c795f43fa1bcc288acff91">format</a>( procBodyFormat, fTransparencyTestProcName, procBody );</div>
<div class="line"><span class="preprocessor">#ifdef _DEBUG_SHADER</span></div>
<div class="line">                    printf(<span class="stringliteral">"-- transparencyTest &lt;&lt;%s&gt;&gt;.\n"</span>, procBody.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> <span class="comment">// eval the body only once to define the procedure</span></div>
<div class="line"> <span class="keywordflow">if</span> (<a class="code" href="./class_m_global.html#a09e405631e7cf680f8ac9d934ad73434">MGlobal::executeCommand</a>(procBody, <span class="keyword">false</span>, <span class="keyword">false</span>) == MS::kSuccess)</div>
<div class="line">                    {</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// NOTE: on failure to get procedure we clear values and fall back to auto (ie. no break here)</span></div>
<div class="line">                fTransparencyTestProcName = <span class="stringliteral">""</span>;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">case</span> eTestOpacitySemantics:</div>
<div class="line">            fTechniqueIsTransparent = eTestOpacitySemantics;</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// Need to find opacity plug:</span></div>
<div class="line"> <span class="keywordtype">bool</span> foundOpacity = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> paramCount = fUniformParameters.length();</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; paramCount &amp;&amp; !foundOpacity; ++i )</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> param = fUniformParameters.getElement(i);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// look for opacity -- filter for float1 parameters</span></div>
<div class="line"> <span class="keywordflow">if</span>( param.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a> &amp;&amp; param.<a class="code" href="./class_m_uniform_parameter.html#ac7fba35931cc9a520837b0a752352e16">numElements</a>() == 1)</div>
<div class="line">                    {</div>
<div class="line">                        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)param.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(effectVariable)</div>
<div class="line">                        {</div>
<div class="line">                            D3DX11_EFFECT_VARIABLE_DESC varDesc;</div>
<div class="line">                            memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_VARIABLE_DESC));</div>
<div class="line">                            effectVariable-&gt;GetDesc(&amp;varDesc);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check semantic first</span></div>
<div class="line">                            foundOpacity = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kOpacity, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span>(foundOpacity == <span class="keyword">false</span>)</div>
<div class="line">                            {</div>
<div class="line"> <span class="comment">// Then check annotation</span></div>
<div class="line"> <span class="keywordtype">bool</span> boolValue = 0;</div>
<div class="line">                                foundOpacity = (getAnnotation(effectVariable, dx11ShaderSemantic::kOpacity, boolValue) &amp;&amp; boolValue);</div>
<div class="line">                            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(foundOpacity)</div>
<div class="line">                            {</div>
<div class="line">                                fOpacityPlugName = param.<a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>().<a name="a214"></a><a class="code" href="./class_m_plug.html#a3694e3dcc355fb7d654a0bb6a8a3ff1c">partialName</a>();   <span class="comment">// get the plug name, might be different than the variable name</span></div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">if</span> (!foundOpacity)</div>
<div class="line">                {</div>
<div class="line">                    fErrorLog += dx11ShaderStrings::getString( dx11ShaderStrings::kErrorIsTransparentOpacity );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line">            fErrorLog += dx11ShaderStrings::getString( dx11ShaderStrings::kErrorUnknownIsTransparent );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">    The attribute editor for dx11Shader has a "Default Texture Data"</span></div>
<div class="line"><span class="comment">    section which allows declaring which textured colored channel is</span></div>
<div class="line"><span class="comment">    associated with a texture coordinates declared in the varying</span></div>
<div class="line"><span class="comment">    parameters. This is used by the UV editor to automatically switch</span></div>
<div class="line"><span class="comment">    to the texture that matches the UV set being edited. We want to</span></div>
<div class="line"><span class="comment">    pre-populate these fields with the textured uniform parameter that</span></div>
<div class="line"><span class="comment">    has the lowest "UVEditorOrder" since it represents the preferred</span></div>
<div class="line"><span class="comment">    channel. In the absence of any ordering annotation, we will use</span></div>
<div class="line"><span class="comment">    the first parameter that is a texture.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"> <span class="keywordtype">int</span> bestIndex = INT_MAX;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> defaultTex;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numUniform = fUniformParameters.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numUniform; i++ ) {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> elem = fUniformParameters.<a class="code" href="./class_m_varying_parameter.html#a40cde1a792fb9a978d3a3a68414fb865">getElement</a>(i);</div>
<div class="line"> <span class="keywordflow">if</span>( elem.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a name="a215"></a><a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6a7d3972f1f1ee99452d3c715b157b5cad">MUniformParameter::kType2DTexture</a> ) {</div>
<div class="line"> <span class="comment">// Skip items which are not UI visible:</span></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> uniformPlug(elem.<a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>());</div>
<div class="line"> <span class="keywordflow">if</span> (uniformPlug.isNull())</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> uniformAttribute(uniformPlug.attribute());</div>
<div class="line"> <span class="keywordflow">if</span> (uniformAttribute.isHidden())</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> currentIndex = bestIndex - numUniform + i;</div>
<div class="line"></div>
<div class="line">            ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)elem.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">int</span> uvEditorOrder;</div>
<div class="line"> <span class="keywordflow">if</span> (getAnnotation(effectVariable, <span class="stringliteral">"UVEditorOrder"</span>, uvEditorOrder))</div>
<div class="line">                {</div>
<div class="line">                    currentIndex = uvEditorOrder;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (currentIndex &lt; bestIndex)</div>
<div class="line">            {</div>
<div class="line">                bestIndex = currentIndex;</div>
<div class="line">                defaultTex = elem.<a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (defaultTex.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> depFn( thisMObject() );</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iVar = 0; iVar &lt; fVaryingParameters.length(); ++iVar)</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html">MVaryingParameter</a> elem = fVaryingParameters.getElement(iVar);</div>
<div class="line"> <span class="keywordflow">if</span>( elem.<a class="code" href="./class_m_varying_parameter.html#ad72ff2b3fb20052e4a2455dad5c10682">getSourceType</a>() == <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a45b7096916b12a78e94c62bba9d50739">MVaryingParameter::kTexCoord</a> ) {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> attrName( elem.<a class="code" href="./class_m_varying_parameter.html#a2e8d4c38a60806df8c2ffd6d09e70b96">name</a>() );</div>
<div class="line">                attrName += <span class="stringliteral">"_DefaultTexture"</span>;</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> defaultTexPlug = depFn.findPlug( attrName );</div>
<div class="line"> <span class="keywordflow">if</span>( !defaultTexPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() ) {</div>
<div class="line">                    defaultTexPlug.<a class="code" href="./class_m_plug.html#aec7c3792a53d27a61ece4f7b81cc123b">setValue</a>( defaultTex );</div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> defaultTexAttr(defaultTexPlug.<a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>());</div>
<div class="line">                    defaultTexAttr.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>(<span class="stringliteral">"HW_shader_parameter"</span>);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::techniqueIsTransparent()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">switch</span> (fTechniqueIsTransparent)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">case</span> eTransparent:</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">case</span> eOpaque:</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">case</span> eScriptedTest:</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">int</span> result = 0;</div>
<div class="line"> <a class="code" href="./class_m_global.html#a09e405631e7cf680f8ac9d934ad73434">MGlobal::executeCommand</a>(fTransparencyTestProcName + <span class="stringliteral">" "</span> + name(), result, <span class="keyword">false</span>, <span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">return</span> (result == 0 ? <span class="keyword">false</span> : <span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">default</span>: <span class="comment">// For others need to continue</span></div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Need to check current opacity value:</span></div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> depFn( thisMObject() );</div>
<div class="line"> <span class="keywordflow">if</span> (fOpacityPlugName != <span class="stringliteral">""</span>)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> opacityPlug = depFn.findPlug( fOpacityPlugName );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( !opacityPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() ) {</div>
<div class="line"> <span class="keywordtype">float</span> currentOpacity = 1.0f;</div>
<div class="line">            opacityPlug.<a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>( currentOpacity );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> currentOpacity &lt; 1.0f;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Assume opaque if opacity plug not found.</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Pass Management</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line">dx11ShaderDX11Pass* dx11ShaderNode::activatePass( dx11ShaderDX11Device *dxDevice, dx11ShaderDX11DeviceContext *dxContext, dx11ShaderDX11EffectTechnique* dxTechnique, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passId, ERenderType renderType )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="comment">// When called for swatch or UV, we want the color pass:</span></div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> colorSem;</div>
<div class="line">    colorSem.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>(<a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a97ffcfc5e6c4bd512eab6727c58a9ae8">MHWRender::MPassContext::kColorPassSemantic</a>);</div>
<div class="line"> <span class="keywordflow">return</span> activatePass( dxDevice, dxContext, dxTechnique, passId, colorSem, renderType );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    This method does the main expensive work of setting the active pass.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">dx11ShaderDX11Pass* dx11ShaderNode::activatePass( dx11ShaderDX11Device *dxDevice, dx11ShaderDX11DeviceContext *dxContext, dx11ShaderDX11EffectTechnique* dxTechnique,</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passId, <span class="keyword">const</span> <a class="code" href="./class_m_string_array.html">MStringArray</a>&amp; passSem, ERenderType renderType, <span class="keyword">const</span> RenderItemDesc* renderItemDesc )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    dx11ShaderDX11Pass* dxPass = dxTechnique-&gt;GetPassByIndex(passId);</div>
<div class="line"> <span class="keywordflow">if</span>(dxPass == NULL || dxPass-&gt;IsValid() == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> args;</div>
<div class="line">        args.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( MStringFromInt(passId) );</div>
<div class="line">        args.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( fTechniqueName );</div>
<div class="line"></div>
<div class="line">        fErrorLog += dx11ShaderStrings::getString( dx11ShaderStrings::kErrorSetPass, args );</div>
<div class="line">        displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( !passHandlesContext( passSem, passId, renderType, renderItemDesc ) )</div>
<div class="line"> <span class="keywordflow">return</span> NULL;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get state block mask : identify the states changed by the pass</span></div>
<div class="line">    D3DX11_STATE_BLOCK_MASK stateBlockMask;</div>
<div class="line">    memset(&amp;stateBlockMask, 0, <span class="keyword">sizeof</span>(D3DX11_STATE_BLOCK_MASK));</div>
<div class="line">    dxPass-&gt;ComputeStateBlockMask(&amp;stateBlockMask);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// In case the pass modifies the rasterizer state, store the current state description</span></div>
<div class="line">    D3D11_RASTERIZER_DESC orgRasterizerDesc;</div>
<div class="line"> <span class="keywordflow">if</span>(stateBlockMask.RSRasterizerState)</div>
<div class="line">    {</div>
<div class="line">        ID3D11RasterizerState* orgRasterizerState;</div>
<div class="line">        dxContext-&gt;RSGetState(&amp;orgRasterizerState);</div>
<div class="line">        orgRasterizerState-&gt;GetDesc(&amp;orgRasterizerDesc);</div>
<div class="line">        orgRasterizerState-&gt;Release();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// to fix "potentially uninitialized local variable 'orgRasterizerDesc' used" warning treated as error</span></div>
<div class="line">        memset(&amp;orgRasterizerDesc, 0, <span class="keyword">sizeof</span>(D3D11_RASTERIZER_DESC));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    dxPass-&gt;Apply(0, dxContext);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(stateBlockMask.RSRasterizerState || overrideRasterizerState(renderType))</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Check new rasterizer state against stored one</span></div>
<div class="line">        ID3D11RasterizerState* newRasterizerState;</div>
<div class="line">        dxContext-&gt;RSGetState(&amp;newRasterizerState);</div>
<div class="line"></div>
<div class="line">        D3D11_RASTERIZER_DESC newRasterizerDesc;</div>
<div class="line">        newRasterizerDesc.FillMode = D3D11_FILL_SOLID;</div>
<div class="line">        newRasterizerDesc.CullMode = D3D11_CULL_BACK;</div>
<div class="line">        newRasterizerDesc.FrontCounterClockwise = FALSE;</div>
<div class="line">        newRasterizerDesc.DepthBias = D3D11_DEFAULT_DEPTH_BIAS;</div>
<div class="line">        newRasterizerDesc.DepthBiasClamp = D3D11_DEFAULT_DEPTH_BIAS_CLAMP;</div>
<div class="line">        newRasterizerDesc.SlopeScaledDepthBias = D3D11_DEFAULT_SLOPE_SCALED_DEPTH_BIAS;</div>
<div class="line">        newRasterizerDesc.DepthClipEnable = TRUE;</div>
<div class="line">        newRasterizerDesc.ScissorEnable = FALSE;</div>
<div class="line">        newRasterizerDesc.MultisampleEnable = FALSE;</div>
<div class="line">        newRasterizerDesc.AntialiasedLineEnable = FALSE;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (NULL != newRasterizerState)</div>
<div class="line">        {</div>
<div class="line">            newRasterizerState-&gt;GetDesc(&amp;newRasterizerDesc);</div>
<div class="line">            newRasterizerState-&gt;Release();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> createNewRasterizeState = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// SetRasterizerState used in a shader will change the state as a block, and not attribute by attribute.</span></div>
<div class="line"> <span class="comment">// Restore depth attributes to prevent visual issue on the wireframe.</span></div>
<div class="line"> <span class="keywordflow">if</span>( stateBlockMask.RSRasterizerState &amp;&amp;</div>
<div class="line">            ( newRasterizerDesc.DepthBias != orgRasterizerDesc.DepthBias ||</div>
<div class="line">              newRasterizerDesc.SlopeScaledDepthBias != orgRasterizerDesc.SlopeScaledDepthBias ) )</div>
<div class="line">        {</div>
<div class="line">            newRasterizerDesc.DepthBias = orgRasterizerDesc.DepthBias;</div>
<div class="line">            newRasterizerDesc.SlopeScaledDepthBias = orgRasterizerDesc.SlopeScaledDepthBias;</div>
<div class="line">            createNewRasterizeState = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// When a transparent material is managed internaly by Maya,</span></div>
<div class="line"> <span class="comment">// it is rendered twice : once for back and again for front</span></div>
<div class="line"> <span class="comment">// the effect should not override the cull mode</span></div>
<div class="line"> <span class="keywordflow">if</span>( isRenderScene(renderType) &amp;&amp;</div>
<div class="line">            techniqueIsTransparent() &amp;&amp;</div>
<div class="line">            fTechniqueOverridesDrawState == <span class="keyword">false</span> &amp;&amp;</div>
<div class="line">            ( newRasterizerDesc.CullMode != orgRasterizerDesc.CullMode ||</div>
<div class="line">              newRasterizerDesc.FrontCounterClockwise != orgRasterizerDesc.FrontCounterClockwise ) )</div>
<div class="line">        {</div>
<div class="line">            newRasterizerDesc.CullMode = orgRasterizerDesc.CullMode;</div>
<div class="line">            newRasterizerDesc.FrontCounterClockwise = orgRasterizerDesc.FrontCounterClockwise;</div>
<div class="line">            createNewRasterizeState = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Force back culling for swatch and uv texture render</span></div>
<div class="line"> <span class="keywordflow">if</span>( !isRenderScene(renderType) &amp;&amp;</div>
<div class="line">            newRasterizerDesc.FillMode == D3D11_FILL_SOLID &amp;&amp;</div>
<div class="line">            newRasterizerDesc.CullMode == D3D11_CULL_NONE )</div>
<div class="line">        {</div>
<div class="line">            newRasterizerDesc.CullMode = D3D11_CULL_BACK;</div>
<div class="line">            newRasterizerDesc.FrontCounterClockwise = <span class="keyword">true</span>;</div>
<div class="line">            createNewRasterizeState = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( createNewRasterizeState &amp;&amp; SUCCEEDED( dxDevice-&gt;CreateRasterizerState( &amp;newRasterizerDesc, &amp;newRasterizerState ) ) )</div>
<div class="line">        {</div>
<div class="line">            dxContext-&gt;RSSetState( newRasterizerState );</div>
<div class="line">            newRasterizerState-&gt;Release();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(!isRenderScene(renderType))</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Swatches require the DestBlendAlpha value to be ONE otherwise</span></div>
<div class="line"> <span class="comment">// we end up with a completely transparent swatch showing the nice</span></div>
<div class="line"> <span class="comment">// gray underneath the swatch.</span></div>
<div class="line">        ID3D11BlendState* newBlendState;</div>
<div class="line">        FLOAT newBlendFactor[4];</div>
<div class="line">        UINT newSampleMask;</div>
<div class="line">        dxContext-&gt;OMGetBlendState(&amp;newBlendState, newBlendFactor, &amp;newSampleMask);</div>
<div class="line"></div>
<div class="line">        D3D11_BLEND_DESC newBlendDesc;</div>
<div class="line">        newBlendState-&gt;GetDesc(&amp;newBlendDesc);</div>
<div class="line">        newBlendState-&gt;Release();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> createNewBlendState = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check first renderTarget only</span></div>
<div class="line"> <span class="keywordflow">if</span>( newBlendDesc.RenderTarget[0].BlendEnable != FALSE &amp;&amp;</div>
<div class="line">            newBlendDesc.RenderTarget[0].DestBlendAlpha != D3D11_BLEND_ONE )</div>
<div class="line">        {</div>
<div class="line">            newBlendDesc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ONE;</div>
<div class="line">            createNewBlendState = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( createNewBlendState &amp;&amp; SUCCEEDED( dxDevice-&gt;CreateBlendState( &amp;newBlendDesc, &amp;newBlendState ) ) )</div>
<div class="line">        {</div>
<div class="line">            dxContext-&gt;OMSetBlendState(newBlendState, newBlendFactor, newSampleMask);</div>
<div class="line">            newBlendState-&gt;Release();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> dxPass;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::passHasHullShader(dx11ShaderDX11Pass* dxPass)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    PassHasHullShaderMap::const_iterator it = fPassHasHullShaderMap.find(dxPass);</div>
<div class="line"> <span class="keywordflow">if</span>(it != fPassHasHullShaderMap.end())</div>
<div class="line"> <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line"></div>
<div class="line">    D3DX11_PASS_SHADER_DESC hullShaderDesc;</div>
<div class="line">    memset(&amp;hullShaderDesc, 0, <span class="keyword">sizeof</span>(D3DX11_PASS_SHADER_DESC));</div>
<div class="line">    HRESULT hr = dxPass-&gt;GetHullShaderDesc(&amp;hullShaderDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> bContainsHullShader = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">if</span>(SUCCEEDED(hr) &amp;&amp; hullShaderDesc.pShaderVariable &amp;&amp; hullShaderDesc.pShaderVariable-&gt;IsValid())</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// The most recent Effect11 library will return a pointer to an empty shader</span></div>
<div class="line"> <span class="comment">// so we need to make sure there is actual bytecode before we ask for the</span></div>
<div class="line"> <span class="comment">// shader itself.</span></div>
<div class="line">        D3DX11_EFFECT_SHADER_DESC hullEffectDesc;</div>
<div class="line">        memset(&amp;hullEffectDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_SHADER_DESC));</div>
<div class="line">        hr = hullShaderDesc.pShaderVariable-&gt;GetShaderDesc(hullShaderDesc.ShaderIndex,&amp;hullEffectDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (SUCCEEDED(hr) &amp;&amp; hullEffectDesc.BytecodeLength) <span class="comment">// This will not work if Optimize() has been called.</span></div>
<div class="line">        {</div>
<div class="line">            ID3D11HullShader* pHullShader = NULL;</div>
<div class="line">            hullShaderDesc.pShaderVariable-&gt;GetHullShader(hullShaderDesc.ShaderIndex,&amp;pHullShader);</div>
<div class="line"> <span class="keywordflow">if</span>(pHullShader)</div>
<div class="line">            {</div>
<div class="line">                bContainsHullShader = <span class="keyword">true</span>;</div>
<div class="line">                pHullShader-&gt;Release();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fPassHasHullShaderMap[dxPass] = bContainsHullShader;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> bContainsHullShader;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">dx11ShaderDX11InputLayout* dx11ShaderNode::getInputLayout(dx11ShaderDX11Device* dxDevice, dx11ShaderDX11Pass* dxPass, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numLayouts, <span class="keyword">const</span> dx11ShaderDX11InputElementDesc* layoutDesc)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    PassInputLayoutMap::iterator it = fPassInputLayoutMap.find(dxPass);</div>
<div class="line"> <span class="keywordflow">if</span>(it != fPassInputLayoutMap.end())</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Already in cache check if still valid</span></div>
<div class="line">        InputLayoutData&amp; data = it-&gt;second;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( numLayouts == data.numLayouts )</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">bool</span> isEqual = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; isEqual &amp;&amp; i &lt; numLayouts; ++i)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> CachedInputElementDesc &amp;haveDesc = data.layoutDesc[i];</div>
<div class="line"> <span class="keyword">const</span> dx11ShaderDX11InputElementDesc &amp;wantDesc = layoutDesc[i];</div>
<div class="line"></div>
<div class="line">                isEqual = ( haveDesc.SemanticIndex == wantDesc.SemanticIndex &amp;&amp;     <span class="comment">// Check int and enum values first, string last</span></div>
<div class="line">                            haveDesc.Format == wantDesc.Format &amp;&amp;</div>
<div class="line">                            haveDesc.InputSlot == wantDesc.InputSlot &amp;&amp;</div>
<div class="line">                            haveDesc.AlignedByteOffset == wantDesc.AlignedByteOffset &amp;&amp;</div>
<div class="line">                            haveDesc.InputSlotClass == wantDesc.InputSlotClass &amp;&amp;</div>
<div class="line">                            haveDesc.InstanceDataStepRate == wantDesc.InstanceDataStepRate &amp;&amp;</div>
<div class="line">                            strcmp(haveDesc.SemanticName.asChar(), wantDesc.SemanticName) == 0 );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(isEqual)</div>
<div class="line"> <span class="keywordflow">return</span> data.inputLayout;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Was not valid, flush from cache</span></div>
<div class="line">        data.inputLayout-&gt;Release();</div>
<div class="line"> <span class="keyword">delete</span> [] data.layoutDesc;</div>
<div class="line">        fPassInputLayoutMap.erase(it);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    D3DX11_PASS_DESC descPass;</div>
<div class="line">    memset(&amp;descPass, 0, <span class="keyword">sizeof</span>(D3DX11_PASS_DESC));</div>
<div class="line">    dxPass-&gt;GetDesc(&amp;descPass);</div>
<div class="line"></div>
<div class="line">    ID3D11InputLayout* inputLayout = NULL;</div>
<div class="line">    dxDevice-&gt;CreateInputLayout(layoutDesc, numLayouts, descPass.pIAInputSignature, descPass.IAInputSignatureSize, &amp;inputLayout);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache the new layout</span></div>
<div class="line"> <span class="keywordflow">if</span>(inputLayout != NULL)</div>
<div class="line">    {</div>
<div class="line">        InputLayoutData data;</div>
<div class="line">        data.inputLayout = inputLayout;</div>
<div class="line">        data.numLayouts = numLayouts;</div>
<div class="line">        data.layoutDesc = <span class="keyword">new</span> CachedInputElementDesc[numLayouts];</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numLayouts; ++i)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> dx11ShaderDX11InputElementDesc &amp;wantDesc = layoutDesc[i];</div>
<div class="line">            CachedInputElementDesc &amp;cacheDesc = data.layoutDesc[i];</div>
<div class="line"></div>
<div class="line">            cacheDesc.SemanticIndex = wantDesc.SemanticIndex;</div>
<div class="line">            cacheDesc.Format = wantDesc.Format;</div>
<div class="line">            cacheDesc.InputSlot = wantDesc.InputSlot;</div>
<div class="line">            cacheDesc.AlignedByteOffset = wantDesc.AlignedByteOffset;</div>
<div class="line">            cacheDesc.InputSlotClass = wantDesc.InputSlotClass;</div>
<div class="line">            cacheDesc.InstanceDataStepRate = wantDesc.InstanceDataStepRate;</div>
<div class="line">            cacheDesc.SemanticName = <a class="code" href="./class_m_string.html">MString</a>(wantDesc.SemanticName);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fPassInputLayoutMap[dxPass] = data;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> inputLayout;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Rendering</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> dx11ShaderNode::render( <a name="_a216"></a><a class="code" href="./class_m_geometry_list.html">MGeometryList</a>&amp; iterator)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> result = <a name="a217"></a><a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line">    glPushClientAttrib(GL_CLIENT_ALL_ATTRIB_BITS);</div>
<div class="line">    glPushAttrib(GL_CURRENT_BIT);</div>
<div class="line"></div>
<div class="line">    glEnableClientState(GL_VERTEX_ARRAY);</div>
<div class="line">    glEnableClientState(GL_NORMAL_ARRAY);</div>
<div class="line">    glColor4f(0.7f, 0.1f, 0.1f, 1.0f);</div>
<div class="line">    glDisable(GL_LIGHTING);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>( ; iterator.<a name="a218"></a><a class="code" href="./class_m_geometry_list.html#add4bf50abae421d88b5549de6c11fc75">isDone</a>() == <span class="keyword">false</span>; iterator.<a name="a219"></a><a class="code" href="./class_m_geometry_list.html#a041249f802c5bf4c2deae666610e03c4">next</a>())</div>
<div class="line">    {</div>
<div class="line"> <a name="_a220"></a><a class="code" href="./class_m_geometry_legacy.html">MGeometryLegacy</a>&amp; geometry = iterator.<a name="a221"></a><a class="code" href="./class_m_geometry_list.html#a2c08d17ca16945612458abffaa4e9744">geometry</a>( <a name="a222"></a><a class="code" href="./class_m_geometry_list.html#a726ca809ffd3d67ab4b8476646f26635a5864aadd76da2b7e46a339ab8b8963ec">MGeometryList::kMatrices</a> );</div>
<div class="line"></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a name="_a223"></a><a class="code" href="./class_m_geometry_data.html">MGeometryData</a> position = geometry.<a name="a224"></a><a class="code" href="./class_m_geometry_legacy.html#a117087d6021defde4f3202650c48f3ce">position</a>();</div>
<div class="line"></div>
<div class="line">            GLint size = 0;</div>
<div class="line"> <span class="keywordflow">switch</span> (position.<a name="a225"></a><a class="code" href="./class_m_geometry_data.html#ae7f845614494e601791f2bda961d3040">elementSize</a>())</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a226"></a><a class="code" href="./class_m_geometry_data.html#a04d0ee530fb951314449e379d305989aa567435a26feac1c98cd5213345ec6681">MGeometryData::kOne</a>:   size = 1; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a227"></a><a class="code" href="./class_m_geometry_data.html#a04d0ee530fb951314449e379d305989aa4832c274be24ffa9788603aca6170ee0">MGeometryData::kTwo</a>:   size = 2; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a228"></a><a class="code" href="./class_m_geometry_data.html#a04d0ee530fb951314449e379d305989aad6fb0958fd1722e295de251dac67641b">MGeometryData::kThree</a>: size = 3; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a229"></a><a class="code" href="./class_m_geometry_data.html#a04d0ee530fb951314449e379d305989aaa15f48d946f7d4be2415298aa71dda52">MGeometryData::kFour</a>:  size = 4; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:                    <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"> <span class="keyword">const</span> GLvoid* data = position.<a name="a230"></a><a class="code" href="./class_m_geometry_data.html#ac73113f892730ec6fce5da7e3273c9cd">data</a>();</div>
<div class="line"></div>
<div class="line">            glVertexPointer(size, GL_FLOAT, 0, data);</div>
<div class="line">        }</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_geometry_data.html">MGeometryData</a> normal = geometry.<a name="a231"></a><a class="code" href="./class_m_geometry_legacy.html#aa6680785c2ecf1772013b55775fbcc2d">normal</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> GLvoid* data = normal.<a class="code" href="./class_m_geometry_data.html#ac73113f892730ec6fce5da7e3273c9cd">data</a>();</div>
<div class="line"></div>
<div class="line">            glNormalPointer(GL_FLOAT, 0, data);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primitiveIdx = 0; primitiveIdx &lt; geometry.<a name="a232"></a><a class="code" href="./class_m_geometry_legacy.html#a1a7e6f6f8f6d3be99f6f0524ab76ad85">primitiveArrayCount</a>(); ++primitiveIdx)</div>
<div class="line">        {</div>
<div class="line"> <a name="_a233"></a><a class="code" href="./class_m_geometry_primitive.html">MGeometryPrimitive</a> primitive = geometry.<a name="a234"></a><a class="code" href="./class_m_geometry_legacy.html#ad0b84023dd720ca2b0b8b05893dab358">primitiveArray</a>(primitiveIdx);</div>
<div class="line"></div>
<div class="line">            GLenum mode = GL_TRIANGLES;</div>
<div class="line"> <span class="keywordflow">switch</span> (primitive.<a name="a235"></a><a class="code" href="./class_m_geometry_primitive.html#a81289ee7c426a9a90718b1e6538d0b1e">drawPrimitiveType</a>())</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a236"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20a57a311fc6dd7498f2339ab45af414377">MGeometryPrimitive::kPoints</a>:           mode = GL_POINTS;           <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a237"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20a9808e481c6346dfc333afb4c52890ac9">MGeometryPrimitive::kLines</a>:            mode = GL_LINES;            <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a238"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20a505d8b3b6fdcadeb908f49f661e66957">MGeometryPrimitive::kLineStrip</a>:        mode = GL_LINE_STRIP;       <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a239"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20a77bbbae9232e672917b31ff19338862a">MGeometryPrimitive::kLineLoop</a>:         mode = GL_LINE_LOOP;        <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a240"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20aa2c70dd76c8172a9298334473c914304">MGeometryPrimitive::kTriangles</a>:        mode = GL_TRIANGLES;        <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a241"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20a6f6fdd3e537134843d971d56257d1bfc">MGeometryPrimitive::kTriangleStrip</a>:    mode = GL_TRIANGLE_STRIP;   <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a242"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20a532cdfa40aeed0b199f5e364e871cf89">MGeometryPrimitive::kTriangleFan</a>:      mode = GL_TRIANGLE_FAN;     <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a243"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20a43eddf4744999050792731235f2a11c8">MGeometryPrimitive::kQuads</a>:            mode = GL_QUADS;            <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a244"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20aa0706e5cde92ef24fdc1b15bc193e374">MGeometryPrimitive::kQuadStrip</a>:        mode = GL_QUAD_STRIP;       <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a245"></a><a class="code" href="./class_m_geometry_primitive.html#ae182ab6bcd18c718e2eec923ff9dde20acc108ad225e1e4fbcdd2d42397895608">MGeometryPrimitive::kPolygon</a>:          mode = GL_POLYGON;          <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:                                    <span class="keywordflow">continue</span>;</div>
<div class="line">            };</div>
<div class="line">            GLenum format = GL_UNSIGNED_INT;</div>
<div class="line"> <span class="keywordflow">switch</span> (primitive.<a name="a246"></a><a class="code" href="./class_m_geometry_primitive.html#abe112368fa2f44533515ab803a11ab34">dataType</a>())</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a247"></a><a class="code" href="./class_m_geometry_data.html#a16b11be27a8e9362dd122c4d879e01aea589716b974587a5b575bf02d0b74245a">MGeometryData::kChar</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a248"></a><a class="code" href="./class_m_geometry_data.html#a16b11be27a8e9362dd122c4d879e01aea771a88748799bba09da625ffee5c6945">MGeometryData::kUnsignedChar</a>:          format = GL_UNSIGNED_BYTE;  <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a249"></a><a class="code" href="./class_m_geometry_data.html#a16b11be27a8e9362dd122c4d879e01aeacc48eb3dce9079e1af81af4db6506343">MGeometryData::kInt16</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a250"></a><a class="code" href="./class_m_geometry_data.html#a16b11be27a8e9362dd122c4d879e01aea3d97c6fcb525dc79fed35f39fd7bab76">MGeometryData::kUnsignedInt16</a>:         format = GL_UNSIGNED_SHORT; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a251"></a><a class="code" href="./class_m_geometry_data.html#a16b11be27a8e9362dd122c4d879e01aeae3e576e62ae36818ff6edced2065c36e">MGeometryData::kInt32</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a252"></a><a class="code" href="./class_m_geometry_data.html#a16b11be27a8e9362dd122c4d879e01aeaa93f90f58b3077bdbedeb9506e0143fd">MGeometryData::kUnsignedInt32</a>:         format = GL_UNSIGNED_INT;   <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:                                    <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line">            GLsizei count = primitive.<a name="a253"></a><a class="code" href="./class_m_geometry_primitive.html#ac9580a2ec3ad9690d0fb0ea0b3179fec">elementCount</a>();</div>
<div class="line"> <span class="keyword">const</span> GLvoid* indices = primitive.<a name="a254"></a><a class="code" href="./class_m_geometry_primitive.html#ad3b74abc0bab69f337c70783e73f5bef">data</a>();</div>
<div class="line">            glDrawElements(mode, count, format, indices);</div>
<div class="line">            result = <a name="a255"></a><a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>; <span class="comment">// something drew</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    glPopAttrib();</div>
<div class="line">    glPopClientAttrib();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Renders a representation of the active effect/technique to display in the attribute editor.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The geometry (a sphere) is rendered in DX in a texture target, using the same pipeline as the viewport render</span></div>
<div class="line"><span class="comment">    the texture target is then blit to the output image.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    If there is no valid effect/technique, a simple shader is compiled and used to offer a dummy representation of the shader.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The geometry buffers are retrieved from MGeometryUtilities,</span></div>
<div class="line"><span class="comment">    and currently need to be manually altered if the active technique needs any custom indexing.</span></div>
<div class="line"><span class="comment">    This is the case for the crack free tessellation (PNAEN9 and PNAEN18 index buffer types).</span></div>
<div class="line"><span class="comment">    This is done in renderPass().</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> dx11ShaderNode::renderSwatchImage( <a name="_a256"></a><a class="code" href="./class_m_image.html">MImage</a> &amp; image )</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Get device</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MHWRender::MRenderer</a>* theRenderer = <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MHWRender::MRenderer::theRenderer</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!theRenderer || theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#aac2a5827e6a0ce3333e62ffa7751ba5e">drawAPIIsOpenGL</a>()) <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a name="_a257"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target_manager.html">MHWRender::MRenderTargetManager</a>* targetManager = theRenderer-&gt;<a name="a258"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a2228b9005f574393fbe87a4477161dc3">getRenderTargetManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!targetManager) <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line">    ID3D11Device* dxDevice = (ID3D11Device*)theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a637ec8cc3cc0e631f1d134f6891f89f0">GPUDeviceHandle</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!dxDevice) <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width, height;</div>
<div class="line">    image.<a name="a259"></a><a class="code" href="./class_m_image.html#acab1f6acf34fc74e4d717322fa35241a">getSize</a>(width, height);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_target_description.html">MHWRender::MRenderTargetDescription</a> textureDesc( <a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">"dx11Shader_swatch_texture_target"</span>), width, height, 0, <a class="code" href="./namespace_m_h_w_render.html#ab8dcc38685c6e5601a32fb70764742dca0e33962255b311165cb5d31c43ff576e">MHWRender::kR8G8B8A8_UNORM</a>, 1, <span class="keyword">false</span>);</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_target.html">MHWRender::MRenderTarget</a>* textureTarget = targetManager-&gt;<a name="a260"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target_manager.html#a34596dab85af525cd42532e7e5e5c39e">acquireRenderTarget</a>(textureDesc);</div>
<div class="line"> <span class="keywordflow">if</span> (!textureTarget) <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a> *context = <a name="a261"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a740208508edba7934a27816decbb9570">MHWRender::MRenderUtilities::acquireSwatchDrawContext</a>(textureTarget);</div>
<div class="line"> <span class="keywordflow">if</span> (!context) {</div>
<div class="line">        targetManager-&gt;<a name="a262"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target_manager.html#a3ac81120f77bddaf281b6f1ba21c83d1">releaseRenderTarget</a>(textureTarget);</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// If no valid effect/technique/pass, create a temporary effect to use</span></div>
<div class="line">    ID3DX11Effect *dxEffect = NULL;</div>
<div class="line">    ID3DX11EffectTechnique *dxTechnique = fTechnique;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Use local parameters lists to switch between loaded effect and temporary effect</span></div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter_list.html">MUniformParameterList</a>* uniformParameters = &amp;fUniformParameters;</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>* varyingParameters = &amp;fVaryingParameters;</div>
<div class="line">    ResourceTextureMap* resourceTexture = &amp;fResourceTextureMap;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> indexBufferType = fTechniqueIndexBufferType;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPasses = fTechniquePassCount;</div>
<div class="line">    ERenderType renderType = RENDER_SWATCH;</div>
<div class="line"> <span class="keywordflow">if</span>(numPasses == 0 || dxTechnique == NULL || dxTechnique-&gt;IsValid() == <span class="keyword">false</span> || (fUniformParameters.length() == 0 &amp;&amp; fVaryingParameters.length() == 0))</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* simpleShaderCode =   <span class="stringliteral">"// transform object vertices to view space and project them in perspective: \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"float4x4 gWvpXf : WorldViewProjection; \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"struct appdata \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float3 Pos : POSITION; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float4 Color : COLOR0; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"}; \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"struct vertexOutput \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float4 Pos : POSITION; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float4 Color : COLOR0; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"}; \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"vertexOutput BasicVS(appdata IN, uniform float4x4 WvpXf) \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   vertexOutput OUT; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float4 Po = float4(IN.Pos,1); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   OUT.Pos = mul(Po,WvpXf); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   OUT.Color = IN.Color; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   return OUT; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"} \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"float4 BasicPS(vertexOutput IN) : COLOR \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   return IN.Color; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"} \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"technique10 simple \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   pass p0 \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   { \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"       SetVertexShader( CompileShader( vs_4_0, BasicVS(gWvpXf) ) ); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"       SetGeometryShader( NULL ); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"       SetPixelShader( CompileShader( ps_4_0, BasicPS() ) ); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   } \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"} \r\n"</span>;</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> simpleShaderLength = (<span class="keywordtype">unsigned</span> int)strlen(simpleShaderCode);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create a new effect, as well as new varyingParameters and uniformParameters lists</span></div>
<div class="line">        buildTemporaryEffect(<span class="keyword">this</span>,</div>
<div class="line">                    dxDevice, simpleShaderCode, simpleShaderLength,</div>
<div class="line">                    dxEffect, dxTechnique, numPasses,</div>
<div class="line">                    varyingParameters, uniformParameters, indexBufferType);</div>
<div class="line"></div>
<div class="line">        renderType = RENDER_SWATCH_PROXY;</div>
<div class="line">        resourceTexture = <span class="keyword">new</span> ResourceTextureMap;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> result = <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"> <span class="keywordflow">if</span>(numPasses &gt; 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Get geometry</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>* geometry = acquireReferenceGeometry( <a name="a263"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#a5f45789e2294fc128af5b04595d96505acb4a5f68a3b6cd8c05b1dc9c5a487c88">MHWRender::MGeometryUtilities::kDefaultSphere</a>, *varyingParameters );</div>
<div class="line"> <span class="keywordflow">if</span>(geometry != NULL)</div>
<div class="line">        {</div>
<div class="line">            updateParameters(*context, *uniformParameters, *resourceTexture, renderType);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">float</span> clearColor[4]; <span class="comment">// = { 1.0f, 0.0f, 0.0f, 1.0f };</span></div>
<div class="line"> <a name="a264"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#acca1b80fae8742954c0939bce723c913">MHWRender::MRenderUtilities::swatchBackgroundColor</a>( clearColor[0], clearColor[1], clearColor[2], clearColor[3] );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// render geometry to texture target</span></div>
<div class="line"> <span class="keywordflow">if</span>( renderTechnique(dxDevice, dxTechnique, numPasses,</div>
<div class="line">                                textureTarget, width, height, clearColor,</div>
<div class="line">                                geometry, <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1eaa2c70dd76c8172a9298334473c914304">MHWRender::MGeometry::kTriangles</a>, 3,</div>
<div class="line">                                *varyingParameters, renderType, indexBufferType) )</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// At this point we have the drawing in the target texture</span></div>
<div class="line"> <span class="comment">// blit texture target to swatch image</span></div>
<div class="line">                result = <a name="a265"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a7659377d100bff1d4b48427c270f1ebc">MHWRender::MRenderUtilities::blitTargetToImage</a>(textureTarget, image);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <a name="a266"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#ab050d473690fac85ffa49ebea3aef7ff">MHWRender::MGeometryUtilities::releaseReferenceGeometry</a>( geometry );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Temporary effect</span></div>
<div class="line"> <span class="keywordflow">if</span>(dxEffect)</div>
<div class="line">    {</div>
<div class="line">        CDX11EffectCompileHelper::releaseEffect(<span class="keyword">this</span>, dxEffect, <span class="stringliteral">"TemporaryEffect"</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The parameters lists were created for the temporary effect</span></div>
<div class="line"> <span class="keyword">delete</span> uniformParameters;</div>
<div class="line"> <span class="keyword">delete</span> varyingParameters;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// As was the resource texture</span></div>
<div class="line">        releaseAllTextures(*resourceTexture);</div>
<div class="line"> <span class="keyword">delete</span> resourceTexture;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a name="a267"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a5222892109760efc845e37469b0f6cb4">MHWRender::MRenderUtilities::releaseDrawContext</a>( context );</div>
<div class="line"></div>
<div class="line">    targetManager-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_target_manager.html#a3ac81120f77bddaf281b6f1ba21c83d1">releaseRenderTarget</a>(textureTarget);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Override this method to support texture display in the UV texture editor.</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> dx11ShaderNode::getAvailableImages( <span class="keyword">const</span> <a name="_a268"></a><a class="code" href="./struct_m_px_hardware_shader_1_1_shader_context.html">MPxHardwareShader::ShaderContext</a> &amp;context,<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> &amp;uvSetName,<a class="code" href="./class_m_string_array.html">MStringArray</a> &amp;imageNames )</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Locate the varying parameters whose source is 'uvSetName'</span></div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> uvParams;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a>      uvLocalName = uvSetName==<span class="stringliteral">""</span> ? <span class="stringliteral">"map1"</span> : uvSetName;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nVarying = fVaryingParameters.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>();</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nVarying; i++ ) {</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html">MVaryingParameter</a> elem = fVaryingParameters.<a class="code" href="./class_m_varying_parameter.html#a40cde1a792fb9a978d3a3a68414fb865">getElement</a>(i);</div>
<div class="line"> <span class="keywordflow">if</span>( elem.<a class="code" href="./class_m_varying_parameter.html#ad72ff2b3fb20052e4a2455dad5c10682">getSourceType</a>() == <a class="code" href="./class_m_varying_parameter.html#afb0ef1fa13fbda77e55c3b59adcae321a45b7096916b12a78e94c62bba9d50739">MVaryingParameter::kTexCoord</a> &amp;&amp; elem.<a class="code" href="./class_m_varying_parameter.html#a45e2132632639698f9c4f668be933a70">getSourceSetName</a>() == uvLocalName ) {</div>
<div class="line">            uvParams.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( elem.<a class="code" href="./class_m_varying_parameter.html#a2e8d4c38a60806df8c2ffd6d09e70b96">name</a>() );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Determine the default texture.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> defaultTex;</div>
<div class="line"> <span class="keywordflow">if</span>( uvParams.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0 ) {</div>
<div class="line"> <span class="comment">// Only process the first entry of this UV set (if multiple exist).</span></div>
<div class="line"> <span class="comment">// There can only be one default, so we'll only consider the default</span></div>
<div class="line"> <span class="comment">// of the first varying input of this UV set.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> depFn( thisMObject() );</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> attrName( uvParams[0] );</div>
<div class="line">        attrName += <span class="stringliteral">"_DefaultTexture"</span>;</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> defaultTexPlug = depFn.findPlug( attrName );</div>
<div class="line"> <span class="keywordflow">if</span>( !defaultTexPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() ) {</div>
<div class="line">            defaultTexPlug.<a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>( defaultTex );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Locate any texture UVLinks that point to these uvParams and record</span></div>
<div class="line"> <span class="comment">// those textures.</span></div>
<div class="line"> <span class="comment">// If no UVLinks found, display all 2D textures.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    std::multimap&lt;int, MString&gt; sortedTextures;</div>
<div class="line">    std::vector&lt;MString&gt; unsortedTextures;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nUniform = fUniformParameters.length();</div>
<div class="line"> <span class="keywordflow">if</span>( imageNames.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0 ) {</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nUniform; i++ ) {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> elem = fUniformParameters.<a class="code" href="./class_m_varying_parameter.html#a40cde1a792fb9a978d3a3a68414fb865">getElement</a>(i);</div>
<div class="line"> <span class="keywordflow">if</span>( elem.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6a7d3972f1f1ee99452d3c715b157b5cad">MUniformParameter::kType2DTexture</a> ) {</div>
<div class="line"> <span class="comment">// Skip items which are not UI visible:</span></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> uniformPlug(elem.<a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>());</div>
<div class="line"> <span class="keywordflow">if</span> (uniformPlug.isNull())</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> uniformAttribute(uniformPlug.attribute());</div>
<div class="line"> <span class="keywordflow">if</span> (uniformAttribute.isHidden())</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">                ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)elem.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">                {</div>
<div class="line"> <span class="keywordtype">int</span> uvEditorOrder;</div>
<div class="line"> <span class="keywordflow">if</span> (getAnnotation(effectVariable, <span class="stringliteral">"UVEditorOrder"</span>, uvEditorOrder))</div>
<div class="line">                    {</div>
<div class="line">                        sortedTextures.insert(std::pair&lt;int, MString&gt;(uvEditorOrder, elem.<a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>()));</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                unsortedTextures.push_back(elem.<a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// First copy items that are ordered:</span></div>
<div class="line"> <span class="keywordflow">for</span> (std::multimap&lt;int, MString&gt;::iterator itSorted = sortedTextures.begin();</div>
<div class="line">         itSorted != sortedTextures.end();</div>
<div class="line">         ++itSorted)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> &amp;elemName(itSorted-&gt;second);</div>
<div class="line"> <span class="keywordflow">if</span>( elemName == defaultTex ) {</div>
<div class="line">            imageNames.<a name="a269"></a><a class="code" href="./class_m_string_array.html#a3db31367f989449bb9b121cd734dc0df">insert</a>( elemName, 0 );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            imageNames.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( elemName );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Then append unordered items:</span></div>
<div class="line"> <span class="keywordflow">for</span> (std::vector&lt;MString&gt;::iterator itOther = unsortedTextures.begin();</div>
<div class="line">         itOther != unsortedTextures.end();</div>
<div class="line">         ++itOther)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> &amp;elemName(*itOther);</div>
<div class="line"> <span class="keywordflow">if</span>( elemName == defaultTex ) {</div>
<div class="line">            imageNames.<a class="code" href="./class_m_string_array.html#a3db31367f989449bb9b121cd734dc0df">insert</a>( elemName, 0 );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            imageNames.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>( elemName );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> (imageNames.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0) ? <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a> : <a name="a270"></a><a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a598e4c5d4c234c1bf09367d64487519c">MStatus::kNotImplemented</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Renders the specified texture (imageName) to the UV editor.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The texture is rendered in DX using a simple effect.</span></div>
<div class="line"><span class="comment">    When creating the effect a temporary uniform and varying parameters lists are created accordingly,</span></div>
<div class="line"><span class="comment">    so we can use the same pipeline as when rendering the material in viewport 2.0</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The UV editor uses an OpenGL viewport, therefore we first render the texture</span></div>
<div class="line"><span class="comment">    to a DX texture target and then blit the result to GL.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    To increase the performance of the UV editor, instead of rendering and blitting to GL on each call,</span></div>
<div class="line"><span class="comment">    the result GL texture is cached and reused as long as possible.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> dx11ShaderNode::renderImage( <span class="keyword">const</span> <a class="code" href="./struct_m_px_hardware_shader_1_1_shader_context.html">MPxHardwareShader::ShaderContext</a>&amp; shaderContext, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; imageName, floatRegion region, <span class="keyword">const</span> <a name="_a271"></a><a class="code" href="./struct_m_px_hardware_shader_1_1_render_parameters.html">MPxHardwareShader::RenderParameters</a>&amp; parameters, <span class="keywordtype">int</span>&amp; imageWidth, <span class="keywordtype">int</span>&amp; imageHeight )</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Get device</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MHWRender::MRenderer</a>* theRenderer = <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MHWRender::MRenderer::theRenderer</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!theRenderer || theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#aac2a5827e6a0ce3333e62ffa7751ba5e">drawAPIIsOpenGL</a>())</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line">    ID3D11Device* dxDevice = (ID3D11Device*)theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a637ec8cc3cc0e631f1d134f6891f89f0">GPUDeviceHandle</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!dxDevice) <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a> *context = <a name="a272"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#ab9589288e0f14cffca1b6da7d262631d">MHWRender::MRenderUtilities::acquireUVTextureDrawContext</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!context) <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> textureName, layerName;</div>
<div class="line"> <span class="keywordtype">int</span> alphaChannelIdx, mipmapLevels;</div>
<div class="line"> <a name="_a273"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a>* texture = getUVTexture(context, imageName, imageWidth, imageHeight, textureName, layerName, alphaChannelIdx, mipmapLevels);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(texture == NULL)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a5222892109760efc845e37469b0f6cb4">MHWRender::MRenderUtilities::releaseDrawContext</a>( context );</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a598e4c5d4c234c1bf09367d64487519c">MStatus::kNotImplemented</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Early return, this is just a call to get the size of the texture ("Use image ratio" is on)</span></div>
<div class="line"> <span class="keywordflow">if</span>(region[0][0] == 0 &amp;&amp; region[0][1] == 0 &amp;&amp; region[1][0] == 0 &amp;&amp; region[1][1] == 0)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a5222892109760efc845e37469b0f6cb4">MHWRender::MRenderUtilities::releaseDrawContext</a>( context );</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Retrieve data from render parameters</span></div>
<div class="line"> <span class="keywordtype">float</span> baseColor[4] = {parameters.<a name="a274"></a>baseColor.<a name="a275"></a><a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, parameters.baseColor.<a name="a276"></a><a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, parameters.baseColor.<a name="a277"></a><a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>, parameters.baseColor.<a name="a278"></a><a class="code" href="./class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e">a</a> };</div>
<div class="line"> <span class="keywordtype">bool</span> unfiltered = parameters.<a name="a279"></a>unfiltered;</div>
<div class="line"> <span class="keywordtype">bool</span> showAlphaMask = parameters.<a name="a280"></a>showAlphaMask;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_GL_TEXTURE_CACHING</span></div>
<div class="line"> <span class="comment">// Try with cached GL texture</span></div>
<div class="line"> <span class="keywordflow">if</span>(fUVEditorGLTextureId &gt; 0 &amp;&amp;</div>
<div class="line">        fUVEditorLastTexture == textureName &amp;&amp;</div>
<div class="line">        fUVEditorLastLayer == layerName &amp;&amp;</div>
<div class="line">    fUVEditorLastAlphaChannel == alphaChannelIdx &amp;&amp;</div>
<div class="line">        fUVEditorShowAlphaMask == showAlphaMask &amp;&amp;</div>
<div class="line">        fUVEditorBaseColor[0] == baseColor[0] &amp;&amp;</div>
<div class="line">        fUVEditorBaseColor[1] == baseColor[1] &amp;&amp;</div>
<div class="line">        fUVEditorBaseColor[2] == baseColor[2] &amp;&amp;</div>
<div class="line">        fUVEditorBaseColor[3] == baseColor[3] )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a5222892109760efc845e37469b0f6cb4">MHWRender::MRenderUtilities::releaseDrawContext</a>( context );</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> result = <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"> <span class="keywordflow">if</span>( renderGLTexture(fUVEditorGLTextureId, fUVEditorGLTextureScaleU, fUVEditorGLTextureScaleV, region, unfiltered) )</div>
<div class="line">            result = <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// Cached GL texture out of date, release it</span></div>
<div class="line"> <span class="keywordflow">if</span>(fUVEditorGLTextureId &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        releaseGLTexture(fUVEditorGLTextureId);</div>
<div class="line">        fUVEditorGLTextureId = 0;</div>
<div class="line">    }</div>
<div class="line">    fUVEditorLastTexture = textureName;</div>
<div class="line">    fUVEditorLastLayer = layerName;</div>
<div class="line">  fUVEditorLastAlphaChannel = alphaChannelIdx;</div>
<div class="line">    fUVEditorShowAlphaMask = showAlphaMask;</div>
<div class="line">    fUVEditorBaseColor[0] = baseColor[0];</div>
<div class="line">    fUVEditorBaseColor[1] = baseColor[1];</div>
<div class="line">    fUVEditorBaseColor[2] = baseColor[2];</div>
<div class="line">    fUVEditorBaseColor[3] = baseColor[3];</div>
<div class="line">    fUVEditorGLTextureScaleU = fUVEditorGLTextureScaleV = 1.0f;</div>
<div class="line"><span class="preprocessor">#endif //USE_GL_TEXTURE_CACHING</span></div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_target_manager.html">MHWRender::MRenderTargetManager</a>* targetManager = theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a2228b9005f574393fbe87a4477161dc3">getRenderTargetManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!targetManager) <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If no valid effect/technique/pass, create a temporary effect to use</span></div>
<div class="line">    ID3DX11Effect *dxEffect = NULL;</div>
<div class="line">    ID3DX11EffectTechnique *dxTechnique = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Use local parameters lists to switch between loaded effect and temporary effect</span></div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter_list.html">MUniformParameterList</a>* uniformParameters = NULL;</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>* varyingParameters = NULL;</div>
<div class="line">    ResourceTextureMap* resourceTexture = NULL;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> indexBufferType;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create effect</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPasses = 0;</div>
<div class="line">    ERenderType renderType = RENDER_UVTEXTURE;</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* simpleShaderCode =   <span class="stringliteral">"float4x4 gWvpXf : WorldViewProjection; \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"SamplerState SamplerLinear \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   Filter = MIN_MAG_MIP_LINEAR; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   AddressU = Wrap; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   AddressV = Wrap; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"}; \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"Texture2D myTexture; \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"float4 baseColor = { 1.0f, 1.0f, 1.0f, 1.0f }; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"bool showAlphaMask = false; \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"struct appdata \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float3 Pos : POSITION; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float2 Uv : TEXTCOORD; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"}; \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"struct vertexOutput \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float4 Pos : POSITION; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float2 Uv : TEXTCOORD; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"}; \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"vertexOutput BasicVS(appdata IN, uniform float4x4 WvpXf) \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   vertexOutput OUT; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float4 Po = float4(IN.Pos,1); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   OUT.Pos = mul(Po,WvpXf); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   OUT.Uv = IN.Uv; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   return OUT; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"} \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"float4 BasicPS(vertexOutput IN) : COLOR \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   float4 color = myTexture.Sample(SamplerLinear, IN.Uv); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   color *= baseColor; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   if(showAlphaMask) \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"       color = float4(color.www, 1.0f); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   return color; \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"} \r\n"</span> \</div>
<div class="line"></div>
<div class="line"> <span class="stringliteral">"technique10 simple \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"{ \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   pass p0 \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   { \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"       SetVertexShader( CompileShader( vs_4_0, BasicVS(gWvpXf) ) ); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"       SetGeometryShader( NULL ); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"       SetPixelShader( CompileShader( ps_4_0, BasicPS() ) ); \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"   } \r\n"</span> \</div>
<div class="line"> <span class="stringliteral">"} \r\n"</span>;</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> simpleShaderLength = (<span class="keywordtype">unsigned</span> int)strlen(simpleShaderCode);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create a new effect, as well as new varyingParameters and uniformParameters lists</span></div>
<div class="line">        buildTemporaryEffect(<span class="keyword">this</span>,</div>
<div class="line">                    dxDevice, simpleShaderCode, simpleShaderLength,</div>
<div class="line">                    dxEffect, dxTechnique, numPasses,</div>
<div class="line">                    varyingParameters, uniformParameters, indexBufferType);</div>
<div class="line"></div>
<div class="line">        resourceTexture = <span class="keyword">new</span> ResourceTextureMap;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We use a custom effect here</span></div>
<div class="line"> <span class="comment">// set a fixed mipmap levels so we load the right texture :</span></div>
<div class="line"> <span class="comment">// - consistency : same quality between the UV editor and the scene</span></div>
<div class="line"> <span class="comment">// - performance : will use the cached texture instead of loading a different version</span></div>
<div class="line">        fFixedTextureMipMapLevels = mipmapLevels;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Push texture and parameters to uniform parameters</span></div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">int</span> u = 0; u &lt; uniformParameters-&gt;<a class="code" href="./class_m_uniform_parameter_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>(); ++u )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = uniformParameters-&gt;<a class="code" href="./class_m_uniform_parameter_list.html#a6a79ec55a70b556044955e86cb48d609">getElement</a>(u);</div>
<div class="line"> <span class="keywordflow">if</span>( uniform.<a class="code" href="./class_m_uniform_parameter.html#a37357b066d4c628b1fae2f1ee08b2b12">isATexture</a>() )</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>( uniform.<a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>() == <a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">"myTexture"</span>) ) {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> fullName = textureName;</div>
<div class="line"> <span class="keywordflow">if</span>(alphaChannelIdx != -1 || layerName.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0) {</div>
<div class="line">                    fullName += <a class="code" href="./class_m_string.html">MString</a>(&amp;layerNameSeparator, 1) + layerName;</div>
<div class="line">                    fullName += <a class="code" href="./class_m_string.html">MString</a>(&amp;layerNameSeparator, 1) + alphaChannelIdx;</div>
<div class="line">                }</div>
<div class="line">                uniform.<a name="a281"></a><a class="code" href="./class_m_uniform_parameter.html#a702414289a74bf62b6ef182c64378292">setAsString</a>(fullName);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( uniform.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a> &amp;&amp; uniform.<a name="a282"></a><a class="code" href="./class_m_uniform_parameter.html#a72edb7c3619d3c48c0fc5021f18d347e">numColumns</a>() == 4 &amp;&amp; uniform.<a name="a283"></a><a class="code" href="./class_m_uniform_parameter.html#a377c747149ace700fb29f0d2052dde30">numRows</a>() == 1 )</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>( uniform.<a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>() == <a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">"baseColor"</span>) )</div>
<div class="line">                uniform.<a name="a284"></a><a class="code" href="./class_m_uniform_parameter.html#a71c021490db45149a9bb635bfe04cddd">setAsFloatArray</a>(baseColor, 4);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( uniform.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a name="a285"></a><a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6a52b0938c028df56b62bc9e9080475e7f">MUniformParameter::kTypeBool</a> &amp;&amp; uniform.<a class="code" href="./class_m_uniform_parameter.html#a72edb7c3619d3c48c0fc5021f18d347e">numColumns</a>() == 1 &amp;&amp; uniform.<a class="code" href="./class_m_uniform_parameter.html#a377c747149ace700fb29f0d2052dde30">numRows</a>() == 1 )</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>( uniform.<a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>() == <a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">"showAlphaMask"</span>) )</div>
<div class="line">                uniform.<a name="a286"></a><a class="code" href="./class_m_uniform_parameter.html#adce6ab6521852e06df1e9ac4a5cda02d">setAsBool</a>(showAlphaMask);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> result = <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"> <span class="keywordflow">if</span>(numPasses &gt; 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Get geometry</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>* geometry = acquireReferenceGeometry( <a name="a287"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#a5f45789e2294fc128af5b04595d96505a184eac47c82e5c13dd2dd52420cbf89f">MHWRender::MGeometryUtilities::kDefaultPlane</a>, *varyingParameters );</div>
<div class="line"> <span class="keywordflow">if</span>(geometry != NULL)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Create texture target</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_target_description.html">MHWRender::MRenderTargetDescription</a> textureDesc( <a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">"dx11Shader_uv_texture_target"</span>), imageWidth, imageHeight, 0, <a class="code" href="./namespace_m_h_w_render.html#ab8dcc38685c6e5601a32fb70764742dca0e33962255b311165cb5d31c43ff576e">MHWRender::kR8G8B8A8_UNORM</a>, 1, <span class="keyword">false</span>);</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_target.html">MHWRender::MRenderTarget</a>* textureTarget = targetManager-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_target_manager.html#a34596dab85af525cd42532e7e5e5c39e">acquireRenderTarget</a>(textureDesc);</div>
<div class="line"> <span class="keywordflow">if</span>(textureTarget != NULL)</div>
<div class="line">            {</div>
<div class="line">                updateParameters(*context, *uniformParameters, *resourceTexture, renderType);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">float</span> clearColor[4] = { 0.0f, 0.0f, 0.0f, 0.0f };</div>
<div class="line"></div>
<div class="line"> <span class="comment">// render geometry to texture target</span></div>
<div class="line"> <span class="keywordflow">if</span>( renderTechnique(dxDevice, dxTechnique, numPasses,</div>
<div class="line">                                    textureTarget, imageWidth, imageHeight, clearColor,</div>
<div class="line">                                    geometry, <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1eaa2c70dd76c8172a9298334473c914304">MHWRender::MGeometry::kTriangles</a>, 3,</div>
<div class="line">                                    *varyingParameters, renderType, indexBufferType) )</div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// At this point we have the drawing in the target texture</span></div>
<div class="line"> <span class="comment">// blit texture to GL</span></div>
<div class="line"><span class="preprocessor">#ifdef USE_GL_TEXTURE_CACHING</span></div>
<div class="line">                    fUVEditorGLTextureId = createGLTextureFromTarget(textureTarget, fUVEditorGLTextureScaleU, fUVEditorGLTextureScaleV);</div>
<div class="line"> <span class="keywordflow">if</span>(fUVEditorGLTextureId &gt; 0 &amp;&amp; renderGLTexture(fUVEditorGLTextureId, fUVEditorGLTextureScaleU, fUVEditorGLTextureScaleV, region, unfiltered) )</div>
<div class="line">                        result = <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">                    result = <a name="a288"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a737dde8474ab2cbc3ea2596026e4ef4b">MHWRender::MRenderUtilities::blitTargetToGL</a>(textureTarget, region, unfiltered);</div>
<div class="line"><span class="preprocessor">#endif //USE_GL_TEXTURE_CACHING</span></div>
<div class="line"></div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                targetManager-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_target_manager.html#a3ac81120f77bddaf281b6f1ba21c83d1">releaseRenderTarget</a>(textureTarget);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#ab050d473690fac85ffa49ebea3aef7ff">MHWRender::MGeometryUtilities::releaseReferenceGeometry</a>( geometry );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Temporary effect</span></div>
<div class="line"> <span class="keywordflow">if</span>(dxEffect)</div>
<div class="line">    {</div>
<div class="line">        CDX11EffectCompileHelper::releaseEffect(<span class="keyword">this</span>, dxEffect, <span class="stringliteral">"TemporaryEffect"</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The parameters lists were created for the temporary effect</span></div>
<div class="line"> <span class="keyword">delete</span> uniformParameters;</div>
<div class="line"> <span class="keyword">delete</span> varyingParameters;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// As was the resource texture</span></div>
<div class="line">        releaseAllTextures(*resourceTexture);</div>
<div class="line"> <span class="keyword">delete</span> resourceTexture;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Reset the fixed levels</span></div>
<div class="line">    fFixedTextureMipMapLevels = -1;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a5222892109760efc845e37469b0f6cb4">MHWRender::MRenderUtilities::releaseDrawContext</a>( context );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Renders the specified texture (imageName) to the UV editor in viewport 2.0.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> dx11ShaderNode::renderImage( <span class="keyword">const</span> <a class="code" href="./struct_m_px_hardware_shader_1_1_shader_context.html">MPxHardwareShader::ShaderContext</a>&amp; shaderContext, <a name="_a289"></a><a class="code" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html">MHWRender::MUIDrawManager</a>&amp; uiDrawManager, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; imageName, floatRegion region, <span class="keyword">const</span> <a class="code" href="./struct_m_px_hardware_shader_1_1_render_parameters.html">MPxHardwareShader::RenderParameters</a>&amp; parameters, <span class="keywordtype">int</span>&amp; imageWidth, <span class="keywordtype">int</span>&amp; imageHeight )</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Get device</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MHWRender::MRenderer</a>* theRenderer = <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MHWRender::MRenderer::theRenderer</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!theRenderer || theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#aac2a5827e6a0ce3333e62ffa7751ba5e">drawAPIIsOpenGL</a>())</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line">    ID3D11Device* dxDevice = (ID3D11Device*)theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a637ec8cc3cc0e631f1d134f6891f89f0">GPUDeviceHandle</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!dxDevice) <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a> *context = <a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#ab9589288e0f14cffca1b6da7d262631d">MHWRender::MRenderUtilities::acquireUVTextureDrawContext</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!context) <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00">MStatus::kFailure</a>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a>* texture = getUVTexture(context, imageName, imageWidth, imageHeight);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(texture == NULL)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a5222892109760efc845e37469b0f6cb4">MHWRender::MRenderUtilities::releaseDrawContext</a>( context );</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a598e4c5d4c234c1bf09367d64487519c">MStatus::kNotImplemented</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Early return, this is just a call to get the size of the texture ("Use image ratio" is on)</span></div>
<div class="line"> <span class="keywordflow">if</span>(region[0][0] == 0 &amp;&amp; region[0][1] == 0 &amp;&amp; region[1][0] == 0 &amp;&amp; region[1][1] == 0)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_utilities.html#a5222892109760efc845e37469b0f6cb4">MHWRender::MRenderUtilities::releaseDrawContext</a>( context );</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Render texture on quad</span></div>
<div class="line"> <a name="_a290"></a><a class="code" href="./class_m_point_array.html">MPointArray</a> positions;</div>
<div class="line"> <a class="code" href="./class_m_point_array.html">MPointArray</a>&amp; texcoords = positions;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Tri #0</span></div>
<div class="line">    positions.<a name="a291"></a><a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(region[0][0], region[0][1]);</div>
<div class="line">    positions.<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(region[1][0], region[0][1]);</div>
<div class="line">    positions.<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(region[1][0], region[1][1]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Tri #1</span></div>
<div class="line">    positions.<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(region[0][0], region[0][1]);</div>
<div class="line">    positions.<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(region[1][0], region[1][1]);</div>
<div class="line">    positions.<a class="code" href="./class_m_point_array.html#abe5a9fe36b4651af38a4a26c85f46e1a">append</a>(region[0][0], region[1][1]);</div>
<div class="line"></div>
<div class="line">    uiDrawManager.<a name="a292"></a><a class="code" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html#a9baede3e37abe9551e50a8c6be65ec4d">setColor</a>( parameters.baseColor );</div>
<div class="line">    uiDrawManager.<a name="a293"></a><a class="code" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html#aa02e49a4dc244a97fdfcb4a5452773fe">setTexture</a>( texture );</div>
<div class="line">    uiDrawManager.<a name="a294"></a><a class="code" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html#af740bfef414d18e34661378f7f4bfb91">setTextureSampler</a>( parameters.unfiltered ? <a name="a295"></a><a class="code" href="./class_m_h_w_render_1_1_m_sampler_state.html#ac4b92e6b8c820ded95490092f8bfff74a52e14aff9dd4572590cdbfe29c0b79a9">MHWRender::MSamplerState::kMinMagMipPoint</a> : <a name="a296"></a><a class="code" href="./class_m_h_w_render_1_1_m_sampler_state.html#ac4b92e6b8c820ded95490092f8bfff74acfbcff8a89a15e685607e83819784d80">MHWRender::MSamplerState::kMinMagMipLinear</a>, <a name="a297"></a><a class="code" href="./class_m_h_w_render_1_1_m_sampler_state.html#ac06d679b414bf6ad84118e6e9712fd58a3f5d4a87f8f641542cda0389c3291985">MHWRender::MSamplerState::kTexWrap</a> );</div>
<div class="line">    uiDrawManager.<a name="a298"></a><a class="code" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html#a0a8ebc59bf8740d56560abf3e8d7e63d">setTextureMask</a>( parameters.showAlphaMask ? <a name="a299"></a><a class="code" href="./class_m_h_w_render_1_1_m_blend_state.html#a508bf9ce7f09728669b77bdc572a2340a49d7d249c9c91e4ce0132bcffe5d73d9">MHWRender::MBlendState::kAlphaChannel</a> : <a name="a300"></a><a class="code" href="./class_m_h_w_render_1_1_m_blend_state.html#a508bf9ce7f09728669b77bdc572a2340ae071e81463337bd111c8cd13ed696616">MHWRender::MBlendState::kRGBAChannels</a> );</div>
<div class="line">    uiDrawManager.<a name="a301"></a><a class="code" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html#ab7479336abc018548fe68277932d848a">mesh</a>( <a name="a302"></a><a class="code" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html#a08260379b97fd733e30ea92e891ede1eaa2c70dd76c8172a9298334473c914304">MHWRender::MUIDrawManager::kTriangles</a>, positions, NULL, NULL, NULL, &amp;texcoords );</div>
<div class="line">    uiDrawManager.<a class="code" href="./class_m_h_w_render_1_1_m_u_i_draw_manager.html#aa02e49a4dc244a97fdfcb4a5452773fe">setTexture</a>( NULL );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a>* dx11ShaderNode::getUVTexture(<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a> *context, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; imageName, <span class="keywordtype">int</span>&amp; imageWidth, <span class="keywordtype">int</span>&amp; imageHeight)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> textureName, layerName;</div>
<div class="line"> <span class="keywordtype">int</span> alphaChannelIdx, mipmapLevels;</div>
<div class="line"> <span class="keywordflow">return</span> getUVTexture(context, imageName, imageWidth, imageHeight, textureName, layerName, alphaChannelIdx, mipmapLevels);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a>* dx11ShaderNode::getUVTexture(<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a> *context, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; imageName, <span class="keywordtype">int</span>&amp; imageWidth, <span class="keywordtype">int</span>&amp; imageHeight, <a class="code" href="./class_m_string.html">MString</a> &amp;textureName, <a class="code" href="./class_m_string.html">MString</a>&amp; layerName, <span class="keywordtype">int</span> &amp;alphaChannelIdx, <span class="keywordtype">int</span> &amp;mipmapLevels)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> imageParam;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nUniform = fUniformParameters.length();</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nUniform; i++ ) {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> elem = fUniformParameters.getElement(i);</div>
<div class="line"> <span class="keywordflow">if</span>( elem.<a class="code" href="./class_m_uniform_parameter.html#a37357b066d4c628b1fae2f1ee08b2b12">isATexture</a>() &amp;&amp; elem.<a class="code" href="./class_m_uniform_parameter.html#aca2cba4630391c78dcf1a828986160da">name</a>() == imageName ) { <span class="comment">// Check for isATexture, as multiple parameters can have the same UI name.</span></div>
<div class="line">            imageParam = elem;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Only supports 2D textures.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">if</span>( imageParam.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() != <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6a7d3972f1f1ee99452d3c715b157b5cad">MUniformParameter::kType2DTexture</a> ) {</div>
<div class="line"> <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// It happens that the UV editor get rendered before the viewport (or the swatch)</span></div>
<div class="line"> <span class="comment">// Retrieving the texture string value will clear the hasChanged flag</span></div>
<div class="line"> <span class="comment">// And when the viewport will get rendered, the texture will not be properly updated to the effect</span></div>
<div class="line"> <span class="keywordflow">if</span> (imageParam.<a name="a303"></a><a class="code" href="./class_m_uniform_parameter.html#a9d4d257e5bb7e85eb9fdeca499dc9361">hasChanged</a>(*context))</div>
<div class="line">        fForceUpdateTexture = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get texture</span></div>
<div class="line">    getTextureDesc(*context, imageParam, textureName, layerName, alphaChannelIdx);</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a>* texture = NULL;</div>
<div class="line">    mipmapLevels = 1;</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Generate mip map levels desired by technique</span></div>
<div class="line">        mipmapLevels = fTechniqueTextureMipMapLevels;</div>
<div class="line"> <span class="comment">// If the texture itself specify a level, it prevails over the technique's</span></div>
<div class="line">        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)imageParam.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(effectVariable)</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectShaderResourceVariable* resourceVar = effectVariable-&gt;AsShaderResource();</div>
<div class="line"> <span class="keywordflow">if</span>(resourceVar)</div>
<div class="line">                getAnnotation(resourceVar, dx11ShaderAnnotation::kMipmaplevels, mipmapLevels);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        texture = loadTexture(textureName, layerName, alphaChannelIdx, mipmapLevels);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Release texture used for previous uv editor render and store the new one.</span></div>
<div class="line"> <span class="comment">// This is helpful if the scene does not render the texture.</span></div>
<div class="line"> <span class="comment">// This prevent having to load the same texture again and again on each draw</span></div>
<div class="line">    releaseTexture(fUVEditorTexture);</div>
<div class="line">    fUVEditorTexture = texture;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(texture)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a304"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture_description.html">MHWRender::MTextureDescription</a> desc;</div>
<div class="line">        texture-&gt;<a name="a305"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture.html#ad1b6f25f4fb913a233b1c2bff46a62a1">textureDescription</a>(desc);</div>
<div class="line"></div>
<div class="line">        imageWidth  = (int)desc.<a name="a306"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture_description.html#a2582291699b63f6ddc938c371b54344e">fWidth</a>;</div>
<div class="line">        imageHeight = (<span class="keywordtype">int</span>)desc.<a name="a307"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture_description.html#aa3b84951e55674788c9ae0f404a8ee17">fHeight</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> texture;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Render all the geometry within the renderItemList using active technique</span></div>
<div class="line"><span class="comment">    This is called to render the geometry in the viewport 2.0</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Split the render items in 2 lists; the items that can receive shadows and the ones that can't.</span></div>
<div class="line"><span class="comment">    Render both lists against the selected technique.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::render(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context, <span class="keyword">const</span> <a name="_a308"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MHWRender::MRenderItemList</a>&amp; renderItemList)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span>(fTechnique == NULL || fTechnique-&gt;IsValid() == <span class="keyword">false</span>)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get device</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MHWRender::MRenderer</a>* theRenderer = <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MHWRender::MRenderer::theRenderer</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!theRenderer) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    ID3D11Device* dxDevice = (ID3D11Device*)theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a637ec8cc3cc0e631f1d134f6891f89f0">GPUDeviceHandle</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!dxDevice) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get context</span></div>
<div class="line">    ID3D11DeviceContext* dxContext = NULL;</div>
<div class="line">    dxDevice-&gt;GetImmediateContext(&amp;dxContext);</div>
<div class="line"> <span class="keywordflow">if</span> (!dxContext) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    ERenderType renderType = RENDER_SCENE;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update shader parameters</span></div>
<div class="line">    updateParameters(context, fUniformParameters, fResourceTextureMap, renderType);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// These will hold the global and per-light state</span></div>
<div class="line"> <span class="comment">// while we toggle the per-geometry state:</span></div>
<div class="line">    TshadowFlagBackupState shadowFlagBackupState;</div>
<div class="line">    initShadowFlagBackupState(shadowFlagBackupState);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We can now render in different context:</span></div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> passSem = getPassSemanticsRemovingColorPassIfNecessary(context);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Draw (return true if we manage to draw anything, not necessarily everything)</span></div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Split items with shadows from items without, and non material override items, only if necessary.</span></div>
<div class="line">    RenderItemList shadowOnRenderVec, shadowOffRenderVec, nonMaterialOverrideRenderVec;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> numRenderItems = renderItemList.<a name="a309"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> renderItemIdx=0; renderItemIdx &lt; numRenderItems; ++renderItemIdx)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <a name="_a310"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* renderItem = renderItemList.<a name="a311"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(renderItemIdx);</div>
<div class="line"> <span class="keywordflow">if</span> (renderItem)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (renderItem-&gt;<a name="a312"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a34f68c9a676a4fce3e56c3ec86b2c319">type</a>() ==  <a name="a313"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49ea1fcf574a73eba1a959c51838083573e4">MHWRender::MRenderItem::OverrideNonMaterialItem</a>) {</div>
<div class="line">                nonMaterialOverrideRenderVec.push_back(renderItem);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renderItem-&gt;<a name="a314"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a84fc76ef02716b725765f6de1ff3a8c6">receivesShadows</a>() || shadowFlagBackupState.empty()) {</div>
<div class="line">                shadowOnRenderVec.push_back(renderItem);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                shadowOffRenderVec.push_back(renderItem);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!shadowOnRenderVec.empty())</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!shadowFlagBackupState.empty())</div>
<div class="line">            setPerGeometryShadowOnFlag(<span class="keyword">true</span>, shadowFlagBackupState);</div>
<div class="line">        result |= renderTechnique(dxDevice, dxContext, fTechnique, fTechniquePassCount, passSem, shadowOnRenderVec, fVaryingParameters, renderType, fTechniqueIndexBufferType);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!shadowOffRenderVec.empty())</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!shadowFlagBackupState.empty())</div>
<div class="line">            setPerGeometryShadowOnFlag(<span class="keyword">false</span>, shadowFlagBackupState);</div>
<div class="line">        result |= renderTechnique(dxDevice, dxContext, fTechnique, fTechniquePassCount, passSem, shadowOffRenderVec, fVaryingParameters, renderType, fTechniqueIndexBufferType);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!nonMaterialOverrideRenderVec.empty())</div>
<div class="line">    {</div>
<div class="line">        renderType = RENDER_SCENE_NON_MATERIAL;</div>
<div class="line">        result |= renderTechnique(dxDevice, dxContext, fTechnique, fTechniquePassCount, passSem, nonMaterialOverrideRenderVec, fVaryingParameters, renderType, fTechniqueIndexBufferType);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    dxContext-&gt;Release();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Render all the geometries within the renderItemList using specified technique</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Render the items against all compatible passes of the selected technique.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::renderTechnique(dx11ShaderDX11Device *dxDevice, dx11ShaderDX11DeviceContext *dxContext, dx11ShaderDX11EffectTechnique* dxTechnique,</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPasses, <span class="keyword">const</span> <a class="code" href="./class_m_string_array.html">MStringArray</a>&amp; passSem,</div>
<div class="line"> <span class="keyword">const</span> RenderItemList&amp; renderItemList, <span class="keyword">const</span> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>&amp; varyingParameters, ERenderType renderType, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; indexBufferType)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( isRenderNonMaterialItem(renderType) )</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// When rendering non material items loop items first, then passes : each non material item may have different value (solidColor, lineSize, pointSize)</span></div>
<div class="line"> <span class="comment">// that requires the effect variable to be updated before activating the pass.</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span> numRenderItems = renderItemList.size();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> renderItemIdx = 0; renderItemIdx &lt; numRenderItems; ++renderItemIdx)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* renderItem = renderItemList[renderItemIdx];</div>
<div class="line"> <span class="keywordflow">if</span>(renderItem)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>* geometry = renderItem-&gt;<a name="a315"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#aee2e53b30cbf1699eac04ce5659398d3">geometry</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(geometry)</div>
<div class="line">                {</div>
<div class="line">                    RenderItemDesc renderItemDesc = { <span class="keyword">false</span>, <span class="keyword">false</span> };</div>
<div class="line">                    updateOverrideNonMaterialItemParameters(renderItem, renderItemDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> primitiveStride;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MHWRender::MGeometry::Primitive</a> primitiveType = renderItem-&gt;<a name="a316"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#af3ddb45109547883d06426f0530ddf0c">primitive</a>(primitiveStride);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passId = 0; passId &lt; numPasses; ++passId)</div>
<div class="line">                    {</div>
<div class="line">                        dx11ShaderDX11Pass* dxPass = activatePass(dxDevice, dxContext, dxTechnique, passId, passSem, renderType, &amp;renderItemDesc);</div>
<div class="line"> <span class="keywordflow">if</span>(dxPass)</div>
<div class="line">                        {</div>
<div class="line">                            result |= renderPass(dxDevice, dxContext, dxPass, geometry, primitiveType, primitiveStride, varyingParameters, renderType, indexBufferType);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Loop passes, then render items : reduce amount of pass activation</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passId = 0; passId &lt; numPasses; ++passId)</div>
<div class="line">        {</div>
<div class="line">            dx11ShaderDX11Pass* dxPass = activatePass(dxDevice, dxContext, dxTechnique, passId, passSem, renderType);</div>
<div class="line"> <span class="keywordflow">if</span>(dxPass)</div>
<div class="line">            {</div>
<div class="line">                result |= renderPass(dxDevice, dxContext, dxPass, renderItemList, varyingParameters, renderType, indexBufferType);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Render all the geometries within the renderItemList using specified pass</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::renderPass(dx11ShaderDX11Device *dxDevice, dx11ShaderDX11DeviceContext *dxContext, dx11ShaderDX11Pass* dxPass,</div>
<div class="line"> <span class="keyword">const</span> RenderItemList&amp; renderItemList,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>&amp; varyingParameters, ERenderType renderType, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; indexBufferType)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span> numRenderItems = renderItemList.size();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> renderItemIdx = 0; renderItemIdx &lt; numRenderItems; ++renderItemIdx)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* renderItem = renderItemList[renderItemIdx];</div>
<div class="line"> <span class="keywordflow">if</span>(renderItem)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>* geometry = renderItem-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#aee2e53b30cbf1699eac04ce5659398d3">geometry</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(geometry)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">int</span> primitiveStride;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MHWRender::MGeometry::Primitive</a> primitiveType = renderItem-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#af3ddb45109547883d06426f0530ddf0c">primitive</a>(primitiveStride);</div>
<div class="line"> </div>
<div class="line">                result |= renderPass(dxDevice, dxContext, dxPass, geometry, primitiveType, primitiveStride, varyingParameters, renderType, indexBufferType);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Render a single geometry using specified technique</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Render the geometry against all compatible passes of the selected technique.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::renderTechnique(dx11ShaderDX11Device *dxDevice, dx11ShaderDX11DeviceContext *dxContext, dx11ShaderDX11EffectTechnique* dxTechnique, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPasses,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>* geometry, <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MHWRender::MGeometry::Primitive</a> primitiveType, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primitiveStride,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>&amp; varyingParameters, ERenderType renderType, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; indexBufferType)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passId = 0; passId &lt; numPasses; ++passId)</div>
<div class="line">    {</div>
<div class="line">        dx11ShaderDX11Pass* dxPass = activatePass(dxDevice, dxContext, dxTechnique, passId, renderType);</div>
<div class="line"> <span class="keywordflow">if</span>(dxPass)</div>
<div class="line">        {</div>
<div class="line">            result |= renderPass(dxDevice, dxContext, dxPass, geometry, primitiveType, primitiveStride, varyingParameters, renderType, indexBufferType);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Render a single geometry using specified technique to a texture target (swatch and uv editor)</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::renderTechnique(dx11ShaderDX11Device *dxDevice, dx11ShaderDX11EffectTechnique* dxTechnique, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPasses,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_target.html">MHWRender::MRenderTarget</a>* textureTarget, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height, <span class="keywordtype">float</span> clearColor[4],</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>* geometry, <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MHWRender::MGeometry::Primitive</a> primitiveType, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primitiveStride,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>&amp; varyingParameters, ERenderType renderType, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; indexBufferType)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    ID3D11RenderTargetView* textureView = (ID3D11RenderTargetView*)(textureTarget-&gt;<a name="a317"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_target.html#ad7bcab0d1707ef0da22fc72ada62c40e">resourceHandle</a>());</div>
<div class="line"> <span class="keywordflow">if</span>(textureView == NULL)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(fMayaSwatchRenderVar &amp;&amp; needUpdateMayaSwatchRenderVar(renderType))</div>
<div class="line">        fMayaSwatchRenderVar-&gt;AsScalar()-&gt;SetBool( <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line">    ID3D11DeviceContext* dxContext = NULL;</div>
<div class="line">    dxDevice-&gt;GetImmediateContext(&amp;dxContext);</div>
<div class="line"></div>
<div class="line">    ContextStates contextStates;</div>
<div class="line">    backupStates(dxContext, contextStates);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set colour and depth surfaces.</span></div>
<div class="line">    dxContext-&gt;OMSetRenderTargets( 1, &amp;textureView, NULL );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Setup viewport</span></div>
<div class="line"> <span class="keyword">const</span> D3D11_VIEWPORT viewport = { 0.0f, 0.0f, (float)(width), (float)(height), 0.0f, 1.0f };</div>
<div class="line">    dxContext-&gt;RSSetViewports( 1, &amp;viewport );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Clear the entire buffer (RGB, Depth)</span></div>
<div class="line">    dxContext-&gt;ClearRenderTargetView( textureView, clearColor );</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> result = renderTechnique(dxDevice, dxContext, dxTechnique, numPasses,</div>
<div class="line">                            geometry, <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1eaa2c70dd76c8172a9298334473c914304">MHWRender::MGeometry::kTriangles</a>, 3,</div>
<div class="line">                            varyingParameters, renderType, indexBufferType);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Clean up</span></div>
<div class="line">    restoreStates(dxContext, contextStates);</div>
<div class="line">    dxContext-&gt;Release();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(fMayaSwatchRenderVar &amp;&amp; needUpdateMayaSwatchRenderVar(renderType))</div>
<div class="line">        fMayaSwatchRenderVar-&gt;AsScalar()-&gt;SetBool( <span class="keyword">false</span> );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Render a single geometry using specified pass</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    For the swatch rendering, the geometry buffers are provided by MGeometryUtilities,</span></div>
<div class="line"><span class="comment">    if the crack free tessellation (PNAEN9 and PNAEN18) is enabled,</span></div>
<div class="line"><span class="comment">    temporary buffers are created and the CrackFreePrimitiveGenerator is applied.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    To improve the rendering performance, the input layout is cached and reused as much as possible</span></div>
<div class="line"><span class="comment">    until the list of vertex buffers changes - usually when another technique is selected.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::renderPass(dx11ShaderDX11Device *dxDevice, dx11ShaderDX11DeviceContext *dxContext, dx11ShaderDX11Pass* dxPass,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>* geometry, <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MHWRender::MGeometry::Primitive</a> primitiveType, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primitiveStride,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_varying_parameter_list.html">MVaryingParameterList</a>&amp; varyingParameters, ERenderType renderType, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; indexBufferType)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vtxBufferCount = (geometry != NULL ? geometry-&gt;<a name="a318"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a2d6ad76bad123c47513c5941e7493914">vertexBufferCount</a>() : 0);</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idxBufferCount = (geometry != NULL ? geometry-&gt;<a name="a319"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a841bcde01083fb1b48f22c553d1d695c">indexBufferCount</a>() : 0);</div>
<div class="line"> <span class="keywordflow">if</span>(vtxBufferCount == 0 || vtxBufferCount &gt;= D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT)</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> bContainsHullShader = passHasHullShader(dxPass);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> bAddPNAENAdjacentEdges = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> bAddPNAENDominantEdges = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> bAddPNAENDominantPosition = <span class="keyword">false</span>;</div>
<div class="line">    std::vector&lt;float&gt; floatPNAENPositionBuffer;</div>
<div class="line">    std::vector&lt;float&gt; floatPNAENUVBuffer;</div>
<div class="line"> <span class="keywordflow">if</span>(isRenderSwatch(renderType))</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span>(indexBufferType == <span class="stringliteral">"PNAEN18"</span>) {</div>
<div class="line">            bAddPNAENAdjacentEdges = <span class="keyword">true</span>;</div>
<div class="line">            bAddPNAENDominantEdges = <span class="keyword">true</span>;</div>
<div class="line">            bAddPNAENDominantPosition = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexBufferType == <span class="stringliteral">"PNAEN9"</span>) {</div>
<div class="line">            bAddPNAENAdjacentEdges = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set up vertex buffers and input layout</span></div>
<div class="line"> <span class="comment">// ---------------------------------------------------------------------------</span></div>
<div class="line">    D3D11_INPUT_ELEMENT_DESC    layout[D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];</div>
<div class="line">    ID3D11Buffer*               vtxBuffers[D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                strides[D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                offsets[D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];</div>
<div class="line"> <span class="keywordtype">int</span>                         numBoundBuffers = 0;</div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a>                mappedVertexBuffers;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertexCount = 0;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vtxId = 0; vtxId &lt; vtxBufferCount; ++vtxId)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <a name="_a320"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* buffer = geometry-&gt;<a name="a321"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a8dbf1ef3c0feaff25da15a60fe968a80">vertexBuffer</a>(vtxId);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer == NULL)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (vertexCount == 0)</div>
<div class="line">            vertexCount = buffer-&gt;<a name="a322"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a42db940e8d3c623487a4e2c34024751c">vertexCount</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a>&amp; desc = buffer-&gt;<a name="a323"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a331cfb987f5f4d632a747e7fbbbe4a43">descriptor</a>();</div>
<div class="line">        ID3D11Buffer* vtxBuffer = (ID3D11Buffer*)buffer-&gt;<a name="a324"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e">resourceHandle</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (vtxBuffer == NULL)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    fieldOffset     = desc.<a name="a325"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aaa02ea556dee3025f49406b9d3fb662c">offset</a>();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    fieldStride     = desc.<a name="a326"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#a2f0529f7f5ff03b8a26e3a3d1925bb2b">stride</a>();</div>
<div class="line"> <span class="keywordtype">int</span>                             dimension       = desc.<a name="a327"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#ae5acbe47d704ceb866e3717e2ac9422f">dimension</a>();</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4">MHWRender::MGeometry::Semantic</a>  semantic        = desc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>();</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef PRINT_DEBUG_INFO</span></div>
<div class="line">        fprintf(</div>
<div class="line">            stderr,</div>
<div class="line"> <span class="stringliteral">"REQUESTED-VB: Buffer(%s)\n"</span>, <a name="a328"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a19e106f192d0c974c6f5cdd3f07e3288">MHWRender::MGeometry::semanticString</a>(semantic).asChar()</div>
<div class="line">        );</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> isCustomSemantic = (desc.<a name="a329"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aec39ee3496166457d1ccdf73c8d1a3b2">semanticName</a>().<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0);</div>
<div class="line"></div>
<div class="line">        MatchingParameters matchingParameters;</div>
<div class="line">        getDstSemanticsFromSrcVertexDescriptor(varyingParameters, desc, matchingParameters);</div>
<div class="line"> <span class="keywordtype">size_t</span> semanticBufferCount = matchingParameters.size();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// See if name was previously bound together with another one:</span></div>
<div class="line"> <span class="comment">// Probably redundant since we do not declare duplicate vertex buffers</span></div>
<div class="line"> <span class="comment">// in dx11ShaderNode::buildVertexDescriptorFromVaryingParameters</span></div>
<div class="line"> <span class="keywordflow">if</span> (semanticBufferCount &gt; 1 &amp;&amp; isCustomSemantic)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iSeen = 0; iSeen &lt; mappedVertexBuffers.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); ++iSeen)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">if</span> (mappedVertexBuffers[iSeen] == desc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aca2cba4630391c78dcf1a828986160da">name</a>())</div>
<div class="line">                {</div>
<div class="line">                    semanticBufferCount = 0;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            mappedVertexBuffers.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>(desc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aca2cba4630391c78dcf1a828986160da">name</a>());</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">if</span>(semanticBufferCount == 0)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (bAddPNAENAdjacentEdges &amp;&amp;</div>
<div class="line">            ( (semantic == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4aa20581584e5f9447cb96afb4f2e10703">MHWRender::MGeometry::kPosition</a> &amp;&amp; floatPNAENPositionBuffer.empty()) ||</div>
<div class="line">                (semantic == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93">MHWRender::MGeometry::kTexture</a> &amp;&amp; floatPNAENUVBuffer.empty()) ) )</div>
<div class="line">        {</div>
<div class="line">            std::vector&lt;float&gt;&amp; data = (semantic == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4aa20581584e5f9447cb96afb4f2e10703">MHWRender::MGeometry::kPosition</a> ? floatPNAENPositionBuffer : floatPNAENUVBuffer);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = buffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a42db940e8d3c623487a4e2c34024751c">vertexCount</a>() * dimension;</div>
<div class="line">            data.resize(size);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* nonConstBuffer = <span class="keyword">const_cast&lt;</span><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>*<span class="keyword">&gt;</span>(buffer);</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">void</span>* values = nonConstBuffer-&gt;<a name="a330"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#abc9e783c4d7826700a6a6824451f8230">map</a>();</div>
<div class="line">            memcpy(&amp;data[0], values, size * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line">            nonConstBuffer-&gt;<a name="a331"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a>();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We can have multiple bindings at the same input slot:</span></div>
<div class="line"> <span class="keywordtype">int</span> inputSlot = numBoundBuffers;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// multiple buffers can be bound to the same output buffer</span></div>
<div class="line"> <span class="comment">// we will loop through</span></div>
<div class="line"> <span class="comment">// -------------------------------------------------------</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> semanticId = 0; semanticId &lt; semanticBufferCount; ++semanticId)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> MatchingParameter&amp; param = matchingParameters[semanticId];</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MHWRender::MGeometry::DataType</a> vertexDataType = desc.<a name="a332"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc7588a483f61d3d4a1e8204ca14d6f6">dataType</a>();</div>
<div class="line"> <span class="keywordflow">switch</span> (vertexDataType)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a333"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a5686197bafb177bdc82550848416a1ad">MHWRender::MGeometry::kFloat</a>:</div>
<div class="line">            {</div>
<div class="line">                fieldStride *= <span class="keyword">sizeof</span>(float);</div>
<div class="line"> <span class="keywordflow">switch</span> (dimension) {</div>
<div class="line"> <span class="keywordflow">case</span> 1: layout[numBoundBuffers].Format = DXGI_FORMAT_R32_FLOAT; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> 2: layout[numBoundBuffers].Format = DXGI_FORMAT_R32G32_FLOAT; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> 3: layout[numBoundBuffers].Format = DXGI_FORMAT_R32G32B32_FLOAT; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> 4: layout[numBoundBuffers].Format = DXGI_FORMAT_R32G32B32A32_FLOAT; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>: <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a334"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae3e576e62ae36818ff6edced2065c36e">MHWRender::MGeometry::kInt32</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a335"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6aa93f90f58b3077bdbedeb9506e0143fd">MHWRender::MGeometry::kUnsignedInt32</a>:</div>
<div class="line">            {</div>
<div class="line">                fieldStride *= <span class="keyword">sizeof</span>(int);</div>
<div class="line"> <span class="keywordflow">switch</span> (dimension) {</div>
<div class="line"> <span class="keywordflow">case</span> 1: layout[numBoundBuffers].Format = DXGI_FORMAT_R32_UINT; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> 2: layout[numBoundBuffers].Format = DXGI_FORMAT_R32G32_UINT; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> 3: layout[numBoundBuffers].Format = DXGI_FORMAT_R32G32B32_UINT; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> 4: layout[numBoundBuffers].Format = DXGI_FORMAT_R32G32B32A32_UINT; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>: <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            ID3D11Buffer* customVtxBuffer = vtxBuffer;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> customFieldOffset = fieldOffset;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> customFieldStride = fieldStride;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (isCustomSemantic)</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// we just use the semantic name if there is one</span></div>
<div class="line">                layout[numBoundBuffers].SemanticName = desc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aec39ee3496166457d1ccdf73c8d1a3b2">semanticName</a>().<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">                layout[numBoundBuffers].SemanticIndex = 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// it's a custom semantic, that is probably managed by a vertex buffer generator</span></div>
<div class="line"> <span class="comment">// if geometry dimension or type do not match varying parameter create an empty buffer</span></div>
<div class="line"> <span class="keywordtype">int</span> elementSize = desc.<a name="a336"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#a064b0aed53f7aa48d27145b41f9590aa">dataTypeSize</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(dimension != param.dimension || elementSize != param.elementSize)</div>
<div class="line">                {</div>
<div class="line"> <span class="keywordtype">int</span> bufferSize = elementSize * dimension * buffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a42db940e8d3c623487a4e2c34024751c">vertexCount</a>();</div>
<div class="line"> <span class="keywordtype">char</span> *bufferData = <span class="keyword">new</span> <span class="keywordtype">char</span>[bufferSize];</div>
<div class="line">                    ::memset(bufferData, bufferSize, 0);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create new vertex buffer</span></div>
<div class="line"> <span class="keyword">const</span> D3D11_BUFFER_DESC bufDesc = { bufferSize, D3D11_USAGE_IMMUTABLE, D3D11_BIND_VERTEX_BUFFER, 0, 0, 0 };</div>
<div class="line"> <span class="keyword">const</span> D3D11_SUBRESOURCE_DATA bufData = { bufferData, 0, 0 };</div>
<div class="line">                    customVtxBuffer = NULL;</div>
<div class="line">                    dxDevice-&gt;CreateBuffer(&amp;bufDesc, &amp;bufData, &amp;customVtxBuffer);</div>
<div class="line"> <span class="keyword">delete</span> [] bufferData;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                semantic = param.semantic;</div>
<div class="line"> <span class="keywordtype">int</span> semanticIndex = param.semanticIndex;</div>
<div class="line"> <span class="keywordflow">switch</span> (semantic) {</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4aa20581584e5f9447cb96afb4f2e10703">MHWRender::MGeometry::kPosition</a>:   layout[numBoundBuffers].SemanticName = <span class="stringliteral">"POSITION"</span>; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a227e8416235cd3b43077ca91504a463f">MHWRender::MGeometry::kNormal</a>:     layout[numBoundBuffers].SemanticName = <span class="stringliteral">"NORMAL"</span>; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4a6de4261b95102b5402b425d62e1bda93">MHWRender::MGeometry::kTexture</a>:    layout[numBoundBuffers].SemanticName = <span class="stringliteral">"TEXCOORD"</span>; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4afc0133ebaa6c307b2388ecf5f72f6fdf">MHWRender::MGeometry::kColor</a>:      layout[numBoundBuffers].SemanticName = <span class="stringliteral">"COLOR"</span>; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4ab90d6591156ad2cb2eea2cb5b75e77e0">MHWRender::MGeometry::kTangent</a>:    layout[numBoundBuffers].SemanticName = <span class="stringliteral">"TANGENT"</span>; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4af6ed1c5faf6f0993971e8043ffa1a111">MHWRender::MGeometry::kBitangent</a>:  layout[numBoundBuffers].SemanticName = <span class="stringliteral">"BINORMAL"</span>; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>: <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">                layout[numBoundBuffers].SemanticIndex = semanticIndex;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(customVtxBuffer)</div>
<div class="line">            {</div>
<div class="line"><span class="preprocessor">#ifdef PRINT_DEBUG_INFO</span></div>
<div class="line">                fprintf(</div>
<div class="line">                    stderr,</div>
<div class="line"> <span class="stringliteral">"VTX_BUFFER_INFO: Buffer(%d), Name(%s), BufferType(%s), BufferDimension(%d), BufferSemantic(%s), Offset(%d), Stride(%d), Handle(%p)\n"</span>,</div>
<div class="line">                    vtxId,</div>
<div class="line">                    desc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aca2cba4630391c78dcf1a828986160da">name</a>().<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),</div>
<div class="line"> <a name="a337"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a2164a45dbdf2ae0f47998f5e5ac854e6">MHWRender::MGeometry::dataTypeString</a>(vertexDataType).<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),</div>
<div class="line">                    dimension,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a19e106f192d0c974c6f5cdd3f07e3288">MHWRender::MGeometry::semanticString</a>(semantic).<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),</div>
<div class="line">                    fieldOffset,</div>
<div class="line">                    fieldStride,</div>
<div class="line">                    vtxBuffer);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">                layout[numBoundBuffers].InputSlot = inputSlot;</div>
<div class="line">                layout[numBoundBuffers].AlignedByteOffset = 0;</div>
<div class="line">                layout[numBoundBuffers].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;</div>
<div class="line">                layout[numBoundBuffers].InstanceDataStepRate = 0;</div>
<div class="line">                vtxBuffers[numBoundBuffers] = customVtxBuffer;</div>
<div class="line">                strides[numBoundBuffers] = customFieldStride;</div>
<div class="line">                offsets[numBoundBuffers] = customFieldOffset;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(customVtxBuffer != vtxBuffer)</div>
<div class="line">                    customVtxBuffer-&gt;Release();</div>
<div class="line"></div>
<div class="line">                ++numBoundBuffers;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// Activate vertex buffers</span></div>
<div class="line"> <span class="keywordflow">if</span> (numBoundBuffers &lt;= 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    dxContext-&gt;IASetVertexBuffers(0, numBoundBuffers, vtxBuffers, strides, offsets);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Acquire and set input layout based on vertex buffers</span></div>
<div class="line">    ID3D11InputLayout* inputLayout = getInputLayout(dxDevice, dxPass, numBoundBuffers, layout);</div>
<div class="line"> <span class="keywordflow">if</span> (inputLayout == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    dxContext-&gt;IASetInputLayout(inputLayout);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( idxBufferCount == 0 )</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// No index buffer</span></div>
<div class="line">        D3D11_PRIMITIVE_TOPOLOGY topo = getPrimitiveTopology(primitiveType, primitiveStride, bContainsHullShader);</div>
<div class="line"></div>
<div class="line">        dxContext-&gt;IASetPrimitiveTopology(topo);</div>
<div class="line">        dxContext-&gt;Draw(vertexCount, 0);</div>
<div class="line"></div>
<div class="line">        result |= <span class="keyword">true</span>; <span class="comment">// drew something</span></div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Setup index buffers and draw</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idxId = 0; idxId &lt; idxBufferCount; ++idxId)</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a name="_a338"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MHWRender::MIndexBuffer</a>* buffer = geometry-&gt;<a name="a339"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#aa2f26ad753c6cf66a2d0badd1328ebee">indexBuffer</a>(idxId);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer == NULL)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            ID3D11Buffer* idxBuffer = (ID3D11Buffer*)buffer-&gt;<a name="a340"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e">resourceHandle</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (idxBuffer == NULL)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MHWRender::MGeometry::DataType</a> indexDataType = buffer-&gt;<a name="a341"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#abc7588a483f61d3d4a1e8204ca14d6f6">dataType</a>();</div>
<div class="line"></div>
<div class="line">            DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> formatSize = 0;</div>
<div class="line"> <span class="keywordflow">switch</span> (indexDataType)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a342"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a589716b974587a5b575bf02d0b74245a">MHWRender::MGeometry::kChar</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a343"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a771a88748799bba09da625ffee5c6945">MHWRender::MGeometry::kUnsignedChar</a>:</div>
<div class="line">                format = DXGI_FORMAT_R8_UINT;</div>
<div class="line">                formatSize = 1;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a344"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6acc48eb3dce9079e1af81af4db6506343">MHWRender::MGeometry::kInt16</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a345"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a3d97c6fcb525dc79fed35f39fd7bab76">MHWRender::MGeometry::kUnsignedInt16</a>:</div>
<div class="line">                format = DXGI_FORMAT_R16_UINT;</div>
<div class="line">                formatSize = 2;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae3e576e62ae36818ff6edced2065c36e">MHWRender::MGeometry::kInt32</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6aa93f90f58b3077bdbedeb9506e0143fd">MHWRender::MGeometry::kUnsignedInt32</a>:</div>
<div class="line">                format = DXGI_FORMAT_R32_UINT;</div>
<div class="line">                formatSize = 4;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indexBufferSize = buffer-&gt;<a name="a346"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#a90ca964ebcc1b02bbcde225edd49e812">size</a>();</div>
<div class="line"></div>
<div class="line">            ID3D11Buffer* customIdxBuffer = idxBuffer;</div>
<div class="line"> <span class="keywordflow">if</span> (bAddPNAENAdjacentEdges &amp;&amp; floatPNAENPositionBuffer.empty() == <span class="keyword">false</span> &amp;&amp; floatPNAENUVBuffer.empty() == <span class="keyword">false</span> &amp;&amp; formatSize != 2)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indexCount = indexBufferSize;</div>
<div class="line"></div>
<div class="line"> <a name="_a347"></a><a class="code" href="./class_m_uint_array.html">MUintArray</a> currentIndexBuffer;</div>
<div class="line">                currentIndexBuffer.<a name="a348"></a><a class="code" href="./class_m_uint_array.html#a8c66dfa06f3736b2a214c5aed58bd216">setLength</a>(indexCount);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MHWRender::MIndexBuffer</a>* nonConstBuffer = <span class="keyword">const_cast&lt;</span><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MHWRender::MIndexBuffer</a>*<span class="keyword">&gt;</span>(buffer);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* indices = nonConstBuffer-&gt;<a name="a349"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#abc9e783c4d7826700a6a6824451f8230">map</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iidx = 0; iidx &lt; indexCount; ++iidx)</div>
<div class="line">                {</div>
<div class="line"> <span class="keywordflow">switch</span> (indexDataType)</div>
<div class="line">                    {</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a589716b974587a5b575bf02d0b74245a">MHWRender::MGeometry::kChar</a>:           currentIndexBuffer[iidx] = (<span class="keywordtype">unsigned</span> int)((__int8*)indices)[iidx]; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a771a88748799bba09da625ffee5c6945">MHWRender::MGeometry::kUnsignedChar</a>:   currentIndexBuffer[iidx] = (<span class="keywordtype">unsigned</span> int)((<span class="keywordtype">unsigned</span> __int8*)indices)[iidx]; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6acc48eb3dce9079e1af81af4db6506343">MHWRender::MGeometry::kInt16</a>:          currentIndexBuffer[iidx] = (<span class="keywordtype">unsigned</span> int)((__int16*)indices)[iidx]; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a3d97c6fcb525dc79fed35f39fd7bab76">MHWRender::MGeometry::kUnsignedInt16</a>:  currentIndexBuffer[iidx] = (<span class="keywordtype">unsigned</span> int)((<span class="keywordtype">unsigned</span> __int16*)indices)[iidx]; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae3e576e62ae36818ff6edced2065c36e">MHWRender::MGeometry::kInt32</a>:          currentIndexBuffer[iidx] = (<span class="keywordtype">unsigned</span> int)((__int32*)indices)[iidx]; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6aa93f90f58b3077bdbedeb9506e0143fd">MHWRender::MGeometry::kUnsignedInt32</a>:  currentIndexBuffer[iidx] = (<span class="keywordtype">unsigned</span> int)((<span class="keywordtype">unsigned</span> __int32*)indices)[iidx]; <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:    <span class="keywordflow">continue</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                nonConstBuffer-&gt;<a name="a350"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTri = indexCount/3;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> triSize = CrackFreePrimitiveGenerator::computeTriangleSize(bAddPNAENAdjacentEdges, bAddPNAENDominantEdges, bAddPNAENDominantPosition);</div>
<div class="line">                indexBufferSize = numTri * triSize;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dataBufferSize = indexBufferSize * formatSize;</div>
<div class="line">                indices = <span class="keyword">new</span> <span class="keywordtype">char</span>[dataBufferSize];</div>
<div class="line">                CrackFreePrimitiveGenerator::mutateIndexBuffer( currentIndexBuffer, &amp;floatPNAENPositionBuffer[0], &amp;floatPNAENUVBuffer[0],</div>
<div class="line">                                    bAddPNAENAdjacentEdges, bAddPNAENDominantEdges, bAddPNAENDominantPosition,</div>
<div class="line">                                    (formatSize == 1 ? <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6a771a88748799bba09da625ffee5c6945">MHWRender::MGeometry::kUnsignedChar</a> : <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6aa93f90f58b3077bdbedeb9506e0143fd">MHWRender::MGeometry::kUnsignedInt32</a>), indices );</div>
<div class="line"></div>
<div class="line">                primitiveStride = triSize;</div>
<div class="line">                primitiveType = <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea23d4e011c2b72a286021ca9a5a121830">MHWRender::MGeometry::kPatch</a>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create new index buffer</span></div>
<div class="line"> <span class="keyword">const</span> D3D11_BUFFER_DESC bufDesc = { dataBufferSize, D3D11_USAGE_IMMUTABLE, D3D11_BIND_INDEX_BUFFER, 0, 0, 0 };</div>
<div class="line"> <span class="keyword">const</span> D3D11_SUBRESOURCE_DATA bufData = { indices, 0, 0 };</div>
<div class="line">                customIdxBuffer = NULL;</div>
<div class="line">                dxDevice-&gt;CreateBuffer(&amp;bufDesc, &amp;bufData, &amp;customIdxBuffer);</div>
<div class="line"> <span class="keyword">delete</span> [] indices;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (customIdxBuffer)</div>
<div class="line">            {</div>
<div class="line">                D3D11_PRIMITIVE_TOPOLOGY topo = getPrimitiveTopology(primitiveType, primitiveStride, bContainsHullShader);</div>
<div class="line"> <span class="keywordflow">if</span>(topo == D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">    #ifdef PRINT_DEBUG_INFO</span></div>
<div class="line">                fprintf(stderr, <span class="stringliteral">"IDX_BUFFER_INFO: Buffer(%d), IndexingPrimType(%s), IndexType(%s), IndexCount(%d), Handle(%p)\n"</span>,</div>
<div class="line">                    idxId,</div>
<div class="line"> <a name="a351"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ae9ba871c853febb72a1bb4586451a92f">MHWRender::MGeometry::primitiveString</a>(primitiveType).asChar(),</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a2164a45dbdf2ae0f47998f5e5ac854e6">MHWRender::MGeometry::dataTypeString</a>(indexDataType).asChar(),</div>
<div class="line">                    indexBufferSize,</div>
<div class="line">                    customIdxBuffer);</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Activate index buffer and draw</span></div>
<div class="line">                dxContext-&gt;IASetIndexBuffer(customIdxBuffer, format, 0);</div>
<div class="line">                dxContext-&gt;IASetPrimitiveTopology(topo);</div>
<div class="line">                dxContext-&gt;DrawIndexed(indexBufferSize, 0, 0);</div>
<div class="line"></div>
<div class="line">                result |= <span class="keyword">true</span>; <span class="comment">// drew something</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(customIdxBuffer != idxBuffer)</div>
<div class="line">                    customIdxBuffer-&gt;Release();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Backup all states of dx context, should called before each render operation</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::backupStates(dx11ShaderDX11DeviceContext *dxContext, ContextStates &amp;states)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    dxContext-&gt;RSGetState(&amp;(states.rasterizerState));</div>
<div class="line">    dxContext-&gt;OMGetDepthStencilState(&amp;(states.depthStencilState), &amp;(states.stencilRef));</div>
<div class="line">    dxContext-&gt;OMGetBlendState(&amp;(states.blendState), states.blendFactor, &amp;(states.sampleMask));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Restore all states of dx context, should called after each render operation</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::restoreStates(dx11ShaderDX11DeviceContext *dxContext, ContextStates &amp;states)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>(states.rasterizerState) {</div>
<div class="line">        dxContext-&gt;RSSetState(states.rasterizerState);</div>
<div class="line">        states.rasterizerState-&gt;Release();</div>
<div class="line">        states.rasterizerState = NULL;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(states.depthStencilState) {</div>
<div class="line">        dxContext-&gt;OMSetDepthStencilState(states.depthStencilState, states.stencilRef);</div>
<div class="line">        states.depthStencilState-&gt;Release();</div>
<div class="line">        states.depthStencilState = NULL;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(states.blendState) {</div>
<div class="line">        dxContext-&gt;OMSetBlendState(states.blendState, states.blendFactor, states.sampleMask);</div>
<div class="line">        states.blendState-&gt;Release();</div>
<div class="line">        states.blendState = NULL;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Update any parameters on shader</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::updateParameters( <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context, <a class="code" href="./class_m_uniform_parameter_list.html">MUniformParameterList</a>&amp; uniformParameters, ResourceTextureMap &amp;resourceTexture, ERenderType renderType )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="comment">// If the render frame stamp did not change, it's likely that this shader is used by multiple objects,</span></div>
<div class="line"> <span class="comment">// and is called more than once in a single frame render.</span></div>
<div class="line"> <span class="comment">// No need to update the light parameters (again) as it's quite costly</span></div>
<div class="line"> <span class="keywordtype">bool</span> updateLightParameters = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> updateViewParams = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> updateTextures = fForceUpdateTexture;</div>
<div class="line"> <span class="keywordflow">if</span>(isRenderScene(renderType))</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// We are rendering the scene</span></div>
<div class="line">        MUint64 currentFrameStamp = context.<a name="a352"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#ac9d36cff81e99e1fb66d9e162b97ecfb">getFrameStamp</a>();</div>
<div class="line">        updateLightParameters = (currentFrameStamp != fLastFrameStamp);</div>
<div class="line">        updateViewParams = (currentFrameStamp != fLastFrameStamp);</div>
<div class="line">        fLastFrameStamp = currentFrameStamp;</div>
<div class="line">        fForceUpdateTexture = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html">MHWRender::MPassContext</a> &amp; passCtx = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#ad3f9422688a9ffbe815c374ece46c1ea">getPassContext</a>();</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string_array.html">MStringArray</a> &amp; passSem = passCtx.<a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a9737189d5cfffd795336d711a678d627">passSemantics</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (passSem.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 1 &amp;&amp; passSem[0] == <a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a728fc00f0764227a6f345c089058c998">MHWRender::MPassContext::kSelectionPassSemantic</a>)</div>
<div class="line">            updateLightParameters = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>(isRenderSwatch(renderType))</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// We are rendering the swatch using current effect</span></div>
<div class="line"> <span class="comment">// Reset the renderId, to be sure that the next updateParameters() will go through</span></div>
<div class="line">        fLastFrameStamp = (MUint64)-1;</div>
<div class="line">        fForceUpdateTexture = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// We are rendering the proxy swatch or the uv texture (temporary effect)</span></div>
<div class="line">        fLastFrameStamp = (MUint64)-1;</div>
<div class="line">        updateLightParameters = <span class="keyword">false</span>;</div>
<div class="line"> <span class="comment">// We need to update the texture when rendering the swatch or uv texture using a custom effect</span></div>
<div class="line">        updateTextures = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> updateTransparencyTextures = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#a26785cadef1a01dd4c02c67901a11dd8">MHWRender::MFrameContext::TransparencyAlgorithm</a> transAlg = context.<a name="a353"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#a5246f5d3ae4c7f8c7d785502a720f07c">getTransparencyAlgorithm</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (transAlg == <a name="a354"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#a26785cadef1a01dd4c02c67901a11dd8aaa978d4c34ec301d5213210b7b81bf30">MHWRender::MFrameContext::kDepthPeeling</a> || transAlg == <a name="a355"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#a26785cadef1a01dd4c02c67901a11dd8a6ae420ddf8bd05ffe6173339dcdc78e2">MHWRender::MFrameContext::kWeightedAverage</a>)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span>( isRenderScene(renderType) &amp;&amp; techniqueIsTransparent() &amp;&amp; techniqueSupportsAdvancedTransparency())</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html">MHWRender::MPassContext</a> &amp; passCtx = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#ad3f9422688a9ffbe815c374ece46c1ea">getPassContext</a>();</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string_array.html">MStringArray</a> &amp; passSemantics = passCtx.<a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a9737189d5cfffd795336d711a678d627">passSemantics</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; passSemantics.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &amp;&amp; !updateTransparencyTextures; ++i)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; semantic = passSemantics[i];</div>
<div class="line"> <span class="keywordflow">if</span>( semantic == <a name="a356"></a><a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a9160078f7d16515ce7b689a7e0356c90">MHWRender::MPassContext::kTransparentPeelSemantic</a> ||</div>
<div class="line">                    semantic == <a name="a357"></a><a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#ad9f3e908d48e77144e99c804074485b1">MHWRender::MPassContext::kTransparentPeelAndAvgSemantic</a> ||</div>
<div class="line">                    semantic == <a name="a358"></a><a class="code" href="./class_m_h_w_render_1_1_m_pass_context.html#a70c9d0658fe61e3154bb60cb40daf2a2">MHWRender::MPassContext::kTransparentWeightedAvgSemantic</a>)</div>
<div class="line">                {</div>
<div class="line">                    updateTransparencyTextures = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">    All parameters that are driven by a light and require an update first get</span></div>
<div class="line"><span class="comment">    refreshed using the value stored in the uniform parameter. This helper</span></div>
<div class="line"><span class="comment">    function will populate the set of parameters that need to be reset.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The set will contain all light parameters that a part of a light group</span></div>
<div class="line"><span class="comment">    that was marked as dirty either because a value changed, or because the</span></div>
<div class="line"><span class="comment">    lighting sources have changed (like when going from swatch render back</span></div>
<div class="line"><span class="comment">    to scene render).</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    std::set&lt;int&gt; lightParametersToUpdate;</div>
<div class="line"> <span class="keywordflow">if</span>(updateLightParameters)</div>
<div class="line">    {</div>
<div class="line">        getLightParametersToUpdate(lightParametersToUpdate, renderType);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update parameters that are driven by Global Viewport parameters, like full viewport Gamma Correction:</span></div>
<div class="line"> <span class="keywordflow">if</span> (updateViewParams)</div>
<div class="line">    {</div>
<div class="line">        updateViewportGlobalParameters( context );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update uniform values</span></div>
<div class="line"> <span class="comment">// -------------------------------------</span></div>
<div class="line">    D3DX11_EFFECT_TYPE_DESC descType;</div>
<div class="line">    memset(&amp;descType, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_TYPE_DESC));</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">int</span> u = uniformParameters.<a class="code" href="./class_m_uniform_parameter_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>(); u--; ) {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = uniformParameters.<a class="code" href="./class_m_uniform_parameter_list.html#a6a79ec55a70b556044955e86cb48d609">getElement</a>(u);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( uniform.<a class="code" href="./class_m_uniform_parameter.html#a9d4d257e5bb7e85eb9fdeca499dc9361">hasChanged</a>(context) || lightParametersToUpdate.count(u) || (updateTextures &amp;&amp; uniform.<a class="code" href="./class_m_uniform_parameter.html#a37357b066d4c628b1fae2f1ee08b2b12">isATexture</a>()) ) {</div>
<div class="line"></div>
<div class="line">            ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!effectVariable)  <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">            effectVariable-&gt;GetType()-&gt;GetDesc(&amp;descType);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span>( uniform.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>()) {</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a>: {</div>
<div class="line"> <span class="keywordflow">if</span> (uniform.<a name="a359"></a><a class="code" href="./class_m_uniform_parameter.html#ab2fb525ee83e7211d9cce975f9224047">semantic</a>() == <a name="a360"></a><a class="code" href="./class_m_uniform_parameter.html#ae2d1a7ca98deaf6f6acd790af2e234efae3e697f1682b81aab2f7b1e205ece4df">MUniformParameter::kSemanticViewportPixelSize</a>) {</div>
<div class="line"> <span class="keywordtype">int</span> width, height;</div>
<div class="line">                        context.<a name="a361"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a84f8e099a466341238b4b4e40cde4167">getRenderTargetSize</a>(width, height);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> data[] = { (float)width, (<span class="keywordtype">float</span>)height };</div>
<div class="line">                        effectVariable-&gt;AsVector()-&gt;SetFloatVector( data );</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (uniform.<a class="code" href="./class_m_uniform_parameter.html#ab2fb525ee83e7211d9cce975f9224047">semantic</a>() == <a name="a362"></a><a class="code" href="./class_m_uniform_parameter.html#ae2d1a7ca98deaf6f6acd790af2e234efaea6ef2e23bb54f3a8cbe2ee20f806b81">MUniformParameter::kSemanticNearClipPlane</a>) {</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status = MS::kSuccess;</div>
<div class="line"> <a name="_a363"></a><a class="code" href="./class_m_double_array.html">MDoubleArray</a> tuple = context.<a name="a364"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a3a2746b602eb8dd543fa0a74497614d1">getTuple</a>(MFrameContext::kViewNearClipValue, &amp;status);</div>
<div class="line"> <span class="keywordtype">float</span> data = status ? tuple[0] : 0.1f ;</div>
<div class="line">                        effectVariable-&gt;AsScalar()-&gt;SetFloat( data );</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (uniform.<a class="code" href="./class_m_uniform_parameter.html#ab2fb525ee83e7211d9cce975f9224047">semantic</a>() == <a name="a365"></a><a class="code" href="./class_m_uniform_parameter.html#ae2d1a7ca98deaf6f6acd790af2e234efa4cc42ecfffec0584e050a06153497a8b">MUniformParameter::kSemanticFarClipPlane</a>) {</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status = MS::kSuccess;</div>
<div class="line"> <a class="code" href="./class_m_double_array.html">MDoubleArray</a> tuple = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a3a2746b602eb8dd543fa0a74497614d1">getTuple</a>(MFrameContext::kViewFarClipValue, &amp;status);</div>
<div class="line"> <span class="keywordtype">float</span> data = status ? tuple[0] : 10000.0f ;</div>
<div class="line">                        effectVariable-&gt;AsScalar()-&gt;SetFloat( data );</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* data = uniform.<a name="a366"></a><a class="code" href="./class_m_uniform_parameter.html#adeb3f26c0cb456d9028fb6e6d71cc51a">getAsFloatArray</a>(context);</div>
<div class="line"> <span class="keywordflow">if</span> (data) {</div>
<div class="line"> <span class="keywordflow">if</span> (descType.Class == D3D10_SVC_SCALAR) {</div>
<div class="line">                                effectVariable-&gt;AsScalar()-&gt;SetFloat( data[0] );</div>
<div class="line">                            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (descType.Class == D3D10_SVC_VECTOR) {</div>
<div class="line">                                effectVariable-&gt;AsVector()-&gt;SetFloatVector( (<span class="keywordtype">float</span>*)data );</div>
<div class="line">                            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (descType.Class == D3D10_SVC_MATRIX_COLUMNS) {</div>
<div class="line">                                effectVariable-&gt;AsMatrix()-&gt;SetMatrix( (<span class="keywordtype">float</span>*)data );</div>
<div class="line">                            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (descType.Class == D3D10_SVC_MATRIX_ROWS) {</div>
<div class="line">                                effectVariable-&gt;AsMatrix()-&gt;SetMatrixTranspose( (<span class="keywordtype">float</span>*)data );</div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// @@@@@ Error ?!?!</span></div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a367"></a><a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ab6e6fe667e0718b58ca5f6ac419c7cf7">MUniformParameter::kTypeInt</a>:</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a368"></a><a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6af9dad01c655cbd183b93acbd5fcaf72d">MUniformParameter::kTypeEnum</a>:</div>
<div class="line">                    {</div>
<div class="line"> <span class="keywordflow">if</span> (descType.Class == D3D10_SVC_SCALAR) {</div>
<div class="line">                        effectVariable-&gt;AsScalar()-&gt;SetInt( uniform.<a name="a369"></a><a class="code" href="./class_m_uniform_parameter.html#ac4394d7d6b3a9352b2aa83b77b3cac8e">getAsInt</a>(context) );</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// @@@@@ Error ?!?!</span></div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6a52b0938c028df56b62bc9e9080475e7f">MUniformParameter::kTypeBool</a>: {</div>
<div class="line"> <span class="keywordflow">if</span> (descType.Class == D3D10_SVC_SCALAR) {</div>
<div class="line">                        effectVariable-&gt;AsScalar()-&gt;SetBool( uniform.<a name="a370"></a><a class="code" href="./class_m_uniform_parameter.html#a528943f9cbfb601fc64e343a3e7072ec">getAsBool</a>(context) );</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// @@@@@ Error ?!?!</span></div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a name="a371"></a><a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6a00d1e209478ab74cbadfbe8435e32e81">MUniformParameter::kTypeString</a>: {</div>
<div class="line"> <span class="comment">// @@@@@ Error ?!?!</span></div>
<div class="line">                } <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>: {</div>
<div class="line"> <span class="keywordflow">if</span>( uniform.<a class="code" href="./class_m_uniform_parameter.html#a37357b066d4c628b1fae2f1ee08b2b12">isATexture</a>()) {</div>
<div class="line">                        ID3DX11EffectShaderResourceVariable* resourceVar = effectVariable-&gt;AsShaderResource();</div>
<div class="line"> <span class="keywordflow">if</span> (resourceVar) {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html#ae2d1a7ca98deaf6f6acd790af2e234ef">MUniformParameter::DataSemantic</a> sem = uniform.<a class="code" href="./class_m_uniform_parameter.html#ab2fb525ee83e7211d9cce975f9224047">semantic</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (sem == <a name="a372"></a><a class="code" href="./class_m_uniform_parameter.html#ae2d1a7ca98deaf6f6acd790af2e234efa812025dab4ab6e8be46ea315d6a84714">MUniformParameter::kSemanticTranspDepthTexture</a>) {</div>
<div class="line"> <span class="keywordflow">if</span>(updateTransparencyTextures) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a> *tex = context.<a name="a373"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#ae73c53b8f05ae3a36dfb3716a7b67f7a">getInternalTexture</a>(</div>
<div class="line"> <a name="a374"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a609137988e7f98d815cb896e0b9f5687a595431c5b1fde4070f7044d413776959">MHWRender::MDrawContext::kDepthPeelingTranspDepthTexture</a>);</div>
<div class="line"> <span class="keywordflow">if</span> (tex) {</div>
<div class="line">                                        resourceVar-&gt;SetResource((ID3D11ShaderResourceView*)tex-&gt;<a name="a375"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture.html#ad7bcab0d1707ef0da22fc72ada62c40e">resourceHandle</a>());</div>
<div class="line">                                    }</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sem == <a name="a376"></a><a class="code" href="./class_m_uniform_parameter.html#ae2d1a7ca98deaf6f6acd790af2e234efa539b874523c9051e0d0b5c56e0864bd8">MUniformParameter::kSemanticOpaqueDepthTexture</a>) {</div>
<div class="line"> <span class="keywordflow">if</span>(updateTransparencyTextures) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a> *tex = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#ae73c53b8f05ae3a36dfb3716a7b67f7a">getInternalTexture</a>(</div>
<div class="line"> <a name="a377"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a609137988e7f98d815cb896e0b9f5687aa01e0dd3ae5219a692110a1f48c48c5d">MHWRender::MDrawContext::kDepthPeelingOpaqueDepthTexture</a>);</div>
<div class="line"> <span class="keywordflow">if</span> (tex) {</div>
<div class="line">                                        resourceVar-&gt;SetResource((ID3D11ShaderResourceView*)tex-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_texture.html#ad7bcab0d1707ef0da22fc72ada62c40e">resourceHandle</a>());</div>
<div class="line">                                    }</div>
<div class="line">                                }</div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> textureName, layerName;</div>
<div class="line"> <span class="keywordtype">int</span> alphaChannelIdx;</div>
<div class="line">                                getTextureDesc(context, uniform, textureName, layerName, alphaChannelIdx);                              </div>
<div class="line">                                assignTexture(resourceVar, textureName, layerName, alphaChannelIdx, resourceTexture, uniform.<a class="code" href="./class_m_uniform_parameter.html#a000c434a3beb6c2cc9681d9e445cf0eb">getSource</a>().<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>());   </div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(updateLightParameters)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Update using draw context properties if light is explicitely connected.</span></div>
<div class="line"> <span class="comment">// Must be done after we have reset lights to their previous values as</span></div>
<div class="line"> <span class="comment">// explicit light connections overrides values stored in shader:</span></div>
<div class="line">        updateExplicitLightConnections(context, renderType);</div>
<div class="line"></div>
<div class="line">        updateImplicitLightConnections(context, renderType);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::updateOverrideNonMaterialItemParameters( <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* item, RenderItemDesc&amp; renderItemDesc )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span> (!item || item-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a34f68c9a676a4fce3e56c3ec86b2c319">type</a>() != <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49ea1fcf574a73eba1a959c51838083573e4">MHWRender::MRenderItem::OverrideNonMaterialItem</a>)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size;</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> defaultColorParameter(<span class="stringliteral">"defaultColor"</span>);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* defaultColor = item-&gt;<a name="a378"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a70a11ae313e27dea9015dbf7baf58428">getShaderFloatArrayParameter</a>(defaultColorParameter, size);</div>
<div class="line"> <span class="keywordflow">if</span>(defaultColor &amp;&amp; size == 4) {</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> solidColorUniform(<span class="stringliteral">"gsSolidColor"</span>);</div>
<div class="line">            ID3DX11EffectVariable* effectVariable = findEffectVariable(fUniformParameters, solidColorUniform, <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a>, D3D10_SVC_VECTOR);</div>
<div class="line"> <span class="keywordflow">if</span>( effectVariable != NULL ) {</div>
<div class="line">                effectVariable-&gt;AsVector()-&gt;SetFloatVector( defaultColor );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MHWRender::MGeometry::Primitive</a> primitive = item-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#af3ddb45109547883d06426f0530ddf0c">primitive</a>();</div>
<div class="line"> <span class="keywordflow">if</span>( primitive == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea9808e481c6346dfc333afb4c52890ac9">MHWRender::MGeometry::kLines</a> || primitive == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea505d8b3b6fdcadeb908f49f661e66957">MHWRender::MGeometry::kLineStrip</a> ) {</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> lineWidthParameter(<span class="stringliteral">"lineWidth"</span>);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* lineWidth = item-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a70a11ae313e27dea9015dbf7baf58428">getShaderFloatArrayParameter</a>(lineWidthParameter, size);</div>
<div class="line"> <span class="keywordflow">if</span>(lineWidth &amp;&amp; size == 2 &amp;&amp; lineWidth[0] &gt; 1.f &amp;&amp; lineWidth[1] &gt; 1.f) {</div>
<div class="line">            renderItemDesc.isFatLine = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> fatLineWidthUniform(<span class="stringliteral">"gsFatLineWidth"</span>);</div>
<div class="line">            ID3DX11EffectVariable* effectVariable = findEffectVariable(fUniformParameters, fatLineWidthUniform, <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a>, D3D10_SVC_VECTOR);</div>
<div class="line"> <span class="keywordflow">if</span>( effectVariable != NULL ) {</div>
<div class="line">                effectVariable-&gt;AsVector()-&gt;SetFloatVector( lineWidth );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>( primitive == <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1ea57a311fc6dd7498f2339ab45af414377">MHWRender::MGeometry::kPoints</a> ) {</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> pointSizeParameter(<span class="stringliteral">"pointSize"</span>);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* pointSize = item-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a70a11ae313e27dea9015dbf7baf58428">getShaderFloatArrayParameter</a>(pointSizeParameter, size);</div>
<div class="line"> <span class="keywordflow">if</span>(pointSize &amp;&amp; size == 2 &amp;&amp; pointSize[0] &gt; 1.f &amp;&amp; pointSize[1] &gt; 1.f) {</div>
<div class="line">            renderItemDesc.isFatPoint = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> fatPointSizeUniform(<span class="stringliteral">"gsFatPointSize"</span>);</div>
<div class="line">            ID3DX11EffectVariable* effectVariable = findEffectVariable(fUniformParameters, fatPointSizeUniform, <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a>, D3D10_SVC_VECTOR);</div>
<div class="line"> <span class="keywordflow">if</span>( effectVariable != NULL ) {</div>
<div class="line">                effectVariable-&gt;AsVector()-&gt;SetFloatVector( pointSize );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::updateViewportGlobalParameters( <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>(fMayaGammaCorrectVar)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">bool</span> isGammaEnabled = context.<a name="a379"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#a1f7de24693b8d7be24a0624f9b970983">getPostEffectEnabled</a>( <a name="a380"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#aed6597b6ca26d0c599d1d9a004442e21a550bf52c4c647f45835f21ffbad9f095">MHWRender::MFrameContext::kGammaCorrection</a> );</div>
<div class="line">        fMayaGammaCorrectVar-&gt;AsScalar()-&gt;SetBool( isGammaEnabled );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Hardware Fog Staff</span></div>
<div class="line"> <span class="keywordflow">if</span> (fMayaHwFogEnabled)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a381"></a><a class="code" href="./struct_m_h_w_render_1_1_m_frame_context_1_1_hw_fog_params.html">MHWRender::MFrameContext::HwFogParams</a> hwFogParams = context.<a name="a382"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#aa4e74730699e09cec07f3b59fd2679e8">getHwFogParameters</a>();</div>
<div class="line">        fMayaHwFogEnabled-&gt;AsScalar()-&gt;SetBool( hwFogParams.<a name="a383"></a><a class="code" href="./struct_m_h_w_render_1_1_m_frame_context_1_1_hw_fog_params.html#ae127077f7a1eda466f6837a3a1dc8277">HwFogEnabled</a> );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fMayaHwFogMode)</div>
<div class="line">            fMayaHwFogMode-&gt;AsScalar()-&gt;SetInt( hwFogParams.<a name="a384"></a><a class="code" href="./struct_m_h_w_render_1_1_m_frame_context_1_1_hw_fog_params.html#aa283269f91a1d2ddac0f0af5a485ff39">HwFogMode</a> );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fMayaHwFogStart)</div>
<div class="line">            fMayaHwFogStart-&gt;AsScalar()-&gt;SetFloat( hwFogParams.<a name="a385"></a><a class="code" href="./struct_m_h_w_render_1_1_m_frame_context_1_1_hw_fog_params.html#aab8b5ae43dd8979294e7a9e933be5934">HwFogStart</a> );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fMayaHwFogEnd)</div>
<div class="line">            fMayaHwFogEnd-&gt;AsScalar()-&gt;SetFloat( hwFogParams.<a name="a386"></a><a class="code" href="./struct_m_h_w_render_1_1_m_frame_context_1_1_hw_fog_params.html#a2080b4810338eb92be71796f16e547d5">HwFogEnd</a> );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fMayaHwFogDensity)</div>
<div class="line">            fMayaHwFogDensity-&gt;AsScalar()-&gt;SetFloat( hwFogParams.<a name="a387"></a><a class="code" href="./struct_m_h_w_render_1_1_m_frame_context_1_1_hw_fog_params.html#ab98580d56f9bccc16b7ab408055774e3">HwFogDensity</a> );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fMayaHwFogColor)</div>
<div class="line">            fMayaHwFogColor-&gt;AsVector()-&gt;SetFloatVector(&amp;hwFogParams.<a name="a388"></a><a class="code" href="./struct_m_h_w_render_1_1_m_frame_context_1_1_hw_fog_params.html#a145d982480d906036f1de9abd0eb6333">HwFogColor</a>[0]);</div>
<div class="line">    }   </div>
<div class="line"></div>
<div class="line"> <span class="comment">// Depth range update for point light shadow pass.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fDepthRange)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">float</span> vNear = 0.01f;</div>
<div class="line"> <span class="keywordtype">float</span> vFar = 100000.0f;</div>
<div class="line">        fDepthRange-&gt;AsScalar()-&gt;SetFloat(<span class="keywordtype">float</span>(vFar-vNear));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">The effect needs to compute shadows only if three conditions are met:</span></div>
<div class="line"><span class="comment">    1- Shadowcasting is globally enabled (Lighting-&gt;Shadow in view)</span></div>
<div class="line"><span class="comment">    2- The surface is illuminated by a light that creates shadows</span></div>
<div class="line"><span class="comment">    3- The surface is marked as receiving shadows</span></div>
<div class="line"><span class="comment">The first two conditions were detected and set in the effect when we</span></div>
<div class="line"><span class="comment">last refreshed the light parameters, but the last one depends on the</span></div>
<div class="line"><span class="comment">geometry being rendered and can change from one object to another one</span></div>
<div class="line"><span class="comment">in the draw list.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Here we store the parameter position of all attributes of "ShadowOn"</span></div>
<div class="line"><span class="comment">semantics along with the current value stored in the shader.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::initShadowFlagBackupState(TshadowFlagBackupState&amp; stateBackup )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span> (stateBackup.empty()) {</div>
<div class="line"> <span class="comment">// Build backup state with all current values of parameters with ShadowOn semantics:</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> shaderLightIndex = 0; shaderLightIndex &lt; fLightParameters.size(); ++shaderLightIndex )</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"></div>
<div class="line">            LightParameterInfo::TConnectableParameters::const_iterator it = shaderLightInfo.fConnectableParameters.begin();</div>
<div class="line">            LightParameterInfo::TConnectableParameters::const_iterator itEnd = shaderLightInfo.fConnectableParameters.end();</div>
<div class="line"> <span class="keywordflow">for</span> (; it != itEnd; ++it)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> parameterType  = it-&gt;second;</div>
<div class="line"> <span class="keywordflow">if</span> (parameterType == CUniformParameterBuilder::eLightShadowOn)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> parameterIndex = it-&gt;first;</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(parameterIndex);</div>
<div class="line">                    ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable) {</div>
<div class="line"><span class="preprocessor">#if defined(USE_BOOL)</span></div>
<div class="line">                        BOOL currentState;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> <span class="keywordtype">bool</span> currentState;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">                        effectVariable-&gt;AsScalar()-&gt;GetBool( &amp;currentState );</div>
<div class="line">                        stateBackup.insert(TshadowFlagBackupState::value_type(parameterIndex, currentState != 0));</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">Here we adjust the "ShadowON" parameter of all shader light groups</span></div>
<div class="line"><span class="comment">to take into account the "ReceivesShadow" state of the geometry</span></div>
<div class="line"><span class="comment">about to be rendered.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setPerGeometryShadowOnFlag(<span class="keywordtype">bool</span> receivesShadows, TshadowFlagBackupState&amp; stateBackup )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="comment">// Set the state of all ShadowOn parameters:</span></div>
<div class="line">    TshadowFlagBackupState::const_iterator it = stateBackup.begin();</div>
<div class="line">    TshadowFlagBackupState::const_iterator itEnd = stateBackup.end();</div>
<div class="line"> <span class="keywordflow">for</span> (; it != itEnd; ++it)</div>
<div class="line">    {</div>
<div class="line">        setParameterAsScalar(it-&gt;first, it-&gt;second &amp;&amp; receivesShadows);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Uniform and varying parameters</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::clearParameters()</div>
<div class="line">{</div>
<div class="line">    clearLightConnectionData();</div>
<div class="line"></div>
<div class="line">    fUniformParameters.setLength(0);</div>
<div class="line">    setUniformParameters( fUniformParameters, <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line">    fVaryingParametersUpdateId = 0;</div>
<div class="line">    fVaryingParameters.setLength(0);</div>
<div class="line">    setVaryingParameters( fVaryingParameters, <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line">    fTechniqueIsTransparent = eOpaque;</div>
<div class="line">    fOpacityPlugName = <span class="stringliteral">""</span>;</div>
<div class="line">    fTransparencyTestProcName = <span class="stringliteral">""</span>;</div>
<div class="line"></div>
<div class="line">    initMayaParameters();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Checks the shader for any parameters that affect Uniform Parameter creation.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::preBuildUniformParameterList()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!fEffect || !fTechnique) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// does the shader want us to use the variable name as maya attribute name (instead of UI name)?</span></div>
<div class="line">    fVariableNameAsAttributeName = <span class="keyword">true</span>;</div>
<div class="line">    getAnnotation(fTechnique, dx11ShaderAnnotation::kVariableNameAsAttributeName, fVariableNameAsAttributeName);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">Build the uniform parameter list by processing all the parameter information</span></div>
<div class="line"><span class="comment">stored in the effect. We let the CUniformParameterBuilder helper class take</span></div>
<div class="line"><span class="comment">care of extracting all the information, then we sort all parameters according</span></div>
<div class="line"><span class="comment">to a potentially defined UIOrder. This is also where we properly order the</span></div>
<div class="line"><span class="comment">UIGroups defined in the parameter annotations, and create the helper structure</span></div>
<div class="line"><span class="comment">that remembers which parameter belongs to which group.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::buildUniformParameterList()</div>
<div class="line">{</div>
<div class="line">    preBuildUniformParameterList();</div>
<div class="line"></div>
<div class="line">    setTopoDirty();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the effect description.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fEffect) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    D3DX11_EFFECT_DESC desc;</div>
<div class="line">    memset(&amp;desc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_DESC));</div>
<div class="line">    fEffect-&gt;GetDesc(&amp;desc);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Iterate the effect parameters, processing each one.</span></div>
<div class="line"> <span class="comment">// --------------------------------------------------------------</span></div>
<div class="line">    fUniformParameters.setLength(0);</div>
<div class="line">    std::vector&lt; CUniformParameterBuilder &gt; builders;</div>
<div class="line">    std::vector&lt; CUniformParameterBuilder* &gt; successfulBuilder;</div>
<div class="line">    builders.resize(desc.GlobalVariables);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; desc.GlobalVariables; i++)</div>
<div class="line">    {</div>
<div class="line">        ID3DX11EffectVariable* pD3DVar = fEffect-&gt;GetVariableByIndex(i);</div>
<div class="line">        CUniformParameterBuilder&amp; builder = builders[i];</div>
<div class="line">        builder.init(pD3DVar,<span class="keyword">this</span>,i);</div>
<div class="line"> <span class="keywordflow">if</span>(builder.build())</div>
<div class="line">        {</div>
<div class="line">            successfulBuilder.push_back(&amp;builder);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            fWarningLog += builder.getWarnings();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    std::sort(successfulBuilder.begin(),successfulBuilder.end(),CUniformParameterBuilder::compareUIOrder );</div>
<div class="line"></div>
<div class="line">    fUIGroupParameters.clear();</div>
<div class="line">    fUIGroupParameters.resize(fUIGroupNames.length());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// All the groups were initially added in the same order as</span></div>
<div class="line"> <span class="comment">// they were returned from the compiler. We want them to be</span></div>
<div class="line"> <span class="comment">// sorted by UIOrder instead:</span></div>
<div class="line">    std::vector&lt;int&gt; uiGroupRemapping;</div>
<div class="line">    uiGroupRemapping.resize(fUIGroupNames.length(), -1);</div>
<div class="line"> <span class="keywordtype">int</span> numRemapped = 0;</div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> sortedUIGroupNames;</div>
<div class="line"></div>
<div class="line">    std::vector&lt; CUniformParameterBuilder* &gt;::iterator iter = successfulBuilder.<a class="code" href="./class_m_string_array.html#a1ebac8c16ac95b2b81d78055841992f3">begin</a>();</div>
<div class="line"> <span class="keywordflow">for</span>(; iter != successfulBuilder.end();++iter)</div>
<div class="line">    {</div>
<div class="line">        CUniformParameterBuilder* pBuilder(*iter);</div>
<div class="line">        fUniformParameters.append(pBuilder-&gt;getParameter());</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> uiGroupIndex = pBuilder-&gt;getUIGroupIndex();</div>
<div class="line"> <span class="keywordflow">if</span> (uiGroupIndex &gt;= 0)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (uiGroupRemapping[uiGroupIndex] == -1) {</div>
<div class="line">                sortedUIGroupNames.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>(fUIGroupNames[(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)uiGroupIndex]);</div>
<div class="line">                uiGroupRemapping[uiGroupIndex] = numRemapped;</div>
<div class="line">                ++numRemapped;</div>
<div class="line">            }</div>
<div class="line">            uiGroupIndex = uiGroupRemapping[uiGroupIndex];</div>
<div class="line"></div>
<div class="line">            fUIGroupParameters[uiGroupIndex].push_back(fUniformParameters.length() - 1);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    fUIGroupNames = sortedUIGroupNames;</div>
<div class="line"></div>
<div class="line">    updateImplicitLightParameterCache( successfulBuilder);</div>
<div class="line">    displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Parse through the current technique.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    For the current technique parse through the passes and for each pass extract out the required layout</span></div>
<div class="line"><span class="comment">    to use at draw time.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    For all pass on a technique we need the combined format to be returned as the vertex requirement.</span></div>
<div class="line"><span class="comment">    We can keep a set of MVertexBufferDescriptors for this (one per technique).</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The varying parameters are used by Maya to produce the required vertex buffers,</span></div>
<div class="line"><span class="comment">    and during the rendering to activate the necessary buffers and build the input layout</span></div>
<div class="line"><span class="comment">    that matches the current pass being processed.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::buildVaryingParameterList()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!fEffect) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fVaryingParametersUpdateId = 0;</div>
<div class="line">    fVaryingParameters.setLength(0);</div>
<div class="line"></div>
<div class="line">    ID3DX11EffectTechnique* dxTechnique = fEffect-&gt;GetTechniqueByIndex( fTechniqueIdx );</div>
<div class="line"> <span class="keywordflow">if</span> (dxTechnique)</div>
<div class="line">    {</div>
<div class="line">        D3DX11_TECHNIQUE_DESC descTechnique;</div>
<div class="line">        memset(&amp;descTechnique, 0, <span class="keyword">sizeof</span>(D3DX11_TECHNIQUE_DESC));</div>
<div class="line">        dxTechnique-&gt;GetDesc(&amp;descTechnique);</div>
<div class="line"></div>
<div class="line">        ::buildVaryingParameterList(dxTechnique, descTechnique.Passes, fVaryingParameters, fErrorLog, fWarningLog, fTechniqueIndexBufferType);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    buildVertexDescriptorFromVaryingParameters();</div>
<div class="line">    displayErrorAndWarnings();</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span>  dx11ShaderNode::buildVertexDescriptorFromVaryingParameters()</div>
<div class="line">{</div>
<div class="line">    fVaryingParametersVertexDescriptorList.clear();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;fVaryingParameters.length(); i++) {</div>
<div class="line"> <a class="code" href="./class_m_varying_parameter.html">MVaryingParameter</a> varying = fVaryingParameters.<a class="code" href="./class_m_varying_parameter.html#a40cde1a792fb9a978d3a3a68414fb865">getElement</a>(i);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We need to find all the vertexbuffer requirements</span></div>
<div class="line"> <span class="comment">// they are based on the source of the Varying parameter</span></div>
<div class="line"> <span class="comment">// i.e We will have to use the right source to set in the right</span></div>
<div class="line"> <span class="comment">// final shader destination</span></div>
<div class="line"> <span class="comment">// -----------------------------------------------------</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4">MHWRender::MGeometry::Semantic</a>  sourceSemantic  = getVertexBufferSemantic(varying.<a class="code" href="./class_m_varying_parameter.html#ad72ff2b3fb20052e4a2455dad5c10682">getSourceType</a>());</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> semanticName = varying.<a class="code" href="./class_m_varying_parameter.html#a0ad0ec4f7ace0e9abc7efc5853bf82b6">semanticName</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// generate the right name for the binding of the vertex buffer to the righ data source</span></div>
<div class="line"> <span class="comment">// based on the data adjust to the right source</span></div>
<div class="line"> <span class="comment">// -------------------------------------------------------------------------------------</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> sourceSetName   = varying.<a class="code" href="./class_m_varying_parameter.html#a45e2132632639698f9c4f668be933a70">getSourceSetName</a>();</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a> desc(</div>
<div class="line">            sourceSetName,</div>
<div class="line">            sourceSemantic,</div>
<div class="line">            (<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MHWRender::MGeometry::DataType</a>) varying.<a class="code" href="./class_m_varying_parameter.html#ac5bc75c68e4af65e137a099a49e299af">type</a>(),</div>
<div class="line">            varying.<a class="code" href="./class_m_varying_parameter.html#ae5acbe47d704ceb866e3717e2ac9422f">dimension</a>());</div>
<div class="line">        desc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#a1d51bb626fca50378067f40d1d1ce89e">setSemanticName</a>(semanticName);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Do not create extra vertex buffers if we have multiple UV</span></div>
<div class="line"> <span class="comment">// that can be mapped to the same one:</span></div>
<div class="line"> <span class="keywordtype">bool</span> addDescriptor = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iVB=0; iVB &lt; fVaryingParametersVertexDescriptorList.length(); ++iVB) {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MHWRender::MVertexBufferDescriptor</a> existingDesc;</div>
<div class="line">            fVaryingParametersVertexDescriptorList.getDescriptor(iVB, existingDesc);</div>
<div class="line"> <span class="keywordflow">if</span> (existingDesc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aca2cba4630391c78dcf1a828986160da">name</a>() == desc.name() &amp;&amp;</div>
<div class="line">                existingDesc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>() == desc.semantic() &amp;&amp;</div>
<div class="line">                existingDesc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aec39ee3496166457d1ccdf73c8d1a3b2">semanticName</a>() == desc.semanticName() &amp;&amp;</div>
<div class="line">                existingDesc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc7588a483f61d3d4a1e8204ca14d6f6">dataType</a>() == desc.dataType() &amp;&amp;</div>
<div class="line">                existingDesc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#ae5acbe47d704ceb866e3717e2ac9422f">dimension</a>() == desc.dimension() &amp;&amp;</div>
<div class="line">                existingDesc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#aaa02ea556dee3025f49406b9d3fb662c">offset</a>() == desc.offset() &amp;&amp;</div>
<div class="line">                existingDesc.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#a2f0529f7f5ff03b8a26e3a3d1925bb2b">stride</a>() == desc.stride() )</div>
<div class="line">            {</div>
<div class="line">                addDescriptor = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">if</span> (addDescriptor)</div>
<div class="line">            fVaryingParametersVertexDescriptorList.append(desc);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef PRINT_DEBUG_INFO</span></div>
<div class="line">        fprintf(</div>
<div class="line">            stderr,</div>
<div class="line"> <span class="stringliteral">"PrepareVertexBuffer: Name(%s), SourceSemantics(%s)\n"</span>,</div>
<div class="line">            sourceSetName.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(),</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a19e106f192d0c974c6f5cdd3f07e3288">MHWRender::MGeometry::semanticString</a>(sourceSemantic).<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>()</div>
<div class="line">        );</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Identify uniform parameters with special semantic that are used for internal purpose:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    kBBoxExtraScale - controls the Maya internal bounding box extra scale.</span></div>
<div class="line"><span class="comment">        The parameter, visible in the Attribute Editor, will allow the user to increase the bounding box so that Maya</span></div>
<div class="line"><span class="comment">        will not clip the geometry when any displacement is set in the shader.</span></div>
<div class="line"><span class="comment">    kMayaSwatchRender - boolean parameter that can be used to identify if the shader is executed to render the swatch.</span></div>
<div class="line"><span class="comment">        The variable is set to true during the swatch render operation, and set to false once finished.</span></div>
<div class="line"><span class="comment">        The shader can then behave differently when rendering the scene and the swatch.</span></div>
<div class="line"><span class="comment">        This is currently used by the MayaUberShader to disable any displacement for the swatch.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::initMayaParameters()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Find the Bounding Box Extra Scale parameter</span></div>
<div class="line"> <span class="comment">// It's determined by the float parameter with semantic BoundingBoxExtraScale or an annotation BoundingBoxExtraScale set to True</span></div>
<div class="line"> <span class="keywordtype">bool</span> foundBBoxExtraScale = <span class="keyword">false</span>;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> bboxExtraScalePlugName;</div>
<div class="line"> <span class="keywordtype">float</span> bboxExtraScaleValueFromEffect = 0.0f;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the Maya Swatch Render parameter</span></div>
<div class="line"> <span class="comment">// It's determined by the bool parameter with semantic MayaSwatchRender</span></div>
<div class="line"> <span class="keywordtype">bool</span> foundMayaSwatchRender = <span class="keyword">false</span>;</div>
<div class="line">    fMayaSwatchRenderVar = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the Maya viewport Gamma Correction parameter</span></div>
<div class="line"> <span class="keywordtype">bool</span> foundMayaGammaCorrect = <span class="keyword">false</span>;</div>
<div class="line">    fMayaGammaCorrectVar = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the Maya Hardware Fog parameter</span></div>
<div class="line"> <span class="keywordtype">bool</span> foundMayaHwFogEnabled = <span class="keyword">false</span>;</div>
<div class="line">    fMayaHwFogEnabled = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> foundMayaHwFogMode = <span class="keyword">false</span>;</div>
<div class="line">    fMayaHwFogMode = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> foundMayaHwFogStart = <span class="keyword">false</span>;</div>
<div class="line">    fMayaHwFogStart = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> foundMayaHwFogEnd = <span class="keyword">false</span>;</div>
<div class="line">    fMayaHwFogEnd = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> foundMayaHwFogDensity = <span class="keyword">false</span>;</div>
<div class="line">    fMayaHwFogDensity = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> foundMayaHwFogColor = <span class="keyword">false</span>;</div>
<div class="line">    fMayaHwFogColor = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> foundDepthRange = <span class="keyword">false</span>;</div>
<div class="line">    fDepthRange = NULL;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find any shader parameters that may change the geo of the object on hardware</span></div>
<div class="line">    fShaderChangesGeo = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    fIgnoreLightLimits = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> paramCount = fUniformParameters.length();</div>
<div class="line"> <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; paramCount; ++i )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> param = fUniformParameters.getElement(i);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// look for BBoxExtraScale or MayaHwFogStart or MayaHwFogEnd or MayaHwFogDensity -- filter for float1 parameters</span></div>
<div class="line"> <span class="keywordflow">if</span> ((foundBBoxExtraScale == <span class="keyword">false</span> || </div>
<div class="line">            foundMayaHwFogStart == <span class="keyword">false</span> || </div>
<div class="line">            foundMayaHwFogEnd == <span class="keyword">false</span> || </div>
<div class="line">            foundMayaHwFogDensity == <span class="keyword">false</span>||</div>
<div class="line">            fDepthRange) &amp;&amp; </div>
<div class="line">            param.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a> &amp;&amp; </div>
<div class="line">            param.<a class="code" href="./class_m_uniform_parameter.html#ac7fba35931cc9a520837b0a752352e16">numElements</a>() == 1)</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)param.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(effectVariable)</div>
<div class="line">            {</div>
<div class="line">                D3DX11_EFFECT_VARIABLE_DESC varDesc;</div>
<div class="line">                memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_VARIABLE_DESC));</div>
<div class="line">                effectVariable-&gt;GetDesc(&amp;varDesc);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check semantic first</span></div>
<div class="line">                foundBBoxExtraScale = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kBboxExtraScale, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span> (foundBBoxExtraScale == <span class="keyword">false</span>)</div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// Then check annotation</span></div>
<div class="line"> <span class="keywordtype">bool</span> boolValue = 0;</div>
<div class="line">                    foundBBoxExtraScale = (getAnnotation(effectVariable, dx11ShaderSemantic::kBboxExtraScale, boolValue) &amp;&amp; boolValue);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (foundBBoxExtraScale)</div>
<div class="line">                {</div>
<div class="line">                    bboxExtraScalePlugName = param.<a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>().<a class="code" href="./class_m_plug.html#a58e7cf126b4fe51e9705cee4faaf59fc">name</a>();    <span class="comment">// get the plug name, might be different than the variable name</span></div>
<div class="line">                    effectVariable-&gt;AsScalar()-&gt;GetFloat( &amp;bboxExtraScaleValueFromEffect );</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                foundMayaHwFogStart = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kHwFogStart, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span> (foundMayaHwFogStart)</div>
<div class="line">                {</div>
<div class="line">                    fMayaHwFogStart = effectVariable;</div>
<div class="line">                    fMayaHwFogStart-&gt;AsScalar()-&gt;SetFloat( 0.0f );  <span class="comment">// reset to 0.0f by default</span></div>
<div class="line">                    param.<a name="a389"></a><a class="code" href="./class_m_uniform_parameter.html#ab5ef06b49e994b093b442788b96167d5">setUIHidden</a>(<span class="keyword">true</span>);    <span class="comment">// hide from UI</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                foundMayaHwFogEnd = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kHwFogEnd, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span> (foundMayaHwFogEnd)</div>
<div class="line">                {</div>
<div class="line">                    fMayaHwFogEnd = effectVariable;</div>
<div class="line">                    fMayaHwFogEnd-&gt;AsScalar()-&gt;SetFloat( 100.0f );  <span class="comment">// reset to 100.0f by default</span></div>
<div class="line">                    param.<a class="code" href="./class_m_uniform_parameter.html#ab5ef06b49e994b093b442788b96167d5">setUIHidden</a>(<span class="keyword">true</span>);    <span class="comment">// hide from UI</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                foundMayaHwFogDensity = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kHwFogDensity, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span> (foundMayaHwFogDensity)</div>
<div class="line">                {</div>
<div class="line">                    fMayaHwFogDensity = effectVariable;</div>
<div class="line">                    fMayaHwFogDensity-&gt;AsScalar()-&gt;SetFloat( 0.1f );    <span class="comment">// reset to 0.1f by default</span></div>
<div class="line">                    param.<a class="code" href="./class_m_uniform_parameter.html#ab5ef06b49e994b093b442788b96167d5">setUIHidden</a>(<span class="keyword">true</span>);    <span class="comment">// hide from UI</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                foundDepthRange = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kLightRange, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span> (foundDepthRange)</div>
<div class="line">                {</div>
<div class="line">                    fDepthRange = effectVariable;</div>
<div class="line">                    fDepthRange-&gt;AsScalar()-&gt;SetFloat( 100000.0f ); <span class="comment">// reset to 100000.0f by default</span></div>
<div class="line">                    param.<a class="code" href="./class_m_uniform_parameter.html#ab5ef06b49e994b093b442788b96167d5">setUIHidden</a>(<span class="keyword">true</span>);    <span class="comment">// hide from UI</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// look for MayaHwFogColor -- filter for float4 parameters</span></div>
<div class="line"> <span class="keywordflow">if</span> (foundMayaHwFogColor == <span class="keyword">false</span> &amp;&amp; </div>
<div class="line">            param.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a> &amp;&amp; </div>
<div class="line">            param.<a class="code" href="./class_m_uniform_parameter.html#ac7fba35931cc9a520837b0a752352e16">numElements</a>() == 4)</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)param.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(effectVariable)</div>
<div class="line">            {</div>
<div class="line">                D3DX11_EFFECT_VARIABLE_DESC varDesc;</div>
<div class="line">                memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_VARIABLE_DESC));</div>
<div class="line">                effectVariable-&gt;GetDesc(&amp;varDesc);</div>
<div class="line">                foundMayaHwFogColor = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kHwFogColor, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span> (foundMayaHwFogColor)</div>
<div class="line">                {</div>
<div class="line">                    fMayaHwFogColor = effectVariable;</div>
<div class="line"> <a name="_a390"></a><a class="code" href="./class_m_float_array.html">MFloatArray</a> fogColor;</div>
<div class="line">                    fogColor.<a name="a391"></a><a class="code" href="./class_m_float_array.html#a6d61a0ea5cd7a087db5ee81a990d4307">append</a>(0.5f);</div>
<div class="line">                    fogColor.<a class="code" href="./class_m_float_array.html#a6d61a0ea5cd7a087db5ee81a990d4307">append</a>(0.5f);</div>
<div class="line">                    fogColor.<a class="code" href="./class_m_float_array.html#a6d61a0ea5cd7a087db5ee81a990d4307">append</a>(0.5f);</div>
<div class="line">                    fogColor.<a class="code" href="./class_m_float_array.html#a6d61a0ea5cd7a087db5ee81a990d4307">append</a>(1.0f);</div>
<div class="line">                    fMayaHwFogColor-&gt;AsVector()-&gt;SetFloatVector(&amp;fogColor[0]);  <span class="comment">// reset to (0.5f, 0.5f, 0.5f, 1.0f) by default</span></div>
<div class="line">                    param.<a class="code" href="./class_m_uniform_parameter.html#ab5ef06b49e994b093b442788b96167d5">setUIHidden</a>(<span class="keyword">true</span>);    <span class="comment">// hide from UI</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// look for MayaSwatchRender or MayaGammaCorrection or MayaHwFogEnabled -- filter for bool parameters</span></div>
<div class="line"> <span class="keywordflow">if</span>( (foundMayaSwatchRender == <span class="keyword">false</span> || </div>
<div class="line">            foundMayaGammaCorrect == <span class="keyword">false</span> || </div>
<div class="line">            foundMayaHwFogEnabled == <span class="keyword">false</span>) &amp;&amp; </div>
<div class="line">            param.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6a52b0938c028df56b62bc9e9080475e7f">MUniformParameter::kTypeBool</a> &amp;&amp; </div>
<div class="line">            param.<a class="code" href="./class_m_uniform_parameter.html#ac7fba35931cc9a520837b0a752352e16">numElements</a>() == 1)</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)param.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(effectVariable)</div>
<div class="line">            {</div>
<div class="line">                D3DX11_EFFECT_VARIABLE_DESC varDesc;</div>
<div class="line">                memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_VARIABLE_DESC));</div>
<div class="line">                effectVariable-&gt;GetDesc(&amp;varDesc);</div>
<div class="line"></div>
<div class="line">                foundMayaSwatchRender = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kMayaSwatchRender, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span>(foundMayaSwatchRender)</div>
<div class="line">                {</div>
<div class="line">                    fMayaSwatchRenderVar = effectVariable;</div>
<div class="line">                    fMayaSwatchRenderVar-&gt;AsScalar()-&gt;SetBool( <span class="keyword">false</span> ); <span class="comment">// reset to false by default</span></div>
<div class="line">                    param.<a class="code" href="./class_m_uniform_parameter.html#ab5ef06b49e994b093b442788b96167d5">setUIHidden</a>(<span class="keyword">true</span>);    <span class="comment">// hide from UI</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                foundMayaGammaCorrect = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kMayaGammaCorrection, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span>(foundMayaGammaCorrect)</div>
<div class="line">                {</div>
<div class="line">                    fMayaGammaCorrectVar = effectVariable;</div>
<div class="line">                    fMayaGammaCorrectVar-&gt;AsScalar()-&gt;SetBool( <span class="keyword">false</span> ); <span class="comment">// reset to false by default</span></div>
<div class="line">                    param.<a class="code" href="./class_m_uniform_parameter.html#ab5ef06b49e994b093b442788b96167d5">setUIHidden</a>(<span class="keyword">true</span>);    <span class="comment">// hide from UI</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                foundMayaHwFogEnabled = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kHwFogEnabled, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span> (foundMayaHwFogEnabled)</div>
<div class="line">                {</div>
<div class="line">                    fMayaHwFogEnabled = effectVariable;</div>
<div class="line">                    fMayaHwFogEnabled-&gt;AsScalar()-&gt;SetBool( <span class="keyword">false</span> );    <span class="comment">// reset to false by default</span></div>
<div class="line">                    param.<a class="code" href="./class_m_uniform_parameter.html#ab5ef06b49e994b093b442788b96167d5">setUIHidden</a>(<span class="keyword">true</span>);    <span class="comment">// hide from UI</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// look for MayaHwFogMode -- filter for int parameters</span></div>
<div class="line"> <span class="keywordflow">if</span> (foundMayaHwFogMode == <span class="keyword">false</span> &amp;&amp; param.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ab6e6fe667e0718b58ca5f6ac419c7cf7">MUniformParameter::kTypeInt</a> &amp;&amp; param.<a class="code" href="./class_m_uniform_parameter.html#ac7fba35931cc9a520837b0a752352e16">numElements</a>() == 1)</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)param.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">            {</div>
<div class="line">                D3DX11_EFFECT_VARIABLE_DESC varDesc;</div>
<div class="line">                memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_VARIABLE_DESC));</div>
<div class="line">                effectVariable-&gt;GetDesc(&amp;varDesc);</div>
<div class="line">                foundMayaHwFogMode = ( varDesc.Semantic != NULL &amp;&amp; ::_stricmp(dx11ShaderSemantic::kHwFogMode, varDesc.Semantic) == 0 );</div>
<div class="line"> <span class="keywordflow">if</span> (foundMayaHwFogMode)</div>
<div class="line">                {</div>
<div class="line">                    fMayaHwFogMode = effectVariable;</div>
<div class="line">                    fMayaHwFogMode-&gt;AsScalar()-&gt;SetInt(0);  <span class="comment">// reset to 0 by default</span></div>
<div class="line">                    param.<a class="code" href="./class_m_uniform_parameter.html#ab5ef06b49e994b093b442788b96167d5">setUIHidden</a>(<span class="keyword">true</span>);    <span class="comment">// hide from UI</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// search parameters to see if anything is used in the shader that causes the shader to change the geo on hardware</span></div>
<div class="line"> <span class="keywordflow">if</span> ( fShaderChangesGeo == <span class="keyword">false</span> &amp;&amp; param.<a class="code" href="./class_m_uniform_parameter.html#ac52395416dfb965501c67061d7198c1c">type</a>() == <a class="code" href="./class_m_uniform_parameter.html#ad8ed01ff3ff33333d8e19db4d2818bb6ae59341821f9cdc0608d1f8775fb3eb7a">MUniformParameter::kTypeFloat</a> &amp;&amp; param.<a class="code" href="./class_m_uniform_parameter.html#ac7fba35931cc9a520837b0a752352e16">numElements</a>() == 1 )</div>
<div class="line">        {</div>
<div class="line">            ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)param.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(effectVariable)</div>
<div class="line">            {</div>
<div class="line">                D3DX11_EFFECT_VARIABLE_DESC varDesc;</div>
<div class="line">                memset(&amp;varDesc, 0, <span class="keyword">sizeof</span>(D3DX11_EFFECT_VARIABLE_DESC));</div>
<div class="line">                effectVariable-&gt;GetDesc(&amp;varDesc);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Is the 'Time' semantic used?</span></div>
<div class="line"> <span class="comment">// This may not always mean the geo is changed by the shader, but it is possible, so to be safe we flag the shader as changing geo</span></div>
<div class="line">                fShaderChangesGeo = (   varDesc.Semantic != NULL &amp;&amp;</div>
<div class="line">                                        ( ::_stricmp(dx11ShaderSemantic::kTime, varDesc.Semantic) == 0 ||</div>
<div class="line">                                          ::_stricmp(dx11ShaderSemantic::kAnimationTime, varDesc.Semantic) == 0 ||</div>
<div class="line">                                          ::_stricmp(dx11ShaderSemantic::kFrameNumber, varDesc.Semantic) == 0 ||</div>
<div class="line">                                          ::_stricmp(dx11ShaderSemantic::kFrame, varDesc.Semantic) == 0)</div>
<div class="line">                                    );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// early exit since we handled all known cases:</span></div>
<div class="line"> <span class="keywordflow">if</span>(foundBBoxExtraScale &amp;&amp; foundMayaSwatchRender &amp;&amp; foundMayaGammaCorrect &amp;&amp; fShaderChangesGeo)</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(bboxExtraScalePlugName.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Parameter not found, reset value</span></div>
<div class="line">        fBBoxExtraScalePlugName.clear();</div>
<div class="line">        fBBoxExtraScaleValue = 0.0f;</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fBBoxExtraScalePlugName = bboxExtraScalePlugName;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get value from effect only when current is invalid,</span></div>
<div class="line"> <span class="comment">// We don't want to overwrite the value on reload.</span></div>
<div class="line"> <span class="keywordflow">if</span>(fBBoxExtraScaleValue &lt; 1.0f)</div>
<div class="line">        fBBoxExtraScaleValue = bboxExtraScaleValueFromEffect;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Attibute Editor</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_string_array.html">MStringArray</a> dx11ShaderNode::getUIGroupParameters(<span class="keywordtype">int</span> uiGroupIndex)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> retVal;</div>
<div class="line"> <span class="keywordflow">if</span>(uiGroupIndex &lt; (<span class="keywordtype">int</span>)fUIGroupParameters.size())</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> std::vector&lt;int&gt; &amp;groupParams(fUIGroupParameters[uiGroupIndex]);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iParam=0; iParam &lt; groupParams.size(); ++iParam)</div>
<div class="line">        {</div>
<div class="line">            appendParameterNameIfVisible(groupParams[iParam], retVal);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> retVal;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Find out which index corresponds to a given a UI group name.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    This function is used first by the CUniformParameterBuilder to</span></div>
<div class="line"><span class="comment">    get the initial index for each distinct UI group, then, after the</span></div>
<div class="line"><span class="comment">    names are properly sorted in dx11ShaderNode::buildUniformParameterList</span></div>
<div class="line"><span class="comment">    we use this function to help the dx11Shader command parse out the</span></div>
<div class="line"><span class="comment">    UI group names.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">int</span> dx11ShaderNode::getIndexForUIGroupName(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; uiGroupName, <span class="keywordtype">bool</span> appendGroup) {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0;</div>
<div class="line"> <span class="comment">// Linear search in array is efficient for sizes less than 20.</span></div>
<div class="line"> <span class="keywordflow">for</span> ( ; index &lt; fUIGroupNames.length(); index++)</div>
<div class="line"> <span class="keywordflow">if</span> ( fUIGroupNames[index] == uiGroupName || sanitizeName(fUIGroupNames[index]) == uiGroupName)</div>
<div class="line"> <span class="keywordflow">return</span> index;</div>
<div class="line"> <span class="keywordflow">if</span> (appendGroup)</div>
<div class="line">    {</div>
<div class="line">        fUIGroupNames.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>(uiGroupName);</div>
<div class="line"> <span class="keywordflow">return</span> index;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Helper function used by the AE via the dx11Shader command to</span></div>
<div class="line"><span class="comment">    know which light is currently driving a light group. For</span></div>
<div class="line"><span class="comment">    explicitly connected lights, we follow the connection to the</span></div>
<div class="line"><span class="comment">    light shape. For implicit lights, we check if we have a cached</span></div>
<div class="line"><span class="comment">    light in the light info structure.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code" href="./class_m_string.html">MString</a> dx11ShaderNode::getLightConnectionInfo(<span class="keywordtype">int</span> lightIndex)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span>(lightIndex &lt; (<span class="keywordtype">int</span>)fLightParameters.size())</div>
<div class="line">    {</div>
<div class="line">        LightParameterInfo&amp; currLight = fLightParameters[lightIndex];</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> thisDependNode;</div>
<div class="line">        thisDependNode.<a class="code" href="./class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>(thisMObject());</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> thisLightConnectionPlug = thisDependNode.<a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(currLight.fAttrConnectedLight, <span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (thisLightConnectionPlug.<a name="a392"></a><a class="code" href="./class_m_plug.html#a40a52cd1e2411064f234ac9a6559385b">isConnected</a>())</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Find the light connected as source to this plug:</span></div>
<div class="line"> <a class="code" href="./class_m_plug_array.html">MPlugArray</a> srcCnxArray;</div>
<div class="line">            thisLightConnectionPlug.<a name="a393"></a><a class="code" href="./class_m_plug.html#acf1340576a4a0a78a0045e67ee4155bf">connectedTo</a>(srcCnxArray,<span class="keyword">true</span>,<span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (srcCnxArray.<a name="a394"></a><a class="code" href="./class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0)</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> sourcePlug = srcCnxArray[0];</div>
<div class="line"> <a name="_a395"></a><a class="code" href="./class_m_dag_path.html">MDagPath</a> sourcePath;</div>
<div class="line"> <a name="a396"></a><a class="code" href="./class_m_dag_path.html#a422aa5ec02565f757c13fe2873ed25d7">MDagPath::getAPathTo</a>(sourcePlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), sourcePath);</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> sourceTransform;</div>
<div class="line">                sourceTransform.<a class="code" href="./class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>(sourcePath.<a name="a397"></a><a class="code" href="./class_m_dag_path.html#a13f88add2c589379a22d5aaaa4a39fb4">transform</a>());</div>
<div class="line"> <span class="keywordflow">return</span> sourceTransform.name();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If light is currently cached, also return it:</span></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> useImplicitPlug = thisDependNode.<a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>( currLight.fAttrUseImplicit, <span class="keyword">false</span> );</div>
<div class="line"> <span class="keywordflow">if</span>( !useImplicitPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() ) {</div>
<div class="line"> <span class="keywordtype">bool</span> useImplicit;</div>
<div class="line">            useImplicitPlug.<a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>( useImplicit );</div>
<div class="line"> <span class="keywordflow">if</span> (useImplicit)</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// Make sure cached light is still in model:</span></div>
<div class="line"> <span class="keywordflow">if</span> (!currLight.fCachedImplicitLight.isNull())</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"> <a name="_a398"></a><a class="code" href="./class_m_fn_dag_node.html">MFnDagNode</a> lightDagNode(currLight.fCachedImplicitLight, &amp;status);</div>
<div class="line"> <span class="keywordflow">if</span> (status.<a name="a399"></a><a class="code" href="./class_m_status.html#a6040f0420421c317bced8b857b413f47">statusCode</a>() == <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a> &amp;&amp; lightDagNode.inModel() ) {</div>
<div class="line"> <a class="code" href="./class_m_dag_path.html">MDagPath</a> cachedPath;</div>
<div class="line"> <a class="code" href="./class_m_dag_path.html#a422aa5ec02565f757c13fe2873ed25d7">MDagPath::getAPathTo</a>(currLight.fCachedImplicitLight, cachedPath);</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> cachedTransform;</div>
<div class="line">                        cachedTransform.<a class="code" href="./class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>(cachedPath.<a class="code" href="./class_m_dag_path.html#a13f88add2c589379a22d5aaaa4a39fb4">transform</a>());</div>
<div class="line"> <span class="keywordflow">return</span> cachedTransform.<a name="a400"></a><a class="code" href="./class_m_fn_dependency_node.html#a049384adbea0396ea2f03d1ad4d69df1">name</a>();</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lightIndex == fImplicitAmbientLight)</div>
<div class="line"> <span class="keywordflow">return</span> dx11ShaderStrings::getString( dx11ShaderStrings::kAmbient );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="stringliteral">""</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_string_array.html">MStringArray</a> dx11ShaderNode::getLightableParameters(<span class="keywordtype">int</span> lightIndex, <span class="keywordtype">bool</span> showSemantics)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> retVal;</div>
<div class="line"> <span class="keywordflow">if</span>(lightIndex &lt; (<span class="keywordtype">int</span>)fLightParameters.size())</div>
<div class="line">    {</div>
<div class="line">        LightParameterInfo&amp; currLight = fLightParameters[lightIndex];</div>
<div class="line"> <span class="keywordflow">for</span> (LightParameterInfo::TConnectableParameters::const_iterator idxIter=currLight.fConnectableParameters.begin();</div>
<div class="line">            idxIter != currLight.fConnectableParameters.end();</div>
<div class="line">            ++idxIter)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">bool</span> appended = appendParameterNameIfVisible((*idxIter).first, retVal);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (appended &amp;&amp; showSemantics) {</div>
<div class="line"> <span class="keywordtype">int</span> paramType((*idxIter).second);</div>
<div class="line">                retVal.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>(CUniformParameterBuilder::getLightParameterSemantic(paramType));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> retVal;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Find out which index corresponds to a given a light group name.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    This function is used first by the CUniformParameterBuilder to</span></div>
<div class="line"><span class="comment">    get the initial index for each distinct light group, then, after the</span></div>
<div class="line"><span class="comment">    names are properly sorted in dx11ShaderNode::buildUniformParameterList</span></div>
<div class="line"><span class="comment">    we use this function to help the dx11Shader command parse out the</span></div>
<div class="line"><span class="comment">    light group names.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">int</span> dx11ShaderNode::getIndexForLightName(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; lightName, <span class="keywordtype">bool</span> appendLight) {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0;</div>
<div class="line"> <span class="comment">// Linear search in array is efficient for sizes less than 20.</span></div>
<div class="line"> <span class="keywordflow">for</span> ( ; index &lt; fLightNames.length(); index++)</div>
<div class="line"> <span class="keywordflow">if</span> ( fLightNames[index] == lightName || sanitizeName(fLightNames[index]) == lightName)</div>
<div class="line"> <span class="keywordflow">return</span> index;</div>
<div class="line"> <span class="keywordflow">if</span> (appendLight)</div>
<div class="line">    {</div>
<div class="line">        fLightNames.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>(lightName);</div>
<div class="line"> <span class="keywordflow">return</span> index;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    In the AE we only want to expose visible parameters, so</span></div>
<div class="line"><span class="comment">    test here for parameter visibility:</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::appendParameterNameIfVisible(<span class="keywordtype">int</span> paramIndex, <a class="code" href="./class_m_string_array.html">MStringArray</a>&amp; paramArray)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(paramIndex);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> uniformPlug(uniform.<a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>());</div>
<div class="line"> <span class="keywordflow">if</span> (uniformPlug.isNull())</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> uniformAttribute(uniformPlug.attribute());</div>
<div class="line"> <span class="keywordflow">if</span> (uniformAttribute.isHidden())</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    paramArray.<a class="code" href="./class_m_string_array.html#a18d06b3d0af1426e654ac2cc1dc86c60">append</a>(uniformAttribute.shortName());</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Light Management</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* ======================================================================</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    How to define dx11Shader lights:</span></div>
<div class="line"><span class="comment">    ===============================</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    When parsing the effect parameters, we search for information on</span></div>
<div class="line"><span class="comment">    parameters that can be grouped together as a logical light for the</span></div>
<div class="line"><span class="comment">    effect. This can be explicitly done by using the same light name</span></div>
<div class="line"><span class="comment">    string in an "Object" annotation set on all parameters that should be</span></div>
<div class="line"><span class="comment">    grouped together, but we also try to implicitly do this by finding a</span></div>
<div class="line"><span class="comment">    common name prefix on attributes that have light semantics but no</span></div>
<div class="line"><span class="comment">    explicit Object annotation. For the complete list of light semantics</span></div>
<div class="line"><span class="comment">    and annotations, please consult the SDK documentation.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Some pointers on how dx11Shader lighting works:</span></div>
<div class="line"><span class="comment">    ==============================================</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The lighting code in a dx11Shader can compute shadows using the shadowmap</span></div>
<div class="line"><span class="comment">    generated by a light. Since this shadowmap is computed while drawing, it</span></div>
<div class="line"><span class="comment">    can only be accessed in the light information provided by the draw context,</span></div>
<div class="line"><span class="comment">    which is also the best place to look if we want to know if a light is both</span></div>
<div class="line"><span class="comment">    visible and enabled. This is why lighting in dx11Shaders does not explicitly</span></div>
<div class="line"><span class="comment">    connect on light shapes and transforms to pull values, but rather matches</span></div>
<div class="line"><span class="comment">    scene lights with draw context lights at render time and transfers light</span></div>
<div class="line"><span class="comment">    parameter values directly from the draw context to the shader parameters.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The dx11Shader provides 3 different lighting modes in the attribute editor.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    1- "Automatic Bind" (default) Where we try to automatically find the best</span></div>
<div class="line"><span class="comment">       scene light to drive a set of light parameters on a shader. The scene</span></div>
<div class="line"><span class="comment">       light is assigned at draw time when refreshing the light parameters of</span></div>
<div class="line"><span class="comment">       the shader and the assignment is cached in the light parameter info to</span></div>
<div class="line"><span class="comment">       provide consistent lighting.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    2- Explicit connection: When a user explicitly assign a scene light to a set</span></div>
<div class="line"><span class="comment">       of shader parameters using the Attribute Editor we explicitely connect the</span></div>
<div class="line"><span class="comment">       light shape to the "connected_light" attribute of the shader and use this</span></div>
<div class="line"><span class="comment">       connection to find the corresponding draw context light.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    3- "Use Shader Settings": Where we do not transfer any scene light information</span></div>
<div class="line"><span class="comment">       and instead use the parameter values currently found in the shader.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    This is tracked using 2 attributes and a cache MObject for each light group.</span></div>
<div class="line"><span class="comment">    The first attribute is a boolean controlling automatic binding, the second</span></div>
<div class="line"><span class="comment">    attribute is used to connect to a light shape for explicit connections, and</span></div>
<div class="line"><span class="comment">    the MObject allows remembering the last used scene light in automatic bind</span></div>
<div class="line"><span class="comment">    mode to prevent lighting to change when a new light is added to the scene:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">                            *_implicit_light</span></div>
<div class="line"><span class="comment">                          | true      | false</span></div>
<div class="line"><span class="comment">                ----------|-----------|--------------</span></div>
<div class="line"><span class="comment">        *_connected_light |           | Explicit</span></div>
<div class="line"><span class="comment">                connected |  N/A      |   connection</span></div>
<div class="line"><span class="comment">                ----------|-----------|--------------</span></div>
<div class="line"><span class="comment">                          | Automatic | Use Shader</span></div>
<div class="line"><span class="comment">              unconnected |   Bind    |   Settings</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The special case of the ambient light:</span></div>
<div class="line"><span class="comment">    =====================================</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    In the draw context, all ambient lights are merged together into a</span></div>
<div class="line"><span class="comment">    single ambient light whose color and intensity is the blend of all</span></div>
<div class="line"><span class="comment">    ambient light present in the scene. When "Automatic Binding" is done</span></div>
<div class="line"><span class="comment">    on such ambient light(s), it will use the merged color value, which is</span></div>
<div class="line"><span class="comment">    subject to change as ambient lights are activated and deactivated.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Explicit connections to ambient light requires fetching the parameter</span></div>
<div class="line"><span class="comment">    values from the scene light instead of copying the information from</span></div>
<div class="line"><span class="comment">    the merged ambient light from the draw context.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   ====================================================================== */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This is where we create the light connection attributes</span></div>
<div class="line"><span class="comment">// when a shader is first assigned. When a scene is loaded,</span></div>
<div class="line"><span class="comment">// we only need to retrieve the dynamic attributes that were</span></div>
<div class="line"><span class="comment">// created by the persistence code. The code also handles</span></div>
<div class="line"><span class="comment">// re-creating the attributes if the light group names were</span></div>
<div class="line"><span class="comment">// changed in the effect file.</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::refreshLightConnectionAttributes(<span class="keywordtype">bool</span> inSceneUpdateNotification)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> ( inSceneUpdateNotification || (!<a class="code" href="./class_m_file_i_o.html#accbcaffc37fcbee9f7974aae80c8014b">MFileIO::isReadingFile</a>() &amp;&amp; !<a class="code" href="./class_m_file_i_o.html#a30bf5678402012d5607a6b0f22d2c2a5">MFileIO::isOpeningFile</a>()) )</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> fnDepThisNode(thisMObject());</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iLi=0; iLi&lt;fLightParameters.size(); ++iLi)</div>
<div class="line">        {</div>
<div class="line">            LightParameterInfo&amp; currLight(fLightParameters[iLi]);</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> sanitizedLightGroupName = sanitizeName(fLightNames[(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)iLi]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If the attributes are not there at this time then create them.</span></div>
<div class="line"> <span class="keywordflow">if</span> (currLight.fAttrUseImplicit.isNull())</div>
<div class="line">                currLight.fAttrUseImplicit = fnDepThisNode.attribute(sanitizedLightGroupName + <span class="stringliteral">"_use_implicit_lighting"</span>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (currLight.fAttrUseImplicit.isNull())</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// Create:</span></div>
<div class="line"> <a class="code" href="./class_m_fn_numeric_attribute.html">MFnNumericAttribute</a> fnAttr;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> attrName = sanitizedLightGroupName + <span class="stringliteral">"_use_implicit_lighting"</span>;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> attrUseImplicit = fnAttr.<a name="a401"></a><a class="code" href="./class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(attrName , attrName, <a name="a402"></a><a class="code" href="./class_m_fn_numeric_data.html#a1d1cfd8ffb84e947f82999c682b666a7a8cfc0ab572a96edfc9db7c02f0d025d7">MFnNumericData::kBoolean</a>);</div>
<div class="line">                fnAttr.<a name="a403"></a><a class="code" href="./class_m_fn_numeric_attribute.html#aae3f2fbbbce06e006f1838a1fb6fdcdd">setDefault</a>(<span class="keyword">true</span>);</div>
<div class="line">                fnAttr.<a class="code" href="./class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>(<span class="keyword">false</span>);</div>
<div class="line">                fnAttr.<a class="code" href="./class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>(<span class="keyword">true</span>);</div>
<div class="line">                fnAttr.<a class="code" href="./class_m_fn_attribute.html#a0810da59cbaac7ecbd26ba0a43d0ac35">setAffectsAppearance</a>(<span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (!attrUseImplicit.<a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>())</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_d_g_modifier.html">MDGModifier</a> implicitModifier;</div>
<div class="line">                    status = implicitModifier.<a name="a404"></a><a class="code" href="./class_m_d_g_modifier.html#ad714eb6c2e6f51659e3e50f176c75a91">addAttribute</a>(thisMObject(), attrUseImplicit);</div>
<div class="line"> <span class="keywordflow">if</span> (status.<a class="code" href="./class_m_status.html#a6040f0420421c317bced8b857b413f47">statusCode</a>() == <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>)</div>
<div class="line">                    {</div>
<div class="line">                        status = implicitModifier.<a class="code" href="./class_m_d_g_modifier.html#a984345cd272bc1a32a9fc2e93a6678b2">doIt</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (status.<a class="code" href="./class_m_status.html#a6040f0420421c317bced8b857b413f47">statusCode</a>() == <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>)</div>
<div class="line">                        {</div>
<div class="line">                            currLight.fAttrUseImplicit = attrUseImplicit;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="comment">// Ensure category "HW_shader_parameter" is set on this attribute.</span></div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> lAttrUseImplicitLight(fnDepThisNode.attribute(sanitizedLightGroupName + <span class="stringliteral">"_use_implicit_lighting"</span>));</div>
<div class="line">            lAttrUseImplicitLight.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>(<span class="stringliteral">"HW_shader_parameter"</span>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (currLight.fAttrConnectedLight.isNull())</div>
<div class="line">            {</div>
<div class="line">                currLight.fAttrConnectedLight = fnDepThisNode.attribute(sanitizedLightGroupName + <span class="stringliteral">"_connected_light"</span>);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">if</span> (currLight.fAttrConnectedLight.isNull())</div>
<div class="line">            {</div>
<div class="line"> <a name="_a405"></a><a class="code" href="./class_m_fn_message_attribute.html">MFnMessageAttribute</a> msgAttr;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> attrName = sanitizedLightGroupName + <span class="stringliteral">"_connected_light"</span>;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> attrConnectedLight = msgAttr.<a name="a406"></a><a class="code" href="./class_m_fn_message_attribute.html#a808909c19784e506b141107b425a04df">create</a>(attrName, attrName);</div>
<div class="line">                msgAttr.<a class="code" href="./class_m_fn_attribute.html#a0810da59cbaac7ecbd26ba0a43d0ac35">setAffectsAppearance</a>(<span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (!attrConnectedLight.<a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>())</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_d_g_modifier.html">MDGModifier</a> implicitModifier;</div>
<div class="line">                    status = implicitModifier.<a class="code" href="./class_m_d_g_modifier.html#ad714eb6c2e6f51659e3e50f176c75a91">addAttribute</a>(thisMObject(), attrConnectedLight);</div>
<div class="line"> <span class="keywordflow">if</span> (status.<a class="code" href="./class_m_status.html#a6040f0420421c317bced8b857b413f47">statusCode</a>() == <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>)</div>
<div class="line">                    {</div>
<div class="line">                        status = implicitModifier.<a class="code" href="./class_m_d_g_modifier.html#a984345cd272bc1a32a9fc2e93a6678b2">doIt</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (status.<a class="code" href="./class_m_status.html#a6040f0420421c317bced8b857b413f47">statusCode</a>() == <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>)</div>
<div class="line">                        {</div>
<div class="line">                            currLight.fAttrConnectedLight = attrConnectedLight;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> <span class="comment">// Ensure category "HW_shader_parameter" is set on this attribute.</span></div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> lAttrConnectLight(fnDepThisNode.attribute(sanitizedLightGroupName + <span class="stringliteral">"_connected_light"</span>));</div>
<div class="line">            lAttrConnectLight.<a class="code" href="./class_m_fn_attribute.html#ab9fc72838d451881be5ef4a910700afc">addToCategory</a>(<span class="stringliteral">"HW_shader_parameter"</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Hmmm. Really not a good idea to start adding parameters while scene is not fullly loaded.</span></div>
<div class="line"> <span class="comment">// Ask to be called back at a later time:</span></div>
<div class="line">        PostSceneUpdateAttributeRefresher::add(<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    If it is determined that the shader itself may change the geo then we dirty the shadow maps</span></div>
<div class="line"><span class="comment">    Examples of the shader changing geo: time-based effects that change vertex positions, hardware skinning, gpu-cloth, etc.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::updateShaderBasedGeoChanges()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!fShaderChangesGeo)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">double</span> currentTime = <a name="a407"></a><a class="code" href="./class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a name="a408"></a><a class="code" href="./class_m_time.html#a324b14b7506c6e4f47912161956974ed">value</a>();</div>
<div class="line"> <span class="keywordflow">if</span> ( abs(currentTime - fLastTime) &gt; 0.000000001 )</div>
<div class="line">    {</div>
<div class="line">        fLastTime = currentTime;</div>
<div class="line"></div>
<div class="line"> <a name="a409"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a06b742a8850af64d01e3fcbd9450916f">MHWRender::MRenderer::setLightsAndShadowsDirty</a>();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    If need to get all lights evaluated and get valid light information ignore light limit option in Viewport 2.0.</span></div>
<div class="line"><span class="comment">    Should call this before each refresh.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::updateLightsInformation()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> ( fIgnoreLightLimits )</div>
<div class="line"> <a name="a410"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#ad3ef90830d42d36701abb67d53748f08">MHWRender::MRenderer::needEvaluateAllLights</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    This is where we explicitely connect a light selected by the user</span></div>
<div class="line"><span class="comment">    by creating an explicit connection between the "lightData" of the</span></div>
<div class="line"><span class="comment">    light shape and the "*_connected_light" attribute. This connection</span></div>
<div class="line"><span class="comment">    can be traversed by the Attribute Editor to navigate between the</span></div>
<div class="line"><span class="comment">    dx11Shader and the connected light in both directions.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::connectLight(<span class="keywordtype">int</span> lightIndex, <a class="code" href="./class_m_dag_path.html">MDagPath</a> lightPath)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span>(lightIndex &lt; (<span class="keywordtype">int</span>)fLightParameters.size())</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_d_g_modifier.html">MDGModifier</a> DG;</div>
<div class="line">        LightParameterInfo&amp; currLight = fLightParameters[lightIndex];</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Connect the light to the connection placeholder:</span></div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> lightShapeNode = lightPath.<a name="a411"></a><a class="code" href="./class_m_dag_path.html#ae024049dad815f2f186e6a4fead8be51">node</a>();</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> dependNode;</div>
<div class="line">        dependNode.<a class="code" href="./class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>(lightShapeNode);</div>
<div class="line"> <span class="comment">// Connecting to lightData allows backward navigation:</span></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> otherPlug = dependNode.<a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(<span class="stringliteral">"lightData"</span>);</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> paramPlug(thisMObject(),currLight.fAttrConnectedLight);</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status = DG.<a class="code" href="./class_m_d_g_modifier.html#afbd18f066f70fcd1864ddb4af91f3c7b">connect</a>(otherPlug,paramPlug);</div>
<div class="line"> <span class="keywordflow">if</span>(status.<a class="code" href="./class_m_status.html#a6040f0420421c317bced8b857b413f47">statusCode</a>() == <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>)</div>
<div class="line">        {</div>
<div class="line">            DG.<a class="code" href="./class_m_d_g_modifier.html#a984345cd272bc1a32a9fc2e93a6678b2">doIt</a>();</div>
<div class="line"></div>
<div class="line">            currLight.fIsDirty = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Lock parameters:</span></div>
<div class="line">            setLightParameterLocking(currLight, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Flush implicit cache:</span></div>
<div class="line">            currLight.fCachedImplicitLight = <a class="code" href="./class_m_object.html">MObject</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Mark the light as being explicitly connected:</span></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> useImplicitPlug(thisMObject(), currLight.fAttrUseImplicit);</div>
<div class="line"> <span class="keywordflow">if</span>( !useImplicitPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() ) {</div>
<div class="line">                useImplicitPlug.<a class="code" href="./class_m_plug.html#aec7c3792a53d27a61ece4f7b81cc123b">setValue</a>( <span class="keyword">false</span> );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// trigger additional refresh of view to make sure shadow maps are updated</span></div>
<div class="line">            refreshView();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Helper function to trigger a viewport refresh</span></div>
<div class="line"><span class="comment">    This can be used when we need shadow maps calculated for lights outside the default light list</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::refreshView()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span> (<a name="a412"></a><a class="code" href="./class_m_global.html#ac7296da94b1d0b659833fc653a6af10e">MGlobal::mayaState</a>() != <a name="a413"></a><a class="code" href="./class_m_global.html#afb0008b4212928b7913ba9cfc64fe88ba347100316aff63bf166232d8145a44f6">MGlobal::kBatch</a>)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a414"></a><a class="code" href="./class_m3d_view.html">M3dView</a> view = <a name="a415"></a><a class="code" href="./class_m3d_view.html#a3cda809eff914b04ff47de958c365f09">M3dView::active3dView</a>();</div>
<div class="line">        view.<a name="a416"></a><a class="code" href="./class_m3d_view.html#a733fc93c61bcc5c95614fa6ef66ddbd7">refresh</a>( <span class="keyword">true</span> <span class="comment">/*all views*/</span>, <span class="keyword">false</span> <span class="comment">/*force*/</span> );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Helper function to set light requires shadow on/off</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setLightRequiresShadows(<span class="keyword">const</span> <a class="code" href="./class_m_object.html">MObject</a>&amp; lightObject, <span class="keywordtype">bool</span> requiresShadow)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span> (!lightObject.<a class="code" href="./class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>())</div>
<div class="line">        {</div>
<div class="line"><span class="preprocessor">            #if defined(PRINT_DEBUG_INFO_SHADOWS)</span></div>
<div class="line">                        fprintf(stderr, <span class="stringliteral">"Clear implicit light path on disconnect light: %s\n"</span>, <a class="code" href="./class_m_fn_dag_node.html">MFnDagNode</a>( lightObject ).fullPathName().asChar());</div>
<div class="line"><span class="preprocessor">            #endif</span></div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MHWRender::MRenderer</a>* theRenderer = <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MHWRender::MRenderer::theRenderer</a>();</div>
<div class="line">            theRenderer-&gt;<a name="a417"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#ac777540ab7b1bca5d51f7d03e62b4643">setLightRequiresShadows</a>( lightObject, requiresShadow );</div>
<div class="line">        }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Explicitly disconnect an explicit light connection:</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::disconnectLight(<span class="keywordtype">int</span> lightIndex)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span>(lightIndex &lt; (<span class="keywordtype">int</span>)fLightParameters.size())</div>
<div class="line">    {</div>
<div class="line">        LightParameterInfo&amp; currLight = fLightParameters[lightIndex];</div>
<div class="line">        currLight.fIsDirty = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Unlock all light parameters:</span></div>
<div class="line">        setLightParameterLocking(currLight, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Flush implicit cache:</span></div>
<div class="line">        setLightRequiresShadows(currLight.fCachedImplicitLight, <span class="keyword">false</span>);</div>
<div class="line">        currLight.fCachedImplicitLight = <a class="code" href="./class_m_object.html">MObject</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Disconnect the light from the connection placeholder:</span></div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> thisDependNode;</div>
<div class="line">            thisDependNode.<a class="code" href="./class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>(thisMObject());</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> thisLightConnectionPlug = thisDependNode.<a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(currLight.fAttrConnectedLight, <span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (thisLightConnectionPlug.<a class="code" href="./class_m_plug.html#a40a52cd1e2411064f234ac9a6559385b">isConnected</a>())</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// Find the light connected as source to this plug:</span></div>
<div class="line"> <a class="code" href="./class_m_plug_array.html">MPlugArray</a> srcCnxArray;</div>
<div class="line">                thisLightConnectionPlug.<a class="code" href="./class_m_plug.html#acf1340576a4a0a78a0045e67ee4155bf">connectedTo</a>(srcCnxArray,<span class="keyword">true</span>,<span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (srcCnxArray.<a class="code" href="./class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0)</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> sourcePlug = srcCnxArray[0];</div>
<div class="line"> <a class="code" href="./class_m_d_g_modifier.html">MDGModifier</a> DG;</div>
<div class="line">                    DG.<a class="code" href="./class_m_d_g_modifier.html#aee585c763e12aa6277000a028dbfa619">disconnect</a>(sourcePlug, thisLightConnectionPlug);</div>
<div class="line">                    DG.<a class="code" href="./class_m_d_g_modifier.html#a984345cd272bc1a32a9fc2e93a6678b2">doIt</a>();</div>
<div class="line"></div>
<div class="line">                    setLightRequiresShadows(sourcePlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>(), <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// trigger additional refresh of view to make sure shadow maps are updated</span></div>
<div class="line">                    refreshView();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Implicit light connection:</span></div>
<div class="line"><span class="comment">    =========================</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    In this function we want to bind the M shader lights to the best</span></div>
<div class="line"><span class="comment">    subset of the N scene lights found in the draw context. For performance</span></div>
<div class="line"><span class="comment">    we keep count of the number of light to connect and short-circuit loops</span></div>
<div class="line"><span class="comment">    when we ran out of lights to bind on either the shader or draw context side.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    This function can be called in 3 different context:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    - Scene: We have multiple lights in the draw context and we need to</span></div>
<div class="line"><span class="comment">             find a light that is compatible with the shader whenever the</span></div>
<div class="line"><span class="comment">             cached light is not found and it is not explicitly connected.</span></div>
<div class="line"><span class="comment">    - Default light: The draw context will contain only a single light and</span></div>
<div class="line"><span class="comment">                     it needs to override light in all three lighting modes.</span></div>
<div class="line"><span class="comment">    - Swatch: Same requirements as "Default Light", but does not override</span></div>
<div class="line"><span class="comment">              lights in "Use Shader Settings" mode.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    We need to keep track of which lights are implicitly/explicitly bound to</span></div>
<div class="line"><span class="comment">    make sure we do not automatically bind the same light more than once.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Scene ligths that are part of the scene but cannot be found in the draw</span></div>
<div class="line"><span class="comment">    context are either invisible, disabled, or in any other lighting combination</span></div>
<div class="line"><span class="comment">    (like "Use Selected Light") where we do not want to see the lighting in the</span></div>
<div class="line"><span class="comment">    shader. For these lights we turn the shader lighting "off" by setting</span></div>
<div class="line"><span class="comment">    the shader parameter values to black, with zero intensity.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::updateImplicitLightConnections(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context, ERenderType renderType)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>(!needUpdateImplicitLightConnections(renderType))</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a45d7b67b2b407db2a3a3927ef09db3e2">MHWRender::MDrawContext::LightFilter</a> lightFilter = fIgnoreLightLimits</div>
<div class="line">        ? <a name="a418"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a45d7b67b2b407db2a3a3927ef09db3e2a8d9a85c34398a46f44834be0b4fec0e4">MHWRender::MDrawContext::kFilteredIgnoreLightLimit</a> : <a name="a419"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a45d7b67b2b407db2a3a3927ef09db3e2ad63bad246d971bae12546a9784c65d31">MHWRender::MDrawContext::kFilteredToLightLimit</a>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbSceneLights = context.<a name="a420"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a245ec3740263f7f3c076dd9c723141b7">numberOfActiveLights</a>(lightFilter);</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbSceneLightsToBind = nbSceneLights;</div>
<div class="line"> <span class="keywordtype">bool</span> implicitLightWasRebound = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Detect headlamp scene rendering mode:</span></div>
<div class="line"> <span class="keywordtype">bool</span> useDefaultLight = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">if</span>(isRenderScene(renderType) &amp;&amp; nbSceneLights == 1)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* sceneLightParam = context.<a name="a421"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a05eaca3528290935c1b9ee55ae020c75">getLightParameterInformation</a>( 0 );</div>
<div class="line"> <span class="keyword">const</span> ELightType sceneLightType = getLightType(sceneLightParam);</div>
<div class="line"> <span class="keywordflow">if</span>(sceneLightType == eDefaultLight )</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Swatch and headlamp are the same as far as</span></div>
<div class="line"> <span class="comment">// implicit light connection is concerned:</span></div>
<div class="line">            useDefaultLight = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbShaderLights = (<span class="keywordtype">unsigned</span> int)fLightParameters.size();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbShaderLightsToBind = nbShaderLights;</div>
<div class="line"> <span class="comment">// Keep track of the shader lights that were treated : binding was successful</span></div>
<div class="line">    std::vector&lt;bool&gt; shaderLightTreated(nbShaderLights, <span class="keyword">false</span>);</div>
<div class="line">    std::vector&lt;bool&gt; shaderLightUsesImplicit(nbShaderLights, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> depFn( thisMObject() );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Keep track of the scene lights that were used : binding was successful</span></div>
<div class="line">    std::vector&lt;bool&gt; sceneLightUsed(nbSceneLights, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Upkeep pass.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// We want to know exactly which shader light will later require implicit</span></div>
<div class="line"> <span class="comment">// connection, and which scene lights are already used. We also remember</span></div>
<div class="line"> <span class="comment">// lights that were previously bound using the cached light parameter of</span></div>
<div class="line"> <span class="comment">// the light group info structure. It the cached light exists, and is</span></div>
<div class="line"> <span class="comment">// still available for automatic binding, we immediately reuse it.</span></div>
<div class="line"> <span class="keywordflow">if</span>(isRenderScene(renderType) &amp;&amp; !useDefaultLight)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Find out all explicitely connected lights and mark them as already</span></div>
<div class="line"> <span class="comment">// bound.</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shaderLightIndex = 0;</div>
<div class="line">            shaderLightIndex &lt; nbShaderLights &amp;&amp; nbShaderLightsToBind &amp;&amp; nbSceneLightsToBind;</div>
<div class="line">            ++shaderLightIndex )</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> thisLightConnectionPlug = depFn.findPlug(shaderLightInfo.fAttrConnectedLight, <span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (thisLightConnectionPlug.<a class="code" href="./class_m_plug.html#a40a52cd1e2411064f234ac9a6559385b">isConnected</a>())</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// Find the light connected as source to this plug:</span></div>
<div class="line"> <a class="code" href="./class_m_plug_array.html">MPlugArray</a> srcCnxArray;</div>
<div class="line">                thisLightConnectionPlug.<a class="code" href="./class_m_plug.html#acf1340576a4a0a78a0045e67ee4155bf">connectedTo</a>(srcCnxArray,<span class="keyword">true</span>,<span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (srcCnxArray.<a class="code" href="./class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0)</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> sourcePlug = srcCnxArray[0];</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sceneLightIndex = 0; sceneLightIndex &lt; nbSceneLights; ++sceneLightIndex)</div>
<div class="line">                    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* sceneLightParam = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a05eaca3528290935c1b9ee55ae020c75">getLightParameterInformation</a>( sceneLightIndex, lightFilter );</div>
<div class="line"> <span class="keywordflow">if</span>(sceneLightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#ac8cc78537b5a5d66bd3cc96bf8ef506e">lightPath</a>().<a class="code" href="./class_m_dag_path.html#ae024049dad815f2f186e6a4fead8be51">node</a>() == sourcePlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>())</div>
<div class="line">                        {</div>
<div class="line">                            sceneLightUsed[sceneLightIndex] = <span class="keyword">true</span>;</div>
<div class="line">                            nbSceneLightsToBind--;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderLightInfo.fCachedImplicitLight.isNull())</div>
<div class="line">                    {</div>
<div class="line">                        (<span class="keyword">const_cast&lt;</span>LightParameterInfo&amp;<span class="keyword">&gt;</span>(shaderLightInfo)).fCachedImplicitLight = <a class="code" href="./class_m_object.html">MObject</a>();</div>
<div class="line"> <span class="comment">// Light is explicitely connected, so parameters are locked:</span></div>
<div class="line">                        setLightParameterLocking(shaderLightInfo, <span class="keyword">true</span>);</div>
<div class="line">                        implicitLightWasRebound = <span class="keyword">true</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update cached implicit lights:</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shaderLightIndex = 0;</div>
<div class="line">            shaderLightIndex &lt; nbShaderLights &amp;&amp; nbShaderLightsToBind;</div>
<div class="line">            ++shaderLightIndex )</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// See if this light uses implicit connections:</span></div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> useImplicitPlug = depFn.findPlug( shaderLightInfo.fAttrUseImplicit, <span class="keyword">false</span> );</div>
<div class="line"> <span class="keywordflow">if</span>( !useImplicitPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() ) {</div>
<div class="line"> <span class="keywordtype">bool</span> useImplicit;</div>
<div class="line">                useImplicitPlug.<a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>( useImplicit );</div>
<div class="line">                shaderLightUsesImplicit[shaderLightIndex] = useImplicit;</div>
<div class="line"> <span class="keywordflow">if</span> (useImplicit)</div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// Make sure cached light is still in model:</span></div>
<div class="line"> <span class="keywordflow">if</span> (!shaderLightInfo.fCachedImplicitLight.isNull())</div>
<div class="line">                    {</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"> <a class="code" href="./class_m_fn_dag_node.html">MFnDagNode</a> lightDagNode(shaderLightInfo.fCachedImplicitLight, &amp;status);</div>
<div class="line"> <span class="keywordflow">if</span> (status.<a class="code" href="./class_m_status.html#a6040f0420421c317bced8b857b413f47">statusCode</a>() == <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a> &amp;&amp; lightDagNode.inModel() ) {</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Try to connect to the cached light:</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* matchingSceneLightParam = NULL;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sceneLightIndex = 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>( ; sceneLightIndex &lt; nbSceneLights; ++sceneLightIndex)</div>
<div class="line">                            {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* sceneLightParam = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a05eaca3528290935c1b9ee55ae020c75">getLightParameterInformation</a>( sceneLightIndex, lightFilter );</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>( sceneLightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#ac8cc78537b5a5d66bd3cc96bf8ef506e">lightPath</a>().<a class="code" href="./class_m_dag_path.html#ae024049dad815f2f186e6a4fead8be51">node</a>() == shaderLightInfo.fCachedImplicitLight )</div>
<div class="line">                                {</div>
<div class="line">                                    matchingSceneLightParam = sceneLightParam;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (matchingSceneLightParam)</div>
<div class="line">                            {</div>
<div class="line"> <span class="keywordflow">if</span> (!sceneLightUsed[sceneLightIndex])</div>
<div class="line">                                {</div>
<div class="line">                                    connectLight(shaderLightInfo, matchingSceneLightParam);</div>
<div class="line">                                    sceneLightUsed[sceneLightIndex] = <span class="keyword">true</span>;         <span class="comment">// mark this scene light as used</span></div>
<div class="line">                                    nbSceneLightsToBind--;</div>
<div class="line">                                    shaderLightTreated[shaderLightIndex] = <span class="keyword">true</span>;    <span class="comment">// mark this shader light as binded</span></div>
<div class="line">                                    nbShaderLightsToBind--;</div>
<div class="line">                                }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                                {</div>
<div class="line">                                    setLightRequiresShadows(shaderLightInfo.fCachedImplicitLight, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Light already in use, clear the cache to allow binding at a later stage:</span></div>
<div class="line">                                    (<span class="keyword">const_cast&lt;</span>LightParameterInfo&amp;<span class="keyword">&gt;</span>(shaderLightInfo)).fCachedImplicitLight = <a class="code" href="./class_m_object.html">MObject</a>();</div>
<div class="line">                                    setLightParameterLocking(shaderLightInfo, <span class="keyword">false</span>);</div>
<div class="line">                                    implicitLightWasRebound = <span class="keyword">true</span>;</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                            {</div>
<div class="line"> <span class="comment">// mark this shader light as bound even if not found in DC</span></div>
<div class="line">                                turnOffLight(shaderLightInfo);</div>
<div class="line">                                shaderLightTreated[shaderLightIndex] = <span class="keyword">true</span>;</div>
<div class="line">                                nbShaderLightsToBind--;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                        {</div>
<div class="line"> <span class="comment">// Note that we don't need to clear the requirement for</span></div>
<div class="line"> <span class="comment">// implicit shadow maps here as light deletion is already handled by the renderer</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Light is not in the model anymore, allow rebinding:</span></div>
<div class="line">                            (<span class="keyword">const_cast&lt;</span>LightParameterInfo&amp;<span class="keyword">&gt;</span>(shaderLightInfo)).fCachedImplicitLight = <a class="code" href="./class_m_object.html">MObject</a>();</div>
<div class="line">                            setLightParameterLocking(shaderLightInfo, <span class="keyword">false</span>);</div>
<div class="line">                            implicitLightWasRebound = <span class="keyword">true</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// This light is either explicitly bound, or in the</span></div>
<div class="line"> <span class="comment">// "Use Shader Settings" mode, so we have one less</span></div>
<div class="line"> <span class="comment">// shader light to bind:</span></div>
<div class="line">                    nbShaderLightsToBind--;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Here we are in swatch or default light mode and must override all light connection</span></div>
<div class="line"> <span class="comment">// by marking them all as available for "Automatic Bind"</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shaderLightIndex = 0;</div>
<div class="line">            shaderLightIndex &lt; nbShaderLights &amp;&amp; nbShaderLightsToBind &amp;&amp; nbSceneLightsToBind;</div>
<div class="line">            ++shaderLightIndex )</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> thisLightConnectionPlug = depFn.findPlug(shaderLightInfo.fAttrConnectedLight, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> useImplicit = <span class="keyword">true</span>;</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> useImplicitPlug = depFn.findPlug( shaderLightInfo.fAttrUseImplicit, <span class="keyword">false</span> );</div>
<div class="line"> <span class="keywordflow">if</span>( !useImplicitPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() ) {</div>
<div class="line">                useImplicitPlug.<a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>( useImplicit );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (thisLightConnectionPlug.<a class="code" href="./class_m_plug.html#a40a52cd1e2411064f234ac9a6559385b">isConnected</a>() || useImplicit || useDefaultLight )</div>
<div class="line">            {</div>
<div class="line">                shaderLightUsesImplicit[shaderLightIndex] = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// In swatch rendering, lights in the "Use Shader Settings" mode are not</span></div>
<div class="line"> <span class="comment">// overridden:</span></div>
<div class="line">                nbShaderLightsToBind--;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// First pass ... try to connect each shader lights with the best scene light possible.</span></div>
<div class="line"> <span class="comment">// This means for each light whose type is explicitly known, we try to find the first</span></div>
<div class="line"> <span class="comment">// draw context light that is of the same type.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// The type of the shader light is deduced automatically first by looking for a substring</span></div>
<div class="line"> <span class="comment">// match in the light "Object" annotation, then by searching the parameter name, and finally</span></div>
<div class="line"> <span class="comment">// by checking which combination of position/direction semantics the light requires:</span></div>
<div class="line"> <span class="keywordflow">if</span>(isRenderScene(renderType) &amp;&amp; !useDefaultLight)</div>
<div class="line">        fImplicitAmbientLight = -1;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shaderLightIndex = 0;</div>
<div class="line">        shaderLightIndex &lt; nbShaderLights &amp;&amp; nbShaderLightsToBind &amp;&amp; nbSceneLightsToBind;</div>
<div class="line">        ++shaderLightIndex )</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"> <span class="keyword">const</span> ELightType shaderLightType = shaderLightInfo.lightType();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(!shaderLightUsesImplicit[shaderLightIndex] || shaderLightTreated[shaderLightIndex] == <span class="keyword">true</span>)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sceneLightIndex = 0; sceneLightIndex &lt; nbSceneLights; ++sceneLightIndex)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>(sceneLightUsed[sceneLightIndex] == <span class="keyword">true</span>)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* sceneLightParam = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a05eaca3528290935c1b9ee55ae020c75">getLightParameterInformation</a>( sceneLightIndex, lightFilter );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> ELightType sceneLightType = getLightType(sceneLightParam);</div>
<div class="line"> <span class="keywordflow">if</span>( shaderLightType == sceneLightType || shaderLightInfo.fHasLightTypeSemantics )</div>
<div class="line">            {</div>
<div class="line">                connectLight(shaderLightInfo, sceneLightParam, renderType);</div>
<div class="line"></div>
<div class="line">                shaderLightTreated[shaderLightIndex] = <span class="keyword">true</span>;    <span class="comment">// mark this shader light as binded</span></div>
<div class="line">                nbShaderLightsToBind--;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Rendering swatch needs to drive all lights, except if they have a light type semantics,</span></div>
<div class="line"> <span class="comment">// where we only need to drive one:</span></div>
<div class="line"> <span class="keywordflow">if</span> (isRenderScene(renderType) || shaderLightInfo.fHasLightTypeSemantics)</div>
<div class="line">                {</div>
<div class="line">                    sceneLightUsed[sceneLightIndex] = <span class="keyword">true</span>;         <span class="comment">// mark this scene light as used</span></div>
<div class="line">                    nbSceneLightsToBind--;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(isRenderScene(renderType) &amp;&amp; !useDefaultLight)</div>
<div class="line">                {</div>
<div class="line">                    setLightRequiresShadows(shaderLightInfo.fCachedImplicitLight, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">                    (<span class="keyword">const_cast&lt;</span>LightParameterInfo&amp;<span class="keyword">&gt;</span>(shaderLightInfo)).fCachedImplicitLight = sceneLightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#ac8cc78537b5a5d66bd3cc96bf8ef506e">lightPath</a>().<a class="code" href="./class_m_dag_path.html#ae024049dad815f2f186e6a4fead8be51">node</a>();</div>
<div class="line">                    setLightParameterLocking(shaderLightInfo, <span class="keyword">true</span>);</div>
<div class="line">                    implicitLightWasRebound = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// only update 'fImplicitAmbientLight' if it was not set yet. This allows the user to</span></div>
<div class="line"> <span class="comment">// manually bind an ambient light into the shader and still see any implicit 'Ambient' lighting bound in AE.</span></div>
<div class="line"> <span class="keywordflow">if</span> (sceneLightType == eAmbientLight &amp;&amp; fImplicitAmbientLight &lt; 0)</div>
<div class="line">                        fImplicitAmbientLight = shaderLightIndex;</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// Will need to refresh defaults on next scene redraw:</span></div>
<div class="line">                    (<span class="keyword">const_cast&lt;</span>LightParameterInfo&amp;<span class="keyword">&gt;</span>(shaderLightInfo)).fIsDirty = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Second pass ... connect remaining shader lights with scene lights that are not yet connected.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// In this pass, we consider compatible all lights that possess a superset of the</span></div>
<div class="line"> <span class="comment">// semantics required by the shader light, so a scene spot light can be bound to</span></div>
<div class="line"> <span class="comment">// shader lights requesting only a position, or a direction, and any light can bind</span></div>
<div class="line"> <span class="comment">// to a shader light that only requires a color:</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shaderLightIndex = 0;</div>
<div class="line">        shaderLightIndex &lt; nbShaderLights &amp;&amp; nbShaderLightsToBind &amp;&amp; nbSceneLightsToBind;</div>
<div class="line">        ++shaderLightIndex )</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span>(!shaderLightUsesImplicit[shaderLightIndex] || shaderLightTreated[shaderLightIndex] == <span class="keyword">true</span>)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"> <span class="keyword">const</span> ELightType shaderLightType = shaderLightInfo.lightType();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sceneLightIndex = 0; sceneLightIndex &lt; nbSceneLights; ++sceneLightIndex)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>(sceneLightUsed[sceneLightIndex] == <span class="keyword">true</span>)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* sceneLightParam = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a05eaca3528290935c1b9ee55ae020c75">getLightParameterInformation</a>( sceneLightIndex, lightFilter );</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> ELightType sceneLightType = getLightType(sceneLightParam);</div>
<div class="line"> <span class="keywordflow">if</span>( isLightAcceptable(shaderLightType, sceneLightType) )</div>
<div class="line">            {</div>
<div class="line">                connectLight(shaderLightInfo, sceneLightParam, renderType);</div>
<div class="line"></div>
<div class="line">                shaderLightTreated[shaderLightIndex] = <span class="keyword">true</span>;    <span class="comment">// mark this shader light as binded</span></div>
<div class="line">                nbShaderLightsToBind--;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Rendering swatch needs to drive all lights, except if they have a light type semantics,</span></div>
<div class="line"> <span class="comment">// where we only need to drive one:</span></div>
<div class="line"> <span class="keywordflow">if</span> (isRenderScene(renderType) || shaderLightInfo.fHasLightTypeSemantics)</div>
<div class="line">                {</div>
<div class="line">                    sceneLightUsed[sceneLightIndex] = <span class="keyword">true</span>;         <span class="comment">// mark this scene light as used</span></div>
<div class="line">                    nbSceneLightsToBind--;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(isRenderScene(renderType) &amp;&amp; !useDefaultLight)</div>
<div class="line">                {</div>
<div class="line">                    (<span class="keyword">const_cast&lt;</span>LightParameterInfo&amp;<span class="keyword">&gt;</span>(shaderLightInfo)).fCachedImplicitLight = sceneLightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#ac8cc78537b5a5d66bd3cc96bf8ef506e">lightPath</a>().<a class="code" href="./class_m_dag_path.html#ae024049dad815f2f186e6a4fead8be51">node</a>();</div>
<div class="line">                    setLightParameterLocking(shaderLightInfo, <span class="keyword">true</span>);</div>
<div class="line">                    implicitLightWasRebound = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">                    setLightRequiresShadows(shaderLightInfo.fCachedImplicitLight, <span class="keyword">true</span>);</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// Will need to refresh defaults on next scene redraw:</span></div>
<div class="line">                    (<span class="keyword">const_cast&lt;</span>LightParameterInfo&amp;<span class="keyword">&gt;</span>(shaderLightInfo)).fIsDirty = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Final pass: shutdown all implicit lights that were not bound</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shaderLightIndex = 0;</div>
<div class="line">        shaderLightIndex &lt; nbShaderLights &amp;&amp; nbShaderLightsToBind;</div>
<div class="line">        ++shaderLightIndex )</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span>(!shaderLightUsesImplicit[shaderLightIndex] || shaderLightTreated[shaderLightIndex] == <span class="keyword">true</span>)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"></div>
<div class="line">        turnOffLight(shaderLightInfo);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(isRenderSwatch(renderType) || useDefaultLight)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Will need to refresh defaults on next scene redraw:</span></div>
<div class="line">            (<span class="keyword">const_cast&lt;</span>LightParameterInfo&amp;<span class="keyword">&gt;</span>(shaderLightInfo)).fIsDirty = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If during this update phase we changed any of the cached implicit light</span></div>
<div class="line"> <span class="comment">// objects, we need to trigger a refresh of the attribute editor light binding</span></div>
<div class="line"> <span class="comment">// information to show the current light connection settings. Multiple requests</span></div>
<div class="line"> <span class="comment">// are pooled by the refresher and only one request is sent to the AE in the next</span></div>
<div class="line"> <span class="comment">// idle window.</span></div>
<div class="line"> <span class="keywordflow">if</span> (implicitLightWasRebound)</div>
<div class="line">        IdleAttributeEditorImplicitRefresher::activate();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Traverse all explicit light connections and refresh the shader data if the light</span></div>
<div class="line"><span class="comment">    is found in the draw context, otherwise turn off the light.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    This is also where we handle the special case of the merged ambient lights by</span></div>
<div class="line"><span class="comment">    refreshing the connected ambient light, but only if we found the merged one</span></div>
<div class="line"><span class="comment">    inside the draw context. Not finding ambient lights in the draw context mean that</span></div>
<div class="line"><span class="comment">    they are all invisible, or disabled, or otherwise not drawn.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::updateExplicitLightConnections(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context, ERenderType renderType)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>(!needUpdateExplicitLightConnections(renderType))</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbShaderLights = (<span class="keywordtype">unsigned</span> int)fLightParameters.size();</div>
<div class="line"> <span class="keywordflow">if</span>(nbShaderLights &lt; 0)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a45d7b67b2b407db2a3a3927ef09db3e2">MHWRender::MDrawContext::LightFilter</a> lightFilter = fIgnoreLightLimits</div>
<div class="line">        ? <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a45d7b67b2b407db2a3a3927ef09db3e2a8d9a85c34398a46f44834be0b4fec0e4">MHWRender::MDrawContext::kFilteredIgnoreLightLimit</a> : <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a45d7b67b2b407db2a3a3927ef09db3e2ad63bad246d971bae12546a9784c65d31">MHWRender::MDrawContext::kFilteredToLightLimit</a>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbSceneLights = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a245ec3740263f7f3c076dd9c723141b7">numberOfActiveLights</a>(lightFilter);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> thisDependNode;</div>
<div class="line">    thisDependNode.<a class="code" href="./class_m_fn_base.html#ad09f5acece0f9926b3e0e55cff78c3be">setObject</a>(thisMObject());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> shaderLightIndex = 0; shaderLightIndex &lt;nbShaderLights; ++shaderLightIndex )</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> thisLightConnectionPlug = thisDependNode.<a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(shaderLightInfo.fAttrConnectedLight, <span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (thisLightConnectionPlug.<a class="code" href="./class_m_plug.html#a40a52cd1e2411064f234ac9a6559385b">isConnected</a>())</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Find the light connected as source to this plug:</span></div>
<div class="line"> <a class="code" href="./class_m_plug_array.html">MPlugArray</a> srcCnxArray;</div>
<div class="line">            thisLightConnectionPlug.<a class="code" href="./class_m_plug.html#acf1340576a4a0a78a0045e67ee4155bf">connectedTo</a>(srcCnxArray,<span class="keyword">true</span>,<span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (srcCnxArray.<a class="code" href="./class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0)</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> sourcePlug = srcCnxArray[0];</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> sourceLight(sourcePlug.<a class="code" href="./class_m_plug.html#ae024049dad815f2f186e6a4fead8be51">node</a>());</div>
<div class="line"> <span class="keywordtype">bool</span> bHasAmbient = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> bLightEnabled = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sceneLightIndex = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(; sceneLightIndex &lt; nbSceneLights; ++sceneLightIndex)</div>
<div class="line">                {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* sceneLightParam = context.<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html#a05eaca3528290935c1b9ee55ae020c75">getLightParameterInformation</a>( sceneLightIndex, lightFilter );</div>
<div class="line"> <span class="keywordflow">if</span>(sceneLightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#ac8cc78537b5a5d66bd3cc96bf8ef506e">lightPath</a>().<a class="code" href="./class_m_dag_path.html#ae024049dad815f2f186e6a4fead8be51">node</a>() == sourceLight)</div>
<div class="line">                    {</div>
<div class="line">                        setLightRequiresShadows(sourceLight, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Use connectLight to transfer all values.</span></div>
<div class="line">                        connectLight(shaderLightInfo, sceneLightParam);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Keep light visibility state in case shader cares:</span></div>
<div class="line"> <a class="code" href="./class_m_float_array.html">MFloatArray</a> floatVals;</div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./class_m_string.html">MString</a> kLightOn(<span class="stringliteral">"lightOn"</span>);</div>
<div class="line">                        sceneLightParam-&gt;<a name="a422"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( kLightOn, floatVals );</div>
<div class="line">                        bLightEnabled = (floatVals.<a name="a423"></a><a class="code" href="./class_m_float_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0 || floatVals[0] &gt; 0) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (eAmbientLight == getLightType(sceneLightParam))</div>
<div class="line">                    {</div>
<div class="line">                        bHasAmbient = <span class="keyword">true</span>;</div>
<div class="line">                        bLightEnabled = <span class="keyword">true</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (bHasAmbient &amp;&amp; sceneLightIndex == nbSceneLights)</div>
<div class="line">                    bLightEnabled = connectExplicitAmbientLight(shaderLightInfo, sourceLight);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Adjust LightEnable parameter if it exists based on the presence of the light in the draw context:</span></div>
<div class="line"> <span class="keywordflow">if</span> (!bLightEnabled)</div>
<div class="line">                {</div>
<div class="line">                    turnOffLight(shaderLightInfo);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    This function rebuilds all the shader light information structures:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    fLightParameters: Main struct that contains the frequently use runtime information</span></div>
<div class="line"><span class="comment">        Contains:</span></div>
<div class="line"><span class="comment">            fLightType: What kind of scene light drives this shader light completely</span></div>
<div class="line"><span class="comment">            fHasLightTypeSemantics: Is the shader light code able to adapt to multiple light types?</span></div>
<div class="line"><span class="comment">            fIsDirty: Should we refresh the shader light parameter values at the next redraw?</span></div>
<div class="line"><span class="comment">            fConnectableParameters: Set of indices in the uniform parameter array that define this shader light</span></div>
<div class="line"><span class="comment">            fAttrUseImplicit: Boolean attribute whose value is true when in "Automatic Bind" mode</span></div>
<div class="line"><span class="comment">            fAttrConnectedLight: Message attribute that is connected to a light shape for explicit binds</span></div>
<div class="line"><span class="comment">            fCachedImplicitLight: Reference to the light shape that was automatically bound during last redraw</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">     fLightDescriptions: String array containing pairs of (Light Group Name, Light Group Type) returned by</span></div>
<div class="line"><span class="comment">                         "dx11Shader -listLightInformation" query and used by the AE to create the light</span></div>
<div class="line"><span class="comment">                         connection panel and to filter which scene lights can appear in the dropdowns for</span></div>
<div class="line"><span class="comment">                         explicit connection</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::updateImplicitLightParameterCache(std::vector&lt;CUniformParameterBuilder*&gt;&amp; builders)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> fnDepThisNode(thisMObject());</div>
<div class="line"> <a class="code" href="./class_m_d_g_modifier.html">MDGModifier</a> implicitModifier;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The attributes for connected lights and implicit binding can be created from</span></div>
<div class="line"> <span class="comment">// the persistence. Try to preserve them if possible.</span></div>
<div class="line"> <span class="keywordtype">bool</span> updateConnectionAttributes = ( !<a class="code" href="./class_m_file_i_o.html#accbcaffc37fcbee9f7974aae80c8014b">MFileIO::isReadingFile</a>() &amp;&amp; !<a class="code" href="./class_m_file_i_o.html#a30bf5678402012d5607a6b0f22d2c2a5">MFileIO::isOpeningFile</a>() );</div>
<div class="line"> <span class="keywordflow">if</span> ( updateConnectionAttributes ) {</div>
<div class="line"> <span class="comment">// Do not update if the light groups are exactly the same:</span></div>
<div class="line"> <span class="comment">//   (happens a lot when switching from one technique to another)</span></div>
<div class="line"> <span class="keywordflow">if</span> ( fLightParameters.size() == fLightNames.length() )</div>
<div class="line">        {</div>
<div class="line">            updateConnectionAttributes = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iLi=0; iLi&lt;fLightParameters.size(); ++iLi) {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> newName = sanitizeName(fLightNames[(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)iLi]) + <span class="stringliteral">"_use_implicit_lighting"</span>;</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> currentAttribute(fLightParameters[iLi].fAttrUseImplicit, &amp;status);</div>
<div class="line"> <span class="keywordflow">if</span> (status.<a class="code" href="./class_m_status.html#a6040f0420421c317bced8b857b413f47">statusCode</a>() != <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a> || currentAttribute.name() != newName ) {</div>
<div class="line">                    updateConnectionAttributes = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> ( updateConnectionAttributes ) {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iLi=0; iLi&lt;fLightParameters.size(); ++iLi)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>(fLightParameters[iLi].fAttrUseImplicit.isNull() == <span class="keyword">false</span>)</div>
<div class="line">                implicitModifier.<a name="a424"></a><a class="code" href="./class_m_d_g_modifier.html#ab5595b225c59b15d902dc34b849d90d0">removeAttribute</a>(thisMObject(), fLightParameters[iLi].fAttrUseImplicit);</div>
<div class="line"> <span class="keywordflow">if</span>(fLightParameters[iLi].fAttrConnectedLight.isNull() == <span class="keyword">false</span>)</div>
<div class="line">                implicitModifier.<a class="code" href="./class_m_d_g_modifier.html#ab5595b225c59b15d902dc34b849d90d0">removeAttribute</a>(thisMObject(), fLightParameters[iLi].fAttrConnectedLight);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    implicitModifier.<a class="code" href="./class_m_d_g_modifier.html#a984345cd272bc1a32a9fc2e93a6678b2">doIt</a>();</div>
<div class="line"></div>
<div class="line">    fLightParameters.<a name="a425"></a><a class="code" href="./class_m_status.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>();</div>
<div class="line">    fLightParameters.resize(fLightNames.length());</div>
<div class="line">    refreshLightConnectionAttributes();</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">        first loop over all uniform parameters to find out which parameters belong to</span></div>
<div class="line"><span class="comment">        which light group, to find out if a shader light group defines an "intelligent"</span></div>
<div class="line"><span class="comment">        light that has code that can adapt to any connected light type, and to find out</span></div>
<div class="line"><span class="comment">        if the CUniformParameterBuilder was able to deduce the light type using either</span></div>
<div class="line"><span class="comment">        the light group name, or by finding a semantic type that is exclusive to one</span></div>
<div class="line"><span class="comment">        light type (like cone angle).</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    std::vector&lt;CUniformParameterBuilder*&gt;::iterator iter = builders.begin();</div>
<div class="line"> <span class="keywordtype">int</span> index = 0;</div>
<div class="line">    CUniformParameterBuilder::ELightType currLightType = CUniformParameterBuilder::eNotLight;</div>
<div class="line">    CUniformParameterBuilder::ELightParameterType paramType;</div>
<div class="line"> <span class="keywordflow">for</span>(;iter != builders.end();++iter,++index)</div>
<div class="line">    {</div>
<div class="line">        CUniformParameterBuilder* currBuilder = *iter;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span>(!currBuilder-&gt;isValidUniformParameter())</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> lightIndex = currBuilder-&gt;getLightIndex();</div>
<div class="line"> <span class="keywordflow">if</span> (lightIndex &lt; 0)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">        LightParameterInfo&amp; currLight(fLightParameters[lightIndex]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// A shader parameter can have a light group "Object" annotation but have</span></div>
<div class="line"> <span class="comment">// no recognized light semantics. In this case we do not need to add</span></div>
<div class="line"> <span class="comment">// this parameter to the light parameter set.</span></div>
<div class="line"> <span class="keywordflow">if</span>(currBuilder-&gt;getLightType() !=  CUniformParameterBuilder::eNotLight)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>(currLightType == CUniformParameterBuilder::eNotLight)</div>
<div class="line">            {</div>
<div class="line">                currLightType = currBuilder-&gt;getLightType();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            paramType = currBuilder-&gt;getLightParameterType();</div>
<div class="line"> <span class="keywordflow">if</span> (paramType == CUniformParameterBuilder::eLightType)</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// This light can be connected to any scene light and react correctly:</span></div>
<div class="line">                currLight.fHasLightTypeSemantics = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            currLight.fConnectableParameters.insert(LightParameterInfo::TConnectableParameters::value_type(index, paramType));</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span>(currBuilder-&gt;getLightType())</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eUndefinedLight:</div>
<div class="line">                currLight.fLightType = eUndefinedLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eSpotLight:</div>
<div class="line">                currLight.fLightType = eSpotLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::ePointLight:</div>
<div class="line">                currLight.fLightType = ePointLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eDirectionalLight:</div>
<div class="line">                currLight.fLightType = eDirectionalLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eAmbientLight:</div>
<div class="line">                currLight.fLightType = eAmbientLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eAreaLight:</div>
<div class="line">                currLight.fLightType = eAreaLight;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            };</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">        Once all light group information is found, we can generate</span></div>
<div class="line"><span class="comment">        the light parameter info array for the AE</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    fLightDescriptions.clear();</div>
<div class="line">    LightParameterInfoVec::iterator iterLight = fLightParameters.begin();</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lightIndex = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(;iterLight != fLightParameters.end();++iterLight, ++lightIndex)</div>
<div class="line">    {</div>
<div class="line">        fLightDescriptions.append(fLightNames[lightIndex]);</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> kInvalid(<span class="stringliteral">"invalid"</span>);</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> kUndefined(<span class="stringliteral">"undefined"</span>);</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> kSpot(<span class="stringliteral">"spot"</span>);</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> kPoint(<span class="stringliteral">"point"</span>);</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> kDirectional(<span class="stringliteral">"directional"</span>);</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> kAmbient(<span class="stringliteral">"ambient"</span>);</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> kArea(<span class="stringliteral">"area"</span>);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> lightType = kInvalid;</div>
<div class="line"> <span class="keywordflow">switch</span>(iterLight-&gt;fLightType)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">case</span> eUndefinedLight:</div>
<div class="line">            lightType = kUndefined;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> eSpotLight:</div>
<div class="line">            lightType = kSpot;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> ePointLight:</div>
<div class="line">            lightType = kPoint;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> eDirectionalLight:</div>
<div class="line">            lightType = kDirectional;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> eAmbientLight:</div>
<div class="line">            lightType = kAmbient;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> eAreaLight:</div>
<div class="line">            lightType = kArea;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:    <span class="comment">// Invalid light</span></div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">        };</div>
<div class="line">        fLightDescriptions.append(lightType);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::clearLightConnectionData()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Unlock all light parameters.</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; fLightParameters.size(); ++i) {</div>
<div class="line">        fLightParameters[i].fCachedImplicitLight = <a class="code" href="./class_m_object.html">MObject</a>();</div>
<div class="line">        setLightParameterLocking(fLightParameters[i], <span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fLightNames.setLength(0);</div>
<div class="line">    fUIGroupNames.setLength(0);</div>
<div class="line">    fUIGroupParameters.clear();</div>
<div class="line">    fLightDescriptions.setLength(0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Populates the set of light parameters that need to be refreshed from the shader parameter</span></div>
<div class="line"><span class="comment">    values in this redraw. This includes all parameters in any light group that was marked as</span></div>
<div class="line"><span class="comment">    being dirty, and can also include parameters from clean groups if the rendering context</span></div>
<div class="line"><span class="comment">    is swatch or default light since the light binding can be overridden.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Light groups will get dirty in the following scenarios:</span></div>
<div class="line"><span class="comment">        - A notification from a connected light shape was received</span></div>
<div class="line"><span class="comment">        - A scene light was explicitely connected or disconnected</span></div>
<div class="line"><span class="comment">        - Last draw was done in swatch or default scene light context</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::getLightParametersToUpdate(std::set&lt;int&gt;&amp; parametersToUpdate, ERenderType renderType)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> shaderLightIndex = 0; shaderLightIndex &lt; fLightParameters.size(); ++shaderLightIndex )</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> LightParameterInfo&amp; shaderLightInfo = fLightParameters[shaderLightIndex];</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (shaderLightInfo.fIsDirty || !isRenderScene(renderType))</div>
<div class="line">        {</div>
<div class="line">            LightParameterInfo::TConnectableParameters::const_iterator it = shaderLightInfo.fConnectableParameters.begin();</div>
<div class="line">            LightParameterInfo::TConnectableParameters::const_iterator itEnd = shaderLightInfo.fConnectableParameters.end();</div>
<div class="line"> <span class="keywordflow">for</span> (; it != itEnd; ++it)</div>
<div class="line">            {</div>
<div class="line">                parametersToUpdate.insert(it-&gt;first);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (isRenderScene(renderType))</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// If light is implicit, it stays dirty (as we do not control</span></div>
<div class="line"> <span class="comment">// what happens with the lights and need to react quickly)</span></div>
<div class="line"> <a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> depFn( thisMObject() );</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> useImplicitPlug = depFn.findPlug( shaderLightInfo.fAttrUseImplicit, <span class="keyword">false</span> );</div>
<div class="line"> <span class="keywordflow">if</span>( !useImplicitPlug.<a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() ) {</div>
<div class="line"> <span class="keywordtype">bool</span> useImplicit;</div>
<div class="line">                    useImplicitPlug.<a class="code" href="./class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>( useImplicit );</div>
<div class="line"> <span class="keywordflow">if</span> (!useImplicit)</div>
<div class="line">                    {</div>
<div class="line"> <span class="comment">// Light will be cleaned. And we are not implicit.</span></div>
<div class="line">                        (<span class="keyword">const_cast&lt;</span>LightParameterInfo&amp;<span class="keyword">&gt;</span>(shaderLightInfo)).fIsDirty = <span class="keyword">false</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Transfer light parameter values from a draw context light info to all shader parameters</span></div>
<div class="line"><span class="comment">    of the specified light group. Uses the drawContextParameterNames acceleration structure</span></div>
<div class="line"><span class="comment">    to iterate quickly through relevant draw context parameters.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::connectLight(<span class="keyword">const</span> LightParameterInfo&amp; lightInfo, <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html">MHWRender::MLightParameterInformation</a>* lightParam, ERenderType renderType)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> positionCount = 0;</div>
<div class="line"> <a name="_a426"></a><a class="code" href="./class_m_float_point.html">MFloatPoint</a> position;</div>
<div class="line"> <a name="_a427"></a><a class="code" href="./class_m_float_vector.html">MFloatVector</a> direction;</div>
<div class="line"> <span class="keywordtype">float</span> intensity = 1.0f;</div>
<div class="line"> <span class="keywordtype">float</span> decayRate = 0.0f;</div>
<div class="line"> <a name="_a428"></a><a class="code" href="./class_m_color.html">MColor</a> color(1.0f, 1.0f, 1.0f);</div>
<div class="line"> <span class="keywordtype">bool</span> globalShadowsOn = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> localShadowsOn = <span class="keyword">false</span>;</div>
<div class="line">    ID3D11ShaderResourceView *shadowResource = NULL;</div>
<div class="line"> <a name="_a429"></a><a class="code" href="./class_m_matrix.html">MMatrix</a> shadowViewProj;</div>
<div class="line"> <a class="code" href="./class_m_color.html">MColor</a> shadowColor;</div>
<div class="line"> <span class="keywordtype">float</span> shadowBias = 0.0f;</div>
<div class="line"> <a name="_a430"></a><a class="code" href="./class_m_angle.html">MAngle</a> hotspot(40.0, <a name="a431"></a><a class="code" href="./class_m_angle.html#abceb2331ad056e3c5ad27894199a49edae77f5ca99dc21b7dfd533074906e0a67">MAngle::kDegrees</a>);</div>
<div class="line"> <a class="code" href="./class_m_angle.html">MAngle</a> falloff(0.0);</div>
<div class="line"></div>
<div class="line">    ELightType lightType = getLightType(lightParam);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Looping on the uniform parameters reduces the processing time by not</span></div>
<div class="line"> <span class="comment">// enumerating light parameters that are not used by the shader.</span></div>
<div class="line">    LightParameterInfo::TConnectableParameters::const_iterator it    = lightInfo.fConnectableParameters.begin();</div>
<div class="line">    LightParameterInfo::TConnectableParameters::const_iterator itEnd = lightInfo.fConnectableParameters.end();</div>
<div class="line"> <span class="keywordflow">for</span> (; it != itEnd; ++it)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> parameterIndex = it-&gt;first;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> parameterType  = it-&gt;second;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (parameterType == CUniformParameterBuilder::eLightType) {</div>
<div class="line">            setParameterAsScalar(parameterIndex, lightType != dx11ShaderNode::eDefaultLight? (<span class="keywordtype">int</span>)lightType : dx11ShaderNode::eDirectionalLight);</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (parameterType == CUniformParameterBuilder::eLightEnable) {</div>
<div class="line">            setParameterAsScalar(parameterIndex, <span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string_array.html">MStringArray</a>&amp; params(drawContextParameterNames(lightType, parameterType, lightParam));</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (params.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; params.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); ++p)</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> pname = params[p];</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206">MHWRender::MLightParameterInformation::StockParameterSemantic</a> semantic = lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a37a7621bc6d9453902d95132fbbe2101">parameterSemantic</a>( pname );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Pull off values with position, direction, intensity or color</span></div>
<div class="line"> <span class="comment">// semantics</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_float_array.html">MFloatArray</a> floatVals;</div>
<div class="line"> <a name="_a432"></a><a class="code" href="./class_m_int_array.html">MIntArray</a> intVals;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (semantic)</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a3305693a0baf5df5ae2efc000aa9c017">MHWRender::MLightParameterInformation::kWorldPosition</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( pname, floatVals );</div>
<div class="line">                position += <a class="code" href="./class_m_float_point.html">MFloatPoint</a>( floatVals[0], floatVals[1], floatVals[2] );</div>
<div class="line">                ++positionCount;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a4006a71da7e8283c7211624c49022eea">MHWRender::MLightParameterInformation::kWorldDirection</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( pname, floatVals );</div>
<div class="line">                direction = <a class="code" href="./class_m_float_vector.html">MFloatVector</a>( floatVals[0], floatVals[1], floatVals[2] );</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206ae19f0601680f2872a292474ab3088b4f">MHWRender::MLightParameterInformation::kIntensity</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( pname, floatVals );</div>
<div class="line">                intensity = floatVals[0];</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a0be6585329840971e20d964386187935">MHWRender::MLightParameterInformation::kDecayRate</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( pname, floatVals );</div>
<div class="line">                decayRate = floatVals[0];</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206afc0133ebaa6c307b2388ecf5f72f6fdf">MHWRender::MLightParameterInformation::kColor</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( pname, floatVals );</div>
<div class="line">                color[0] = floatVals[0];</div>
<div class="line">                color[1] = floatVals[1];</div>
<div class="line">                color[2] = floatVals[2];</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="comment">// Parameter type extraction for shadow maps</span></div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206aca46ea808cc9f011b3f4f014ec9040f3">MHWRender::MLightParameterInformation::kGlobalShadowOn</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( pname, intVals );</div>
<div class="line"> <span class="keywordflow">if</span> (intVals.<a name="a433"></a><a class="code" href="./class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>())</div>
<div class="line">                    globalShadowsOn = (intVals[0] != 0) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a4852662e5cbf7f64d85133baa57386ab">MHWRender::MLightParameterInformation::kShadowOn</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( pname, intVals );</div>
<div class="line"> <span class="keywordflow">if</span> (intVals.<a class="code" href="./class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>())</div>
<div class="line">                    localShadowsOn = (intVals[0] != 0) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206ae05ca22a699a25e0d2030a7a440ecbbe">MHWRender::MLightParameterInformation::kShadowViewProj</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( pname, shadowViewProj);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a6053be989430b7fbd8b07f51528e8df4">MHWRender::MLightParameterInformation::kShadowMap</a>:</div>
<div class="line">                shadowResource = (ID3D11ShaderResourceView *) lightParam-&gt;<a name="a434"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aabc0d75c8960d98b6f8dbe31c777cf56">getParameterTextureHandle</a>( pname );</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206ac1cd724f83701837aee2364b308a9ed2">MHWRender::MLightParameterInformation::kShadowColor</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>( pname, floatVals );</div>
<div class="line">                shadowColor[0] = floatVals[0];</div>
<div class="line">                shadowColor[1] = floatVals[1];</div>
<div class="line">                shadowColor[2] = floatVals[2];</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206ace22882d5498baf50154a878321e7953">MHWRender::MLightParameterInformation::kShadowBias</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>(pname,floatVals);</div>
<div class="line">                shadowBias = floatVals[0];</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> <a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a69b7eb958dd9600fc657a046524e2371">MHWRender::MLightParameterInformation::kCosConeAngle</a>:</div>
<div class="line">                lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>(pname,floatVals);</div>
<div class="line">                hotspot = <a class="code" href="./class_m_angle.html">MAngle</a>(acos(floatVals[0]), <a name="a435"></a><a class="code" href="./class_m_angle.html#abceb2331ad056e3c5ad27894199a49edacbf42b42e59efcda5e100ade7d4df2f5">MAngle::kRadians</a>);</div>
<div class="line">                falloff = <a class="code" href="./class_m_angle.html">MAngle</a>(acos(floatVals[1]), <a class="code" href="./class_m_angle.html#abceb2331ad056e3c5ad27894199a49edacbf42b42e59efcda5e100ade7d4df2f5">MAngle::kRadians</a>);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Compute an average position in case we connected an area</span></div>
<div class="line"> <span class="comment">// light to a shader light that cannot handle the 4 corners:</span></div>
<div class="line"> <span class="keywordflow">if</span> (positionCount &gt; 1)</div>
<div class="line">        {</div>
<div class="line">            position[0] /= (float)positionCount;</div>
<div class="line">            position[1] /= (float)positionCount;</div>
<div class="line">            position[2] /= (float)positionCount;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (parameterType)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightColor:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightAmbientColor:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightSpecularColor:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightDiffuseColor:</div>
<div class="line">            {</div>
<div class="line"> <span class="comment">// For swatch and headlamp, we need to tone down the color if it is driving an ambient light:</span></div>
<div class="line"> <span class="keywordflow">if</span> (!isRenderScene(renderType) &amp;&amp; lightInfo.fLightType == eAmbientLight)</div>
<div class="line">                {</div>
<div class="line">                    color[0] *= 0.15f;</div>
<div class="line">                    color[1] *= 0.15f;</div>
<div class="line">                    color[2] *= 0.15f;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">//update color</span></div>
<div class="line">                setParameterAsVector(parameterIndex, (<span class="keywordtype">float</span>*)&amp;color[0]);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightPosition:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightAreaPosition0:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightAreaPosition1:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightAreaPosition2:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightAreaPosition3:</div>
<div class="line">            setParameterAsVector(parameterIndex, (<span class="keywordtype">float</span>*)&amp;position[0]);</div>
<div class="line">            positionCount = 0;</div>
<div class="line">            position = <a class="code" href="./class_m_float_point.html">MFloatPoint</a>();</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightIntensity:</div>
<div class="line">            setParameterAsScalar(parameterIndex, intensity);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eDecayRate:</div>
<div class="line">            setParameterAsScalar(parameterIndex, decayRate);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightDirection:</div>
<div class="line">            setParameterAsVector(parameterIndex, (<span class="keywordtype">float</span>*)&amp;direction[0]);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightShadowMapBias:</div>
<div class="line">            setParameterAsScalar(parameterIndex, shadowBias);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightShadowColor:</div>
<div class="line">            setParameterAsVector(parameterIndex, (<span class="keywordtype">float</span>*)&amp;shadowColor[0]);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightShadowOn:</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Do an extra check to make sure we have an up-to-date shadow map.</span></div>
<div class="line"> <span class="comment">// If not, disable shadows.</span></div>
<div class="line"> <span class="keywordtype">bool</span> localShadowsDirty = <span class="keyword">false</span>;</div>
<div class="line"> <a class="code" href="./class_m_int_array.html">MIntArray</a> intVals;</div>
<div class="line">            lightParam-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#aa3237e2138596c256a541816278b402f">getParameter</a>(<a name="a436"></a><a class="code" href="./class_m_h_w_render_1_1_m_light_parameter_information.html#a4726f61be6b8b7b5983b153374914206a022e27b9cdda6282fe11b0a803d714f5">MHWRender::MLightParameterInformation::kShadowDirty</a>, intVals );</div>
<div class="line"> <span class="keywordflow">if</span> (intVals.<a class="code" href="./class_m_int_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>())</div>
<div class="line">                localShadowsDirty = (intVals[0] != 0) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">            setParameterAsScalar(parameterIndex, globalShadowsOn &amp;&amp; localShadowsOn &amp;&amp; shadowResource &amp;&amp;</div>
<div class="line">                !localShadowsDirty);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightShadowViewProj:</div>
<div class="line">            setParameterAsMatrix(parameterIndex, shadowViewProj);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightShadowMap:</div>
<div class="line">            setParameterAsResource(parameterIndex, shadowResource);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightHotspot:</div>
<div class="line">            setParameterAsScalar(parameterIndex, <span class="keywordtype">float</span>(hotspot.asRadians()));</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightFalloff:</div>
<div class="line">            setParameterAsScalar(parameterIndex, <span class="keywordtype">float</span>(falloff.asRadians()));</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">default</span>:</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::connectExplicitAmbientLight(<span class="keyword">const</span> LightParameterInfo&amp; lightInfo, <span class="keyword">const</span> <a class="code" href="./class_m_object.html">MObject</a>&amp; sourceLight)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordtype">bool</span> bDidConnect = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (sourceLight.<a name="a437"></a><a class="code" href="./class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a438"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ae33c6f2b55f5c895e9d88b72881608f2">MFn::kAmbientLight</a>))</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"> <a name="_a439"></a><a class="code" href="./class_m_fn_ambient_light.html">MFnAmbientLight</a> ambientLight(sourceLight, &amp;status);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (status == <a class="code" href="./class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>)</div>
<div class="line">        {</div>
<div class="line">            bDidConnect = <span class="keyword">true</span>;</div>
<div class="line">            LightParameterInfo::TConnectableParameters::const_iterator it    = lightInfo.fConnectableParameters.begin();</div>
<div class="line">            LightParameterInfo::TConnectableParameters::const_iterator itEnd = lightInfo.fConnectableParameters.end();</div>
<div class="line"> <span class="keywordflow">for</span> (; it != itEnd; ++it)</div>
<div class="line">            {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> parameterIndex = it-&gt;first;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> parameterType  = it-&gt;second;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (parameterType)</div>
<div class="line">                {</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightType:</div>
<div class="line">                    setParameterAsScalar(parameterIndex, (<span class="keywordtype">int</span>)eAmbientLight);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightEnable:</div>
<div class="line">                    setParameterAsScalar(parameterIndex, <span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightColor:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightAmbientColor:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightSpecularColor:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightDiffuseColor:</div>
<div class="line">                    {</div>
<div class="line"> <span class="comment">//update color</span></div>
<div class="line"> <a class="code" href="./class_m_color.html">MColor</a> ambientColor(ambientLight.color());</div>
<div class="line"> <span class="keywordtype">float</span> color[3];</div>
<div class="line">                        ambientColor.<a name="a440"></a><a class="code" href="./class_m_color.html#a0fdda4fb1326cc833ae4edd772389e57">get</a>(color);</div>
<div class="line">                        setParameterAsVector(parameterIndex, color);</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightIntensity:</div>
<div class="line">                    setParameterAsScalar(parameterIndex, ambientLight.intensity());</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> bDidConnect;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::turnOffLight(<span class="keyword">const</span> LightParameterInfo&amp; lightInfo)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> kOffColor[4] = {0.0f, 0.0f, 0.0f, 0.0f};</div>
<div class="line"></div>
<div class="line">    LightParameterInfo::TConnectableParameters::const_iterator it;</div>
<div class="line"> <span class="keywordflow">for</span> (it = lightInfo.fConnectableParameters.begin();</div>
<div class="line">            it != lightInfo.fConnectableParameters.end(); ++it)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> parameterIndex = it-&gt;first;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> parameterType  = it-&gt;second;</div>
<div class="line"> <span class="keywordflow">switch</span> (parameterType)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightEnable:</div>
<div class="line">            setParameterAsScalar(parameterIndex, <span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightColor:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightAmbientColor:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightSpecularColor:</div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightDiffuseColor:</div>
<div class="line">            setParameterAsVector(parameterIndex, (<span class="keywordtype">float</span>*)kOffColor);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">case</span> CUniformParameterBuilder::eLightIntensity:</div>
<div class="line">            setParameterAsScalar(parameterIndex, 0.0f);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    When a shader light is driver either by an explicit light connection or has been bound</span></div>
<div class="line"><span class="comment">    once to a scene light while in "Automatic Bind" mode, we need to make all attributes</span></div>
<div class="line"><span class="comment">    uneditable in the attribute editor.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    This function locks and unlocks light parameters as connection come and go:</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setLightParameterLocking(<span class="keyword">const</span> LightParameterInfo&amp; lightInfo, <span class="keywordtype">bool</span> locked)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">for</span> (LightParameterInfo::TConnectableParameters::const_iterator idxIter=lightInfo.fConnectableParameters.begin();</div>
<div class="line">        idxIter != lightInfo.fConnectableParameters.end();</div>
<div class="line">        ++idxIter)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">int</span> parameterIndex((*idxIter).first);</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> param = fUniformParameters.getElement(parameterIndex);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> uniformPlug(param.<a class="code" href="./class_m_uniform_parameter.html#ab6d4ca450bab408a98a5803c0dbaa747">getPlug</a>());</div>
<div class="line"> <span class="keywordflow">if</span> (!uniformPlug.isNull())</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> uniformAttribute(uniformPlug.attribute());</div>
<div class="line"> <span class="keywordflow">if</span> (!uniformAttribute.isHidden())</div>
<div class="line">                uniformPlug.setLocked(locked);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Texture Management</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a>* dx11ShaderNode::loadTexture(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; textureName, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; layerName, <span class="keywordtype">int</span> alphaChannelIdx, <span class="keywordtype">int</span> mipmapLevels, <a class="code" href="./class_m_object.html">MObject</a> node)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>(textureName.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 0)</div>
<div class="line"> <span class="keywordflow">return</span> NULL;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MHWRender::MRenderer</a>* theRenderer = <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MHWRender::MRenderer::theRenderer</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(theRenderer == NULL)</div>
<div class="line"> <span class="keywordflow">return</span> NULL;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_texture_manager.html">MHWRender::MTextureManager</a>* txtManager = theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#aa3f2ec2984800e2cd8ea09b4ad9f072e">getTextureManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span>(txtManager == NULL)</div>
<div class="line"> <span class="keywordflow">return</span> NULL;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// check extension of texture.</span></div>
<div class="line"> <span class="comment">// for HDR EXR files, we tell Maya to skip using exposeControl or it would normalize our RGB values via linear mapping</span></div>
<div class="line"> <span class="comment">// We don't want that for things like Vector Displacement Maps.</span></div>
<div class="line"> <span class="comment">// In the future, other 32bit images can be added, such as TIF, but those currently do not load properly in ATIL and</span></div>
<div class="line"> <span class="comment">// therefor we have to force them to use linear exposure control for them to load at all.</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> extension;</div>
<div class="line"> <span class="keywordtype">int</span> idx = textureName.<a class="code" href="./class_m_string.html#a8b323761724ea9659348e33b0fea356b">rindexW</a>(L<span class="charliteral">'.'</span>);</div>
<div class="line"> <span class="keywordflow">if</span>(idx &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        extension = textureName.<a class="code" href="./class_m_string.html#ad748626e545fa6db3afc2f61644b5d62">substringW</a>( idx+1, textureName.<a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>()-1 );</div>
<div class="line">        extension = extension.<a name="a441"></a><a class="code" href="./class_m_string.html#a56fd78fe1cd1bc285cc8c336ed977d7e">toLowerCase</a>();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordtype">bool</span> isEXR = (extension == <span class="stringliteral">"exr"</span>);</div>
<div class="line"></div>
<div class="line"> <a name="_a442"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture_arguments.html">MHWRender::MTextureArguments</a> args(textureName, mipmapLevels, !isEXR, layerName, alphaChannelIdx);</div>
<div class="line">    args.setFileTextureNode(node);</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a>* texture = txtManager-&gt;<a name="a443"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture_manager.html#a04aa3cfef217948abc8edd0f19565f95">acquireTexture</a>( args );</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef _DEBUG_SHADER</span></div>
<div class="line"> <span class="keywordflow">if</span>(texture == NULL)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">"-- Texture %s not found.\n"</span>, textureName.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> texture;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::releaseTexture(<a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a>* texture)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span> (texture)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MHWRender::MRenderer</a>* theRenderer = <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MHWRender::MRenderer::theRenderer</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (theRenderer)</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_texture_manager.html">MHWRender::MTextureManager</a>* txtManager = theRenderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#aa3f2ec2984800e2cd8ea09b4ad9f072e">getTextureManager</a>();</div>
<div class="line">            {</div>
<div class="line"> <span class="keywordflow">if</span> (txtManager)</div>
<div class="line">                {</div>
<div class="line">                    txtManager-&gt;<a name="a444"></a><a class="code" href="./class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a">releaseTexture</a>(texture);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Load the texture file and assign to the shader resource variable.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The texture objects are stored and released when no more used.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The control between the texture quality and the performance can be modified</span></div>
<div class="line"><span class="comment">    using the kMipmaplevels annotation when declaring the texture in the shader file,</span></div>
<div class="line"><span class="comment">    and by using the kTextureMipmaplevels annotation in the technique declaration.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    kTextureMipmaplevels applies to all the textures, while kMipmaplevels only applies to</span></div>
<div class="line"><span class="comment">    one texture. kMipmaplevels prevails over kTextureMipmaplevels.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Pass down the fileTexture node(MObject) to enable the texture background loading.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::assignTexture(dx11ShaderDX11EffectShaderResourceVariable* resourceVar, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; textureName, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; layerName, <span class="keywordtype">int</span> alphaChannelIdx, ResourceTextureMap&amp; resourceTexture, <a class="code" href="./class_m_object.html">MObject</a> node)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="comment">// When using custom effect (uv editor or even swatch), we use a fixed mipmap levels that reflects the levels set in the orignal effect</span></div>
<div class="line"> <span class="comment">// This is to have consistency in texture quality between uv editor and the scene</span></div>
<div class="line"> <span class="comment">// and also avoid loading a different version of the texture on each draw</span></div>
<div class="line"> <span class="keywordtype">int</span> mipmapLevels = fFixedTextureMipMapLevels;</div>
<div class="line"> <span class="keywordflow">if</span>(mipmapLevels &lt; 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Generate mip map levels desired by technique</span></div>
<div class="line">        mipmapLevels = fTechniqueTextureMipMapLevels;</div>
<div class="line"> <span class="comment">// If the texture itself specify a level, it prevails over the technique's</span></div>
<div class="line">        getAnnotation(resourceVar, dx11ShaderAnnotation::kMipmaplevels, mipmapLevels);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_texture.html">MHWRender::MTexture</a>* texture = loadTexture(textureName, layerName, alphaChannelIdx, mipmapLevels, node);</div>
<div class="line"></div>
<div class="line">    ID3D11ShaderResourceView* resource = NULL;</div>
<div class="line"> <span class="keywordflow">if</span>(texture != NULL)</div>
<div class="line">    {</div>
<div class="line">        resource = (ID3D11ShaderResourceView*)texture-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_texture.html#ad7bcab0d1707ef0da22fc72ada62c40e">resourceHandle</a>();</div>
<div class="line"><span class="preprocessor">#ifdef _DEBUG_SHADER</span></div>
<div class="line">        printf(<span class="stringliteral">"-- Texture activate : new texture %s loaded and bound.\n"</span>, textureName.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>());</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    resourceVar-&gt;SetResource( resource );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Release the old texture</span></div>
<div class="line">    ResourceTextureMap::iterator it = resourceTexture.find(resourceVar);</div>
<div class="line"> <span class="keywordflow">if</span>(it != resourceTexture.end()) {</div>
<div class="line">        releaseTexture(it-&gt;second);</div>
<div class="line">        resourceTexture.erase(it);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Register new texture</span></div>
<div class="line"> <span class="keywordflow">if</span>(texture != NULL) {</div>
<div class="line">        resourceTexture[resourceVar] = texture;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::releaseAllTextures(ResourceTextureMap&amp; resourceTexture)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    ResourceTextureMap::iterator it = resourceTexture.begin();</div>
<div class="line">    ResourceTextureMap::iterator itEnd = resourceTexture.end();</div>
<div class="line"> <span class="keywordflow">for</span>(; it != itEnd; ++it) {</div>
<div class="line">        releaseTexture(it-&gt;second);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    resourceTexture.clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::releaseAllTextures()</div>
<div class="line">{</div>
<div class="line">    releaseAllTextures(fResourceTextureMap);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    getTextureFile is used to retrieve the path of the texture file linked to the source node when duplicating</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">bool</span> dx11ShaderNode::getTextureFile(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; uniformName, <a class="code" href="./class_m_string.html">MString</a>&amp; textureFile)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>(fDuplicateNodeSource)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// When we are in duplicate command, let the command be in charge of connecting the texture nodes.</span></div>
<div class="line"> <span class="comment">// Leave the textureFile empty so that connection will be created for the texture parameter.</span></div>
<div class="line"> <span class="comment">// Return true so that the builder will not look for a default value from the shader file.</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// Convenient functions</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setParameterAsVector(<span class="keywordtype">int</span> inParamIndex, <span class="keywordtype">float</span>* data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>( inParamIndex &gt; -1)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(inParamIndex);</div>
<div class="line">        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">            effectVariable-&gt;AsVector()-&gt;SetFloatVector( data );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setParameterAsScalar(<span class="keywordtype">int</span> inParamIndex, <span class="keywordtype">float</span> data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>( inParamIndex &gt; -1)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(inParamIndex);</div>
<div class="line">        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">            effectVariable-&gt;AsScalar()-&gt;SetFloat( data );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setParameterAsScalar(<span class="keywordtype">int</span> inParamIndex, <span class="keywordtype">bool</span> data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>( inParamIndex &gt; -1)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(inParamIndex);</div>
<div class="line">        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">            effectVariable-&gt;AsScalar()-&gt;SetBool( data );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setParameterAsScalar(<span class="keywordtype">int</span> inParamIndex, <span class="keywordtype">int</span> data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>( inParamIndex &gt; -1)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(inParamIndex);</div>
<div class="line">        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">            effectVariable-&gt;AsScalar()-&gt;SetInt( data );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setParameterAsMatrix(<span class="keywordtype">int</span> inParamIndex, <a class="code" href="./class_m_matrix.html">MMatrix</a>&amp; data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>( inParamIndex &gt; -1)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(inParamIndex);</div>
<div class="line">        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">float</span> matrix[4][4];</div>
<div class="line">            data.<a name="a445"></a><a class="code" href="./class_m_matrix.html#afc8a36464bb71526e9d2bc0361f643cf">get</a>(matrix);</div>
<div class="line">            effectVariable-&gt;AsMatrix()-&gt;SetMatrix( (<span class="keywordtype">float</span>*)&amp;matrix[0] );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setParameterAsResource(<span class="keywordtype">int</span> inParamIndex, ID3D11ShaderResourceView* inResource)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>( inParamIndex &gt; -1 &amp;&amp; inResource)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(inParamIndex);</div>
<div class="line">        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">            effectVariable-&gt;AsShaderResource()-&gt;SetResource( inResource );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setParameterFromUniformAsVector(<span class="keywordtype">int</span> inParamIndex,<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context, <span class="keyword">const</span> <span class="keywordtype">float</span> *data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>( inParamIndex &gt; -1)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(inParamIndex);</div>
<div class="line">        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span>(data == NULL)</div>
<div class="line">                data = uniform.<a class="code" href="./class_m_uniform_parameter.html#adeb3f26c0cb456d9028fb6e6d71cc51a">getAsFloatArray</a>(context);</div>
<div class="line"></div>
<div class="line">            effectVariable-&gt;AsVector()-&gt;SetFloatVector( data );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setParameterFromUniformAsScalar(<span class="keywordtype">int</span> inParamIndex,<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MHWRender::MDrawContext</a>&amp; context)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">if</span>( inParamIndex &gt; -1)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_uniform_parameter.html">MUniformParameter</a> uniform = fUniformParameters.getElement(inParamIndex);</div>
<div class="line">        ID3DX11EffectVariable* effectVariable = (ID3DX11EffectVariable *)uniform.<a class="code" href="./class_m_uniform_parameter.html#aabc6dea98709831626d182f1bce0c69a">userData</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (effectVariable)</div>
<div class="line">            effectVariable-&gt;AsScalar()-&gt;SetFloat( uniform.<a name="a446"></a><a class="code" href="./class_m_uniform_parameter.html#a1787ffa3e2b8aa402aea8b96d52d488d">getAsFloat</a>(context) );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Parse through the current technique.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    Build and return the current vertexDescList.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keyword">const</span> <a name="_a447"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor_list.html">MHWRender::MVertexBufferDescriptorList</a>* dx11ShaderNode::vertexBufferDescLists()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Test if requirements have changed and rebuild the vertex Desc list if needed</span></div>
<div class="line"> <span class="comment">// ---------------------------------------------------------------</span></div>
<div class="line"> <span class="keywordflow">if</span> (isDirty(fVaryingParametersGeometryVersionId))</div>
<div class="line">    {</div>
<div class="line">        buildVertexDescriptorFromVaryingParameters();</div>
<div class="line">        fVaryingParametersGeometryVersionId = fGeometryVersionId;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> &amp;fVaryingParametersVertexDescriptorList;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="comment">// ERROR Reporting</span></div>
<div class="line"><span class="comment">// ***********************************</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::displayErrorAndWarnings()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a class="code" href="./class_m_plug.html">MPlug</a> diagnosticsPlug( thisMObject(), sDiagnostics);</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> currentDiagnostic;</div>
<div class="line">    diagnosticsPlug.getValue(currentDiagnostic);</div>
<div class="line"> <span class="keywordflow">if</span>(fErrorLog.length())</div>
<div class="line">    {</div>
<div class="line">        currentDiagnostic += dx11ShaderStrings::getString( dx11ShaderStrings::kErrorLog, fErrorLog );</div>
<div class="line">        diagnosticsPlug.setValue( currentDiagnostic );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If an error occured when loading a scene</span></div>
<div class="line"> <span class="comment">// delay the error message so it is shown last</span></div>
<div class="line"> <span class="comment">// and not lost by the list of missing attributes warnings</span></div>
<div class="line"> <span class="keywordflow">if</span>(<a class="code" href="./class_m_file_i_o.html#accbcaffc37fcbee9f7974aae80c8014b">MFileIO::isReadingFile</a>() &amp;&amp; <a class="code" href="./class_m_file_i_o.html#a30bf5678402012d5607a6b0f22d2c2a5">MFileIO::isOpeningFile</a>())</div>
<div class="line">        {</div>
<div class="line">            AfterOpenErrorCB::addError(fErrorLog);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_global.html#a4ddbe97e58a90e1ab05d45a62c006cf0">MGlobal::displayError</a>(fErrorLog);</div>
<div class="line">        }</div>
<div class="line">        fErrorLog.clear();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span>(fWarningLog.length())</div>
<div class="line">    {</div>
<div class="line">        currentDiagnostic += dx11ShaderStrings::getString( dx11ShaderStrings::kWarningLog, fWarningLog );</div>
<div class="line">        diagnosticsPlug.setValue( currentDiagnostic );</div>
<div class="line"> <a name="a448"></a><a class="code" href="./class_m_global.html#acb043e7fc4eb7fc0f39833d31364b8a4">MGlobal::displayWarning</a>(fWarningLog);</div>
<div class="line">        fWarningLog.clear();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define DX11SHADER_ERROR_LIMIT 20</span></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::reportInternalError( <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">function</span>, <span class="keywordtype">size_t</span> errcode )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> es = <span class="stringliteral">"dx11Shader"</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> ( <span class="keyword">this</span> )</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> ( ++fErrorCount &gt; DX11SHADER_ERROR_LIMIT  )</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> s;</div>
<div class="line">            s += <span class="stringliteral">"\""</span>;</div>
<div class="line">            s += name();</div>
<div class="line">            s += <span class="stringliteral">"\": "</span>;</div>
<div class="line">            s += typeName();</div>
<div class="line">            es = s;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">catch</span> ( ... )</div>
<div class="line">    {}</div>
<div class="line">    es += <span class="stringliteral">" internal error "</span>;</div>
<div class="line">    es += (int)errcode;</div>
<div class="line">    es += <span class="stringliteral">" in "</span>;</div>
<div class="line">    es += <span class="keyword">function</span>;</div>
<div class="line"> <a class="code" href="./class_m_global.html#a4ddbe97e58a90e1ab05d45a62c006cf0">MGlobal::displayError</a>( es );</div>
<div class="line">} <span class="comment">// dx11ShaderNode::reportInternalError</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::getExternalContent(<a name="_a449"></a><a class="code" href="./class_m_external_content_info_table.html">MExternalContentInfoTable</a>&amp; table)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    addExternalContentForFileAttr(table, sShader);</div>
<div class="line"> <a name="a450"></a><a class="code" href="./class_m_px_node.html#abfc494661ea0f7f957a9e437cebb2642">MPxHardwareShader::getExternalContent</a>(table);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> dx11ShaderNode::setExternalContent(<span class="keyword">const</span> <a name="_a451"></a><a class="code" href="./class_m_external_content_location_table.html">MExternalContentLocationTable</a>&amp; table)</div>
<div class="line">{</div>
<div class="line">    setExternalContentForFileAttr(sShader, table);</div>
<div class="line"> <a name="a452"></a><a class="code" href="./class_m_px_node.html#a389fc88c7e5236aa2b9980a1b452cc49">MPxHardwareShader::setExternalContent</a>(table);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>

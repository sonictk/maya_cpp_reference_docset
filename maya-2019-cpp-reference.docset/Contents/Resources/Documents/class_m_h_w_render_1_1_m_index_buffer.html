<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../scripts/utils/adsk.redirect.js"></script>
      <title>MIndexBuffer Class Reference</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_h_w_render_1_1_m_index_buffer.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>MIndexBuffer Class Reference</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/files.html"><span>Files</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="#!/url=./cpp_ref/classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="#!/url=./cpp_ref/hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="#!/url=./cpp_ref/functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  
  <div class="headertitle">
<div class="title">MIndexBuffer Class Reference<div class="ingroups"><a class="el" translate="no" href="#!/url=./cpp_ref/group___open_maya_render.html">OpenMayaRender - API module for rendering</a></div></div>  </div>
<div id="OverviewLinksDiv"><div id="dynsection-overview" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><img id="dynsection-overview-trigger" src="cpp_ref/closed.png" alt="+"> Related help topics: </div><div id="dynsection-overview-content" class="dyncontent" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016 Extension 2</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/Autodesk-Maya-2015.html">What&#39;s New / What&#39;s Changed? &gt; Autodesk Maya 2015</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/Autodesk-Maya-2014.html">What&#39;s New / What&#39;s Changed? &gt; Autodesk Maya 2014</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/Extension-for-Autodesk-Maya-2013.html">What&#39;s New / What&#39;s Changed? &gt; Extension for Autodesk Maya 2013</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Overview-of-the-Viewport-2-0-API/Data-Classes.html">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Data Classes</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/API-constructs/Geometric-Data-MGeometry-.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; API constructs &gt; Geometric Data (MGeometry)</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Geometry-Overrides.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Plug-in Entry Points &gt; Geometry Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Effect-Overrides.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Plug-in Entry Points &gt; Effect Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Customizing-Geometric-Data-for.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Customizing Geometric Data for Shaders</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_h_w_render_1_1_m_index_buffer.html#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_h_w_render_1_1_m_index_buffer.html#pub-static-methods">Static Public Member Functions</a>  </div></div><!--header-->
<div class="contents">

<p><code>#include &lt;MHWGeometry.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><p>Index buffer for use with <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html" title="Class for working with geometric structures used to draw objects. ">MGeometry</a>. </p>
<p>This class represents an index buffer with a specific data type.</p>
<p>When retrieving an index buffer for binding to custom shaders (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html" title="Base class for user defined shading effect draw overrides. ">MPxShaderOverride</a>), <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e" title="Gets a graphics device dependent handle to the vertex indexing data. ">resourceHandle()</a> may be called to get the device dependent handle to the index buffer on the GPU.</p>
<p>When creating an index buffer to supply geometric data to Maya (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a>), <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> may be called to get a pointer to a block of memory to fill with said data. Once filled, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83" title="Commit the data stored in the memory given by acquire() to the buffer. ">commit()</a> must be called to apply the data to the buffer. </p>
<dl class="section "><div id="dynsection-example0" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example0-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example0-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#_a191">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_geometry_override_8h-example.html#_a21">apiMeshShape/apiMeshGeometryOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_sub_scene_override_8cpp-example.html#_a109">apiMeshShape/apiMeshSubSceneOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_sub_scene_override_8h-example.html#_a26">apiMeshShape/apiMeshSubSceneOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8cpp-example.html#_a176">cgFx/cgfxShaderNode.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#_a6">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2crack_free_primitive_generator_8cpp-example.html#_a6">dx11Shader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2crack_free_primitive_generator_8h-example.html#_a4">dx11Shader/crackFreePrimitiveGenerator.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#_a338">dx11Shader/dx11Shader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/foot_print_node__geometry_override_2foot_print_node__geometry_override_8cpp-example.html#_a109">footPrintNode_GeometryOverride/footPrintNode_GeometryOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/foot_print_node__geometry_override__animated_material_2foot_print_node__geometry_override__animated_material_8cpp-example.html#_a117">footPrintNode_GeometryOverride_AnimatedMaterial/footPrintNode_GeometryOverride_AnimatedMaterial.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/foot_print_node__sub_scene_override_2foot_print_node__sub_scene_override_8cpp-example.html#_a52">footPrintNode_SubSceneOverride/footPrintNode_SubSceneOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_override_example1_2geometry_override_example1_8cpp-example.html#_a52">geometryOverrideExample1/geometryOverrideExample1.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_override_example2_2geometry_override_example2_8cpp-example.html#_a44">geometryOverrideExample2/geometryOverrideExample2.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_override_high_performance_2geometry_override_high_performance_8cpp-example.html#_a115">geometryOverrideHighPerformance/geometryOverrideHighPerformance.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_replicator_2geometry_replicator_8cpp-example.html#_a57">geometryReplicator/geometryReplicator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2adjacent_triangles_primitive_generator_8cpp-example.html#_a7">glslShader/adjacentTrianglesPrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2adjacent_triangles_primitive_generator_8h-example.html#_a4">glslShader/adjacentTrianglesPrimitiveGenerator.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2crack_free_primitive_generator_8cpp-example.html#_a6">glslShader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2crack_free_primitive_generator_8h-example.html#_a4">glslShader/crackFreePrimitiveGenerator.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/gpu_cache_2gpu_cache_cmd_8cpp-example.html#_a68">gpuCache/gpuCacheCmd.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/gpu_cache_2gpu_cache_sub_scene_override_8cpp-example.html#_a0">gpuCache/gpuCacheSubSceneOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/gpu_cache_2gpu_cache_sub_scene_override_8h-example.html#_a2">gpuCache/gpuCacheSubSceneOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#_a70">hwPhongShader/hwPhongShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_crack_free_primitive_generator_8cpp-example.html#_a6">tessellatedQuad/CrackFreePrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_crack_free_primitive_generator_8h-example.html#_a4">tessellatedQuad/CrackFreePrimitiveGenerator.h</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#_a69">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>.</dd></div>
</dl></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adbe950e14eb2920b18aa77fdba28d2a4"><td class="memItemLeft" translate="no" align="right" valign="top">&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adbe950e14eb2920b18aa77fdba28d2a4">MIndexBuffer</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MGeometry::DataType</a> type, bool softwareStaged=true)</td></tr>
<tr class="memdesc:adbe950e14eb2920b18aa77fdba28d2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#adbe950e14eb2920b18aa77fdba28d2a4">More...</a><br></td></tr>
<tr class="separator:adbe950e14eb2920b18aa77fdba28d2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c3c986a2900504ec7ce43d30cada93"><td class="memItemLeft" translate="no" align="right" valign="top">&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ab8c3c986a2900504ec7ce43d30cada93">MIndexBuffer</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a> &amp;)</td></tr>
<tr class="memdesc:ab8c3c986a2900504ec7ce43d30cada93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#ab8c3c986a2900504ec7ce43d30cada93">More...</a><br></td></tr>
<tr class="separator:ab8c3c986a2900504ec7ce43d30cada93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104f41add0e6d753b52018452ab5d9be"><td class="memItemLeft" translate="no" align="right" valign="top">&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a104f41add0e6d753b52018452ab5d9be">~MIndexBuffer</a> ()</td></tr>
<tr class="memdesc:a104f41add0e6d753b52018452ab5d9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#a104f41add0e6d753b52018452ab5d9be">More...</a><br></td></tr>
<tr class="separator:a104f41add0e6d753b52018452ab5d9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7588a483f61d3d4a1e8204ca14d6f6"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MGeometry::DataType</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#abc7588a483f61d3d4a1e8204ca14d6f6">dataType</a> () const </td></tr>
<tr class="memdesc:abc7588a483f61d3d4a1e8204ca14d6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type of the buffer.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#abc7588a483f61d3d4a1e8204ca14d6f6">More...</a><br></td></tr>
<tr class="separator:abc7588a483f61d3d4a1e8204ca14d6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ca964ebcc1b02bbcde225edd49e812"><td class="memItemLeft" translate="no" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a90ca964ebcc1b02bbcde225edd49e812">size</a> () const </td></tr>
<tr class="memdesc:a90ca964ebcc1b02bbcde225edd49e812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the buffer in units of <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#abc7588a483f61d3d4a1e8204ca14d6f6" title="Get the data type of the buffer. ">dataType()</a>.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#a90ca964ebcc1b02bbcde225edd49e812">More...</a><br></td></tr>
<tr class="separator:a90ca964ebcc1b02bbcde225edd49e812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bcab0d1707ef0da22fc72ada62c40e"><td class="memItemLeft" translate="no" align="right" valign="top">void *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e">resourceHandle</a> () const </td></tr>
<tr class="memdesc:ad7bcab0d1707ef0da22fc72ada62c40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a graphics device dependent handle to the vertex indexing data.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e">More...</a><br></td></tr>
<tr class="separator:ad7bcab0d1707ef0da22fc72ada62c40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1f9567b0b118122663a0ae42424537"><td class="memItemLeft" translate="no" align="right" valign="top">void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ade1f9567b0b118122663a0ae42424537">resourceHandle</a> (void *handle, unsigned int <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a90ca964ebcc1b02bbcde225edd49e812">size</a>)</td></tr>
<tr class="memdesc:ade1f9567b0b118122663a0ae42424537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly set the graphics-device-dependent hardware buffer resource handle.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#ade1f9567b0b118122663a0ae42424537">More...</a><br></td></tr>
<tr class="separator:ade1f9567b0b118122663a0ae42424537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d1538f7339521cd85c52d140d0bc6c"><td class="memItemLeft" translate="no" align="right" valign="top">bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aa8d1538f7339521cd85c52d140d0bc6c">hasCustomResourceHandle</a> () const </td></tr>
<tr class="memdesc:aa8d1538f7339521cd85c52d140d0bc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this index buffer is using a custom resource handle set by the plugin using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ade1f9567b0b118122663a0ae42424537" title="Directly set the graphics-device-dependent hardware buffer resource handle. ">MIndexBuffer::resourceHandle(void*, unsigned int)</a>.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#aa8d1538f7339521cd85c52d140d0bc6c">More...</a><br></td></tr>
<tr class="separator:aa8d1538f7339521cd85c52d140d0bc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8ad9c60e845cd4fd84c171c0a63a27"><td class="memItemLeft" translate="no" align="right" valign="top">void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27">lockResourceHandle</a> ()</td></tr>
<tr class="memdesc:adf8ad9c60e845cd4fd84c171c0a63a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the resource handle.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27">More...</a><br></td></tr>
<tr class="separator:adf8ad9c60e845cd4fd84c171c0a63a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab064164207ef83bb764a2c57524a14"><td class="memItemLeft" translate="no" align="right" valign="top">void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adab064164207ef83bb764a2c57524a14">unlockResourceHandle</a> ()</td></tr>
<tr class="memdesc:adab064164207ef83bb764a2c57524a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the resource handle.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#adab064164207ef83bb764a2c57524a14">More...</a><br></td></tr>
<tr class="separator:adab064164207ef83bb764a2c57524a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9e3c2ed40ad0c0f0fe55668670d071"><td class="memItemLeft" translate="no" align="right" valign="top">void *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a> (unsigned int <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a90ca964ebcc1b02bbcde225edd49e812">size</a>, bool writeOnly)</td></tr>
<tr class="memdesc:aff9e3c2ed40ad0c0f0fe55668670d071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to memory for the buffer.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">More...</a><br></td></tr>
<tr class="separator:aff9e3c2ed40ad0c0f0fe55668670d071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb3736206f8a73c0fc74757919cfb83"><td class="memItemLeft" translate="no" align="right" valign="top">void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a> (void *buffer)</td></tr>
<tr class="memdesc:aafb3736206f8a73c0fc74757919cfb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the data stored in the memory given by <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> to the buffer.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83">More...</a><br></td></tr>
<tr class="separator:aafb3736206f8a73c0fc74757919cfb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9e783c4d7826700a6a6824451f8230"><td class="memItemLeft" translate="no" align="right" valign="top">void *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#abc9e783c4d7826700a6a6824451f8230">map</a> ()</td></tr>
<tr class="memdesc:abc9e783c4d7826700a6a6824451f8230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only pointer to the existing content of the buffer.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#abc9e783c4d7826700a6a6824451f8230">More...</a><br></td></tr>
<tr class="separator:abc9e783c4d7826700a6a6824451f8230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffeb3b5abb3d61f62b58a391816201c"><td class="memItemLeft" translate="no" align="right" valign="top">void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">unmap</a> ()</td></tr>
<tr class="memdesc:a1ffeb3b5abb3d61f62b58a391816201c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the data exposed by <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a>.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c">More...</a><br></td></tr>
<tr class="separator:a1ffeb3b5abb3d61f62b58a391816201c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26b69fe0c36cb3ee56d827a7fb467cf"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ac26b69fe0c36cb3ee56d827a7fb467cf">update</a> (const void *buffer, unsigned int destOffset, unsigned int numIndices, bool truncateIfSmaller)</td></tr>
<tr class="memdesc:ac26b69fe0c36cb3ee56d827a7fb467cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a portion (or all) of the contents of the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> using the data in the provided software buffer.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#ac26b69fe0c36cb3ee56d827a7fb467cf">More...</a><br></td></tr>
<tr class="separator:ac26b69fe0c36cb3ee56d827a7fb467cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d84312cb36261792b879ffc61e7e16"><td class="memItemLeft" translate="no" align="right" valign="top">void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a75d84312cb36261792b879ffc61e7e16">unload</a> ()</td></tr>
<tr class="memdesc:a75d84312cb36261792b879ffc61e7e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the buffer is resident in GPU memory, calling this method will move it to system memory and free the GPU memory.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#a75d84312cb36261792b879ffc61e7e16">More...</a><br></td></tr>
<tr class="separator:a75d84312cb36261792b879ffc61e7e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c77f256958aa1993cd985b5cf8861f1"><td class="memItemLeft" translate="no" align="right" valign="top">void *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a3c77f256958aa1993cd985b5cf8861f1">acquire</a> (unsigned int <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a90ca964ebcc1b02bbcde225edd49e812">size</a>)</td></tr>
<tr class="memdesc:a3c77f256958aa1993cd985b5cf8861f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>This method is obsolete.</b>  <a href="class_m_h_w_render_1_1_m_index_buffer.html#a3c77f256958aa1993cd985b5cf8861f1">More...</a><br></td></tr>
<tr class="separator:a3c77f256958aa1993cd985b5cf8861f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memItemLeft" translate="no" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this class.  <a href="class_m_h_w_render_1_1_m_index_buffer.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adbe950e14eb2920b18aa77fdba28d2a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MGeometry::DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>softwareStaged</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The data type for the index buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softwareStaged</td><td>A flag defining how buffers are managed and updated. When software staged is specified the system may keep an extra copy of the buffer in system memory for fast read-back and access. Software staging is useful for cases where the buffer is written once and changes infrequently. Software staging helps to improve consolidation performance and handling under low memory conditions. For buffers that change frequently (animated) and are accessed in write only mode you may see better performance if you set this option to false. (default: true)</td></tr>
  </table>
  </dd>
</dl>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> the MIndexBuffers used must be software staged. </p>

</div>
</div>
<a class="anchor" id="ab8c3c986a2900504ec7ce43d30cada93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a104f41add0e6d753b52018452ab5d9be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">~<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note that it is an error to delete <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> objects that are owned by or in use by an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html" title="Class for working with geometric structures used to draw objects. ">MGeometry</a> object. Such actions may cause instability.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to destroy an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> object during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#aa4c938a24a336e5ca1c28372bc6972d7" title="Called after all other stages are completed. ">MPxGeometryOverride::cleanUp()</a> or <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with VP2 Custom Caching in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to destroy an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> buffer during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abc7588a483f61d3d4a1e8204ca14d6f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MGeometry::DataType</a> dataType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data type of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The data type of the buffer </dd></dl>
<dl class="section "><div id="dynsection-example1" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example1-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example1-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8cpp-example.html#a185">cgFx/cgfxShaderNode.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#a18">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2crack_free_primitive_generator_8cpp-example.html#a18">dx11Shader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#a341">dx11Shader/dx11Shader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2adjacent_triangles_primitive_generator_8cpp-example.html#a18">glslShader/adjacentTrianglesPrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2crack_free_primitive_generator_8cpp-example.html#a18">glslShader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a77">hwPhongShader/hwPhongShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_crack_free_primitive_generator_8cpp-example.html#a18">tessellatedQuad/CrackFreePrimitiveGenerator.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#a79">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a90ca964ebcc1b02bbcde225edd49e812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">unsigned int size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the buffer in units of <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#abc7588a483f61d3d4a1e8204ca14d6f6" title="Get the data type of the buffer. ">dataType()</a>. </p>
<p>Returns 0 if unallocated.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the buffer </dd></dl>
<dl class="section "><div id="dynsection-example2" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example2-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example2-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8cpp-example.html#a180">cgFx/cgfxShaderNode.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#a346">dx11Shader/dx11Shader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/gpu_cache_2gpu_cache_sub_scene_override_8cpp-example.html#a1">gpuCache/gpuCacheSubSceneOverride.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a72">hwPhongShader/hwPhongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ad7bcab0d1707ef0da22fc72ada62c40e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void * resourceHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a graphics device dependent handle to the vertex indexing data. </p>
<p>For OpenGL the return value is a pointer to an OpenGL identifier (GLuint) for a vertex buffer containing the indexing data. (e.g. using glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle)). For DirectX11 the return value is a pointer to an ID3D11Buffer interface of the index buffer.</p>
<p>The index buffer identifier can be used to perform drawing of vertex buffer data identified by handles returned from <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e" title="Gets a graphics device dependent handle to a vertex buffer. ">MVertexBuffer::resourceHandle()</a>.</p>
<p>An example setup could be: </p><ol>
<li>
For each vertex buffer query the handle. </li>
<li>
For each data handle set it up using the vertex buffer information (mapped to the draw API). </li>
<li>
Query the index handle. </li>
<li>
Use the index handle and index buffer information (mapped to the draw API) to perform drawing. </li>
</ol>
<p>A NULL pointer will be returned if the graphics device dependent handle is not yet available.</p>
<p>If the pointer is not NULL, the value is only guaranteed to exist during the current draw. The value should never be cached or modified.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to access the resourceHandle of an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to device dependent indexing data. </dd></dl>
<dl class="section "><div id="dynsection-example3" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example3-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example3-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8cpp-example.html#a178">cgFx/cgfxShaderNode.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#a340">dx11Shader/dx11Shader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a74">hwPhongShader/hwPhongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ade1f9567b0b118122663a0ae42424537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void resourceHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly set the graphics-device-dependent hardware buffer resource handle. </p>
<p>This will result in the creation of a custom user index buffer. Maya can render it, but the plugin owns the underlying device resource. When the Maya buffer is deleted, the actual hardware buffer will not be deleted. These buffers cannot be filled with Acquire or read-back with Map. They must be created and pre-filled, by the plugin.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to set the resourceHandle of an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>For OpenGL, handle is a pointer to a GLuint resource identifier for a vertex buffer object. For DirectX11, handle is a pointer to an ID3D11Buffer interface. This pointer must remain valid after <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#a37c7a59c1e34ed5e0528fe0ac351b519" title="Implementations of this method should create and populate vertex and index buffers on the MGeometry i...">MPxGeometryOverride::populateGeometry()</a> returns, though not indefinitely after that. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of indices in the indicated buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8d1538f7339521cd85c52d140d0bc6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool hasCustomResourceHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this index buffer is using a custom resource handle set by the plugin using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ade1f9567b0b118122663a0ae42424537" title="Directly set the graphics-device-dependent hardware buffer resource handle. ">MIndexBuffer::resourceHandle(void*, unsigned int)</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this index buffer is using a custom resource handle. </dd></dl>

</div>
</div>
<a class="anchor" id="adf8ad9c60e845cd4fd84c171c0a63a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void lockResourceHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the resource handle. </p>
<p>The pointer returned from <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e" title="Gets a graphics device dependent handle to the vertex indexing data. ">resourceHandle()</a> is guaranteed to exist between <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adab064164207ef83bb764a2c57524a14" title="Unlock the resource handle. ">unlockResourceHandle()</a>.</p>
<p><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> may store data in system memory, GPU memory or both. Direct access to the GPU representation of the data is possible through the buffer's <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ad7bcab0d1707ef0da22fc72ada62c40e" title="Gets a graphics device dependent handle to the vertex indexing data. ">resourceHandle()</a>. If the GPU representation of the data is to be directly modified using an external graphics or compute API, then <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> must be called on the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> once, before any modifications to the buffer are made.</p>
<p>While a resource handle is locked, any external modifications to the GPU buffer will be recognized by Maya.</p>
<p>While a resource handle is locked, consolidated world will take longer to consolidate the corresponding object. After unlocking a resource handle, consolidated world will take longer to consolidate the corresponding object one more time, the first time the unlocked resource handle is consolidated.</p>
<p>Calling <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adab064164207ef83bb764a2c57524a14" title="Unlock the resource handle. ">unlockResourceHandle()</a> on a custom resource handle has no effect.</p>
<p>Reallocating or deleting the GPU representation of the data between <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adab064164207ef83bb764a2c57524a14" title="Unlock the resource handle. ">unlockResourceHandle()</a> will result in undefined behavior. <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83" title="Commit the data stored in the memory given by acquire() to the buffer. ">commit()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ac26b69fe0c36cb3ee56d827a7fb467cf" title="Set a portion (or all) of the contents of the MIndexBuffer using the data in the provided software bu...">update()</a> may reallocate the GPU representation. <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a75d84312cb36261792b879ffc61e7e16" title="If the buffer is resident in GPU memory, calling this method will move it to system memory and free t...">unload()</a> may delete the GPU representation.</p>
<p><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c" title="Release the data exposed by map(). ">unmap()</a> will work if they are called between <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> and <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adab064164207ef83bb764a2c57524a14" title="Unlock the resource handle. ">unlockResourceHandle()</a>. They operate on the GPU representation.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to access the GPU representation of the buffer. Therefore, calling <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a>, or calling <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83" title="Commit the data stored in the memory given by acquire() to the buffer. ">commit()</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ac26b69fe0c36cb3ee56d827a7fb467cf" title="Set a portion (or all) of the contents of the MIndexBuffer using the data in the provided software bu...">update()</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a> or <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c" title="Release the data exposed by map(). ">unmap()</a> on an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html" title="Vertex buffer for use with MGeometry. ">MVertexBuffer</a> locked resource handle is only safe during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#aa4c938a24a336e5ca1c28372bc6972d7" title="Called after all other stages are completed. ">MPxGeometryOverride::cleanUp()</a> or <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride</a>.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with VP2 Custom Caching in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to access the GPU representation of an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> buffer during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>. </p>

</div>
</div>
<a class="anchor" id="adab064164207ef83bb764a2c57524a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void unlockResourceHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the resource handle. </p>
<p>The pointer returned from resourceHandle is not guaranteed to exist any more.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to unlockResourceHande() an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a>.</p>
<p>See <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#adf8ad9c60e845cd4fd84c171c0a63a27" title="Lock the resource handle. ">lockResourceHandle()</a> for more details. </p>

</div>
</div>
<a class="anchor" id="aff9e3c2ed40ad0c0f0fe55668670d071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void * acquire </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to memory for the buffer. </p>
<p>This method is meant to be used in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#a37c7a59c1e34ed5e0528fe0ac351b519" title="Implementations of this method should create and populate vertex and index buffers on the MGeometry i...">MPxGeometryOverride::populateGeometry()</a> in order to provide data to Maya for drawing the associated object. The size of the buffer returned will be (size * sizeof(dataType())) bytes. The memory for the buffer is managed internally.</p>
<p>Note that not all data types are currently supported for index buffers. If the data type for this buffer is not supported this method will return NULL.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the buffer to acquire </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">writeOnly</td><td>Specified if the returned memory should be uninitialized or filled with actual buffer content. When the current buffer content is not needed, it is preferable to set the writeOnly flag to true for better performance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to memory for the buffer, or NULL on failure </dd></dl>
<dl class="section "><div id="dynsection-example4" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example4-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example4-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#a194">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_sub_scene_override_8cpp-example.html#a119">apiMeshShape/apiMeshSubSceneOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#a14">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2crack_free_primitive_generator_8cpp-example.html#a17">dx11Shader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/foot_print_node__geometry_override_2foot_print_node__geometry_override_8cpp-example.html#a113">footPrintNode_GeometryOverride/footPrintNode_GeometryOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/foot_print_node__geometry_override__animated_material_2foot_print_node__geometry_override__animated_material_8cpp-example.html#a121">footPrintNode_GeometryOverride_AnimatedMaterial/footPrintNode_GeometryOverride_AnimatedMaterial.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_override_example1_2geometry_override_example1_8cpp-example.html#a55">geometryOverrideExample1/geometryOverrideExample1.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_override_example2_2geometry_override_example2_8cpp-example.html#a47">geometryOverrideExample2/geometryOverrideExample2.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_override_high_performance_2geometry_override_high_performance_8cpp-example.html#a118">geometryOverrideHighPerformance/geometryOverrideHighPerformance.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_replicator_2geometry_replicator_8cpp-example.html#a60">geometryReplicator/geometryReplicator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2adjacent_triangles_primitive_generator_8cpp-example.html#a17">glslShader/adjacentTrianglesPrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2crack_free_primitive_generator_8cpp-example.html#a17">glslShader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_crack_free_primitive_generator_8cpp-example.html#a17">tessellatedQuad/CrackFreePrimitiveGenerator.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#a74">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aafb3736206f8a73c0fc74757919cfb83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void commit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit the data stored in the memory given by <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> to the buffer. </p>
<p>If this method is not called, the acquired buffer will not be used in drawing. The pointer must be the same pointer returned from <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a>.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83" title="Commit the data stored in the memory given by acquire() to the buffer. ">commit()</a> an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section "><div id="dynsection-example5" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example5-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example5-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#a195">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_sub_scene_override_8cpp-example.html#a120">apiMeshShape/apiMeshSubSceneOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_primitive_generator_2custom_primitive_generator_8cpp-example.html#a21">customPrimitiveGenerator/customPrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2crack_free_primitive_generator_8cpp-example.html#a20">dx11Shader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/foot_print_node__geometry_override_2foot_print_node__geometry_override_8cpp-example.html#a114">footPrintNode_GeometryOverride/footPrintNode_GeometryOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/foot_print_node__geometry_override__animated_material_2foot_print_node__geometry_override__animated_material_8cpp-example.html#a122">footPrintNode_GeometryOverride_AnimatedMaterial/footPrintNode_GeometryOverride_AnimatedMaterial.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_override_example1_2geometry_override_example1_8cpp-example.html#a56">geometryOverrideExample1/geometryOverrideExample1.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_override_example2_2geometry_override_example2_8cpp-example.html#a48">geometryOverrideExample2/geometryOverrideExample2.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_override_high_performance_2geometry_override_high_performance_8cpp-example.html#a119">geometryOverrideHighPerformance/geometryOverrideHighPerformance.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/geometry_replicator_2geometry_replicator_8cpp-example.html#a61">geometryReplicator/geometryReplicator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2adjacent_triangles_primitive_generator_8cpp-example.html#a20">glslShader/adjacentTrianglesPrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2crack_free_primitive_generator_8cpp-example.html#a20">glslShader/crackFreePrimitiveGenerator.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_crack_free_primitive_generator_8cpp-example.html#a20">tessellatedQuad/CrackFreePrimitiveGenerator.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#a75">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="abc9e783c4d7826700a6a6824451f8230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void * map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a read-only pointer to the existing content of the buffer. </p>
<p>Writing new content in this memory block is not supported and can lead to unexpected behavior.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a> an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to memory for the buffer, or NULL on failure </dd></dl>
<dl class="section "><div id="dynsection-example6" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example6-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example6-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#a349">dx11Shader/dx11Shader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a79">hwPhongShader/hwPhongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a1ffeb3b5abb3d61f62b58a391816201c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void unmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the data exposed by <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#abc9e783c4d7826700a6a6824451f8230" title="Get a read-only pointer to the existing content of the buffer. ">map()</a>. </p>
<p>If this method is not called, the buffer will not be recycled.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is not safe to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a1ffeb3b5abb3d61f62b58a391816201c" title="Release the data exposed by map(). ">unmap()</a> an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a>.</p>
<p>In OpenGL mode, this will leave the ARRAY_BUFFER and ELEMENT_ARRAY_BUFFER bindings to 0. </p>
<dl class="section "><div id="dynsection-example7" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example7-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example7-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#a350">dx11Shader/dx11Shader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/hw_phong_shader_2hw_phong_shader_8cpp-example.html#a80">hwPhongShader/hwPhongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ac26b69fe0c36cb3ee56d827a7fb467cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> update </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>destOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncateIfSmaller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a portion (or all) of the contents of the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> using the data in the provided software buffer. </p>
<p>The internal hardware buffer will be allocated or reallocated to fit if required. The buffer size will be at least (size * sizeof(dataType())) bytes. If this operation requires enlarging an existing buffer and specifies an offset to update only a portion of the contents, then the old data before that offset may not be preserved.</p>
<p>Note that not all data types are currently supported for index buffers. If the data type for this buffer is not supported this method will return <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00" title="The operation failed. ">MStatus::kFailure</a>.</p>
<p>If the index data is already available in the correct format for a simple memory copy, then this function should be more efficient than using acquire/commit or map/unmap. It should require fewer buffer copy operations.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#ac26b69fe0c36cb3ee56d827a7fb467cf" title="Set a portion (or all) of the contents of the MIndexBuffer using the data in the provided software bu...">update()</a> an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The input data buffer, starting with the first index to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destOffset</td><td>The offset (in indices) from the beginning of the buffer to start writing to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numIndices</td><td>The number of indices to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncateIfSmaller</td><td>If true and offset+numIndices is less than the pre-existing size of the buffer, then the buffer contents will be truncated to the new size. Truncating the buffer size will not cause a reallocation and will not lose data before the destOffset.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1" title="The operation was successful. ">MStatus::kSuccess</a></b> The method was successful </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af8c5f748892ec74b32719c8fba7767e1" title="An invalid parameter was provided. ">MStatus::kInvalidParameter</a></b> Buffer was NULL or numIndices was 0. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00" title="The operation failed. ">MStatus::kFailure</a></b> The data type was not valid or there was an error while allocating or updating the hardware buffer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a75d84312cb36261792b879ffc61e7e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void unload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the buffer is resident in GPU memory, calling this method will move it to system memory and free the GPU memory. </p>
<p>The buffer will be automatically reloaded into GPU memory the next time it is needed to draw an object. This method may be used to help manage GPU memory when working with extremely large sets of data.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#a75d84312cb36261792b879ffc61e7e16" title="If the buffer is resident in GPU memory, calling this method will move it to system memory and free t...">unload()</a> an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> object during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#aa4c938a24a336e5ca1c28372bc6972d7" title="Called after all other stages are completed. ">MPxGeometryOverride::cleanUp()</a> or <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with VP2 Custom Caching in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is only safe to unload an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> buffer during <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#ad89ac1b117f04e0026b73378ca097ff1" title="Destructor. ">MPxGeometryOverride::~MPxGeometryOverride()</a>. </p>

</div>
</div>
<a class="anchor" id="a774cd5d8fbebe8e7ed82a5aa587d1f04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">const char * className </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c77f256958aa1993cd985b5cf8861f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void * acquire </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>This method is obsolete.</b> </p>
<dl class="deprecated"><dt><b><a class="el" translate="no" href="#!/url=./cpp_ref/deprecated.html#_deprecated000236">Deprecated:</a></b></dt><dd>Please use <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire(unsigned int size, bool writeOnly)</a> instead.</dd></dl>
<p>Get a pointer to memory for the buffer. This method is meant to be used in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html#a37c7a59c1e34ed5e0528fe0ac351b519" title="Implementations of this method should create and populate vertex and index buffers on the MGeometry i...">MPxGeometryOverride::populateGeometry()</a> in order to provide data to Maya for drawing the associated object. The size of the buffer returned will be (size * sizeof(dataType())) bytes. The memory for the buffer is managed internally.</p>
<p>Note that not all data types are currently supported for index buffers. If the data type for this buffer is not supported this method will return NULL.</p>
<p>When using <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> in conjunction with Evaluation Manager Parallel Update in <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html" title="Base for user-defined classes to prepare geometry for drawing. ">MPxGeometryOverride</a> it is safe to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071" title="Get a pointer to memory for the buffer. ">acquire()</a> an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html" title="Index buffer for use with MGeometry. ">MIndexBuffer</a> if the buffer is software staged and the buffer is not locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the buffer to acquire</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to memory for the buffer, or NULL on failure </dd></dl>

</div>
</div>
<hr>The documentation for this class was generated from the following files:<ul>
<li>MHWGeometry.h</li>
<li>MHWGeometry.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

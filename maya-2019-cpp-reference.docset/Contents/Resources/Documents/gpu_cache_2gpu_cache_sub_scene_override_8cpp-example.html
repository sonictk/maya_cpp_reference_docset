<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><script src="../scripts/utils/adsk.redirect.js" type="text/javascript"></script>
<title>gpuCache/gpuCacheSubSceneOverride.cpp</title>
<meta content="C++" name="topic-subtype"/></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"/><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2gpu_cache_sub_scene_override_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>gpuCache/gpuCacheSubSceneOverride.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./files.html"><span>Files</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">gpuCache/gpuCacheSubSceneOverride.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk</span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download,</span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic</span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "gpuCacheSubSceneOverride.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheShapeNode.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheUnitBoundingBox.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheFrustum.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheUtil.h"</span></div>
<div class="line"><span class="preprocessor">#include "CacheReader.h"</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_set&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/multi_index_container.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/multi_index/member.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/multi_index/mem_fun.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/multi_index/hashed_index.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;tbb/tbb_thread.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDagMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDGMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MModelMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MNodeMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MSceneMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MEventMessage.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHWGeometryUtilities.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAnimControl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDrawContext.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDagNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MItDag.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MSelectionContext.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MSelectionList.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MShaderManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MUserData.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// LOCAL FUNCTIONS and CLASSES</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Guard pattern.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>ScopedGuard</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ScopedGuard(T&amp; value)</div>
<div class="line">        : fValueRef(value), fValueBackup(value)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~ScopedGuard()</div>
<div class="line">    {</div>
<div class="line">        fValueRef = fValueBackup;</div>
<div class="line">    }</div>
<div class="line">    ScopedGuard(<span class="keyword">const</span> ScopedGuard&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    ScopedGuard&amp; operator=(<span class="keyword">const</span> ScopedGuard&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    T&amp; fValueRef;</div>
<div class="line">    T  fValueBackup;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The thread id of the main thread.</span></div>
<div class="line">tbb::tbb_thread::id gsMainThreadId = tbb::this_tbb_thread::get_id();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper functions for MayaBufferArray to fetch the buffer sizes.  Results are in numbers </span></div>
<div class="line"><span class="comment">// of 4-byte words.</span></div>
<div class="line"><span class="keywordtype">size_t</span> MayaBufferSizeHelper(<a name="_a0"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MHWRender::MIndexBuffer</a>* mayaBuffer)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> mayaBuffer-&gt;<a name="a1"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#a90ca964ebcc1b02bbcde225edd49e812">size</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">size_t</span> MayaBufferSizeHelper(<a name="_a2"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* mayaBuffer)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> mayaBuffer-&gt;<a name="a3"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a331cfb987f5f4d632a747e7fbbbe4a43">descriptor</a>().<a name="a4"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#ae5acbe47d704ceb866e3717e2ac9422f">dimension</a>() * mayaBuffer-&gt;<a name="a5"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#a42db940e8d3c623487a4e2c34024751c">vertexCount</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="./namespace_m_h_w_render.html">MHWRender</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// An implementation of the Array interface which wraps a Maya-owned data buffer.  This</span></div>
<div class="line"><span class="comment">// buffer may reside on the GPU, so we do not provide direct read access.  Read access</span></div>
<div class="line"><span class="comment">// can be granted, but this is only safe to do from the main thread.  Readback won't be</span></div>
<div class="line"><span class="comment">// as fast as from a raw memory buffer, but it will typically be fast enough to be useful.</span></div>
<div class="line"><span class="comment">// With huge scenes we can't afford to store two entire copies of the scene geometry.  So</span></div>
<div class="line"><span class="comment">// we can convert our arrays to this type and depend solely on the Maya copy.  We leave</span></div>
<div class="line"><span class="comment">// memory management of the buffers to Maya, so they may be paged out to system memory or</span></div>
<div class="line"><span class="comment">// to disk as needed.</span></div>
<div class="line"><span class="comment">// T - the raw datatype of the array, float or unsigned int.</span></div>
<div class="line"><span class="comment">// C - the maya buffer class containing the data, MVertexBuffer or MIndexBuffer.</span></div>
<div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> C &gt;</div>
<div class="line"><span class="keyword">class </span>MayaBufferArray : <span class="keyword">public</span> Array&lt;T&gt;</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Some places only need temporary read-access to the contents of a Maya buffer.  So</span></div>
<div class="line"> <span class="comment">// instead of creating a full SharedArray which goes in the ArrayRegistry, we can provide</span></div>
<div class="line"> <span class="comment">// an alternate implementation of ArrayReadInterface which provides a bare-bones temporary</span></div>
<div class="line"> <span class="comment">// memory buffer.  This is useful for selection, which is the most common case of readback</span></div>
<div class="line"> <span class="comment">// from renderable buffers.  Less common use cases are when gpuCache exports a copy of itself</span></div>
<div class="line"> <span class="comment">// into a new alembic cache file or when the viewport mode switches to the default viewport.</span></div>
<div class="line"> <span class="keyword">class </span>TempCopyReadableInterface : <span class="keyword">public</span> ArrayReadInterface&lt;T&gt;</div>
<div class="line">    {</div>
<div class="line">         GPUCache::shared_array&lt;T&gt; fLocalArray;</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">        TempCopyReadableInterface(GPUCache::shared_array&lt;T&gt; localArray) : fLocalArray(localArray) {}</div>
<div class="line">        ~TempCopyReadableInterface()<span class="keyword"> override </span>{}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> T* <span class="keyword">get</span>() <span class="keyword">const</span> <span class="keyword">override</span> { <span class="keywordflow">return</span> fLocalArray.get(); }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Array&lt;T&gt;::Digest Digest;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> std::shared_ptr&lt;Array&lt;T&gt; &gt; create(<span class="keyword">const</span> std::shared_ptr&lt;C&gt;&amp; mayaBuffer, Digest digest);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    ~MayaBufferArray()<span class="keyword"> override </span>{}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;const ArrayReadInterface&lt;T&gt; &gt; getReadable()<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Get a temporary readable copy of the buffer contents.  Nothing new</span></div>
<div class="line"> <span class="comment">// will be registered with the ArrayRegistry.</span></div>
<div class="line"> <span class="comment">// This function can only be called from the main thread.</span></div>
<div class="line">        std::shared_ptr&lt;const TempCopyReadableInterface&gt; ret(std::make_shared&lt;const TempCopyReadableInterface&gt;(GetTempArrayCopy()));</div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; getReadableArray()<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Get a full-fledged SharedArray version of the buffer contents.  This</span></div>
<div class="line"> <span class="comment">// SharedArray will be registered with the ArrayRegistry.</span></div>
<div class="line"> <span class="comment">// This function can only be called from the main thread.</span></div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// If the readable version already exists in the registry, return that one.</span></div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(ArrayRegistry&lt;T&gt;::mutex());</div>
<div class="line"></div>
<div class="line">            std::shared_ptr&lt;ReadableArray&lt;T&gt; &gt; ret;</div>
<div class="line"> <span class="comment">// Linux gcc complains about these base class functions unless they are explicitly </span></div>
<div class="line"> <span class="comment">// disambiguated by proving this-&gt;</span></div>
<div class="line">            ret = ArrayRegistry&lt;T&gt;::lookupReadable(this-&gt;digest(), this-&gt;bytes());</div>
<div class="line"> <span class="keywordflow">if</span> (ret)</div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If the readable version doesn't exist in the registry, then create one.</span></div>
<div class="line">        GPUCache::shared_array&lt;T&gt; rawData(GetTempArrayCopy());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> SharedArray&lt;T&gt;::create(rawData, this-&gt;digest(), this-&gt;bytes()/<span class="keyword">sizeof</span>(T));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;C&gt; getMBuffer()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> fMayaBuffer;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">    MayaBufferArray(<span class="keyword">const</span> std::shared_ptr&lt;C&gt;&amp; mayaBuffer, Digest digest)  <span class="comment">// private constructor.  use create() instead.</span></div>
<div class="line">        : Array&lt;T&gt;(MayaBufferSizeHelper(mayaBuffer.get()), digest, false)</div>
<div class="line">        , fMayaBuffer(mayaBuffer)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    MayaBufferArray(<span class="keyword">const</span> MayaBufferArray&amp; other);  <span class="comment">//private and unimplemented</span></div>
<div class="line"></div>
<div class="line">    GPUCache::shared_array&lt;T&gt; GetTempArrayCopy()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Read the buffer contents back out of the Maya buffer and store it in a</span></div>
<div class="line"> <span class="comment">// temporary system memory buffer.</span></div>
<div class="line"> <span class="comment">// If the Maya buffer is resident in GPU ram, then the graphics API calls to </span></div>
<div class="line"> <span class="comment">// access it can only be performed from the main thread.  gpuCache uses a</span></div>
<div class="line"> <span class="comment">// worker thread for file reading, so that code in CacheReaderAlembic has</span></div>
<div class="line"> <span class="comment">// to avoid converting Arrays into ReadableArrays.  It is possible that the</span></div>
<div class="line"> <span class="comment">// file reader thread may create an array which duplicates the contents of</span></div>
<div class="line"> <span class="comment">// a MayaBufferArray, but that situation should clean itself up when the array</span></div>
<div class="line"> <span class="comment">// is eventually converted into a BufferEntry for rendering.</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// We copy the data into a temporary buffer instead of just holding the mapped</span></div>
<div class="line"> <span class="comment">// pointer because the selection code intermixes buffer readback with it's own</span></div>
<div class="line"> <span class="comment">// OpenGL calls. That conflicts with leaving the buffer bound for mapping in vp2.</span></div>
<div class="line"> <span class="comment">// The unmap() API function guarantees that it resets the GL buffer binding to 0</span></div>
<div class="line"> <span class="comment">// so this will behave predictably mixed with other GL code.</span></div>
<div class="line"></div>
<div class="line">        assert(gsMainThreadId == tbb::this_tbb_thread::get_id());</div>
<div class="line"> <span class="keywordflow">if</span> (gsMainThreadId != tbb::this_tbb_thread::get_id())</div>
<div class="line"> <span class="keywordflow">return</span> GPUCache::shared_array&lt;T&gt;();</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> T* src = (<span class="keyword">const</span> T *)fMayaBuffer-&gt;map();</div>
<div class="line"> <span class="keywordtype">size_t</span> numBytes = this-&gt;bytes();</div>
<div class="line"> <span class="keywordtype">size_t</span> numValues = numBytes / <span class="keyword">sizeof</span>(T);</div>
<div class="line">        GPUCache::shared_array&lt;T&gt; rawData(<span class="keyword">new</span> T[numValues]);</div>
<div class="line">        memcpy(rawData.get(), src, numBytes);</div>
<div class="line">        fMayaBuffer-&gt;unmap();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> rawData;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>MakeSharedEnabler;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;C&gt; fMayaBuffer;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> C &gt;</div>
<div class="line"><span class="keyword">struct </span>MayaBufferArray&lt;T,C&gt;::MakeSharedEnabler: <span class="keyword">public</span> MayaBufferArray&lt;T,C&gt;{</div>
<div class="line">    MakeSharedEnabler(<span class="keyword">const</span> std::shared_ptr&lt;C&gt;&amp; mayaBuffer, Digest digest)</div>
<div class="line">    :MayaBufferArray&lt;T,C&gt;(mayaBuffer, digest){}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> C &gt;</div>
<div class="line">std::shared_ptr&lt;Array&lt;T&gt; &gt; MayaBufferArray&lt;T,C&gt;::create(<span class="keyword">const</span> std::shared_ptr&lt;C&gt;&amp; mayaBuffer, Digest digest)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// The Digest is pre-calculated.</span></div>
<div class="line"> <span class="keywordtype">size_t</span> size = MayaBufferSizeHelper(mayaBuffer.get());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We first look if a similar array already exists in the</span></div>
<div class="line"> <span class="comment">// cache. If so, we return the cached array to promote sharing as</span></div>
<div class="line"> <span class="comment">// much as possible.</span></div>
<div class="line">    std::shared_ptr&lt;Array&lt;T&gt; &gt; ret;</div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(ArrayRegistry&lt;T&gt;::mutex());</div>
<div class="line"></div>
<div class="line">        ret = ArrayRegistry&lt;T&gt;::lookupNonReadable(digest, size);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!ret) {</div>
<div class="line">            ret = std::make_shared&lt;MakeSharedEnabler&gt;(mayaBuffer, digest);</div>
<div class="line">            ArrayRegistry&lt;T&gt;::insert(ret);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Explicitly instantiate the two versions we need.</span></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>MayaBufferArray&lt;unsigned int, MHWRender::MIndexBuffer&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>MayaBufferArray&lt;float, MHWRender::MVertexBuffer&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> MayaBufferArray&lt;unsigned int, MHWRender::MIndexBuffer&gt; MayaIndexBufferWrapper;</div>
<div class="line"><span class="keyword">typedef</span> MayaBufferArray&lt;float, MHWRender::MVertexBuffer&gt; MayaVertexBufferWrapper;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS BuffersCache</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class manages all Viewport 2.0 buffers.</span></div>
<div class="line"><span class="comment">// When VRAM is hitting the threshold, the cache will delete free buffers to get </span></div>
<div class="line"><span class="comment">// more room for the new buffers.</span></div>
<div class="line"><span class="comment">// Allocating and evicting are done between frames.</span></div>
<div class="line"><span class="keyword">class </span>BuffersCache</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">static</span> BuffersCache&amp; getInstance()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Singleton</span></div>
<div class="line"> <span class="keyword">static</span> BuffersCache sSingleton;</div>
<div class="line"> <span class="keywordflow">return</span> sSingleton;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set Viewport 2.0 buffers to the render item and add these buffers</span></div>
<div class="line"> <span class="comment">// to this cache. This means that these buffers are going to be used</span></div>
<div class="line"> <span class="comment">// in the render item.</span></div>
<div class="line"> <span class="keywordtype">void</span> setBuffers(</div>
<div class="line">        SubSceneOverride&amp;                            subSceneOverride,</div>
<div class="line"> <a name="_a6"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>*                                 renderItem,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  indices,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; positions,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; normals,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; uvs,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a7"></a><a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>&amp;                          boundingBox</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        assert(positions);</div>
<div class="line"> <span class="keywordflow">if</span> (!positions) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Unloaded render item! Just count the reference.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!renderItem) {</div>
<div class="line"> <span class="keywordflow">if</span> (indices) {</div>
<div class="line">                acquireIndexBuffer(indices);</div>
<div class="line">            }</div>
<div class="line">            acquireVertexBuffer(positions);</div>
<div class="line"> <span class="keywordflow">if</span> (normals) {</div>
<div class="line">                acquireVertexBuffer(normals);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">if</span> (uvs) {</div>
<div class="line">                acquireVertexBuffer(uvs);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Semantic Constants</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a name="_a8"></a><a class="code" href="./class_m_string.html">MString</a> sPositions(<span class="stringliteral">"positions"</span>);</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> sNormals(<span class="stringliteral">"normals"</span>);</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> sUVs(<span class="stringliteral">"uvs"</span>);</div>
<div class="line"></div>
<div class="line"> <a name="_a9"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html">MVertexBufferArray</a> buffers;</div>
<div class="line">        buffers.<a name="a10"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html#acd36fdd49c7d45faff08163ae776c5b2">addBuffer</a>(sPositions, acquireVertexBuffer(positions));</div>
<div class="line"> <span class="keywordflow">if</span> (normals) {</div>
<div class="line">            buffers.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html#acd36fdd49c7d45faff08163ae776c5b2">addBuffer</a>(sNormals, acquireVertexBuffer(normals));</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">if</span> (uvs) {</div>
<div class="line">            buffers.<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_array.html#acd36fdd49c7d45faff08163ae776c5b2">addBuffer</a>(sUVs, acquireVertexBuffer(uvs));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// It the geometry does not require an index buffer, then use an empty one.</span></div>
<div class="line">        subSceneOverride.setGeometryForRenderItem(</div>
<div class="line">            *renderItem,</div>
<div class="line">            buffers,</div>
<div class="line">            indices ? *acquireIndexBuffer(indices) : <a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a>(MGeometry::kUnsignedInt32),</div>
<div class="line">            &amp;boundingBox</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove Viewport 2.0 buffers from this cache. This means that these</span></div>
<div class="line"> <span class="comment">// buffers is no longer used (and might become free buffers and then deleted).</span></div>
<div class="line"> <span class="keywordtype">void</span> removeBuffers(</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  indices,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; positions,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; normals = std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; uvs     = std::shared_ptr&lt;const VertexBuffer&gt;()</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (indices) {</div>
<div class="line">            removeBufferFromCache(indices);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positions) {</div>
<div class="line">            removeBufferFromCache(positions);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (normals) {</div>
<div class="line">            removeBufferFromCache(normals);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (uvs) {</div>
<div class="line">            removeBufferFromCache(uvs);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Shorthand method to do removeBuffers() and setBuffers()</span></div>
<div class="line"> <span class="keywordtype">void</span> updateBuffers(</div>
<div class="line">        SubSceneOverride&amp;                            subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>*                                 renderItem,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  indices,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; positions,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; normals,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; uvs,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>&amp;                          boundingBox,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  prevIndices,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; prevPositions,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; prevNormals = std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; prevUVs     = std::shared_ptr&lt;const VertexBuffer&gt;()</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        removeBuffers(prevIndices, prevPositions, prevNormals, prevUVs);</div>
<div class="line">        setBuffers(subSceneOverride, renderItem, indices, positions, normals, uvs, boundingBox);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the Viewport 2.0 index buffer in the cache. Returns NULL if not found.</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a>* lookup(<span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a>* buffer = NULL;</div>
<div class="line">        lookup(indices, buffer);</div>
<div class="line"> <span class="keywordflow">return</span> buffer;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the Viewport 2.0 vertex buffer in the cache. Returns NULL if not found.</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a>* lookup(<span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a>* buffer = NULL;</div>
<div class="line">        lookup(vertices, buffer);</div>
<div class="line"> <span class="keywordflow">return</span> buffer;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Shrink the cache if the total size of buffers is hitting the threshold.</span></div>
<div class="line"> <span class="comment">// Buffers with 0 reference count will be deleted.</span></div>
<div class="line"> <span class="keywordtype">void</span> shrink()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Delete Viewport 2.0 buffers that are queued for deletion.</span></div>
<div class="line"> <span class="comment">// Their IndexBuffer/VertexBuffer arrays have already been deleted.</span></div>
<div class="line">        doDeleteQueuedBuffers();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">while</span> (fTotalBufferSize &gt; Config::maxVBOSize()) {</div>
<div class="line"> <span class="comment">// No more free buffers can be deleted.</span></div>
<div class="line"> <span class="comment">// All active buffers are already used by render items.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fFreeBuffers.empty()) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Delete a random free buffer.</span></div>
<div class="line">            BufferSet::iterator it = fFreeBuffers.begin();</div>
<div class="line">            fTotalBufferSize -= (*it).bytes();</div>
<div class="line">            fFreeBuffers.erase(it);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Clear and delete all buffers.</span></div>
<div class="line"> <span class="keywordtype">void</span> clear()</div>
<div class="line">    {</div>
<div class="line">        fTotalBufferSize = 0;</div>
<div class="line">        fActiveBuffers.clear();</div>
<div class="line">        fFreeBuffers.clear();</div>
<div class="line"></div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(fBuffersToDeleteMutex);</div>
<div class="line">            fBuffersToDelete.clear();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">class </span>BufferEntry;</div>
<div class="line"></div>
<div class="line">    BuffersCache()</div>
<div class="line">        : fTotalBufferSize(0)</div>
<div class="line">    {</div>
<div class="line">        ArrayBase::registerDestructionCallback(sArrayDestructionCb);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~BuffersCache()</div>
<div class="line">    {</div>
<div class="line">        ArrayBase::unregisterDestructionCallback(sArrayDestructionCb);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    BuffersCache(<span class="keyword">const</span> BuffersCache&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    BuffersCache&amp; operator=(<span class="keyword">const</span> BuffersCache&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Allocate an index buffer or return the existing index buffer.</span></div>
<div class="line"> <span class="comment">// This will add the reference count by 1.</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a>* acquireIndexBuffer(<span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>
<div class="line">    {</div>
<div class="line">        assert(indices);</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a>* buffer = NULL;</div>
<div class="line">        addBufferToCache(indices).getBuffer(buffer);</div>
<div class="line"> <span class="keywordflow">return</span> buffer;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Allocate a vertex buffer or return the existing vertex buffer.</span></div>
<div class="line"> <span class="comment">// This will add the reference count by 1.</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a>* acquireVertexBuffer(<span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>
<div class="line">    {</div>
<div class="line">        assert(vertices);</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a>* buffer = NULL;</div>
<div class="line">        addBufferToCache(vertices).getBuffer(buffer);</div>
<div class="line"> <span class="keywordflow">return</span> buffer;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add the buffer to the cache. If the buffer already exists</span></div>
<div class="line"> <span class="comment">// in the cache, the reference count will be added by 1.</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"> <span class="keyword">const</span> BufferEntry&amp; addBufferToCache(<span class="keyword">const</span> T&amp; buffer)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Already a buffer in use?</span></div>
<div class="line">        BufferSet::iterator it = fActiveBuffers.find(buffer);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fActiveBuffers.end()) {</div>
<div class="line"> <span class="comment">// The buffer is already used by a render item.</span></div>
<div class="line"> <span class="comment">// Just increase the reference count.</span></div>
<div class="line">            assert((*it).refCount() &gt; 0);</div>
<div class="line">            (*it).ref();</div>
<div class="line"> <span class="keywordflow">return</span> *it;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// A free buffer?</span></div>
<div class="line">        it = fFreeBuffers.find(buffer);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fFreeBuffers.end()) {</div>
<div class="line"> <span class="comment">// The buffer is not used by any render items.</span></div>
<div class="line"> <span class="comment">// Move it to active buffer set and increase the reference count.</span></div>
<div class="line">            assert((*it).refCount() == 0);</div>
<div class="line">            BufferSet::iterator newIt = fActiveBuffers.insert(*it).first;</div>
<div class="line">            fFreeBuffers.erase(it);</div>
<div class="line">            (*newIt).ref();</div>
<div class="line"> <span class="keywordflow">return</span> *newIt;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Allocate a new buffer.</span></div>
<div class="line"> <span class="comment">// This will construct a new MIndexBuffer or MVertexBuffer.</span></div>
<div class="line">        BufferSet::iterator newIt = fActiveBuffers.insert(buffer).first;</div>
<div class="line">        (*newIt).ref();</div>
<div class="line">        fTotalBufferSize += (*newIt).bytes();</div>
<div class="line"> <span class="keywordflow">return</span> *newIt;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Declaim that the buffer is not used by a render item.</span></div>
<div class="line"> <span class="comment">// The reference count will be decreased by 1.</span></div>
<div class="line"> <span class="comment">// If the reference count reaches 0, the buffer has the </span></div>
<div class="line"> <span class="comment">// possibility to be deleted in shrink().</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"> <span class="keywordtype">void</span> removeBufferFromCache(<span class="keyword">const</span> T&amp; buffer)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// This must be a buffer in use.</span></div>
<div class="line">        BufferSet::iterator it = fActiveBuffers.find(buffer);</div>
<div class="line">        assert(fFreeBuffers.find(buffer) == fFreeBuffers.end());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (it != fActiveBuffers.end()) {</div>
<div class="line">            assert((*it).refCount() &gt; 0);</div>
<div class="line">            (*it).unref();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This buffer is no longer used by any render items.</span></div>
<div class="line"> <span class="comment">// Move it to free buffer set.</span></div>
<div class="line"> <span class="keywordflow">if</span> ((*it).refCount() == 0) {</div>
<div class="line">                fFreeBuffers.insert(*it);</div>
<div class="line">                fActiveBuffers.erase(it);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find the buffer in the cache.</span></div>
<div class="line"> <span class="comment">// This will not allocate any new buffers.</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"> <span class="keywordtype">void</span> lookup(<span class="keyword">const</span> T&amp; buffer, R&amp; pointer)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// In active buffer set?</span></div>
<div class="line">        BufferSet::iterator it = fActiveBuffers.find(buffer);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fActiveBuffers.end()) {</div>
<div class="line">            assert((*it).refCount() &gt; 0);</div>
<div class="line">            (*it).getBuffer(pointer);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// In free buffer set?</span></div>
<div class="line">        it = fFreeBuffers.find(buffer);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fFreeBuffers.end()) {</div>
<div class="line">            assert((*it).refCount() == 0);</div>
<div class="line">            (*it).getBuffer(pointer);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        pointer = NULL;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Queue the buffer for deletion. This method is thread-safe.</span></div>
<div class="line"> <span class="comment">// Sometimes, a buffer might be deleted in a worker thread.</span></div>
<div class="line"> <span class="keywordtype">void</span> queueBufferForDelete(<span class="keyword">const</span> ArrayBase::Key&amp; key)</div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fBuffersToDeleteMutex);</div>
<div class="line">        fBuffersToDelete.insert(key);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Delete all queued buffers. This method must be called from the main thread.</span></div>
<div class="line"> <span class="keywordtype">void</span> doDeleteQueuedBuffers()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!fBuffersToDelete.empty()) {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(fBuffersToDeleteMutex);</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> BufferSet::nth_index&lt;1&gt;::type::iterator KeyIterator;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> ArrayBase::Key&amp; key : fBuffersToDelete) {</div>
<div class="line"> <span class="comment">// Find all the buffers that have the same key.</span></div>
<div class="line"> <span class="comment">// It's possible that the array is used for both position and normal.</span></div>
<div class="line">                std::pair&lt;KeyIterator,KeyIterator&gt; range = </div>
<div class="line">                    fFreeBuffers.get&lt;1&gt;().equal_range(key);</div>
<div class="line"> <span class="keywordflow">for</span> (KeyIterator it = range.first; it != range.second; it++) {</div>
<div class="line">                    assert((*it).refCount() == 0);</div>
<div class="line">                    fTotalBufferSize -= (*it).bytes();</div>
<div class="line">                }</div>
<div class="line">                fFreeBuffers.get&lt;1&gt;().erase(key);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Done.</span></div>
<div class="line">            fBuffersToDelete.clear();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> sArrayDestructionCb(<span class="keyword">const</span> ArrayBase::Key&amp; key)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Queue the buffers for deletion.</span></div>
<div class="line">        BuffersCache::getInstance().queueBufferForDelete(key);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Delete the buffers immediately if we are in the main thread.</span></div>
<div class="line"> <span class="keywordflow">if</span> (tbb::this_tbb_thread::get_id() == gsMainThreadId) {</div>
<div class="line">            BuffersCache::getInstance().doDeleteQueuedBuffers();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This class provides a common interface for vertex/index buffers.</span></div>
<div class="line"> <span class="keyword">class </span>BufferEntry</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"> <span class="comment">// The unique key for index/vertex buffers.</span></div>
<div class="line"> <span class="keyword">struct </span>BufferKey</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">enum</span> BufferType { kIndex, kVertex };</div>
<div class="line">            BufferType          type;</div>
<div class="line">            ArrayBase::Key      arrayKey;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#ad8ed01ff3ff33333d8e19db4d2818bb6">MGeometry::DataType</a> dataType;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a5a5b1d8320f94d3c3d142753f5527fc4">MGeometry::Semantic</a> semantic;</div>
<div class="line"></div>
<div class="line">            BufferKey(<span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>
<div class="line">                : type(kIndex),</div>
<div class="line">                  arrayKey(indices-&gt;array()-&gt;key()),</div>
<div class="line">                  dataType(<a name="_a11"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MGeometry</a>::kUnsignedInt32),</div>
<div class="line">                  semantic(<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MGeometry</a>::kInvalidSemantic)</div>
<div class="line">            {}</div>
<div class="line"></div>
<div class="line">            BufferKey(<span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>
<div class="line">                : type(kVertex),</div>
<div class="line">                  arrayKey(vertices-&gt;array()-&gt;key()),</div>
<div class="line">                  dataType(vertices-&gt;descriptor().dataType()),</div>
<div class="line">                  semantic(vertices-&gt;descriptor().semantic())</div>
<div class="line">            {}</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>BufferKeyHash : std::unary_function&lt;BufferKey, std::size_t&gt;</div>
<div class="line">        {</div>
<div class="line">            std::size_t operator()(<span class="keyword">const</span> BufferKey&amp; key)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">                std::size_t hashCode = 0;</div>
<div class="line">                boost::hash_combine(hashCode, key.type);</div>
<div class="line">                boost::hash_combine(hashCode, ArrayBase::KeyHash()(key.arrayKey));</div>
<div class="line">                boost::hash_combine(hashCode, key.dataType);</div>
<div class="line">                boost::hash_combine(hashCode, key.semantic);</div>
<div class="line"> <span class="keywordflow">return</span> hashCode;</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">struct </span>BufferKeyEqualTo : std::binary_function&lt;BufferKey, BufferKey, bool&gt;</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> BufferKey&amp; x, <span class="keyword">const</span> BufferKey&amp; y)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> x.type == y.type &amp;&amp;</div>
<div class="line">                        ArrayBase::KeyEqualTo()(x.arrayKey, y.arrayKey) &amp;&amp;</div>
<div class="line">                        x.dataType == y.dataType &amp;&amp;</div>
<div class="line">                        x.semantic == y.semantic;</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        BufferEntry(<span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>
<div class="line">            : fKey(indices),</div>
<div class="line">              fRefCount(0)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Allocate the index buffer and initialize the contents.</span></div>
<div class="line"> <span class="keywordflow">if</span> (indices-&gt;numIndices() &gt; 0) {</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!indices-&gt;array()-&gt;isReadable())</div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// The IndexBuffer has already been converted to a Maya buffer so we can reuse it.  This can</span></div>
<div class="line"> <span class="comment">// happen if the BufferEntry has been deleted but the IndexBuffer that it converted remains</span></div>
<div class="line"> <span class="comment">// and is being reused.  We want to avoid an expensive readback and creation of a duplicate buffer.</span></div>
<div class="line"> <span class="keyword">const</span> MayaIndexBufferWrapper* mbufferWrapper = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>MayaIndexBufferWrapper*<span class="keyword">&gt;</span>(indices-&gt;array().get());</div>
<div class="line">                    assert(mbufferWrapper);</div>
<div class="line"> <span class="keywordflow">if</span> (mbufferWrapper) {</div>
<div class="line">                        std::shared_ptr&lt;MIndexBuffer&gt; mbuffer = mbufferWrapper-&gt;getMBuffer();</div>
<div class="line">                        assert(mbuffer);</div>
<div class="line"> <span class="keywordflow">if</span> (mbuffer) {</div>
<div class="line">                            fIndexBuffer = mbuffer;</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">                fIndexBuffer.reset(<span class="keyword">new</span> <a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a>(MGeometry::kUnsignedInt32));</div>
<div class="line"></div>
<div class="line">                {</div>
<div class="line">                    IndexBuffer::ReadInterfacePtr readable = indices-&gt;readableInterface();</div>
<div class="line"> <span class="keyword">const</span> IndexBuffer::index_t* data = readable-&gt;get();</div>
<div class="line">                    fIndexBuffer-&gt;update(data, 0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)indices-&gt;numIndices(), <span class="keyword">true</span>);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We want to avoid storing two copies of all the scene geometry.  One copy of the scene</span></div>
<div class="line"> <span class="comment">// goes into the Maya SubSceneOverride interface.  The other copy of the scene stored in</span></div>
<div class="line"> <span class="comment">// ReadableArrays is now mostly redundant.  If we want to load huge scenes close to the limit</span></div>
<div class="line"> <span class="comment">// of our system ram, then we can't keep the local ReadableArray copy.</span></div>
<div class="line"> <span class="comment">// So after creating the Maya MIndexBuffer, we graft a non-readable version of the Array</span></div>
<div class="line"> <span class="comment">// back into the IndexBuffer.  The readable version that it previously held can then be freed.</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (indices-&gt;array()-&gt;isReadable()) {</div>
<div class="line">                    std::shared_ptr&lt;Array&lt;IndexBuffer::index_t&gt; &gt; mayaArray = MayaIndexBufferWrapper::create(fIndexBuffer, indices-&gt;array()-&gt;digest());</div>
<div class="line">                    indices-&gt;ReplaceArrayInstance(mayaArray);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        BufferEntry(<span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>
<div class="line">            : fKey(vertices),</div>
<div class="line">              fRefCount(0)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Allocate the vertex buffer and initialize the contents.</span></div>
<div class="line"> <span class="keywordflow">if</span> (vertices-&gt;numVerts() &gt; 0) {</div>
<div class="line"> <span class="comment">// FIXME: Assumes 32-bit float data.</span></div>
<div class="line">                assert(fKey.dataType == MGeometry::kFloat);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> allowReplaceBufferArray = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (!vertices-&gt;array()-&gt;isReadable())</div>
<div class="line">                {</div>
<div class="line"> <span class="comment">// The VertexBuffer has already been converted to a Maya buffer.  We can reuse it if the</span></div>
<div class="line"> <span class="comment">// semantic matches.  This can happen if the BufferEntry has been deleted but the VertexBuffer</span></div>
<div class="line"> <span class="comment">// that it converted remains and is being reused.  We want to avoid an expensive readback and</span></div>
<div class="line"> <span class="comment">// creation of a duplicate buffer.</span></div>
<div class="line"> <span class="keyword">const</span> MayaVertexBufferWrapper* mbufferWrapper = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>MayaVertexBufferWrapper*<span class="keyword">&gt;</span>(vertices-&gt;array().get());</div>
<div class="line">                    assert(mbufferWrapper);</div>
<div class="line"> <span class="keywordflow">if</span> (mbufferWrapper) {</div>
<div class="line">                        std::shared_ptr&lt;MVertexBuffer&gt; mbuffer = mbufferWrapper-&gt;getMBuffer();</div>
<div class="line">                        assert(mbuffer);</div>
<div class="line"> <span class="keywordflow">if</span> (mbuffer) {</div>
<div class="line"> <span class="keywordflow">if</span> (mbuffer-&gt;descriptor().semantic() == vertices-&gt;descriptor().semantic()) {</div>
<div class="line"> <span class="comment">// The semantic matches.  Simply reuse the buffer and we are finished.</span></div>
<div class="line">                                fVertexBuffer = mbuffer;</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// The semantic doesn't match, so we can't reuse the buffer.  An example is a normal</span></div>
<div class="line"> <span class="comment">// and position buffer that happen to match their contents.  The unique key rules mean</span></div>
<div class="line"> <span class="comment">// that we can't make a duplicate MayaVertexBufferWrapper, so make a new MBuffer backed</span></div>
<div class="line"> <span class="comment">// by a plain software buffer.  Graft the software buffer back into the VertexBuffer so</span></div>
<div class="line"> <span class="comment">// that we store both.</span></div>
<div class="line">                                std::shared_ptr&lt;Array&lt;float&gt; &gt; softwareArray = vertices-&gt;array()-&gt;getReadableArray();</div>
<div class="line">                                vertices-&gt;ReplaceArrayInstance(softwareArray);</div>
<div class="line">                                allowReplaceBufferArray = <span class="keyword">false</span>;</div>
<div class="line"> <span class="comment">// Now proceed with normal MBuffer creation, but skip the final step of converting the</span></div>
<div class="line"> <span class="comment">// VertexBuffer back.</span></div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">                fVertexBuffer.reset(<span class="keyword">new</span> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a>(vertices-&gt;descriptor()));</div>
<div class="line"></div>
<div class="line">                {</div>
<div class="line">                    VertexBuffer::ReadInterfacePtr readable = vertices-&gt;readableInterface();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* data = readable-&gt;get();</div>
<div class="line">                    fVertexBuffer-&gt;update(data, 0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vertices-&gt;numVerts(), <span class="keyword">true</span>);</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// We want to avoid storing two copies of all the scene geometry.  One copy of the scene</span></div>
<div class="line"> <span class="comment">// goes into the Maya SubSceneOverride interface.  The other copy of the scene stored in</span></div>
<div class="line"> <span class="comment">// ReadableArrays is now mostly redundant.  If we want to load huge scenes close to the limit</span></div>
<div class="line"> <span class="comment">// of our system ram, then we can't keep the local ReadableArray copy.</span></div>
<div class="line"> <span class="comment">// So after creating the Maya MVertexBuffer, we graft a non-readable version of the Array</span></div>
<div class="line"> <span class="comment">// back into the VertexBuffer.  The readable version that it previously held can then be freed.</span></div>
<div class="line"> <span class="keywordflow">if</span> (allowReplaceBufferArray &amp;&amp; vertices-&gt;array()-&gt;isReadable()) {</div>
<div class="line">                    std::shared_ptr&lt;Array&lt;float&gt; &gt; mayaArray = MayaVertexBufferWrapper::create(fVertexBuffer, vertices-&gt;array()-&gt;digest());</div>
<div class="line">                    vertices-&gt;ReplaceArrayInstance(mayaArray);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The unique key of this buffer.</span></div>
<div class="line"> <span class="keyword">const</span> BufferKey&amp;      key()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> fKey; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The array key of this buffer. (without type and semantic)</span></div>
<div class="line"> <span class="keyword">const</span> ArrayBase::Key&amp; arrayKey()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fKey.arrayKey; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The size of this buffer.</span></div>
<div class="line"> <span class="keywordtype">size_t</span> bytes()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> fKey.arrayKey.fBytes; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the index buffer pointer.</span></div>
<div class="line"> <span class="keywordtype">void</span> getBuffer(<a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a>*&amp; buffer)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">            assert(fIndexBuffer);</div>
<div class="line">            buffer = fIndexBuffer.get();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the vertex buffer pointer.</span></div>
<div class="line"> <span class="keywordtype">void</span> getBuffer(<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a>*&amp; buffer)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">            assert(fVertexBuffer);</div>
<div class="line">            buffer = fVertexBuffer.get();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>   ref()<span class="keyword"> const      </span>{ fRefCount++; }</div>
<div class="line"> <span class="keywordtype">void</span>   unref()<span class="keyword"> const    </span>{ fRefCount--; }</div>
<div class="line"> <span class="keywordtype">size_t</span> refCount()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fRefCount; }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">        BufferKey                           fKey;</div>
<div class="line">        std::shared_ptr&lt;MIndexBuffer&gt;     fIndexBuffer;</div>
<div class="line">        std::shared_ptr&lt;MVertexBuffer&gt;    fVertexBuffer;</div>
<div class="line"> <span class="keyword">mutable</span> <span class="keywordtype">size_t</span>                      fRefCount;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> boost::multi_index_container&lt;</div>
<div class="line">        BufferEntry,</div>
<div class="line">        boost::multi_index::indexed_by&lt;</div>
<div class="line"> <span class="comment">// Index 0: The unique index for each Viewport 2.0 buffer.</span></div>
<div class="line">            boost::multi_index::hashed_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_CONST_MEM_FUN(BufferEntry,<span class="keyword">const</span> BufferEntry::BufferKey&amp;,key),</div>
<div class="line">                BufferEntry::BufferKeyHash,</div>
<div class="line">                BufferEntry::BufferKeyEqualTo</div>
<div class="line">            &gt;,</div>
<div class="line"> <span class="comment">// Index 1: The index for each array murmur3 key.</span></div>
<div class="line"> <span class="comment">//          Note: The same key might be used for different semantic.</span></div>
<div class="line">            boost::multi_index::hashed_non_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_CONST_MEM_FUN(BufferEntry,<span class="keyword">const</span> ArrayBase::Key&amp;,arrayKey),</div>
<div class="line">                ArrayBase::KeyHash,</div>
<div class="line">                ArrayBase::KeyEqualTo</div>
<div class="line">            &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt; BufferSet;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> std::unordered_set&lt;</div>
<div class="line">        ArrayBase::Key,</div>
<div class="line">        ArrayBase::KeyHash,</div>
<div class="line">        ArrayBase::KeyEqualTo</div>
<div class="line">    &gt; KeySet;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span>          fTotalBufferSize;</div>
<div class="line">    BufferSet       fActiveBuffers;</div>
<div class="line">    BufferSet       fFreeBuffers;</div>
<div class="line"></div>
<div class="line">    std::mutex      fBuffersToDeleteMutex;</div>
<div class="line">    KeySet          fBuffersToDelete;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The user data is attached on bounding box place holder render items.</span></div>
<div class="line"><span class="comment">// When the bounding box place holder is drawn, a post draw callback is</span></div>
<div class="line"><span class="comment">// triggered to hint the shape should be read in priority.</span></div>
<div class="line"><span class="keyword">class </span>SubNodeUserData</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SubNodeUserData(<span class="keyword">const</span> SubNode&amp; subNode)</div>
<div class="line">        : fSubNode(subNode)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">virtual</span> ~SubNodeUserData()</div>
<div class="line">    {}</div>
<div class="line">    SubNodeUserData(<span class="keyword">const</span> SubNodeUserData&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    SubNodeUserData&amp; operator=(<span class="keyword">const</span> SubNodeUserData&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> hintShapeReadOrder()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Hint the shape read order.</span></div>
<div class="line"> <span class="comment">// The shape will be loaded in priority.</span></div>
<div class="line">        GlobalReaderCache::theCache().hintShapeReadOrder(fSubNode);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp; fSubNode;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The deletion order of MRenderItem and MPxSubSceneOverride is not consistent.</span></div>
<div class="line"><span class="comment">// We let Maya/VP2 delete the delegate and decrease the reference counter.</span></div>
<div class="line"><span class="keyword">class </span>SubNodeUserDataDelegate : <span class="keyword">public</span> <a name="_a12"></a><a class="code" href="./class_m_user_data.html">MUserData</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SubNodeUserDataDelegate(<span class="keyword">const</span> std::shared_ptr&lt;SubNodeUserData&gt;&amp; userData)</div>
<div class="line">        : <a class="code" href="./class_m_user_data.html">MUserData</a>(true <span class="comment">/*deleteAfterUse*/</span>),</div>
<div class="line">          fUserData(userData)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~SubNodeUserDataDelegate()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> hintShapeReadOrder()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">if</span> (fUserData)</div>
<div class="line">            fUserData-&gt;hintShapeReadOrder();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;SubNodeUserData&gt;  fUserData;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// For GPUCache OGS draw, make sure the pattern has its first bit == 1</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> SetDashLinePattern(<a name="_a13"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pattern)</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> sDashPattern = <span class="stringliteral">"dashPattern"</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> newPattern = pattern;</div>
<div class="line"> <span class="keywordflow">if</span> (newPattern != 0) {</div>
<div class="line"> <span class="keywordflow">while</span> ((newPattern &amp; 0x8000) == 0) {</div>
<div class="line">            newPattern &lt;&lt;= 1;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    shader-&gt;<a name="a14"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef">setParameter</a>(sDashPattern, newPattern);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> BoundingBoxPlaceHolderDrawCallback(<a name="_a15"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a>&amp; context,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a16"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a>&amp; renderItemList,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">int</span> numRenderItems = renderItemList.<a name="a17"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numRenderItems; i++) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>* renderItem = renderItemList.<a name="a18"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(i);</div>
<div class="line"> <span class="keywordflow">if</span> (renderItem) {</div>
<div class="line">            SubNodeUserDataDelegate* userData =</div>
<div class="line"> <span class="keyword">dynamic_cast&lt;</span>SubNodeUserDataDelegate*<span class="keyword">&gt;</span>(renderItem-&gt;<a name="a19"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#afd8b782f19e9508747c851a990d8f5db">customData</a>());</div>
<div class="line"> <span class="keywordflow">if</span> (userData) {</div>
<div class="line">                userData-&gt;hintShapeReadOrder();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> WireframePreDrawCallback(<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a>&amp; context,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a>&amp; renderItemList,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Wireframe on Shaded: Full / Reduced / None</span></div>
<div class="line"> <span class="keyword">const</span> DisplayPref::WireframeOnShadedMode wireOnShadedMode =</div>
<div class="line">        DisplayPref::wireframeOnShadedMode();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Early out if we are not drawing Reduced/None wireframe.</span></div>
<div class="line"> <span class="keywordflow">if</span> (wireOnShadedMode == DisplayPref::kWireframeOnShadedFull) {</div>
<div class="line">        assert(0);  <span class="comment">// Only Reduced/None mode has callbacks.</span></div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Wireframe on shaded.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> displayStyle = context.<a name="a20"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#acd5ce60bbd3d03181b1ad681023ff44d">getDisplayStyle</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (displayStyle &amp; (MDrawContext::kGouraudShaded | MDrawContext::kTextured)) {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pattern =</div>
<div class="line">            (wireOnShadedMode == DisplayPref::kWireframeOnShadedReduced)</div>
<div class="line">            ? Config::kLineStippleDotted  <span class="comment">// Reduce: dotted line</span></div>
<div class="line">            : 0;                          <span class="comment">// None: no wire</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> sDashPattern = <span class="stringliteral">"dashPattern"</span>;        </div>
<div class="line">        SetDashLinePattern(shader, pattern);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> WireframePostDrawCallback(<a class="code" href="./class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a>&amp; context,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a>&amp; renderItemList,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Wireframe on Shaded: Full / Reduced / None</span></div>
<div class="line"> <span class="keyword">const</span> DisplayPref::WireframeOnShadedMode wireOnShadedMode =</div>
<div class="line">        DisplayPref::wireframeOnShadedMode();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Early out if we are not drawing reduced wireframe.</span></div>
<div class="line"> <span class="keywordflow">if</span> (wireOnShadedMode == DisplayPref::kWireframeOnShadedFull) {</div>
<div class="line">        assert(0);  <span class="comment">// Only Reduced/None mode has callbacks.</span></div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Restore the default pattern.</span></div>
<div class="line">    SetDashLinePattern(shader, Config::kLineStippleShortDashed);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* getPointShaderInstance()</div>
<div class="line">{</div>
<div class="line"> <a name="_a21"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer) <span class="keywordflow">return</span> NULL;</div>
<div class="line"> <span class="keyword">const</span> <a name="_a22"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html">MShaderManager</a>* shaderMgr = renderer-&gt;<a name="a23"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125">getShaderManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderMgr) <span class="keywordflow">return</span> NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shaderMgr-&gt;<a name="a24"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a8e4ad27d691969622af2b05d8c6213d9">getStockShader</a>(MShaderManager::k3dFatPointShader);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* getWireShaderInstance()</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer) <span class="keywordflow">return</span> NULL;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html">MShaderManager</a>* shaderMgr = renderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125">getShaderManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderMgr) <span class="keywordflow">return</span> NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shaderMgr-&gt;<a name="a25"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44">getFragmentShader</a>(<span class="stringliteral">"mayaDashLineShader"</span>, <span class="stringliteral">""</span>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* getWireShaderInstanceWithCB()</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer) <span class="keywordflow">return</span> NULL;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html">MShaderManager</a>* shaderMgr = renderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125">getShaderManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderMgr) <span class="keywordflow">return</span> NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shaderMgr-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44">getFragmentShader</a>(<span class="stringliteral">"mayaDashLineShader"</span>, <span class="stringliteral">""</span>, <span class="keyword">false</span>,</div>
<div class="line">        WireframePreDrawCallback, WireframePostDrawCallback);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* getBoundingBoxPlaceHolderShaderInstance()</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer) <span class="keywordflow">return</span> NULL;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html">MShaderManager</a>* shaderMgr = renderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125">getShaderManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderMgr) <span class="keywordflow">return</span> NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shaderMgr-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44">getFragmentShader</a>(<span class="stringliteral">"mayaDashLineShader"</span>, <span class="stringliteral">""</span>, <span class="keyword">false</span>,</div>
<div class="line">        NULL, BoundingBoxPlaceHolderDrawCallback);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* getDiffuseColorShaderInstance()</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer) <span class="keywordflow">return</span> NULL;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html">MShaderManager</a>* shaderMgr = renderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125">getShaderManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderMgr) <span class="keywordflow">return</span> NULL;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shaderMgr-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44">getFragmentShader</a>(<span class="stringliteral">"mayaLambertSurface"</span>, <span class="stringliteral">"outSurfaceFinal"</span>, <span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> releaseShaderInstance(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*&amp; shader)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer) <span class="keywordflow">return</span>;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html">MShaderManager</a>* shaderMgr = renderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125">getShaderManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderMgr) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line">        shaderMgr-&gt;<a name="a26"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a0c7deb55edc231cbb2365b271ecd55f8">releaseShader</a>(shader);</div>
<div class="line">        shader = NULL;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> setDiffuseColor(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader, <span class="keyword">const</span> <a name="_a27"></a><a class="code" href="./class_m_color.html">MColor</a>&amp; diffuseColor)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Color</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> color[3] = {diffuseColor.<a name="a28"></a><a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, diffuseColor.<a name="a29"></a><a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, diffuseColor.<a name="a30"></a><a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>};</div>
<div class="line">        shader-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef">setParameter</a>(<span class="stringliteral">"color"</span>, color);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transparency</span></div>
<div class="line"> <span class="keywordflow">if</span> (diffuseColor.<a name="a31"></a><a class="code" href="./class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e">a</a> &lt; 1.0f) {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> oneMinusAlpha =</div>
<div class="line">                (diffuseColor.<a class="code" href="./class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e">a</a> &gt;= 0.0f) ? 1.0f - diffuseColor.<a class="code" href="./class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e">a</a> : 1.0f;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> transparency[3] = {oneMinusAlpha, oneMinusAlpha, oneMinusAlpha};</div>
<div class="line">            shader-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef">setParameter</a>(<span class="stringliteral">"transparency"</span>, transparency);</div>
<div class="line">            shader-&gt;<a name="a32"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html#a6b65d9b284fc376f7f3458b36c29d8a0">setIsTransparent</a>(<span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">            shader-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html#a6b65d9b284fc376f7f3458b36c29d8a0">setIsTransparent</a>(<span class="keyword">false</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Diffuse</span></div>
<div class="line">        shader-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef">setParameter</a>(<span class="stringliteral">"diffuse"</span>, 1.0f);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> useHardwareInstancing()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// hardwareRenderingGlobals is a default node so we assume</span></div>
<div class="line"> <span class="comment">// that it will never be deleted.</span></div>
<div class="line"> <span class="keyword">static</span> <a name="_a33"></a><a class="code" href="./class_m_plug.html">MPlug</a> sHwInstancingPlug;</div>
<div class="line"> <span class="keywordflow">if</span> (sHwInstancingPlug.<a name="a34"></a><a class="code" href="./class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>()) {</div>
<div class="line"> <a name="_a35"></a><a class="code" href="./class_m_selection_list.html">MSelectionList</a> sl;</div>
<div class="line">        sl.<a name="a36"></a><a class="code" href="./class_m_selection_list.html#a23929aeafb29672f2652128eac9c4dec">add</a>(<span class="stringliteral">"hardwareRenderingGlobals.hwInstancing"</span>);</div>
<div class="line"> <a name="_a37"></a><a class="code" href="./class_m_status.html">MStatus</a> stat = sl.<a name="a38"></a><a class="code" href="./class_m_selection_list.html#a4cdb668fdd6feafe9b296a80cfca26f0">getPlug</a>(0, sHwInstancingPlug);</div>
<div class="line">        MStatAssert(stat);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> sHwInstancingPlug.<a name="a39"></a><a class="code" href="./class_m_plug.html#a69b4092a85b4edf58b7d50f331cc38cf">asBool</a>() &amp;&amp; Config::useHardwareInstancing();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ShaderInstancePtr</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class wraps a MShaderInstance* and its template shader.</span></div>
<div class="line"><span class="keyword">class </span>ShaderInstancePtr</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="comment">// Invalid shader instance.</span></div>
<div class="line">    ShaderInstancePtr()</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Wraps a MShaderInstance* and its template MShaderInstance*.</span></div>
<div class="line">    ShaderInstancePtr(std::shared_ptr&lt;MShaderInstance&gt; shader,</div>
<div class="line">                      std::shared_ptr&lt;MShaderInstance&gt; source)</div>
<div class="line">        : fShader(shader), fTemplate(source)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~ShaderInstancePtr()</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">operator</span> bool ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> fShader &amp;&amp; fTemplate;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* operator-&gt;()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">        assert(fShader);</div>
<div class="line"> <span class="keywordflow">return</span> fShader.get();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* <span class="keyword">get</span>() <span class="keyword">const</span></div>
<div class="line">    {</div>
<div class="line">        assert(fShader);</div>
<div class="line"> <span class="keywordflow">return</span> fShader.get();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;MShaderInstance&gt; getShader()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">        assert(fShader);</div>
<div class="line"> <span class="keywordflow">return</span> fShader;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;MShaderInstance&gt; getTemplate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">        assert(fTemplate);</div>
<div class="line"> <span class="keywordflow">return</span> fTemplate;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> reset()</div>
<div class="line">    {</div>
<div class="line">        fShader.reset();</div>
<div class="line">        fTemplate.reset();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> ShaderInstancePtr&amp; rv)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> fShader == rv.fShader &amp;&amp; fTemplate == rv.fTemplate;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> ShaderInstancePtr&amp; rv)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> !(operator==(rv));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;MShaderInstance&gt; fShader;</div>
<div class="line">    std::shared_ptr&lt;MShaderInstance&gt; fTemplate;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ShaderTemplatePtr</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class wraps a MShaderInstance* as a template.</span></div>
<div class="line"><span class="keyword">class </span>ShaderTemplatePtr</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="comment">// Invalid shader template.</span></div>
<div class="line">    ShaderTemplatePtr()</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Wrap a shader instance to be used as a template.</span></div>
<div class="line">    ShaderTemplatePtr(std::shared_ptr&lt;MShaderInstance&gt; source)</div>
<div class="line">        : fTemplate(source)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~ShaderTemplatePtr()</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">operator</span> bool ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> (fTemplate.get() != NULL);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* <span class="keyword">get</span>() <span class="keyword">const</span></div>
<div class="line">    {</div>
<div class="line">        assert(fTemplate);</div>
<div class="line"> <span class="keywordflow">return</span> fTemplate.get();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;MShaderInstance&gt; getTemplate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">        assert(fTemplate);</div>
<div class="line"> <span class="keywordflow">return</span> fTemplate;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> void (*Deleter)(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*);</div>
<div class="line">    ShaderInstancePtr newShaderInstance(Deleter deleter)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">        assert(fTemplate);</div>
<div class="line">        std::shared_ptr&lt;MShaderInstance&gt; newShader;</div>
<div class="line">        newShader.reset(fTemplate-&gt;clone(), std::ptr_fun(deleter));</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr(newShader, fTemplate);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;MShaderInstance&gt; fTemplate;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ShaderCache</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class manages the shader templates. A shader template can be used to create</span></div>
<div class="line"><span class="comment">// shader instances with different parameters.</span></div>
<div class="line"><span class="keyword">class </span>ShaderCache</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">static</span> ShaderCache&amp; getInstance()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Singleton</span></div>
<div class="line"> <span class="keyword">static</span> ShaderCache sSingleton;</div>
<div class="line"> <span class="keywordflow">return</span> sSingleton;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> void (*Deleter)(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*);</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr newPointShader(Deleter deleter)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for a cached shader.</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> key = <span class="stringliteral">"_reserved_point_shader_"</span>;</div>
<div class="line">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fFragmentCache.get&lt;0&gt;().find(key);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>
<div class="line">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>
<div class="line">            assert(templateShader);  <span class="comment">// no staled pointer</span></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new shader.</span></div>
<div class="line">        ShaderTemplatePtr templateShader =</div>
<div class="line">            wrapShaderTemplate(getPointShaderInstance());</div>
<div class="line"> <span class="keywordflow">if</span> (templateShader) {</div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            FragmentAndShaderTemplate entry;</div>
<div class="line">            entry.fragmentAndOutput = key;</div>
<div class="line">            entry.shader            = templateShader.get();</div>
<div class="line">            entry.ptr               = templateShader.getTemplate();</div>
<div class="line">            fFragmentCache.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr newWireShader(Deleter deleter)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for a cached shader.</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> key = <span class="stringliteral">"_reserved_wire_shader_"</span>;</div>
<div class="line">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fFragmentCache.get&lt;0&gt;().find(key);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>
<div class="line">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>
<div class="line">            assert(templateShader);  <span class="comment">// no staled pointer</span></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new shader.</span></div>
<div class="line">        ShaderTemplatePtr templateShader =</div>
<div class="line">            wrapShaderTemplate(getWireShaderInstance());</div>
<div class="line"> <span class="keywordflow">if</span> (templateShader) {</div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            FragmentAndShaderTemplate entry;</div>
<div class="line">            entry.fragmentAndOutput = key;</div>
<div class="line">            entry.shader            = templateShader.get();</div>
<div class="line">            entry.ptr               = templateShader.getTemplate();</div>
<div class="line">            fFragmentCache.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr newWireShaderWithCB(Deleter deleter)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for a cached shader.</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> key = <span class="stringliteral">"_reserved_wire_shader_with_cb_"</span>;</div>
<div class="line">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fFragmentCache.get&lt;0&gt;().find(key);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>
<div class="line">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>
<div class="line">            assert(templateShader);  <span class="comment">// no staled pointer</span></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new shader.</span></div>
<div class="line">        ShaderTemplatePtr templateShader =</div>
<div class="line">            wrapShaderTemplate(getWireShaderInstanceWithCB());</div>
<div class="line"> <span class="keywordflow">if</span> (templateShader) {</div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            FragmentAndShaderTemplate entry;</div>
<div class="line">            entry.fragmentAndOutput = key;</div>
<div class="line">            entry.shader            = templateShader.get();</div>
<div class="line">            entry.ptr               = templateShader.getTemplate();</div>
<div class="line">            fFragmentCache.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr newBoundingBoxPlaceHolderShader(Deleter deleter)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for a cached shader.</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> key = <span class="stringliteral">"_reserved_bounding_box_place_holder_shader_"</span>;</div>
<div class="line">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fFragmentCache.get&lt;0&gt;().find(key);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>
<div class="line">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>
<div class="line">            assert(templateShader);  <span class="comment">// no staled pointer</span></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new shader.</span></div>
<div class="line">        ShaderTemplatePtr templateShader =</div>
<div class="line">            wrapShaderTemplate(getBoundingBoxPlaceHolderShaderInstance());</div>
<div class="line"> <span class="keywordflow">if</span> (templateShader) {</div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            FragmentAndShaderTemplate entry;</div>
<div class="line">            entry.fragmentAndOutput = key;</div>
<div class="line">            entry.shader            = templateShader.get();</div>
<div class="line">            entry.ptr               = templateShader.getTemplate();</div>
<div class="line">            fFragmentCache.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr newDiffuseColorShader(Deleter deleter)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for a cached shader.</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> key = <span class="stringliteral">"_reserved_diffuse_color_shader_"</span>;</div>
<div class="line">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fFragmentCache.get&lt;0&gt;().find(key);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>
<div class="line">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>
<div class="line">            assert(templateShader);  <span class="comment">// no staled pointer</span></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new shader.</span></div>
<div class="line">        ShaderTemplatePtr templateShader =</div>
<div class="line">            wrapShaderTemplate(getDiffuseColorShaderInstance());</div>
<div class="line"> <span class="keywordflow">if</span> (templateShader) {</div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            FragmentAndShaderTemplate entry;</div>
<div class="line">            entry.fragmentAndOutput = key;</div>
<div class="line">            entry.shader            = templateShader.get();</div>
<div class="line">            entry.ptr               = templateShader.getTemplate();</div>
<div class="line">            fFragmentCache.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr newFragmentShader(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; fragmentName,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; outputStructName,</div>
<div class="line">                                        Deleter        deleter)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for a cached shader.</span></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> key = fragmentName + <span class="stringliteral">":"</span> + outputStructName;</div>
<div class="line">        FragmentAndShaderTemplateCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fFragmentCache.get&lt;0&gt;().find(key);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fFragmentCache.get&lt;0&gt;().end()) {</div>
<div class="line">            ShaderTemplatePtr templateShader = it-&gt;ptr.lock();</div>
<div class="line">            assert(templateShader);  <span class="comment">// no staled pointer</span></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new shader.</span></div>
<div class="line">        ShaderTemplatePtr templateShader =</div>
<div class="line">            createFragmentShader(fragmentName, outputStructName);</div>
<div class="line"> <span class="keywordflow">if</span> (templateShader) {</div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            FragmentAndShaderTemplate entry;</div>
<div class="line">            entry.fragmentAndOutput = key;</div>
<div class="line">            entry.shader            = templateShader.get();</div>
<div class="line">            entry.ptr               = templateShader.getTemplate();</div>
<div class="line">            fFragmentCache.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> templateShader.newShaderInstance(deleter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ShaderCache()  {}</div>
<div class="line">    ~ShaderCache() {}</div>
<div class="line">    ShaderCache(<span class="keyword">const</span> ShaderCache&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    ShaderCache&amp; operator=(<span class="keyword">const</span> ShaderCache&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Release the MShaderInstance and remove the pointer from the cache.</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> shaderTemplateDeleter(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader)</div>
<div class="line">    {</div>
<div class="line">        assert(shader);</div>
<div class="line">        getInstance().removeShaderTemplateFromCache(shader);</div>
<div class="line">        releaseShaderInstance(shader);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove the pointer from the cache.</span></div>
<div class="line"> <span class="keywordtype">void</span> removeShaderTemplateFromCache(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader)</div>
<div class="line">    {</div>
<div class="line">        assert(shader);</div>
<div class="line"> <span class="keywordflow">if</span> (!shader) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove the MShaderInstance* from the cache.</span></div>
<div class="line">        fFragmentCache.get&lt;1&gt;().erase(shader);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Wrap the MShaderInstance* as template.</span></div>
<div class="line">    ShaderTemplatePtr wrapShaderTemplate(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader)</div>
<div class="line">    {</div>
<div class="line">        assert(shader);</div>
<div class="line"> <span class="keywordflow">if</span> (!shader) <span class="keywordflow">return</span> ShaderTemplatePtr();</div>
<div class="line"></div>
<div class="line">        std::shared_ptr&lt;MShaderInstance&gt; ptr;</div>
<div class="line">        ptr.reset(shader, std::ptr_fun(shaderTemplateDeleter));</div>
<div class="line"> <span class="keywordflow">return</span> ShaderTemplatePtr(ptr);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create a shader template from a Maya fragment.</span></div>
<div class="line">    ShaderTemplatePtr createFragmentShader(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; fragmentName,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; outputStructName)</div>
<div class="line">    {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer) <span class="keywordflow">return</span> ShaderTemplatePtr();</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html">MShaderManager</a>* shaderMgr = renderer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125">getShaderManager</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderMgr) <span class="keywordflow">return</span> ShaderTemplatePtr();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> wrapShaderTemplate(</div>
<div class="line">            shaderMgr-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a75e397b8d02f3da09024156fe70eed44">getFragmentShader</a>(fragmentName, outputStructName, <span class="keyword">true</span>));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">struct </span>FragmentAndShaderTemplate {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a>                          fragmentAndOutput;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*                 shader;</div>
<div class="line">        std::weak_ptr&lt;MShaderInstance&gt; ptr;</div>
<div class="line">    };</div>
<div class="line"> <span class="keyword">typedef</span> boost::multi_index_container&lt;</div>
<div class="line">        FragmentAndShaderTemplate,</div>
<div class="line">        boost::multi_index::indexed_by&lt;</div>
<div class="line">            boost::multi_index::hashed_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_MEMBER(FragmentAndShaderTemplate,<a class="code" href="./class_m_string.html">MString</a>,fragmentAndOutput),</div>
<div class="line">                MStringHash</div>
<div class="line">            &gt;,</div>
<div class="line">            boost::multi_index::hashed_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_MEMBER(FragmentAndShaderTemplate,<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*,shader)</div>
<div class="line">            &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt; FragmentAndShaderTemplateCache;</div>
<div class="line"></div>
<div class="line">    FragmentAndShaderTemplateCache  fFragmentCache;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS MaterialGraphTranslatorShaded</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class translates a MaterialGraph to a MShaderInstance*</span></div>
<div class="line"><span class="comment">// that can be used in VP2.0.</span></div>
<div class="line"><span class="keyword">class </span>MaterialGraphTranslatorShaded : <span class="keyword">public</span> ConcreteMaterialNodeVisitor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="comment">// Create a new shader instance.</span></div>
<div class="line"> <span class="keyword">typedef</span> void (*Deleter)(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*);</div>
<div class="line">    MaterialGraphTranslatorShaded(Deleter deleter, <span class="keywordtype">double</span> timeInSeconds)</div>
<div class="line">        : fShader(), fDeleter(deleter), fTimeInSeconds(timeInSeconds)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update an existing shader instance.</span></div>
<div class="line">    MaterialGraphTranslatorShaded(ShaderInstancePtr&amp; shader, <span class="keywordtype">double</span> timeInSeconds)</div>
<div class="line">        : fShader(shader), fDeleter(NULL), fTimeInSeconds(timeInSeconds)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~MaterialGraphTranslatorShaded()<span class="keyword"> override </span>{}</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr getShader()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{ <span class="keywordflow">return</span> fShader; }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> LambertMaterial&amp; node)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">if</span> (!fShader) {</div>
<div class="line">            createShader(<span class="stringliteral">"mayaLambertSurface"</span>, <span class="stringliteral">"outSurfaceFinal"</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        setupLambert(node);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> PhongMaterial&amp; node)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">if</span> (!fShader) {</div>
<div class="line">            createShader(<span class="stringliteral">"mayaPhongSurface"</span>, <span class="stringliteral">"outSurfaceFinal"</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        setupPhong(node);</div>
<div class="line">        setupLambert(node);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> BlinnMaterial&amp; node)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">if</span> (!fShader) {</div>
<div class="line">            createShader(<span class="stringliteral">"mayaBlinnSurface"</span>, <span class="stringliteral">"outSurfaceFinal"</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        setupBlinn(node);</div>
<div class="line">        setupLambert(node);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Nodes that can't be used as root material node.</span></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> SurfaceMaterial&amp; node)<span class="keyword"> override </span>{}</div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> Texture2d&amp; node)<span class="keyword"> override </span>{}</div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> FileTexture&amp; node)<span class="keyword"> override </span>{}</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keywordtype">void</span> createShader(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; fragmentName,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; structOutputName)</div>
<div class="line">    {</div>
<div class="line">        assert(fDeleter);</div>
<div class="line">        fShader = ShaderCache::getInstance().newFragmentShader(</div>
<div class="line">            fragmentName, structOutputName, fDeleter);</div>
<div class="line">        assert(fShader);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setupLambert(<span class="keyword">const</span> LambertMaterial&amp; lambert)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!fShader) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Color</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a> color =</div>
<div class="line">                ShadedModeColor::evaluateDefaultColor(lambert.Color, fTimeInSeconds);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> buffer[3] = {color.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, color.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, color.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>};</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"color"</span>, buffer);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transparency</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a> transparency =</div>
<div class="line">                ShadedModeColor::evaluateColor(lambert.Transparency, fTimeInSeconds);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> buffer[3] = {transparency.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, transparency.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, transparency.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>};</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"transparency"</span>, buffer);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (transparency.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a> &gt; 0 || transparency.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a> &gt; 0 || transparency.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a> &gt; 0) {</div>
<div class="line">                fShader-&gt;setIsTransparent(<span class="keyword">true</span>);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                fShader-&gt;setIsTransparent(<span class="keyword">false</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Ambient Color</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a> ambientColor =</div>
<div class="line">                ShadedModeColor::evaluateColor(lambert.AmbientColor, fTimeInSeconds);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> buffer[3] = {ambientColor.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, ambientColor.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, ambientColor.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>};</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"ambientColor"</span>, buffer);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Incandescence</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a> incandescence =</div>
<div class="line">                ShadedModeColor::evaluateColor(lambert.Incandescence, fTimeInSeconds);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> buffer[3] = {incandescence.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, incandescence.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, incandescence.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>};</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"incandescence"</span>, buffer);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Diffuse</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> diffuse =</div>
<div class="line">                ShadedModeColor::evaluateFloat(lambert.Diffuse, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"diffuse"</span>, diffuse);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Translucence</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> translucence =</div>
<div class="line">                ShadedModeColor::evaluateFloat(lambert.Translucence, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"translucence"</span>, translucence);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Translucence Depth</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> translucenceDepth =</div>
<div class="line">                ShadedModeColor::evaluateFloat(lambert.TranslucenceDepth, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"translucenceDepth"</span>, translucenceDepth);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Translucence Focus</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> translucenceFocus =</div>
<div class="line">                ShadedModeColor::evaluateFloat(lambert.TranslucenceFocus, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"translucenceFocus"</span>, translucenceFocus);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Hide Source</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> hideSource =</div>
<div class="line">                ShadedModeColor::evaluateBool(lambert.HideSource, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"hideSource"</span>, hideSource);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Glow Intensity</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> glowIntensity =</div>
<div class="line">                ShadedModeColor::evaluateFloat(lambert.GlowIntensity, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"glowIntensity"</span>, glowIntensity);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setupPhong(<span class="keyword">const</span> PhongMaterial&amp; phong)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!fShader) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cosine Power</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> cosinePower =</div>
<div class="line">                ShadedModeColor::evaluateFloat(phong.CosinePower, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"cosinePower"</span>, cosinePower);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Specular Color</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a> specularColor =</div>
<div class="line">                ShadedModeColor::evaluateColor(phong.SpecularColor, fTimeInSeconds);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> buffer[3] = {specularColor.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, specularColor.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, specularColor.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>};</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"specularColor"</span>, buffer);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Reflectivity</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> reflectivity =</div>
<div class="line">                ShadedModeColor::evaluateFloat(phong.Reflectivity, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"reflectivity"</span>, reflectivity);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Reflected Color</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a> reflectedColor =</div>
<div class="line">                ShadedModeColor::evaluateColor(phong.ReflectedColor, fTimeInSeconds);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> buffer[3] = {reflectedColor.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, reflectedColor.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, reflectedColor.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>};</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"reflectedColor"</span>, buffer);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setupBlinn(<span class="keyword">const</span> BlinnMaterial&amp; blinn)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!fShader) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Eccentricity</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> eccentricity =</div>
<div class="line">                ShadedModeColor::evaluateFloat(blinn.Eccentricity, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"eccentricity"</span>, eccentricity);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// SpecularRollOff</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> specularRollOff =</div>
<div class="line">                ShadedModeColor::evaluateFloat(blinn.SpecularRollOff, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"specularRollOff"</span>, specularRollOff);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Specular Color</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a> specularColor =</div>
<div class="line">                ShadedModeColor::evaluateColor(blinn.SpecularColor, fTimeInSeconds);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> buffer[3] = {specularColor.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, specularColor.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, specularColor.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>};</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"specularColor"</span>, buffer);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Reflectivity</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> reflectivity =</div>
<div class="line">                ShadedModeColor::evaluateFloat(blinn.Reflectivity, fTimeInSeconds);</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"reflectivity"</span>, reflectivity);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Reflected Color</span></div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a> reflectedColor =</div>
<div class="line">                ShadedModeColor::evaluateColor(blinn.ReflectedColor, fTimeInSeconds);</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> buffer[3] = {reflectedColor.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, reflectedColor.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, reflectedColor.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>};</div>
<div class="line">            fShader-&gt;setParameter(<span class="stringliteral">"reflectedColor"</span>, buffer);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr fShader;</div>
<div class="line">    Deleter           fDeleter;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span>      fTimeInSeconds;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ShaderInstanceCache</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class manages MShaderInstance across multiple gpuCache nodes.</span></div>
<div class="line"><span class="comment">// The cache returns a shared pointer to the requested MShaderInstance.</span></div>
<div class="line"><span class="comment">// The caller shouldn't modify the MShaderInstance* that is returned from</span></div>
<div class="line"><span class="comment">// getSharedXXXShader() because the shader instance might be shared</span></div>
<div class="line"><span class="comment">// with other render items.</span></div>
<div class="line"><span class="comment">// The caller is responsible to hold the pointer.</span></div>
<div class="line"><span class="comment">// If the reference counter goes 0, the MShaderInstance is released.</span></div>
<div class="line"><span class="keyword">class </span>ShaderInstanceCache</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">static</span> ShaderInstanceCache&amp; getInstance()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Singleton</span></div>
<div class="line"> <span class="keyword">static</span> ShaderInstanceCache sSingleton;</div>
<div class="line"> <span class="keywordflow">return</span> sSingleton;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr getSharedPointShader()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Not visible in view, so color is not relevant:</span></div>
<div class="line"> <a class="code" href="./class_m_color.html">MColor</a> color(1.0, 0.0, 1.0);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Look for the cached MShaderInstance.</span></div>
<div class="line">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fPointShaders.get&lt;0&gt;().find(color);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fPointShaders.get&lt;0&gt;().end()) {</div>
<div class="line">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>
<div class="line">            assert(shader);  <span class="comment">// no staled pointer.</span></div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new MShaderInstance.</span></div>
<div class="line">        ShaderInstancePtr shader =</div>
<div class="line">            ShaderCache::getInstance().newPointShader(shaderInstanceDeleter);</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Fat point color.</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> solidColor[4] = {color.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, color.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, color.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>, 1.0f};</div>
<div class="line">            shader-&gt;setParameter(<span class="stringliteral">"solidColor"</span>, solidColor);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            ColorAndShaderInstance entry;</div>
<div class="line">            entry.color  = color;</div>
<div class="line">            entry.shader = shader.get();</div>
<div class="line">            entry.ptr    = shader.getShader();</div>
<div class="line">            entry.source = shader.getTemplate();</div>
<div class="line">            fPointShaders.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shader;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr getSharedWireShader(<span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp; color)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for the cached MShaderInstance.</span></div>
<div class="line">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fWireShaders.get&lt;0&gt;().find(color);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fWireShaders.get&lt;0&gt;().end()) {</div>
<div class="line">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>
<div class="line">            assert(shader);  <span class="comment">// no staled pointer.</span></div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new MShaderInstance.</span></div>
<div class="line">        ShaderInstancePtr shader =</div>
<div class="line">            ShaderCache::getInstance().newWireShader(shaderInstanceDeleter);</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Wireframe dash-line pattern.</span></div>
<div class="line">           SetDashLinePattern(shader.get(), Config::kLineStippleShortDashed);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Wireframe color.</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> solidColor[4] = {color.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, color.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, color.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>, 1.0f};</div>
<div class="line">            shader-&gt;setParameter(<span class="stringliteral">"solidColor"</span>, solidColor);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            ColorAndShaderInstance entry;</div>
<div class="line">            entry.color  = color;</div>
<div class="line">            entry.shader = shader.get();</div>
<div class="line">            entry.ptr    = shader.getShader();</div>
<div class="line">            entry.source = shader.getTemplate();</div>
<div class="line">            fWireShaders.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shader;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr getSharedWireShaderWithCB(<span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp; color)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for the cached MShaderInstance.</span></div>
<div class="line">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fWireShadersWithCB.get&lt;0&gt;().find(color);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fWireShadersWithCB.get&lt;0&gt;().end()) {</div>
<div class="line">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>
<div class="line">            assert(shader);  <span class="comment">// no staled pointer.</span></div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new MShaderInstance.</span></div>
<div class="line">        ShaderInstancePtr shader =</div>
<div class="line">            ShaderCache::getInstance().newWireShaderWithCB(shaderInstanceDeleter);</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Wireframe dash-line pattern.</span></div>
<div class="line">            SetDashLinePattern(shader.get(), Config::kLineStippleShortDashed);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Wireframe color.</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> solidColor[4] = {color.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, color.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, color.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>, 1.0f};</div>
<div class="line">            shader-&gt;setParameter(<span class="stringliteral">"solidColor"</span>, solidColor);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            ColorAndShaderInstance entry;</div>
<div class="line">            entry.color  = color;</div>
<div class="line">            entry.shader = shader.get();</div>
<div class="line">            entry.ptr    = shader.getShader();</div>
<div class="line">            entry.source = shader.getTemplate();</div>
<div class="line">            fWireShadersWithCB.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shader;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr getSharedBoundingBoxPlaceHolderShader(<span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp; color)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for the cached MShaderInstance.</span></div>
<div class="line">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fBoundingBoxPlaceHolderShaders.get&lt;0&gt;().find(color);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fBoundingBoxPlaceHolderShaders.get&lt;0&gt;().end()) {</div>
<div class="line">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>
<div class="line">            assert(shader);  <span class="comment">// no staled pointer.</span></div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new MShaderInstance.</span></div>
<div class="line">        ShaderInstancePtr shader =</div>
<div class="line">            ShaderCache::getInstance().newBoundingBoxPlaceHolderShader(shaderInstanceDeleter);</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Wireframe dash-line pattern.</span></div>
<div class="line">            SetDashLinePattern(shader.get(), Config::kLineStippleShortDashed);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Wireframe color.</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> solidColor[4] = {color.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>, color.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>, color.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>, 1.0f};</div>
<div class="line">            shader-&gt;setParameter(<span class="stringliteral">"solidColor"</span>, solidColor);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            ColorAndShaderInstance entry;</div>
<div class="line">            entry.color  = color;</div>
<div class="line">            entry.shader = shader.get();</div>
<div class="line">            entry.ptr    = shader.getShader();</div>
<div class="line">            entry.source = shader.getTemplate();</div>
<div class="line">            fBoundingBoxPlaceHolderShaders.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shader;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr getSharedDiffuseColorShader(<span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp; color)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Look for the cached MShaderInstance.</span></div>
<div class="line">        ColorAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fDiffuseColorShaders.get&lt;0&gt;().find(color);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fDiffuseColorShaders.get&lt;0&gt;().end()) {</div>
<div class="line">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>
<div class="line">            assert(shader);  <span class="comment">// no staled pointer.</span></div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new MShaderInstance.</span></div>
<div class="line">        ShaderInstancePtr shader =</div>
<div class="line">            ShaderCache::getInstance().newDiffuseColorShader(shaderInstanceDeleter);</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Set the diffuse color.</span></div>
<div class="line">            setDiffuseColor(shader.get(), color);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            ColorAndShaderInstance entry;</div>
<div class="line">            entry.color  = color;</div>
<div class="line">            entry.shader = shader.get();</div>
<div class="line">            entry.ptr    = shader.getShader();</div>
<div class="line">            entry.source = shader.getTemplate();</div>
<div class="line">            fDiffuseColorShaders.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shader;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create a unique lambert shader for diffuse color.</span></div>
<div class="line"> <span class="comment">// The caller can change the shader parameters for material animation.</span></div>
<div class="line">    ShaderInstancePtr getUniqueDiffuseColorShader(<span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp; color)</div>
<div class="line">    {</div>
<div class="line">        ShaderInstancePtr shader =</div>
<div class="line">            ShaderCache::getInstance().newDiffuseColorShader(shaderInstanceDeleter);</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Set the diffuse color.</span></div>
<div class="line">            setDiffuseColor(shader.get(), color);</div>
<div class="line"> <span class="keywordflow">return</span> shader;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This method will get a cached MShaderInstance for the given material.</span></div>
<div class="line">    ShaderInstancePtr getSharedShadedMaterialShader(</div>
<div class="line"> <span class="keyword">const</span> MaterialGraph::Ptr&amp; material,</div>
<div class="line"> <span class="keywordtype">double</span>                    timeInSeconds</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        assert(material);</div>
<div class="line"> <span class="keywordflow">if</span> (!material) <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Look for the cached MShaderInstance.</span></div>
<div class="line">        MaterialAndShaderInstanceCache::nth_index&lt;0&gt;::type::iterator it =</div>
<div class="line">            fShadedMaterialShaders.get&lt;0&gt;().find(material);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Found in cache.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fShadedMaterialShaders.get&lt;0&gt;().end()) {</div>
<div class="line">            std::shared_ptr&lt;MShaderInstance&gt; shader = it-&gt;ptr.lock();</div>
<div class="line">            assert(shader);  <span class="comment">// no staled pointer.</span></div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr(shader, it-&gt;source);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Not found. Get a new MShaderInstance.</span></div>
<div class="line"> <span class="keyword">const</span> MaterialNode::Ptr&amp; rootNode = material-&gt;rootNode();</div>
<div class="line">        assert(rootNode);</div>
<div class="line"></div>
<div class="line">        ShaderInstancePtr shader;</div>
<div class="line"> <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">            MaterialGraphTranslatorShaded shadedTranslator(shaderInstanceDeleter, timeInSeconds);</div>
<div class="line">            rootNode-&gt;accept(shadedTranslator);</div>
<div class="line">            shader = shadedTranslator.getShader();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Insert into cache.</span></div>
<div class="line">            MaterialAndShaderInstance entry;</div>
<div class="line">            entry.material      = material;</div>
<div class="line">            entry.shader        = shader.get();</div>
<div class="line">            entry.ptr           = shader.getShader();</div>
<div class="line">            entry.source        = shader.getTemplate();</div>
<div class="line">            entry.isAnimated    = material-&gt;isAnimated();</div>
<div class="line">            entry.timeInSeconds = timeInSeconds;</div>
<div class="line">            fShadedMaterialShaders.insert(entry);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> shader;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        assert(0);</div>
<div class="line"> <span class="keywordflow">return</span> ShaderInstancePtr();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateCachedShadedShaders(<span class="keywordtype">double</span> timeInSeconds)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Update all cached MShaderInstance* for shaded mode to the current time.</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> MaterialAndShaderInstance&amp; entry : fShadedMaterialShaders) {</div>
<div class="line"> <span class="comment">// Not animated. Skipping.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!entry.isAnimated) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Already up-to-date. Skipping.</span></div>
<div class="line"> <span class="keywordflow">if</span> (entry.timeInSeconds == timeInSeconds) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the MShaderInstance*</span></div>
<div class="line"> <span class="keyword">const</span> MaterialNode::Ptr&amp; rootNode = entry.material-&gt;rootNode();</div>
<div class="line"> <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">                ShaderInstancePtr shader(entry.ptr.lock(), entry.source);</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line">                    MaterialGraphTranslatorShaded shadedTranslator(shader, timeInSeconds);</div>
<div class="line">                    rootNode-&gt;accept(shadedTranslator);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remember the last update time.</span></div>
<div class="line">            entry.timeInSeconds = timeInSeconds;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="comment">// Release the MShaderInstance and remove the pointer from the cache.</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> shaderInstanceDeleter(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader)</div>
<div class="line">    {</div>
<div class="line">        assert(shader);</div>
<div class="line">        getInstance().removeShaderInstanceFromCache(shader);</div>
<div class="line">        releaseShaderInstance(shader);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove the pointer from the cache.</span></div>
<div class="line"> <span class="keywordtype">void</span> removeShaderInstanceFromCache(<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader)</div>
<div class="line">    {</div>
<div class="line">        assert(shader);</div>
<div class="line"> <span class="keywordflow">if</span> (!shader) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove the MShaderInstance* from the cache.</span></div>
<div class="line">        fPointShaders.get&lt;1&gt;().erase(shader);</div>
<div class="line">        fWireShaders.get&lt;1&gt;().erase(shader);</div>
<div class="line">        fWireShadersWithCB.get&lt;1&gt;().erase(shader);</div>
<div class="line">        fBoundingBoxPlaceHolderShaders.get&lt;1&gt;().erase(shader);</div>
<div class="line">        fDiffuseColorShaders.get&lt;1&gt;().erase(shader);</div>
<div class="line">        fShadedMaterialShaders.get&lt;1&gt;().erase(shader);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ShaderInstanceCache()  {}</div>
<div class="line">    ~ShaderInstanceCache() {}</div>
<div class="line">    ShaderInstanceCache(<span class="keyword">const</span> ShaderInstanceCache&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    ShaderInstanceCache&amp; operator=(<span class="keyword">const</span> ShaderInstanceCache&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// MColor as hash key.</span></div>
<div class="line"> <span class="keyword">struct </span>MColorHash : std::unary_function&lt;MColor, std::size_t&gt;</div>
<div class="line">    {</div>
<div class="line">        std::size_t operator()(<span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp; key)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">            std::size_t seed = 0;</div>
<div class="line">            boost::hash_combine(seed, key.<a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>);</div>
<div class="line">            boost::hash_combine(seed, key.<a class="code" href="./class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a>);</div>
<div class="line">            boost::hash_combine(seed, key.<a class="code" href="./class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a>);</div>
<div class="line">            boost::hash_combine(seed, key.<a class="code" href="./class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e">a</a>);</div>
<div class="line"> <span class="keywordflow">return</span> seed;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="comment">// MaterialGraph as hash key.</span></div>
<div class="line"> <span class="keyword">struct </span>MaterialGraphHash : std::unary_function&lt;MaterialGraph::Ptr, std::size_t&gt;</div>
<div class="line">    {</div>
<div class="line">        std::size_t operator()(<span class="keyword">const</span> MaterialGraph::Ptr&amp; key)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> boost::hash_value(key.get());</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="comment">// MShaderInstance* cached by MColor as hash key.</span></div>
<div class="line"> <span class="keyword">struct </span>ColorAndShaderInstance {</div>
<div class="line"> <a class="code" href="./class_m_color.html">MColor</a>                             color;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*                   shader;</div>
<div class="line">        std::weak_ptr&lt;MShaderInstance&gt;   ptr;</div>
<div class="line">        std::shared_ptr&lt;MShaderInstance&gt; source;</div>
<div class="line">    };</div>
<div class="line"> <span class="keyword">typedef</span> boost::multi_index_container&lt;</div>
<div class="line">        ColorAndShaderInstance,</div>
<div class="line">        boost::multi_index::indexed_by&lt;</div>
<div class="line">            boost::multi_index::hashed_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_MEMBER(ColorAndShaderInstance,<a class="code" href="./class_m_color.html">MColor</a>,color),</div>
<div class="line">                MColorHash</div>
<div class="line">            &gt;,</div>
<div class="line">            boost::multi_index::hashed_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_MEMBER(ColorAndShaderInstance,<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*,shader)</div>
<div class="line">            &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt; ColorAndShaderInstanceCache;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// MShaderInstance* cached by MaterialGraph as hash key.</span></div>
<div class="line"> <span class="keyword">struct </span>MaterialAndShaderInstance {</div>
<div class="line">        MaterialGraph::Ptr                 material;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*                   shader;</div>
<div class="line">        std::weak_ptr&lt;MShaderInstance&gt;   ptr;</div>
<div class="line">        std::shared_ptr&lt;MShaderInstance&gt; source;</div>
<div class="line"> <span class="keywordtype">bool</span>                               isAnimated;</div>
<div class="line"> <span class="keyword">mutable</span> <span class="keywordtype">double</span>                     timeInSeconds;</div>
<div class="line">    };</div>
<div class="line"> <span class="keyword">typedef</span> boost::multi_index_container&lt;</div>
<div class="line">        MaterialAndShaderInstance,</div>
<div class="line">        boost::multi_index::indexed_by&lt;</div>
<div class="line">            boost::multi_index::hashed_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_MEMBER(MaterialAndShaderInstance,MaterialGraph::Ptr,material),</div>
<div class="line">                MaterialGraphHash</div>
<div class="line">            &gt;,</div>
<div class="line">            boost::multi_index::hashed_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_MEMBER(MaterialAndShaderInstance,<a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>*,shader)</div>
<div class="line">            &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt; MaterialAndShaderInstanceCache;</div>
<div class="line"></div>
<div class="line">    ColorAndShaderInstanceCache    fPointShaders;</div>
<div class="line">    ColorAndShaderInstanceCache    fWireShaders;</div>
<div class="line">    ColorAndShaderInstanceCache    fWireShadersWithCB;</div>
<div class="line">    ColorAndShaderInstanceCache    fBoundingBoxPlaceHolderShaders;</div>
<div class="line">    ColorAndShaderInstanceCache    fDiffuseColorShaders;</div>
<div class="line">    MaterialAndShaderInstanceCache fShadedMaterialShaders;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS HardwareInstanceData</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>RenderItemWrapper;</div>
<div class="line"><span class="keyword">class </span>HardwareInstanceManagerImpl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// This class contains the hardware instancing information for a render item.</span></div>
<div class="line"><span class="comment">// Each RenderItemWrapper object has the ownership of this object.</span></div>
<div class="line"><span class="comment">// If a RenderItemWrapper holds an instance of this class, the render item is</span></div>
<div class="line"><span class="comment">// already instanced or is an instance candidate (not-yet-instanced).</span></div>
<div class="line"><span class="keyword">class </span>HardwareInstanceData</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HardwareInstanceData(HardwareInstanceManagerImpl* manager,</div>
<div class="line">                         RenderItemWrapper*           renderItem)</div>
<div class="line">        : fMasterData(NULL),</div>
<div class="line">          fInstanceId(0),</div>
<div class="line">          fRenderItem(renderItem),</div>
<div class="line">          fManager(manager)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~HardwareInstanceData()</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    HardwareInstanceData(<span class="keyword">const</span> HardwareInstanceData&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    HardwareInstanceData&amp; operator=(<span class="keyword">const</span> HardwareInstanceData&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Returns the master render item.</span></div>
<div class="line">    HardwareInstanceData* masterData()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fMasterData; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Returns the instance id.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instanceId()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fInstanceId; }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Returns the owner render item.</span></div>
<div class="line">    RenderItemWrapper* renderItem()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fRenderItem; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Returns true if this render item is hardware instanced.</span></div>
<div class="line"> <span class="keywordtype">bool</span> isInstanced()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> fInstanceId &gt; 0; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Returns true if this render item is a mater instance item.</span></div>
<div class="line"> <span class="keywordtype">bool</span> isMasterItem()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fMasterData == <span class="keyword">this</span>; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set up to be an instance candidate.</span></div>
<div class="line"> <span class="keywordtype">void</span> setupCandidate(HardwareInstanceData* master)</div>
<div class="line">    {</div>
<div class="line">        assert(master);</div>
<div class="line">        fMasterData = master;</div>
<div class="line">        fInstanceId = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set up to be an instance.</span></div>
<div class="line"> <span class="keywordtype">void</span> setupInstance(HardwareInstanceData* master, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instanceId)</div>
<div class="line">    {</div>
<div class="line">        assert(master);</div>
<div class="line">        assert(instanceId &gt; 0);</div>
<div class="line">        fMasterData = master;</div>
<div class="line">        fInstanceId = instanceId;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Clear the instance data.</span></div>
<div class="line"> <span class="keywordtype">void</span> clearInstanceData()</div>
<div class="line">    {</div>
<div class="line">        fMasterData = NULL;</div>
<div class="line">        fInstanceId = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Notify that the render item has been changed so its instancing</span></div>
<div class="line"> <span class="comment">// should be recomputed.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyInstancingChange();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Notify that the render item has been changed but the change is</span></div>
<div class="line"> <span class="comment">// destructive (shader or geometry change).</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyInstancingClear();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Notify that the render item's world matrix has been changed.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyWorldMatrixChange();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Notify that the render item is going to be destroyed.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyDestroy();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    HardwareInstanceData* fMasterData;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          fInstanceId;</div>
<div class="line"></div>
<div class="line">    RenderItemWrapper*           fRenderItem;</div>
<div class="line">    HardwareInstanceManagerImpl* fManager;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS RenderItemWrapper</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class wraps a MRenderItem* object. This will make us easier to track</span></div>
<div class="line"><span class="comment">// the state of a render item.</span></div>
<div class="line"><span class="keyword">class </span>RenderItemWrapper</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> std::shared_ptr&lt;RenderItemWrapper&gt; Ptr;</div>
<div class="line"></div>
<div class="line">    RenderItemWrapper(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;                     name,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49e">MRenderItem::RenderItemType</a>  type,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MGeometry::Primitive</a>         primitive)</div>
<div class="line">        : fName(name),</div>
<div class="line">          fType(type),</div>
<div class="line">          fPrimitive(primitive),</div>
<div class="line">          fRenderItem(NULL),</div>
<div class="line">          fEnabled(true),</div>
<div class="line">          fDrawMode((<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MGeometry</a>::DrawMode)0),</div>
<div class="line">          fDepthPriority(<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>::sDormantFilledDepthPriority),</div>
<div class="line">          fIsPointSnapping(false),</div>
<div class="line">          fExcludedFromPostEffects(true),</div>
<div class="line">          fCastsShadows(false),</div>
<div class="line">          fReceivesShadows(false)</div>
<div class="line">    {</div>
<div class="line">        assert(name.<a name="a40"></a><a class="code" href="./class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create the render item.</span></div>
<div class="line">        fRenderItem = MRenderItem::Create(</div>
<div class="line">            name,</div>
<div class="line">            type,</div>
<div class="line">            primitive</div>
<div class="line">        );</div>
<div class="line">        assert(fRenderItem);</div>
<div class="line"> <a name="_a41"></a><a class="code" href="./class_m_selection_mask.html">MSelectionMask</a> gpuCacheMask(ShapeNode::selectionMaskName);</div>
<div class="line">        fRenderItem-&gt;setSelectionMask(gpuCacheMask);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~RenderItemWrapper()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// The buffers are no longer used by this render item.</span></div>
<div class="line">        BuffersCache::getInstance().removeBuffers(</div>
<div class="line">            fIndices,</div>
<div class="line">            fPositions,</div>
<div class="line">            fNormals,</div>
<div class="line">            fUVs</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Notify that the render item is destroyed or already destroyed.</span></div>
<div class="line">        notifyDestroy();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    RenderItemWrapper(<span class="keyword">const</span> RenderItemWrapper&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    RenderItemWrapper&amp; operator=(<span class="keyword">const</span> RenderItemWrapper&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> addToContainer(<a name="_a42"></a><a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        assert(fRenderItem);</div>
<div class="line">        container.<a name="a43"></a><a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html#a3868473990e1902a2929a48acd2746d8">add</a>(fRenderItem);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> removeFromContainer(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">            assert(fName == fRenderItem-&gt;name());</div>
<div class="line">            fRenderItem-&gt;setCustomData(NULL);</div>
<div class="line">            container.<a name="a44"></a><a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html#ab8634382a216e26abb0b47c55d5eb4b6">remove</a>(fName);</div>
<div class="line">            fRenderItem = NULL;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setEnabled(<span class="keywordtype">bool</span> enabled)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fEnabled != enabled) {</div>
<div class="line"> <span class="comment">// Enable/disable the render item.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                fRenderItem-&gt;enable(enabled);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache the enable flag.</span></div>
<div class="line">            fEnabled = enabled;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Visibility changed. We need to recompute shadow map.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fType == MRenderItem::MaterialSceneItem) {</div>
<div class="line">                MRenderer::setLightsAndShadowsDirty();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            notifyInstancingChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setWorldMatrix(<span class="keyword">const</span> <a name="_a45"></a><a class="code" href="./class_m_matrix.html">MMatrix</a>&amp; worldMatrix)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fWorldMatrix != worldMatrix) {</div>
<div class="line"> <span class="comment">// Set the world matrix to the render item.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                fRenderItem-&gt;setMatrix(&amp;worldMatrix);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache the world matrix.</span></div>
<div class="line">            fWorldMatrix = worldMatrix;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// World matrix changed. We need to recompute shadow map.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fType == MRenderItem::MaterialSceneItem) {</div>
<div class="line">                MRenderer::setLightsAndShadowsDirty();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            notifyWorldMatrixChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setBuffers(SubSceneOverride&amp;                               subSceneOverride,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;     indices,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp;    positions,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp;    normals,</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp;    uvs,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>&amp;                             boundingBox)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> buffersChanged =</div>
<div class="line">            fIndices    !=  indices     ||</div>
<div class="line">            fPositions  !=  positions   ||</div>
<div class="line">            fNormals    !=  normals     ||</div>
<div class="line">            fUVs        !=  uvs;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (buffersChanged) {</div>
<div class="line"> <span class="comment">// Update the geometry on the render item.</span></div>
<div class="line">            BuffersCache::getInstance().updateBuffers(</div>
<div class="line">                subSceneOverride,</div>
<div class="line">                fRenderItem,</div>
<div class="line">                indices,</div>
<div class="line">                positions,</div>
<div class="line">                normals,</div>
<div class="line">                uvs,</div>
<div class="line">                boundingBox,</div>
<div class="line">                fIndices,</div>
<div class="line">                fPositions,</div>
<div class="line">                fNormals,</div>
<div class="line">                fUVs</div>
<div class="line">            );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache the buffers.</span></div>
<div class="line">            fIndices        =   indices;</div>
<div class="line">            fPositions      =   positions;</div>
<div class="line">            fNormals        =   normals;</div>
<div class="line">            fUVs            =   uvs;</div>
<div class="line">            fBoundingBox    =   boundingBox;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// World matrix changed. We need to recompute shadow map.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fType == MRenderItem::MaterialSceneItem) {</div>
<div class="line">                MRenderer::setLightsAndShadowsDirty();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Setting the geometry is destructive.</span></div>
<div class="line"> <span class="comment">// Viewport 2.0 will override the geometry for hardware instancing.</span></div>
<div class="line">            notifyInstancingClear();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setShader(<span class="keyword">const</span> ShaderInstancePtr&amp; shader)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fShader != shader) {</div>
<div class="line"> <span class="comment">// Set the new shader to the render item.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                fRenderItem-&gt;setShader(shader.get());</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache the shader pointer.</span></div>
<div class="line">            fShader = shader;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Setting the shader is destructive.</span></div>
<div class="line"> <span class="comment">// Viewport 2.0 will override the shader for hardware instancing.</span></div>
<div class="line">            notifyInstancingClear();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setCustomData(<span class="keyword">const</span> std::shared_ptr&lt;SubNodeUserData&gt;&amp; userData)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fUserData != userData) {</div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                fRenderItem-&gt;setCustomData(<span class="keyword">new</span> SubNodeUserDataDelegate(userData));</div>
<div class="line">            }</div>
<div class="line">            fUserData = userData;</div>
<div class="line"></div>
<div class="line">            notifyInstancingChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setDrawMode(<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3">MGeometry::DrawMode</a> drawMode)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fDrawMode != drawMode) {</div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                fRenderItem-&gt;setDrawMode(drawMode);</div>
<div class="line">            }</div>
<div class="line">            fDrawMode = drawMode;</div>
<div class="line"></div>
<div class="line">            notifyInstancingChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setSnappingSelectionMask()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!fIsPointSnapping) {</div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line"> <a class="code" href="./class_m_selection_mask.html">MSelectionMask</a> pointsForGravityMask(<a name="a46"></a><a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da973e7813e5ba338103dc014a3037bc7a">MSelectionMask::kSelectPointsForGravity</a>);</div>
<div class="line">                fRenderItem-&gt;setSelectionMask(pointsForGravityMask);</div>
<div class="line">            }</div>
<div class="line">            fIsPointSnapping = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">            notifyInstancingChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setDepthPriority(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> depthPriority)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fDepthPriority != depthPriority) {</div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                fRenderItem-&gt;depthPriority(depthPriority);</div>
<div class="line">            }</div>
<div class="line">            fDepthPriority = depthPriority;</div>
<div class="line"></div>
<div class="line">            notifyInstancingChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setExcludedFromPostEffects(<span class="keywordtype">bool</span> exclude)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fExcludedFromPostEffects != exclude) {</div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                fRenderItem-&gt;setExcludedFromPostEffects(exclude);</div>
<div class="line">            }</div>
<div class="line">            fExcludedFromPostEffects = exclude;</div>
<div class="line"></div>
<div class="line">            notifyInstancingChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setCastsShadows(<span class="keywordtype">bool</span> cast)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fCastsShadows != cast) {</div>
<div class="line"> <span class="comment">// Set whether the render item will cast shadows on other objects.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                fRenderItem-&gt;castsShadows(cast);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache the cast shadow flag.</span></div>
<div class="line">            fCastsShadows = cast;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Recompute shadow map if cast shadow flag changes</span></div>
<div class="line"> <span class="keywordflow">if</span> (fType == MRenderItem::MaterialSceneItem) {</div>
<div class="line">                MRenderer::setLightsAndShadowsDirty();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            notifyInstancingChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setReceivesShadows(<span class="keywordtype">bool</span> receive)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fReceivesShadows != receive) {</div>
<div class="line"> <span class="comment">// Set whether the render item will receive shadows from other objects.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                fRenderItem-&gt;receivesShadows(receive);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache the receive shadow flag.</span></div>
<div class="line">            fReceivesShadows = receive;</div>
<div class="line"></div>
<div class="line">            notifyInstancingChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setCompatibleWithMayaInstancer(<span class="keywordtype">bool</span> state)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem &amp;&amp; fRenderItem-&gt;isCompatibleWithMayaInstancer() != state)</div>
<div class="line">        {</div>
<div class="line">            fRenderItem-&gt;setCompatibleWithMayaInstancer(state);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set up for hardware instancing. </span></div>
<div class="line"> <span class="comment">// If the hardware instance data is NULL, the render item will never be instanced.</span></div>
<div class="line"> <span class="comment">// This method must be called from HardwareInstanceManager.</span></div>
<div class="line"> <span class="keywordtype">void</span> installHardwareInstanceData(<span class="keyword">const</span> std::shared_ptr&lt;HardwareInstanceData&gt;&amp; data)</div>
<div class="line">    {</div>
<div class="line">        fHardwareInstanceData = data;</div>
<div class="line">        notifyInstancingChange();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove hardware instancing data. This render item will never be instanced.</span></div>
<div class="line"> <span class="comment">// This method must be called from HardwareInstanceManager.</span></div>
<div class="line"> <span class="keywordtype">void</span> removeHardwareInstanceData(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fHardwareInstanceData) {</div>
<div class="line"> <span class="keywordflow">if</span> (fHardwareInstanceData-&gt;isInstanced()) {</div>
<div class="line"> <span class="comment">// Get rid of the render item that is set up hardware instancing.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) {</div>
<div class="line">                    unloadItem(container);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                assert(!fRenderItem);</div>
<div class="line">                loadItem(subSceneOverride, container);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Delete the hardware instancing data.</span></div>
<div class="line">            fHardwareInstanceData.reset();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Returns true if the render item is already instaned or not-yet-instanced.</span></div>
<div class="line"> <span class="keywordtype">bool</span> hasHardwareInstanceData()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> fHardwareInstanceData.get() != NULL;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Unload the render item. This will delete the actual MRenderItem.</span></div>
<div class="line"> <span class="keywordtype">void</span> unloadItem(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Already unloaded?</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fRenderItem) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove the render item from the container. The container claims</span></div>
<div class="line"> <span class="comment">// a strong ownership so the render item is actually deleted.</span></div>
<div class="line">        removeFromContainer(container);</div>
<div class="line">        fRenderItem = NULL;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Load the render item. This will create a new identical MRenderItem.</span></div>
<div class="line"> <span class="keywordtype">void</span> loadItem(SubSceneOverride&amp; subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Already loaded?</span></div>
<div class="line"> <span class="keywordflow">if</span> (fRenderItem) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create the render item.</span></div>
<div class="line">        fRenderItem = MRenderItem::Create(</div>
<div class="line">            fName,</div>
<div class="line">            fType,</div>
<div class="line">            fPrimitive</div>
<div class="line">        );</div>
<div class="line">        assert(fRenderItem);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add back to container.</span></div>
<div class="line">        addToContainer(container);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Restore parameters.</span></div>
<div class="line">        fRenderItem-&gt;setCustomData(<span class="keyword">new</span> SubNodeUserDataDelegate(fUserData));</div>
<div class="line">        fRenderItem-&gt;enable(fEnabled);</div>
<div class="line">        fRenderItem-&gt;setMatrix(&amp;fWorldMatrix);</div>
<div class="line">        fRenderItem-&gt;setDrawMode(fDrawMode);</div>
<div class="line">        fRenderItem-&gt;depthPriority(fDepthPriority);</div>
<div class="line">        fRenderItem-&gt;setExcludedFromPostEffects(fExcludedFromPostEffects);</div>
<div class="line">        fRenderItem-&gt;castsShadows(fCastsShadows);</div>
<div class="line">        fRenderItem-&gt;receivesShadows(fReceivesShadows);</div>
<div class="line">        fRenderItem-&gt;setShader(fShader.get());</div>
<div class="line">        fRenderItem-&gt;setCompatibleWithMayaInstancer(<span class="keyword">true</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (fIsPointSnapping)</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_selection_mask.html">MSelectionMask</a> pointsForGravityMask(<a class="code" href="./class_m_selection_mask.html#acffca3b33fddce63d3220bc7487e879da973e7813e5ba338103dc014a3037bc7a">MSelectionMask::kSelectPointsForGravity</a>);</div>
<div class="line">            fRenderItem-&gt;setSelectionMask(pointsForGravityMask);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_selection_mask.html">MSelectionMask</a> gpuCacheMask(ShapeNode::selectionMaskName);</div>
<div class="line">            fRenderItem-&gt;setSelectionMask(gpuCacheMask);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Restore buffers.</span></div>
<div class="line">        BuffersCache::getInstance().updateBuffers(</div>
<div class="line">            subSceneOverride,</div>
<div class="line">            fRenderItem,</div>
<div class="line">            fIndices,</div>
<div class="line">            fPositions,</div>
<div class="line">            fNormals,</div>
<div class="line">            fUVs,</div>
<div class="line">            fBoundingBox,</div>
<div class="line">            fIndices,</div>
<div class="line">            fPositions,</div>
<div class="line">            fNormals,</div>
<div class="line">            fUVs</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Query methods</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;                      name()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> fName; }</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49e">MRenderItem::RenderItemType</a>   type()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> fType; }</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MGeometry::Primitive</a>          primitive()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fPrimitive; }</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;SubNodeUserData&gt;&amp; userData()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> fUserData; }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp;  indices()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> fIndices; }</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; positions()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> fPositions; }</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; normals()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> fNormals; }</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; uvs()<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> fUVs; }</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>&amp; boundingBox()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fBoundingBox; }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span>                enabled()<span class="keyword"> const                 </span>{ <span class="keywordflow">return</span> fEnabled; }</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a>&amp;      worldMatrix()<span class="keyword"> const             </span>{ <span class="keywordflow">return</span> fWorldMatrix; }</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3">MGeometry::DrawMode</a> drawMode()<span class="keyword"> const                </span>{ <span class="keywordflow">return</span> fDrawMode; }</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        depthPriority()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> fDepthPriority; }</div>
<div class="line"> <span class="keywordtype">bool</span>                excludedFromPostEffects()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fExcludedFromPostEffects; }</div>
<div class="line"> <span class="keywordtype">bool</span>                castsShadows()<span class="keyword"> const            </span>{ <span class="keywordflow">return</span> fCastsShadows; }</div>
<div class="line"> <span class="keywordtype">bool</span>                receivesShadows()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> fReceivesShadows; }</div>
<div class="line"> <span class="keywordtype">bool</span>                isCompatibleWithMayaInstancer()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fRenderItem ? fRenderItem-&gt;isCompatibleWithMayaInstancer() : <span class="keyword">false</span>; }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> ShaderInstancePtr&amp; shader()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fShader; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Extract the wrapped render item.</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>* wrappedItem()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fRenderItem; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="comment">// Hardware instancing notification methods.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Slight change that we can reuse existing instancing.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyInstancingChange()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fHardwareInstanceData) {</div>
<div class="line">            fHardwareInstanceData-&gt;notifyInstancingChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Destructive change that we have to clear instancing.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyInstancingClear()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fHardwareInstanceData) {</div>
<div class="line">            fHardwareInstanceData-&gt;notifyInstancingClear();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// World matrix change. We need to update instance transform.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyWorldMatrixChange()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fHardwareInstanceData) {</div>
<div class="line">            fHardwareInstanceData-&gt;notifyWorldMatrixChange();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Destructor is being called.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyDestroy()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fHardwareInstanceData) {</div>
<div class="line">            fHardwareInstanceData-&gt;notifyDestroy();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>                           fName;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a688a4360e982358b90610f58d4eef49e">MRenderItem::RenderItemType</a>       fType;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a08260379b97fd733e30ea92e891ede1e">MGeometry::Primitive</a>              fPrimitive;</div>
<div class="line">    std::shared_ptr&lt;SubNodeUserData&gt;      fUserData;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>*                            fRenderItem;</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;const IndexBuffer&gt;    fIndices;</div>
<div class="line">    std::shared_ptr&lt;const VertexBuffer&gt;   fPositions;</div>
<div class="line">    std::shared_ptr&lt;const VertexBuffer&gt;   fNormals;</div>
<div class="line">    std::shared_ptr&lt;const VertexBuffer&gt;   fUVs;</div>
<div class="line"> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>                            fBoundingBox;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span>                                    fEnabled;</div>
<div class="line"> <a class="code" href="./class_m_matrix.html">MMatrix</a>                                 fWorldMatrix;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3">MGeometry::DrawMode</a>                     fDrawMode;</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                            fDepthPriority;</div>
<div class="line"> <span class="keywordtype">bool</span>                                    fIsPointSnapping;</div>
<div class="line"> <span class="keywordtype">bool</span>                                    fExcludedFromPostEffects;</div>
<div class="line"> <span class="keywordtype">bool</span>                                    fCastsShadows;</div>
<div class="line"> <span class="keywordtype">bool</span>                                    fReceivesShadows;</div>
<div class="line"></div>
<div class="line">    ShaderInstancePtr                       fShader;</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;HardwareInstanceData&gt; fHardwareInstanceData;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS HardwareInstanceManagerImpl</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class is expected to manage all hardware instances inside a single</span></div>
<div class="line"><span class="comment">// subscene. Currently, we don't support hardware instances between gpuCache nodes.</span></div>
<div class="line"><span class="comment">// Each SubSceneOverride owns a HardwareInstanceManager.</span></div>
<div class="line"><span class="comment">// The manager tracks the render item changes. At the end of update() method,</span></div>
<div class="line"><span class="comment">// processInstances() is called to set up instances.</span></div>
<div class="line"><span class="comment">// There are 3 places that hold instancing information:</span></div>
<div class="line"><span class="comment">//   1) HardwareInstanceManagerImpl: This class holds all instancing info.</span></div>
<div class="line"><span class="comment">//   2) HardwareInstanceData: This class is attached to each render item to</span></div>
<div class="line"><span class="comment">//                            keep track of the per-renderItem info.</span></div>
<div class="line"><span class="comment">//   3) MRenderItem: An instance render item is set up by calling MPxSubSceneOverride</span></div>
<div class="line"><span class="comment">//                   hardware instancing methods.</span></div>
<div class="line"><span class="keyword">class </span>HardwareInstanceManagerImpl</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HardwareInstanceManagerImpl(SubSceneOverride&amp; subSceneOverride)</div>
<div class="line">        : fSubSceneOverride(subSceneOverride)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~HardwareInstanceManagerImpl()</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    HardwareInstanceManagerImpl(<span class="keyword">const</span> HardwareInstanceManagerImpl&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    HardwareInstanceManagerImpl&amp; operator=(<span class="keyword">const</span> HardwareInstanceManagerImpl&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// This method is called at the end of the subscene's update() method.</span></div>
<div class="line"> <span class="comment">// We have collected all changed/destroyed render items.</span></div>
<div class="line"> <span class="comment">// In this method, we can choose the render items to form hardware</span></div>
<div class="line"> <span class="comment">// instances. Or remove a render item from an existing instance.</span></div>
<div class="line"> <span class="keywordtype">void</span> processInstances(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Clean up removed instances.</span></div>
<div class="line">        removePendingInstances(container);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update all instance world matrices.</span></div>
<div class="line">        updateInstanceTransforms();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Extract dirty source render items.</span></div>
<div class="line">        std::unordered_set&lt;HardwareInstanceData*&gt; dirtySourceItems;</div>
<div class="line">        extractDirtySourceItems(container, dirtySourceItems);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Process all dirty source render items.</span></div>
<div class="line">        std::unordered_set&lt;HardwareInstanceData*&gt; dirtyCandidates;</div>
<div class="line">        processDirtySourceItems(container, dirtySourceItems, dirtyCandidates);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Process all dirty candidates.</span></div>
<div class="line">        processCandidates(container, dirtyCandidates);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Load the render items back if they are still not instances.</span></div>
<div class="line">        loadPendingItems(container);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This method is called at the beginning of the subscene's update method().</span></div>
<div class="line"> <span class="comment">// In this method, we delete everything related to hardware instancing.</span></div>
<div class="line"> <span class="keywordtype">void</span> resetInstances(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// This method must be called before the update() method.</span></div>
<div class="line"> <span class="comment">// So there are no dirty render items.</span></div>
<div class="line">        assert(fInstancingChangeItems.empty());</div>
<div class="line">        assert(fWorldMatrixChangeItems.empty());</div>
<div class="line">        assert(fItemsPendingLoad.empty());</div>
<div class="line">        assert(fItemsPendingRemove.empty());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Collect all render items.</span></div>
<div class="line">        std::unordered_set&lt;RenderItemWrapper*&gt; renderItems;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> HardwareInstance&amp; hwInstance : fInstances) {</div>
<div class="line">            renderItems.insert(hwInstance.master-&gt;renderItem());</div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* data : hwInstance.sources) {</div>
<div class="line">                renderItems.insert(data-&gt;renderItem());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Throw away all the instancing information.</span></div>
<div class="line">        fInstancingChangeItems.clear();</div>
<div class="line">        fWorldMatrixChangeItems.clear();</div>
<div class="line">        fItemsPendingLoad.clear();</div>
<div class="line">        fItemsPendingRemove.clear();</div>
<div class="line">        fInstances.clear();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Delete the attached hardware instance data on the render item.</span></div>
<div class="line"> <span class="comment">// If the render item is already instanced, it will be re-created to</span></div>
<div class="line"> <span class="comment">// get rid of the instancing.</span></div>
<div class="line"> <span class="keywordflow">for</span>(RenderItemWrapper* renderItem : renderItems) {</div>
<div class="line">            renderItem-&gt;removeHardwareInstanceData(fSubSceneOverride, container);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Callback that a render item has been changed. We need to look at</span></div>
<div class="line"> <span class="comment">// the render item in processInstances() method later.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyInstancingChange(HardwareInstanceData* data)</div>
<div class="line">    {</div>
<div class="line">        assert(data &amp;&amp; data-&gt;renderItem());</div>
<div class="line">        fInstancingChangeItems.insert(data);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Callback that a render item's world matrix has been changed.</span></div>
<div class="line"> <span class="comment">// We need to update the instance transform in the master render item.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyWorldMatrixChange(HardwareInstanceData* data)</div>
<div class="line">    {</div>
<div class="line">        assert(data &amp;&amp; data-&gt;renderItem() &amp;&amp; data-&gt;isInstanced());</div>
<div class="line">        fWorldMatrixChangeItems.insert(data);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Callback that a render item has been changed but the change is</span></div>
<div class="line"> <span class="comment">// destructive. The render item should no longer be an instance.</span></div>
<div class="line"> <span class="comment">// e.g. shader change and/or geometry change are destructive.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyInstancingClear(HardwareInstanceData* data, <span class="keywordtype">bool</span> destroy = <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line">        assert(data &amp;&amp; data-&gt;renderItem());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Dirty the render item so it will get processed again later.</span></div>
<div class="line">        fInstancingChangeItems.insert(data);</div>
<div class="line">        fWorldMatrixChangeItems.erase(data);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// All instanced source render items are pending reloading because</span></div>
<div class="line"> <span class="comment">// the master render item has gone.</span></div>
<div class="line"> <span class="comment">// But we don't reload them immediately for performance.</span></div>
<div class="line"> <span class="keywordflow">if</span> (data-&gt;isInstanced()) {</div>
<div class="line">            fItemsPendingLoad.insert(data);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update hardware instance set.</span></div>
<div class="line"> <span class="keywordflow">if</span> (data-&gt;isMasterItem()) {</div>
<div class="line">            HardwareInstanceSet::iterator it = fInstances.find(data);</div>
<div class="line">            assert(it != fInstances.end() &amp;&amp; it-&gt;master == data);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This is a master render item. We dismiss this hardware instance or</span></div>
<div class="line"> <span class="comment">// instance candidate.</span></div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* sourceData : it-&gt;sources) {</div>
<div class="line"> <span class="comment">// Dirty the source item so it will get processed again later.</span></div>
<div class="line">                fInstancingChangeItems.insert(sourceData);</div>
<div class="line">                fWorldMatrixChangeItems.erase(sourceData);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// All instanced source render items are pending reloading because</span></div>
<div class="line"> <span class="comment">// the master render item has gone.</span></div>
<div class="line"> <span class="comment">// But we don't reload them immediately for performance.</span></div>
<div class="line"> <span class="keywordflow">if</span> (sourceData-&gt;isInstanced()) {</div>
<div class="line">                    fItemsPendingLoad.insert(sourceData);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The source render item is no longer instanced.</span></div>
<div class="line">                sourceData-&gt;clearInstanceData();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Clear the master render item's instancing.</span></div>
<div class="line"> <span class="keywordflow">if</span> (data-&gt;isInstanced()) {</div>
<div class="line"> <span class="comment">// If the render item is going to be destroyed, we don't need</span></div>
<div class="line"> <span class="comment">// to call removeAllInstances() ..</span></div>
<div class="line"> <span class="keywordflow">if</span> (!destroy) {</div>
<div class="line"> <span class="comment">// Master render item is gone. No survivals..</span></div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat = fSubSceneOverride.removeAllInstances(</div>
<div class="line">                        *data-&gt;renderItem()-&gt;wrappedItem()</div>
<div class="line">                    );</div>
<div class="line">                    MStatAssert(stat);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Schedule for reloading the master render item to</span></div>
<div class="line"> <span class="comment">// totally get rid of the instancing set up.</span></div>
<div class="line">                fItemsPendingRemove.insert(data);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            fInstances.erase(it);</div>
<div class="line">            data-&gt;clearInstanceData();</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">            HardwareInstanceData* master = data-&gt;masterData();</div>
<div class="line"> <span class="keywordflow">if</span> (master) {</div>
<div class="line"> <span class="comment">// This is a source render item. Find the master render item first.</span></div>
<div class="line">                HardwareInstanceSet::iterator it = fInstances.find(master);</div>
<div class="line">                assert(it != fInstances.end());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove this source render item from the set.</span></div>
<div class="line">                assert(it-&gt;sources.find(data) != it-&gt;sources.end());</div>
<div class="line">                it-&gt;sources.erase(data);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove the instance from the master render item.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!it-&gt;candidate) {</div>
<div class="line">                    assert(master-&gt;isInstanced() &amp;&amp; data-&gt;isInstanced());</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat = fSubSceneOverride.removeInstance(</div>
<div class="line">                        *master-&gt;renderItem()-&gt;wrappedItem(),</div>
<div class="line">                        data-&gt;instanceId()</div>
<div class="line">                    );</div>
<div class="line">                    MStatAssert(stat);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The source render item is no longer instanced.</span></div>
<div class="line">                data-&gt;clearInstanceData();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Callback that a render item is going to be destroyed.</span></div>
<div class="line"> <span class="comment">// This is similar to a destructive change but we will remove the</span></div>
<div class="line"> <span class="comment">// render item permanently.</span></div>
<div class="line"> <span class="keywordtype">void</span> notifyDestroy(HardwareInstanceData* data)</div>
<div class="line">    {</div>
<div class="line">        assert(data &amp;&amp; data-&gt;renderItem());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Same as a destructive change.</span></div>
<div class="line">        notifyInstancingClear(data, <span class="keyword">true</span> <span class="comment">/* destroy */</span> );</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The render item is going to be destroyed. We don't want to</span></div>
<div class="line"> <span class="comment">// deal with it any more.</span></div>
<div class="line">        fInstancingChangeItems.erase(data);</div>
<div class="line">        fWorldMatrixChangeItems.erase(data);</div>
<div class="line">        fItemsPendingLoad.erase(data);</div>
<div class="line">        fItemsPendingRemove.erase(data);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instancePathIndex(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>&amp; renderItem, <span class="keywordtype">int</span> hardwareInstanceIndex)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hardwareInstanceID(hardwareInstanceIndex);</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> HardwareInstance&amp; hwInstance : fInstances) {</div>
<div class="line"> <span class="keywordflow">if</span> (hwInstance.master-&gt;renderItem()-&gt;name() == renderItem.<a name="a47"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#aca2cba4630391c78dcf1a828986160da">name</a>())</div>
<div class="line">            {</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> renderItemName;</div>
<div class="line"> <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (hwInstance.master-&gt;instanceId() == hardwareInstanceID)</div>
<div class="line">                {</div>
<div class="line">                    renderItemName = hwInstance.master-&gt;renderItem()-&gt;name();</div>
<div class="line">                    found = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* sourceData : hwInstance.sources) {</div>
<div class="line"> <span class="keywordflow">if</span> (sourceData-&gt;instanceId() == hardwareInstanceID)</div>
<div class="line">                        {</div>
<div class="line">                            renderItemName = sourceData-&gt;renderItem()-&gt;name();</div>
<div class="line">                            found = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">if</span> (found)</div>
<div class="line">                {</div>
<div class="line"> <a name="_a48"></a><a class="code" href="./class_m_string_array.html">MStringArray</a> renderItemParts;</div>
<div class="line">                    renderItemName.<a name="a49"></a><a class="code" href="./class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">split</a>(<span class="charliteral">':'</span>, renderItemParts);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (renderItemParts.<a name="a50"></a><a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 1 &amp;&amp; renderItemParts[0].isUnsigned())</div>
<div class="line">                    {</div>
<div class="line"> <span class="keywordflow">return</span> renderItemParts[0].asUnsigned();</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> dump()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keyword">using namespace </span>std;</div>
<div class="line">        ostringstream tmp;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span> hwInstCounter = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> HardwareInstance&amp; hwInstance : fInstances) {</div>
<div class="line">            tmp &lt;&lt; <span class="stringliteral">"HW Instance #"</span> &lt;&lt; (hwInstCounter++) &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">            tmp &lt;&lt; <span class="charliteral">'\t'</span> &lt;&lt; <span class="stringliteral">"Master: "</span> </div>
<div class="line">                &lt;&lt; hwInstance.master-&gt;renderItem()-&gt;name().asChar()</div>
<div class="line">                &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">            tmp &lt;&lt; <span class="charliteral">'\t'</span> &lt;&lt; <span class="stringliteral">"Candidate: "</span></div>
<div class="line">                &lt;&lt; (hwInstance.candidate ? <span class="stringliteral">"true"</span> : <span class="stringliteral">"false"</span>)</div>
<div class="line">                &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">            tmp &lt;&lt; <span class="charliteral">'\t'</span> &lt;&lt; <span class="stringliteral">"Sources: "</span></div>
<div class="line">                &lt;&lt; hwInstance.sources.size()</div>
<div class="line">                &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span> sourceCounter = 0;</div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* sourceData : hwInstance.sources) {</div>
<div class="line">                tmp &lt;&lt; <span class="charliteral">'\t'</span> &lt;&lt; <span class="charliteral">'\t'</span> &lt;&lt; <span class="stringliteral">"Source #"</span> &lt;&lt; (sourceCounter++)</div>
<div class="line">                    &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; sourceData-&gt;renderItem()-&gt;name().asChar()</div>
<div class="line">                    &lt;&lt; <span class="stringliteral">" instance ID: "</span> &lt;&lt; sourceData-&gt;instanceId()</div>
<div class="line">                    &lt;&lt; endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        printf(<span class="stringliteral">"%s\n"</span>, tmp.str().c_str());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="comment">// Some render items are destroyed or have destructive changes.</span></div>
<div class="line"> <span class="comment">// This is the final step to update the underlying MRenderItem.</span></div>
<div class="line"> <span class="keywordtype">void</span> removePendingInstances(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* data : fItemsPendingRemove) {</div>
<div class="line">            data-&gt;renderItem()-&gt;unloadItem(container);</div>
<div class="line">        }</div>
<div class="line">        fItemsPendingRemove.clear();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Some render items are no longer instances. We need to re-create</span></div>
<div class="line"> <span class="comment">// the underlying MRenderItem. But we do this lazily because the render</span></div>
<div class="line"> <span class="comment">// item might become instance again.</span></div>
<div class="line"> <span class="keywordtype">void</span> loadPendingItems(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* data : fItemsPendingLoad) {</div>
<div class="line">            assert(data);</div>
<div class="line">            data-&gt;renderItem()-&gt;loadItem(fSubSceneOverride, container);</div>
<div class="line">        }</div>
<div class="line">        fItemsPendingLoad.clear();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Some render items' world matrices have been changed. We need to</span></div>
<div class="line"> <span class="comment">// update the corresponding instance matrix in the master render item.</span></div>
<div class="line"> <span class="keywordtype">void</span> updateInstanceTransforms()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* data : fWorldMatrixChangeItems) {</div>
<div class="line">            assert(data &amp;&amp; data-&gt;isInstanced());</div>
<div class="line"> <span class="keywordflow">if</span> (!data || !data-&gt;isInstanced()) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Note that if this is a master item, master equals to data.</span></div>
<div class="line">            HardwareInstanceData* master = data-&gt;masterData();</div>
<div class="line">            assert(master &amp;&amp; master-&gt;isInstanced());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Render items.</span></div>
<div class="line">            RenderItemWrapper* masterItem = master-&gt;renderItem();</div>
<div class="line">            assert(masterItem);</div>
<div class="line">            RenderItemWrapper* thisItem = data-&gt;renderItem();</div>
<div class="line">            assert(thisItem);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set instance transform.</span></div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat = fSubSceneOverride.updateInstanceTransform(</div>
<div class="line">                *masterItem-&gt;wrappedItem(),</div>
<div class="line">                data-&gt;instanceId(),</div>
<div class="line">                thisItem-&gt;worldMatrix()</div>
<div class="line">            );</div>
<div class="line">            MStatAssert(stat);</div>
<div class="line">        }</div>
<div class="line">        fWorldMatrixChangeItems.clear();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This method will find all dirty source render items based on the current</span></div>
<div class="line"> <span class="comment">// dirty render items (master + source). If a master render item is dirty,</span></div>
<div class="line"> <span class="comment">// we consider all its source render items are dirty as well.</span></div>
<div class="line"> <span class="keywordtype">void</span> extractDirtySourceItems(</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;                          container,</div>
<div class="line">        std::unordered_set&lt;HardwareInstanceData*&gt;&amp; dirtySourceItems)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* data : fInstancingChangeItems) {</div>
<div class="line">            assert(data);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This is a source item. Skip it.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!data-&gt;isMasterItem()) {</div>
<div class="line">                assert(fInstances.find(data) == fInstances.end());</div>
<div class="line">                dirtySourceItems.insert(data);</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We only deal with master render items.</span></div>
<div class="line">            HardwareInstanceSet::iterator it = fInstances.find(data);</div>
<div class="line">            assert(it != fInstances.end());</div>
<div class="line"> <span class="keywordflow">if</span> (it == fInstances.end()) <span class="keywordflow">continue</span>;</div>
<div class="line">            assert(it-&gt;master == data);</div>
<div class="line"> <span class="keywordflow">if</span> (it-&gt;master != data) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Search the source items. If the source item is different from</span></div>
<div class="line"> <span class="comment">// the changed master item, mark it as dirty.</span></div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* sourceData : it-&gt;sources) {</div>
<div class="line">                assert(sourceData);</div>
<div class="line">                dirtySourceItems.insert(sourceData);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Re-hash the master render item since it's changed.</span></div>
<div class="line">            HardwareInstance hwInstance = *it;</div>
<div class="line">            fInstances.erase(it);</div>
<div class="line"> <span class="keywordflow">if</span> (fInstances.get&lt;1&gt;().find(hwInstance.master) == fInstances.get&lt;1&gt;().end()) {</div>
<div class="line"> <span class="comment">// Insert back..</span></div>
<div class="line">                fInstances.insert(hwInstance);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// We already have a hardware instance that has the same look..</span></div>
<div class="line"> <span class="comment">// Dismiss this instance.</span></div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* sourceData : hwInstance.sources) {</div>
<div class="line">                    dirtySourceItems.insert(sourceData);</div>
<div class="line"> <span class="keywordflow">if</span> (sourceData-&gt;isInstanced()) {</div>
<div class="line">                        sourceData-&gt;renderItem()-&gt;unloadItem(container);</div>
<div class="line">                        fItemsPendingLoad.insert(sourceData);</div>
<div class="line">                    }</div>
<div class="line">                    sourceData-&gt;clearInstanceData();</div>
<div class="line">                }</div>
<div class="line">                dirtySourceItems.insert(data);</div>
<div class="line"> <span class="keywordflow">if</span> (data-&gt;isInstanced()) {</div>
<div class="line">                    data-&gt;renderItem()-&gt;unloadItem(container);</div>
<div class="line">                    fItemsPendingLoad.insert(data);</div>
<div class="line">                }</div>
<div class="line">                data-&gt;clearInstanceData();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        fInstancingChangeItems.clear();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This method goes through all dirty source render items and put them</span></div>
<div class="line"> <span class="comment">// to the correct instance group.</span></div>
<div class="line"> <span class="keywordtype">void</span> processDirtySourceItems(</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;                                container,</div>
<div class="line"> <span class="keyword">const</span> std::unordered_set&lt;HardwareInstanceData*&gt;&amp; dirtySourceItems,</div>
<div class="line">        std::unordered_set&lt;HardwareInstanceData*&gt;&amp;       dirtyCandidates)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Process all dirty source items.</span></div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* data : dirtySourceItems) {</div>
<div class="line">            assert(data &amp;&amp; !data-&gt;isMasterItem());</div>
<div class="line">            assert(fInstances.find(data) == fInstances.end());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove the dirty item since its hash (look) is changed.</span></div>
<div class="line">            HardwareInstanceData* master = data-&gt;masterData();</div>
<div class="line"> <span class="keywordflow">if</span> (master) {</div>
<div class="line"> <span class="comment">// Remove the source item from its master's source set.</span></div>
<div class="line">                HardwareInstanceSet::iterator it = fInstances.find(master);</div>
<div class="line">                assert(it != fInstances.end());</div>
<div class="line"> <span class="keywordflow">if</span> (it != fInstances.end()) {</div>
<div class="line">                    assert(it-&gt;sources.find(data) != it-&gt;sources.end());</div>
<div class="line">                    it-&gt;sources.erase(data);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Process this dirty render item.</span></div>
<div class="line"> <span class="keywordtype">bool</span> skipThisItem = <span class="keyword">false</span>;</div>
<div class="line">            HardwareInstanceSet::nth_index&lt;1&gt;::type::iterator it = </div>
<div class="line">                fInstances.get&lt;1&gt;().find(data);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (data-&gt;isInstanced()) {</div>
<div class="line"> <span class="comment">// This render item is already instanced.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it != fInstances.get&lt;1&gt;().end()) {</div>
<div class="line"> <span class="keywordflow">if</span> (data-&gt;masterData() == it-&gt;master) {</div>
<div class="line"> <span class="comment">// Both the render item and its master item are changed,</span></div>
<div class="line"> <span class="comment">// but they finally have the same look again...</span></div>
<div class="line"> <span class="comment">// Simply add the render item back and skip.</span></div>
<div class="line">                        it-&gt;sources.insert(data);</div>
<div class="line">                        skipThisItem = <span class="keyword">true</span>;</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// The instanced render item is changed. We need to</span></div>
<div class="line"> <span class="comment">// remove it from its master.</span></div>
<div class="line">                        leaveInstance(data, container);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// The instanced render item is changed. We need to</span></div>
<div class="line"> <span class="comment">// remove it from its master.</span></div>
<div class="line">                    leaveInstance(data, container);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!skipThisItem) {</div>
<div class="line">                assert(!data-&gt;isInstanced());</div>
<div class="line"> <span class="keywordflow">if</span> (it != fInstances.get&lt;1&gt;().end()) {</div>
<div class="line"> <span class="keywordflow">if</span> (it-&gt;candidate) {</div>
<div class="line"> <span class="comment">// There is a candidate hardware instance. Join</span></div>
<div class="line"> <span class="comment">// the candidate.</span></div>
<div class="line">                        joinCandidate(it-&gt;master, data);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We will review the candidate later.</span></div>
<div class="line">                        dirtyCandidates.insert(it-&gt;master);</div>
<div class="line">                    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// There is already a master render item that has the</span></div>
<div class="line"> <span class="comment">// same look.</span></div>
<div class="line">                        joinInstance(it-&gt;master, data, container);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// There are no instances or candidates that have the</span></div>
<div class="line"> <span class="comment">// same look. We create a new candidate.</span></div>
<div class="line">                    newCandidate(data);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This method goes through all instance candidates and make them instances if</span></div>
<div class="line"> <span class="comment">// the number of source render items meets the threshold requirement.</span></div>
<div class="line"> <span class="keywordtype">void</span> processCandidates(</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;                                container,</div>
<div class="line"> <span class="keyword">const</span> std::unordered_set&lt;HardwareInstanceData*&gt;&amp; dirtyCandidates)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* data : dirtyCandidates) {</div>
<div class="line">            assert(data);</div>
<div class="line"></div>
<div class="line">            HardwareInstanceSet::iterator it = fInstances.find(data);</div>
<div class="line">            assert(it != fInstances.end());</div>
<div class="line"> <span class="keywordflow">if</span> (it == fInstances.end()) <span class="keywordflow">continue</span>;</div>
<div class="line">            assert(it-&gt;candidate &amp;&amp; data == it-&gt;master);</div>
<div class="line"> <span class="keywordflow">if</span> (!it-&gt;candidate || data != it-&gt;master) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If the number of master and source items in the candidate does</span></div>
<div class="line"> <span class="comment">// not meet the threshold requirement, skip this candidate.</span></div>
<div class="line"> <span class="keywordflow">if</span> (it-&gt;sources.size() + 1 &lt; Config::hardwareInstancingThreshold()) {</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove the candidate.</span></div>
<div class="line">            HardwareInstance hwInstance = *it;</div>
<div class="line">            fInstances.erase(it);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create a new hardware instance.</span></div>
<div class="line">            assert(hwInstance.master &amp;&amp; !hwInstance.master-&gt;isInstanced());</div>
<div class="line">            hwInstance.master-&gt;clearInstanceData();</div>
<div class="line">            newInstance(hwInstance.master, container);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Join the remaining instances.</span></div>
<div class="line"> <span class="keywordflow">for</span>(HardwareInstanceData* data : hwInstance.sources) {</div>
<div class="line">                assert(data &amp;&amp; !data-&gt;isInstanced() &amp;&amp; !data-&gt;isMasterItem());</div>
<div class="line">                data-&gt;clearInstanceData();</div>
<div class="line">                joinInstance(hwInstance.master, data, container);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> newCandidate(HardwareInstanceData* source)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// source must be a not-yet-instanced item.</span></div>
<div class="line">        assert(source);</div>
<div class="line">        assert(!source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>
<div class="line"> <span class="keywordflow">if</span> (source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The master of the candidate is the source.</span></div>
<div class="line">        source-&gt;setupCandidate(source);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create a new candidate.</span></div>
<div class="line">        HardwareInstance hwInstance;</div>
<div class="line">        hwInstance.master    = source;</div>
<div class="line">        hwInstance.candidate = <span class="keyword">true</span>;</div>
<div class="line">        fInstances.insert(hwInstance);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> joinCandidate(HardwareInstanceData* master,</div>
<div class="line">                       HardwareInstanceData* source)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// master must be an not instanced master render item.</span></div>
<div class="line">        assert(master);</div>
<div class="line">        assert(!master-&gt;isInstanced() &amp;&amp; master-&gt;isMasterItem());</div>
<div class="line"> <span class="keywordflow">if</span> (master-&gt;isInstanced() || !master-&gt;isMasterItem()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We should know the master render item.</span></div>
<div class="line">        HardwareInstanceSet::iterator it = fInstances.find(master);</div>
<div class="line">        assert(it != fInstances.end());</div>
<div class="line"> <span class="keywordflow">if</span> (it == fInstances.end()) <span class="keywordflow">return</span>;</div>
<div class="line">        assert(it-&gt;master == master &amp;&amp; it-&gt;candidate);</div>
<div class="line"> <span class="keywordflow">if</span> (it-&gt;master != master || !it-&gt;candidate) <span class="keywordflow">return</span>;</div>
<div class="line">        assert(it-&gt;sources.find(source) == it-&gt;sources.end());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// source must be a not-yet-instanced item.</span></div>
<div class="line">        assert(source);</div>
<div class="line">        assert(!source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>
<div class="line"> <span class="keywordflow">if</span> (source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set up the remaining data.</span></div>
<div class="line">        source-&gt;setupCandidate(master);</div>
<div class="line">        it-&gt;sources.insert(source);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> newInstance(HardwareInstanceData* source,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;   container)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// source must be a not-yet-instanced item.</span></div>
<div class="line">        assert(source);</div>
<div class="line">        assert(!source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>
<div class="line"> <span class="keywordflow">if</span> (source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Render items.</span></div>
<div class="line">        RenderItemWrapper* sourceItem = source-&gt;renderItem();</div>
<div class="line">        assert(sourceItem);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Make sure the master render item is loaded.</span></div>
<div class="line">        sourceItem-&gt;loadItem(fSubSceneOverride, container);</div>
<div class="line">        fItemsPendingLoad.erase(source);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Make the source render item as a master item.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instanceId = fSubSceneOverride.addInstanceTransform(</div>
<div class="line">            *sourceItem-&gt;wrappedItem(),</div>
<div class="line">            sourceItem-&gt;worldMatrix()</div>
<div class="line">        );</div>
<div class="line">        assert(instanceId &gt; 0);</div>
<div class="line"> <span class="keywordflow">if</span> (instanceId == 0) <span class="keywordflow">return</span>;    <span class="comment">// failure?</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// The master of the candidate is the source.</span></div>
<div class="line">        source-&gt;setupInstance(source, instanceId);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create a new instance.</span></div>
<div class="line">        HardwareInstance hwInstance;</div>
<div class="line">        hwInstance.master    = source;</div>
<div class="line">        hwInstance.candidate = <span class="keyword">false</span>;</div>
<div class="line">        fInstances.insert(hwInstance);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> joinInstance(HardwareInstanceData* master, </div>
<div class="line">                      HardwareInstanceData* source,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;   container)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// master must be an instanced master render item.</span></div>
<div class="line">        assert(master);</div>
<div class="line">        assert(master-&gt;isInstanced() &amp;&amp; master-&gt;isMasterItem());</div>
<div class="line"> <span class="keywordflow">if</span> (!master-&gt;isInstanced() || !master-&gt;isMasterItem()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We should know the master render item.</span></div>
<div class="line">        HardwareInstanceSet::iterator it = fInstances.find(master);</div>
<div class="line">        assert(it != fInstances.end());</div>
<div class="line"> <span class="keywordflow">if</span> (it == fInstances.end()) <span class="keywordflow">return</span>;</div>
<div class="line">        assert(it-&gt;master == master &amp;&amp; !it-&gt;candidate);</div>
<div class="line"> <span class="keywordflow">if</span> (it-&gt;master != master || it-&gt;candidate) <span class="keywordflow">return</span>;</div>
<div class="line">        assert(it-&gt;sources.find(source) == it-&gt;sources.end());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// source must be a not-yet-instanced item.</span></div>
<div class="line">        assert(source);</div>
<div class="line">        assert(!source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>
<div class="line"> <span class="keywordflow">if</span> (source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Render items.</span></div>
<div class="line">        RenderItemWrapper* masterItem = master-&gt;renderItem();</div>
<div class="line">        assert(masterItem);</div>
<div class="line">        RenderItemWrapper* sourceItem = source-&gt;renderItem();</div>
<div class="line">        assert(sourceItem);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add a new hardware instance to the master render item.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instanceId = fSubSceneOverride.addInstanceTransform(</div>
<div class="line">            *masterItem-&gt;wrappedItem(),</div>
<div class="line">            sourceItem-&gt;worldMatrix()</div>
<div class="line">        );</div>
<div class="line">        assert(instanceId &gt; 0);</div>
<div class="line"> <span class="keywordflow">if</span> (instanceId == 0) <span class="keywordflow">return</span>;    <span class="comment">// failure?</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Delete the source render item. </span></div>
<div class="line">        sourceItem-&gt;unloadItem(container);</div>
<div class="line">        fItemsPendingLoad.erase(source);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set up the remaining data.</span></div>
<div class="line">        source-&gt;setupInstance(master, instanceId);</div>
<div class="line">        it-&gt;sources.insert(source);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> leaveInstance(HardwareInstanceData* source,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;   container)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// source must be an instanced item but not a master.</span></div>
<div class="line">        assert(source);</div>
<div class="line">        assert(source-&gt;isInstanced() &amp;&amp; !source-&gt;isMasterItem());</div>
<div class="line"> <span class="keywordflow">if</span> (!source-&gt;isInstanced() || source-&gt;isMasterItem()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        HardwareInstanceData* master = source-&gt;masterData();</div>
<div class="line">        assert(master);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Render items.</span></div>
<div class="line">        RenderItemWrapper* masterItem = master-&gt;renderItem();</div>
<div class="line">        assert(masterItem);</div>
<div class="line">        RenderItemWrapper* sourceItem = source-&gt;renderItem();</div>
<div class="line">        assert(sourceItem);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remove the hardware instance from the master render item.</span></div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> stat = fSubSceneOverride.removeInstance(</div>
<div class="line">            *masterItem-&gt;wrappedItem(),</div>
<div class="line">            source-&gt;instanceId()</div>
<div class="line">        );</div>
<div class="line">        assert(stat == MS::kSuccess);</div>
<div class="line"> <span class="keywordflow">if</span> (!stat) <span class="keywordflow">return</span>;  <span class="comment">// failure?</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Reload the source render item.</span></div>
<div class="line">        sourceItem-&gt;loadItem(fSubSceneOverride, container);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set up the remaining data.</span></div>
<div class="line">        source-&gt;clearInstanceData();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This function object returns the same hash code for</span></div>
<div class="line"> <span class="comment">// render items that have identical look.</span></div>
<div class="line"> <span class="comment">// We ignore the render item's name and its world matrix.</span></div>
<div class="line"> <span class="keyword">struct </span>VisHash : std::unary_function&lt;HardwareInstanceData*, std::size_t&gt;</div>
<div class="line">    {</div>
<div class="line">        std::size_t operator()(<span class="keyword">const</span> HardwareInstanceData* <span class="keyword">const</span>&amp; data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">            std::size_t seed = 0;</div>
<div class="line"> <span class="keyword">const</span> RenderItemWrapper* w = data-&gt;renderItem();</div>
<div class="line">            assert(w);</div>
<div class="line">            boost::hash_combine(seed, w-&gt;type());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;primitive());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;userData().get());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;indices().get());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;positions().get());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;normals().get());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;uvs().get());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;enabled());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;drawMode());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;depthPriority());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;excludedFromPostEffects());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;castsShadows());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;receivesShadows());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;shader().get());</div>
<div class="line">            boost::hash_combine(seed, w-&gt;isCompatibleWithMayaInstancer());</div>
<div class="line"> <span class="keywordflow">return</span> seed;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This function object returns true if two render items have</span></div>
<div class="line"> <span class="comment">// identical look.</span></div>
<div class="line"> <span class="comment">// We ignore the render item's name and its world matrix.</span></div>
<div class="line"> <span class="keyword">struct </span>VisEqualTo : std::binary_function&lt;HardwareInstanceData*, HardwareInstanceData*, bool&gt;</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> HardwareInstanceData* <span class="keyword">const</span>&amp; xData,</div>
<div class="line"> <span class="keyword">const</span> HardwareInstanceData* <span class="keyword">const</span>&amp; yData)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keyword">const</span> RenderItemWrapper* x = xData-&gt;renderItem();</div>
<div class="line"> <span class="keyword">const</span> RenderItemWrapper* y = yData-&gt;renderItem();</div>
<div class="line">            assert(x &amp;&amp; y);</div>
<div class="line"> <span class="keywordflow">return</span> x-&gt;type()                   == y-&gt;type() &amp;&amp;</div>
<div class="line">                x-&gt;primitive()                 == y-&gt;primitive() &amp;&amp;</div>
<div class="line">                x-&gt;userData().get()            == y-&gt;userData().get() &amp;&amp;</div>
<div class="line">                x-&gt;indices().get()             == y-&gt;indices().get() &amp;&amp;</div>
<div class="line">                x-&gt;positions().get()           == y-&gt;positions().get() &amp;&amp;</div>
<div class="line">                x-&gt;normals().get()             == y-&gt;normals().get() &amp;&amp;</div>
<div class="line">                x-&gt;uvs().get()                 == y-&gt;uvs().get() &amp;&amp;</div>
<div class="line">                x-&gt;enabled()                   == y-&gt;enabled() &amp;&amp;</div>
<div class="line">                x-&gt;drawMode()                  == y-&gt;drawMode() &amp;&amp;</div>
<div class="line">                x-&gt;depthPriority()             == y-&gt;depthPriority() &amp;&amp;</div>
<div class="line">                x-&gt;excludedFromPostEffects()   == y-&gt;excludedFromPostEffects() &amp;&amp;</div>
<div class="line">                x-&gt;castsShadows()              == y-&gt;castsShadows() &amp;&amp;</div>
<div class="line">                x-&gt;receivesShadows()           == y-&gt;receivesShadows() &amp;&amp;</div>
<div class="line">                x-&gt;shader().get()              == y-&gt;shader().get();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Each HardwareInstance stands for a group of render items that</span></div>
<div class="line"> <span class="comment">// have the same appearance.</span></div>
<div class="line"> <span class="comment">// If the group is instanced, only the master render item has the</span></div>
<div class="line"> <span class="comment">// actual MRenderItem. Other render items have no MRenderItems.</span></div>
<div class="line"> <span class="comment">// Otherwise, the group is an instance candidate. The master and </span></div>
<div class="line"> <span class="comment">// other render items behave normal.</span></div>
<div class="line"> <span class="keyword">struct </span>HardwareInstance</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// The master render item.</span></div>
<div class="line">        HardwareInstanceData* master;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// True if this group is an instance candidate (not-yet-instanced).</span></div>
<div class="line"> <span class="comment">// Otherwise, this group is hardware instanced.</span></div>
<div class="line"> <span class="keyword">mutable</span> <span class="keywordtype">bool</span> candidate;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Other render items that have the same appearance as the</span></div>
<div class="line"> <span class="comment">// master render item.</span></div>
<div class="line"> <span class="keyword">mutable</span> std::unordered_set&lt;HardwareInstanceData*&gt; sources;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> boost::multi_index_container&lt;</div>
<div class="line">        HardwareInstance,</div>
<div class="line">        boost::multi_index::indexed_by&lt;</div>
<div class="line"> <span class="comment">// Index 0: The pointer of hardware instance data.</span></div>
<div class="line">            boost::multi_index::hashed_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_MEMBER(HardwareInstance,HardwareInstanceData*,master)</div>
<div class="line">            &gt;,</div>
<div class="line"> <span class="comment">// Index 1: The render item visual hash.</span></div>
<div class="line">            boost::multi_index::hashed_non_unique&lt;</div>
<div class="line">                BOOST_MULTI_INDEX_MEMBER(HardwareInstance,HardwareInstanceData*,master),</div>
<div class="line">                VisHash,</div>
<div class="line">                VisEqualTo</div>
<div class="line">            &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt; HardwareInstanceSet;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The associated subscene.</span></div>
<div class="line">    SubSceneOverride&amp;   fSubSceneOverride;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Keeps all hardware instancing information.</span></div>
<div class="line">    HardwareInstanceSet fInstances;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Helper structures to track render item changes.</span></div>
<div class="line"> <span class="comment">// They should be empty after processInstances() method.</span></div>
<div class="line">    std::unordered_set&lt;HardwareInstanceData*&gt; fInstancingChangeItems;</div>
<div class="line">    std::unordered_set&lt;HardwareInstanceData*&gt; fWorldMatrixChangeItems;</div>
<div class="line">    std::unordered_set&lt;HardwareInstanceData*&gt; fItemsPendingLoad;</div>
<div class="line">    std::unordered_set&lt;HardwareInstanceData*&gt; fItemsPendingRemove;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The following methods have dependency on HardwareInstanceManagerImpl.</span></div>
<div class="line"><span class="keywordtype">void</span> HardwareInstanceData::notifyInstancingChange()</div>
<div class="line">{</div>
<div class="line">    fManager-&gt;notifyInstancingChange(<span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> HardwareInstanceData::notifyInstancingClear()</div>
<div class="line">{</div>
<div class="line">    fManager-&gt;notifyInstancingClear(<span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> HardwareInstanceData::notifyWorldMatrixChange()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Only need to update instance transform.</span></div>
<div class="line"> <span class="keywordflow">if</span> (isInstanced()) {</div>
<div class="line">        fManager-&gt;notifyWorldMatrixChange(<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> HardwareInstanceData::notifyDestroy()</div>
<div class="line">{</div>
<div class="line">    fManager-&gt;notifyDestroy(<span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS ModelCallbacks</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class manages model-level callbacks.</span></div>
<div class="line"><span class="comment">// gpuCache node-level callbacks are registered in GPUCache::SubSceneOverride.</span></div>
<div class="line"><span class="keyword">class </span>ModelCallbacks</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">static</span> ModelCallbacks&amp; getInstance()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Singleton</span></div>
<div class="line"> <span class="keyword">static</span> ModelCallbacks sSingleton;</div>
<div class="line"> <span class="keywordflow">return</span> sSingleton;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ModelCallbacks()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Initialize DAG object attributes that affect display appearance</span></div>
<div class="line"> <span class="comment">// of their descendant shapes.</span></div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"visibility"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"lodVisibility"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"intermediateObject"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"template"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"renderLayerInfo"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"renderLayerId"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"renderLayerRenderable"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"renderLayerColor"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"drawOverride"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"overrideDisplayType"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"overrideLevelOfDetail"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"overrideShading"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"overrideTexturing"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"overridePlayback"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"overrideEnabled"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"overrideVisibility"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"overrideColor"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"useObjectColor"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"objectColor"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"ghosting"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"castsShadows"</span>);</div>
<div class="line">        fAttrsAffectAppearance.insert(<span class="stringliteral">"receiveShadows"</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Hook model/scene/DG/event callbacks.</span></div>
<div class="line">        fMayaExitingCallback = <a name="a51"></a><a class="code" href="./class_m_scene_message.html#a44771b834e9a0ad7291ecdcc880106fe">MSceneMessage::addCallback</a>(</div>
<div class="line"> <a name="a52"></a><a class="code" href="./class_m_scene_message.html#a4f09127c805cc1f5ee20e67db7b45efaa1efff7ad75eeef5a2ac9e3c0e890dbd0">MSceneMessage::kMayaExiting</a>, MayaExitingCallback, NULL);</div>
<div class="line">        fSelectionChangedCallback = <a name="a53"></a><a class="code" href="./class_m_model_message.html#ac4dd423a333cf2a97157987532b36675">MModelMessage::addCallback</a>(</div>
<div class="line"> <a name="a54"></a><a class="code" href="./class_m_model_message.html#a4f09127c805cc1f5ee20e67db7b45efaa256632550aa8e279dac1d41927c59d84">MModelMessage::kActiveListModified</a>, SelectionChangedCallback, <span class="keyword">this</span>);</div>
<div class="line">        fTimeChangeCallback = <a name="a55"></a><a class="code" href="./class_m_d_g_message.html#a0cf2d487672abd947a5abc89ac788789">MDGMessage::addTimeChangeCallback</a>(</div>
<div class="line">            TimeChangeCallback, <span class="keyword">this</span>);</div>
<div class="line">        fRenderLayerChangeCallback = <a name="a56"></a><a class="code" href="./class_m_event_message.html#a8d22c58b90484867755273c2f7ffc6ec">MEventMessage::addEventCallback</a>(</div>
<div class="line"> <span class="stringliteral">"renderLayerChange"</span>, RenderLayerChangeCallback, <span class="keyword">this</span>);</div>
<div class="line">        fRenderLayerManagerChangeCallback = <a class="code" href="./class_m_event_message.html#a8d22c58b90484867755273c2f7ffc6ec">MEventMessage::addEventCallback</a>(</div>
<div class="line"> <span class="stringliteral">"renderLayerManagerChange"</span>, RenderLayerChangeCallback, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Trigger the callback to initialize the selection list.</span></div>
<div class="line">        selectionChanged();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~ModelCallbacks()</div>
<div class="line">    {</div>
<div class="line"> <a name="a57"></a><a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fMayaExitingCallback);</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fSelectionChangedCallback);</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fTimeChangeCallback);</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fRenderLayerChangeCallback);</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fRenderLayerManagerChangeCallback);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ModelCallbacks(<span class="keyword">const</span> ModelCallbacks&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    ModelCallbacks&amp; operator=(<span class="keyword">const</span> ModelCallbacks&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> registerSubSceneOverride(<span class="keyword">const</span> ShapeNode* shapeNode, SubSceneOverride* subSceneOverride)</div>
<div class="line">    {</div>
<div class="line">        assert(shapeNode);</div>
<div class="line"> <span class="keywordflow">if</span> (!shapeNode) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        assert(subSceneOverride);</div>
<div class="line"> <span class="keywordflow">if</span> (!subSceneOverride) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Register the MPxSubSceneOverride to receive callbacks.</span></div>
<div class="line">        fShapeNodes.insert(std::make_pair(shapeNode, subSceneOverride));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> deregisterSubSceneOverride(<span class="keyword">const</span> ShapeNode* shapeNode)</div>
<div class="line">    {</div>
<div class="line">        assert(shapeNode);</div>
<div class="line"> <span class="keywordflow">if</span> (!shapeNode) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Deregister the MPxSubSceneOverride.</span></div>
<div class="line">        fShapeNodes.erase(shapeNode);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Detect selection change and dirty SubSceneOverride.</span></div>
<div class="line"> <span class="keywordtype">void</span> selectionChanged()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Retrieve the current selection list.</span></div>
<div class="line"> <a class="code" href="./class_m_selection_list.html">MSelectionList</a> list;</div>
<div class="line"> <a name="a58"></a><a class="code" href="./class_m_global.html#a6d81d38246555884897fb153c93aaf42">MGlobal::getActiveSelectionList</a>(list);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Find all selected gpuCache nodes.</span></div>
<div class="line">        ShapeNodeNameMap currentSelection;</div>
<div class="line"></div>
<div class="line"> <a name="_a59"></a><a class="code" href="./class_m_dag_path.html">MDagPath</a>   dagPath;</div>
<div class="line"> <a name="_a60"></a><a class="code" href="./class_m_it_dag.html">MItDag</a>     dagIt;</div>
<div class="line"> <a name="_a61"></a><a class="code" href="./class_m_fn_dag_node.html">MFnDagNode</a> dagNode;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0, size = list.<a name="a62"></a><a class="code" href="./class_m_selection_list.html#a99dd6a54b909ede1d11702fe58977e2a">length</a>(); i &lt; size; i++) {</div>
<div class="line"> <span class="keywordflow">if</span> (list.<a name="a63"></a><a class="code" href="./class_m_selection_list.html#a16dda1a34d5f10be257d8421ac6deabd">getDagPath</a>(i, dagPath) &amp;&amp; dagPath.<a name="a64"></a><a class="code" href="./class_m_dag_path.html#a095ae34296e81703965265a42ee783ca">isValid</a>()) {</div>
<div class="line"> <span class="comment">// Iterate the DAG to find descendant gpuCache nodes.</span></div>
<div class="line">                dagIt.<a name="a65"></a><a class="code" href="./class_m_it_dag.html#ac734f26ff1c92ecec3572a31f5e4435c">reset</a>(dagPath, <a name="a66"></a><a class="code" href="./class_m_it_dag.html#a1545968b4f810358b53ae9844bce6bd1a6e92a8757afce03be51397f0b518f4c5">MItDag::kDepthFirst</a>, <a name="a67"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ad409ef3c9033402174590389a6ce18ea">MFn::kPluginShape</a>);</div>
<div class="line"> <span class="keywordflow">for</span> (; !dagIt.<a name="a68"></a><a class="code" href="./class_m_it_dag.html#a8b6dbf6fbab6f4e7bf50a309124cbf4c">isDone</a>(); dagIt.<a name="a69"></a><a class="code" href="./class_m_it_dag.html#a73616f002814b8abe6d921db72d7a496">next</a>()) {</div>
<div class="line"> <span class="keywordflow">if</span> (dagNode.<a name="a70"></a><a class="code" href="./class_m_fn_dag_node.html#a6b2301b53683a8e8f56dd0b9cb088b0f">setObject</a>(dagIt.<a name="a71"></a><a class="code" href="./class_m_it_dag.html#afc1c0d71245e763fc566fc1d67ab06ae">currentItem</a>()) &amp;&amp; dagNode.<a name="a72"></a><a class="code" href="./class_m_fn_dependency_node.html#a1d0bbd4d50dae591f8e003c0aedc8135">typeId</a>() == ShapeNode::id) {</div>
<div class="line"> <span class="keyword">const</span> ShapeNode* shapeNode = (<span class="keyword">const</span> ShapeNode*)dagNode.<a name="a73"></a><a class="code" href="./class_m_fn_dependency_node.html#a4f2c53c9d1dcf25a6462c70fb25aead1">userNode</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (shapeNode) {</div>
<div class="line">                            currentSelection.insert(std::make_pair(dagIt.<a name="a74"></a><a class="code" href="./class_m_it_dag.html#ac4b316731c4019c927aa63731d4749e8">fullPathName</a>(), shapeNode));</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check Active -&gt; Dormant</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> ShapeNodeNameMap::value_type&amp; val : fLastSelection) {</div>
<div class="line"> <span class="keywordflow">if</span> (currentSelection.find(val.first) == currentSelection.end()) {</div>
<div class="line">                ShapeNodeSubSceneMap::iterator it = fShapeNodes.find(val.second);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fShapeNodes.end() &amp;&amp; it-&gt;second) {</div>
<div class="line">                    it-&gt;second-&gt;dirtyEverything();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check Dormant -&gt; Active</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> ShapeNodeNameMap::value_type&amp; val : currentSelection) {</div>
<div class="line"> <span class="keywordflow">if</span> (fLastSelection.find(val.first) == fLastSelection.end()) {</div>
<div class="line">                ShapeNodeSubSceneMap::iterator it = fShapeNodes.find(val.second);</div>
<div class="line"> <span class="keywordflow">if</span> (it != fShapeNodes.end() &amp;&amp; it-&gt;second) {</div>
<div class="line">                    it-&gt;second-&gt;dirtyEverything();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fLastSelection.swap(currentSelection);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Detect time change and dirty SubSceneOverride.</span></div>
<div class="line"> <span class="keywordtype">void</span> timeChanged()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(ShapeNodeSubSceneMap::value_type&amp; val : fShapeNodes) {</div>
<div class="line">            val.second-&gt;dirtyVisibility();   <span class="comment">// visibility animation</span></div>
<div class="line">            val.second-&gt;dirtyWorldMatrix();  <span class="comment">// xform animation</span></div>
<div class="line">            val.second-&gt;dirtyStreams();      <span class="comment">// vertex animation</span></div>
<div class="line">            val.second-&gt;dirtyMaterials();    <span class="comment">// material animation</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Detect render layer change and dirty SubSceneOverride.</span></div>
<div class="line"> <span class="keywordtype">void</span> renderLayerChanged()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(ShapeNodeSubSceneMap::value_type&amp; val : fShapeNodes) {</div>
<div class="line">            val.second-&gt;dirtyEverything();   <span class="comment">// render layer change is destructive</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> affectAppearance(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; attr)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="keywordflow">return</span> (fAttrsAffectAppearance.find(attr) != fAttrsAffectAppearance.cend());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> MayaExitingCallback(<span class="keywordtype">void</span>* clientData)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Free VP2.0 buffers on exit.</span></div>
<div class="line">        BuffersCache::getInstance().clear();</div>
<div class="line">        UnitBoundingBox::clear();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> SelectionChangedCallback(<span class="keywordtype">void</span>* clientData)</div>
<div class="line">    {</div>
<div class="line">        assert(clientData);</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>ModelCallbacks*<span class="keyword">&gt;</span>(clientData)-&gt;selectionChanged();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> TimeChangeCallback(<a name="_a75"></a><a class="code" href="./class_m_time.html">MTime</a>&amp; time, <span class="keywordtype">void</span>* clientData)</div>
<div class="line">    {</div>
<div class="line">        assert(clientData);</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>ModelCallbacks*<span class="keyword">&gt;</span>(clientData)-&gt;timeChanged();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> RenderLayerChangeCallback(<span class="keywordtype">void</span>* clientData)</div>
<div class="line">    {</div>
<div class="line">        assert(clientData);</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>ModelCallbacks*<span class="keyword">&gt;</span>(clientData)-&gt;renderLayerChanged();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> fMayaExitingCallback;</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> fSelectionChangedCallback;</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> fTimeChangeCallback;</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> fRenderLayerChangeCallback;</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> fRenderLayerManagerChangeCallback;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> std::unordered_map&lt;MString,const ShapeNode*,MStringHash&gt; ShapeNodeNameMap;</div>
<div class="line"> <span class="keyword">typedef</span> std::unordered_map&lt;const ShapeNode*,SubSceneOverride*&gt;   ShapeNodeSubSceneMap;</div>
<div class="line"></div>
<div class="line">    ShapeNodeNameMap     fLastSelection;</div>
<div class="line">    ShapeNodeSubSceneMap fShapeNodes;</div>
<div class="line"></div>
<div class="line">    std::unordered_set&lt;MString, MStringHash&gt; fAttrsAffectAppearance;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// Callbacks</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Instance Changed Callback</span></div>
<div class="line"><span class="keywordtype">void</span> InstanceChangedCallback(<a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; child, <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; parent, <span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line">    assert(clientData);</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>SubSceneOverride*<span class="keyword">&gt;</span>(clientData)-&gt;dirtyEverything();</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>SubSceneOverride*<span class="keyword">&gt;</span>(clientData)-&gt;resetDagPaths();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// World Matrix Changed Callback</span></div>
<div class="line"><span class="keywordtype">void</span> WorldMatrixChangedCallback(<a name="_a76"></a><a class="code" href="./class_m_object.html">MObject</a>&amp; transformNode,</div>
<div class="line">    MDagMessage::MatrixModifiedFlags&amp; modified,</div>
<div class="line"> <span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line">    assert(clientData);</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>SubSceneOverride*<span class="keyword">&gt;</span>(clientData)-&gt;dirtyWorldMatrix();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Parent Add/Remove Callback</span></div>
<div class="line"><span class="keywordtype">void</span> ParentChangedCallback(<a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; child, <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; parent, <span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// We register node dirty callbacks on all transform parents/ancestors.</span></div>
<div class="line"> <span class="comment">// If the parent is changed, we will have to re-register all callbacks.</span></div>
<div class="line">    assert(clientData);</div>
<div class="line"> <span class="comment">// Clear the callbacks on parents.</span></div>
<div class="line"> <span class="keyword">static_cast&lt;</span>SubSceneOverride*<span class="keyword">&gt;</span>(clientData)-&gt;clearNodeDirtyCallbacks();</div>
<div class="line"> <span class="comment">// Dirty the render items so we re-register callbacks again in update().</span></div>
<div class="line"> <span class="keyword">static_cast&lt;</span>SubSceneOverride*<span class="keyword">&gt;</span>(clientData)-&gt;dirtyEverything();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Node Dirty Callback</span></div>
<div class="line"><span class="keywordtype">void</span> NodeDirtyCallback(<a class="code" href="./class_m_object.html">MObject</a>&amp; node, <a class="code" href="./class_m_plug.html">MPlug</a>&amp; plug, <span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// One of the parent/ancestor has changed.</span></div>
<div class="line"> <span class="comment">// Dirty the SubSceneOverride if the attribute will affect</span></div>
<div class="line"> <span class="comment">// the appearance of the gpuCache shape.</span></div>
<div class="line">    assert(clientData);</div>
<div class="line"> <a name="_a77"></a><a class="code" href="./class_m_fn_attribute.html">MFnAttribute</a> attr(plug.<a name="a78"></a><a class="code" href="./class_m_plug.html#a240c26abf3ba7645371553cb130691fa">attribute</a>());</div>
<div class="line"> <span class="keywordflow">if</span> (ModelCallbacks::getInstance().affectAppearance(attr.name())) {</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>SubSceneOverride*<span class="keyword">&gt;</span>(clientData)-&gt;dirtyEverything();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="./namespace_m_h_w_render.html">MHWRender</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::HardwareInstanceManager</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class resolve the dependency problem between RenderItemWrapper and</span></div>
<div class="line"><span class="comment">// GPUCache::SubSceneOverride.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::HardwareInstanceManager</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HardwareInstanceManager(SubSceneOverride&amp; subSceneOverride)</div>
<div class="line">        : fImpl(new HardwareInstanceManagerImpl(subSceneOverride))</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~HardwareInstanceManager()</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    HardwareInstanceManager(<span class="keyword">const</span> HardwareInstanceManager&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    HardwareInstanceManager&amp; operator=(<span class="keyword">const</span> HardwareInstanceManager&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> processInstances(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        fImpl-&gt;processInstances(container);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> resetInstances(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        fImpl-&gt;resetInstances(container);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> installHardwareInstanceData(RenderItemWrapper::Ptr&amp; renderItem)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!renderItem-&gt;hasHardwareInstanceData()) {</div>
<div class="line">            std::shared_ptr&lt;HardwareInstanceData&gt; data(</div>
<div class="line"> <span class="keyword">new</span> HardwareInstanceData(fImpl.get(), renderItem.get())</div>
<div class="line">            );</div>
<div class="line">            renderItem-&gt;installHardwareInstanceData(data);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instancePathIndex(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>&amp; renderItem, <span class="keywordtype">int</span> hardwareInstanceIndex)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> fImpl-&gt;instancePathIndex(renderItem, hardwareInstanceIndex);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;HardwareInstanceManagerImpl&gt; fImpl;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::HierarchyStat</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class contains the analysis result of the sub-node hierarchy.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::HierarchyStat</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> std::shared_ptr&lt;const HierarchyStat&gt; Ptr;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// This is the status of a sub-node and its descendants.</span></div>
<div class="line"> <span class="keyword">struct </span>SubNodeStat</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// False if the sub-node and all its descendants have no visibility animation.</span></div>
<div class="line"> <span class="keywordtype">bool</span>   isVisibilityAnimated;</div>
<div class="line"> <span class="comment">// False if the sub-node and all its descendants have no xform animation.</span></div>
<div class="line"> <span class="keywordtype">bool</span>   isXformAnimated;</div>
<div class="line"> <span class="comment">// False if the sub-node and all its descendants have no vertices animation.</span></div>
<div class="line"> <span class="keywordtype">bool</span>   isShapeAnimated;</div>
<div class="line"> <span class="comment">// False if the sub-node and all its descendants have no diffuse color animation.</span></div>
<div class="line"> <span class="keywordtype">bool</span>   isDiffuseColorAnimated;</div>
<div class="line"> <span class="comment">// The next sub-node id if we prune at this sub-node. (depth first, preorder)</span></div>
<div class="line"> <span class="keywordtype">size_t</span> nextSubNodeIndex;</div>
<div class="line"> <span class="comment">// The next shape sub-node id if we prune at this sub-node. (depth first, preorder)</span></div>
<div class="line"> <span class="keywordtype">size_t</span> nextShapeSubNodeIndex;</div>
<div class="line"></div>
<div class="line">        SubNodeStat()</div>
<div class="line">            : isVisibilityAnimated(false),</div>
<div class="line">              isXformAnimated(false),</div>
<div class="line">              isShapeAnimated(false),</div>
<div class="line">              isDiffuseColorAnimated(false),</div>
<div class="line">              nextSubNodeIndex(0),</div>
<div class="line">              nextShapeSubNodeIndex(0)</div>
<div class="line">        {}</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    ~HierarchyStat() {}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> setStat(<span class="keywordtype">size_t</span> subNodeIndex, SubNodeStat&amp; stat)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (subNodeIndex &gt;= fStats.size()) {</div>
<div class="line">            fStats.resize(subNodeIndex+1);</div>
<div class="line">        }</div>
<div class="line">        fStats[subNodeIndex] = stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> SubNodeStat&amp; stat(<span class="keywordtype">size_t</span> subNodeIndex)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{ <span class="keywordflow">return</span> fStats[subNodeIndex]; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    HierarchyStat() {}</div>
<div class="line">    HierarchyStat(<span class="keyword">const</span> HierarchyStat&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    HierarchyStat&amp; operator=(<span class="keyword">const</span> HierarchyStat&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"> <span class="keyword">friend</span> <span class="keyword">class </span>HierarchyStatVisitor;</div>
<div class="line"></div>
<div class="line">    std::vector&lt;SubNodeStat&gt; fStats;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::HierarchyStatVisitor</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class analyzes the sub-node hierarchy to help pruning non-animated sub-hierarchy.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::HierarchyStatVisitor : <span class="keyword">public</span> SubNodeVisitor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HierarchyStatVisitor(<span class="keyword">const</span> SubNode::Ptr&amp; geometry)</div>
<div class="line">        : fGeometry(geometry),</div>
<div class="line">          fIsParentVisibilityAnimated(false),</div>
<div class="line">          fIsVisibilityAnimated(false),</div>
<div class="line">          fIsParentXformAnimated(false),</div>
<div class="line">          fIsXformAnimated(false),</div>
<div class="line">          fIsShapeAnimated(false),</div>
<div class="line">          fIsDiffuseColorAnimated(false),</div>
<div class="line">          fSubNodeIndex(0),</div>
<div class="line">          fShapeSubNodeIndex(0)</div>
<div class="line">    {</div>
<div class="line">        fHierarchyStat.reset(<span class="keyword">new</span> HierarchyStat());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~HierarchyStatVisitor()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{}</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> HierarchyStat::Ptr getStat()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{ <span class="keywordflow">return</span> fHierarchyStat; }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp;   xform,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Increase the sub-node counter.</span></div>
<div class="line"> <span class="keywordtype">size_t</span> thisSubNodeIndex = fSubNodeIndex;</div>
<div class="line">        fSubNodeIndex++;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Is the visibility animated?</span></div>
<div class="line"> <span class="keywordtype">bool</span> isVisibilityAnimated = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (xform.getSamples().size() &gt; 1) {</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>
<div class="line">                xform.getSamples().begin()-&gt;second;</div>
<div class="line"> <span class="keywordflow">if</span> (sample) {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> oneVisibility = sample-&gt;visibility();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> XformData::SampleMap::value_type&amp; val : xform.getSamples()) {</div>
<div class="line"> <span class="keywordflow">if</span> (val.second &amp;&amp; val.second-&gt;visibility() != oneVisibility) {</div>
<div class="line">                        isVisibilityAnimated = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Is the xform animated?</span></div>
<div class="line"> <span class="keywordtype">bool</span> isXformAnimated = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (xform.getSamples().size() &gt; 1) {</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>
<div class="line">                xform.getSamples().begin()-&gt;second;</div>
<div class="line"> <span class="keywordflow">if</span> (sample) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a>&amp; oneMatrix = sample-&gt;xform();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> XformData::SampleMap::value_type&amp; val : xform.getSamples()) {</div>
<div class="line"> <span class="keywordflow">if</span> (val.second &amp;&amp; val.second-&gt;xform() != oneMatrix) {</div>
<div class="line">                        isXformAnimated = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Push the xform/visibility animated flag down the hierarchy.</span></div>
<div class="line">        {</div>
<div class="line">            ScopedGuard&lt;bool&gt; parentVisibilityGuard(fIsParentVisibilityAnimated);</div>
<div class="line">            fIsParentVisibilityAnimated = fIsParentVisibilityAnimated || isVisibilityAnimated;</div>
<div class="line"></div>
<div class="line">            ScopedGuard&lt;bool&gt; parentXformGuard(fIsParentXformAnimated);</div>
<div class="line">            fIsParentXformAnimated = fIsParentXformAnimated || isXformAnimated;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Shape animated flags for all descendant shapes.</span></div>
<div class="line"> <span class="keywordtype">bool</span> isShapeAnimated        = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> isDiffuseColorAnimated = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Recursive calls into children</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> SubNode::Ptr&amp; child : subNode.getChildren()) {</div>
<div class="line">                child-&gt;accept(*<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Merge shape animated flags.</span></div>
<div class="line">                isVisibilityAnimated   = isVisibilityAnimated   || fIsVisibilityAnimated;</div>
<div class="line">                isXformAnimated        = isXformAnimated        || fIsXformAnimated;</div>
<div class="line">                isShapeAnimated        = isShapeAnimated        || fIsShapeAnimated;</div>
<div class="line">                isDiffuseColorAnimated = isDiffuseColorAnimated || fIsDiffuseColorAnimated;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Pull shape animated flags up the hierarchy.</span></div>
<div class="line">            fIsVisibilityAnimated   = isVisibilityAnimated;</div>
<div class="line">            fIsXformAnimated        = isXformAnimated;</div>
<div class="line">            fIsShapeAnimated        = isShapeAnimated;</div>
<div class="line">            fIsDiffuseColorAnimated = isDiffuseColorAnimated;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        appendStat(thisSubNodeIndex);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> ShapeData&amp;   shape,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Increase the sub-node counter.</span></div>
<div class="line"> <span class="keywordtype">size_t</span> thisSubNodeIndex = fSubNodeIndex;</div>
<div class="line">        fSubNodeIndex++;</div>
<div class="line">        fShapeSubNodeIndex++;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Is the shape animated ?</span></div>
<div class="line">        fIsShapeAnimated = shape.getSamples().size() &gt; 1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Is the diffuse color animated?</span></div>
<div class="line">        fIsDiffuseColorAnimated = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fIsShapeAnimated) {</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">                shape.getSamples().begin()-&gt;second;</div>
<div class="line"> <span class="keywordflow">if</span> (sample) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp; oneColor = sample-&gt;diffuseColor();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> ShapeData::SampleMap::value_type&amp; val : shape.getSamples()) {</div>
<div class="line"> <span class="keywordflow">if</span> (val.second &amp;&amp; val.second-&gt;diffuseColor() != oneColor) {</div>
<div class="line">                        fIsDiffuseColorAnimated = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Is the visibility animated?</span></div>
<div class="line">        fIsVisibilityAnimated = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fIsShapeAnimated) {</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">                shape.getSamples().begin()-&gt;second;</div>
<div class="line"> <span class="keywordflow">if</span> (sample) {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> oneVisibility = sample-&gt;visibility();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> ShapeData::SampleMap::value_type&amp; val : shape.getSamples()) {</div>
<div class="line"> <span class="keywordflow">if</span> (val.second &amp;&amp; val.second-&gt;visibility() != oneVisibility) {</div>
<div class="line">                        fIsVisibilityAnimated = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Shape's xform is not animated..</span></div>
<div class="line">        fIsXformAnimated = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        appendStat(thisSubNodeIndex);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> appendStat(<span class="keywordtype">size_t</span> subNodeIndex)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Record the stat of this sub-node.</span></div>
<div class="line">        HierarchyStat::SubNodeStat stat;</div>
<div class="line">        stat.isVisibilityAnimated   = fIsVisibilityAnimated || fIsParentVisibilityAnimated;</div>
<div class="line">        stat.isXformAnimated        = fIsXformAnimated || fIsParentXformAnimated;</div>
<div class="line">        stat.isShapeAnimated        = fIsShapeAnimated;</div>
<div class="line">        stat.isDiffuseColorAnimated = fIsDiffuseColorAnimated;</div>
<div class="line">        stat.nextSubNodeIndex       = fSubNodeIndex;</div>
<div class="line">        stat.nextShapeSubNodeIndex  = fShapeSubNodeIndex;</div>
<div class="line"></div>
<div class="line">        fHierarchyStat-&gt;setStat(subNodeIndex, stat);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keyword">const</span> SubNode::Ptr fGeometry;</div>
<div class="line"> <span class="keywordtype">bool</span>               fIsParentVisibilityAnimated;</div>
<div class="line"> <span class="keywordtype">bool</span>               fIsVisibilityAnimated;</div>
<div class="line"> <span class="keywordtype">bool</span>               fIsParentXformAnimated;</div>
<div class="line"> <span class="keywordtype">bool</span>               fIsXformAnimated;</div>
<div class="line"> <span class="keywordtype">bool</span>               fIsShapeAnimated;</div>
<div class="line"> <span class="keywordtype">bool</span>               fIsDiffuseColorAnimated;</div>
<div class="line"> <span class="keywordtype">size_t</span>             fSubNodeIndex;</div>
<div class="line"> <span class="keywordtype">size_t</span>             fShapeSubNodeIndex;</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;HierarchyStat&gt; fHierarchyStat;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::SubNodeRenderItems</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class contains the render items for each sub node.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::SubNodeRenderItems</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> std::shared_ptr&lt;SubNodeRenderItems&gt; Ptr;</div>
<div class="line"></div>
<div class="line">    SubNodeRenderItems()</div>
<div class="line">        : fIsBoundingBoxPlaceHolder(false),</div>
<div class="line">          fIsSelected(false),</div>
<div class="line">          fVisibility(true),</div>
<div class="line">          fValidPoly(true)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~SubNodeRenderItems()</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    SubNodeRenderItems(<span class="keyword">const</span> SubNodeRenderItems&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    SubNodeRenderItems&amp; operator=(<span class="keyword">const</span> SubNodeRenderItems&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateRenderItems(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;      subNodePrefix,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp;       wireColor,</div>
<div class="line"> <span class="keyword">const</span> ShapeData&amp;    shape,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;      subNode,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span>          isSelected)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Get the current shape sample.</span></div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">            shape.getSample(subSceneOverride.getTime());</div>
<div class="line"> <span class="keywordflow">if</span> (!sample) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache flags</span></div>
<div class="line">        fIsBoundingBoxPlaceHolder = sample-&gt;isBoundingBoxPlaceHolder();</div>
<div class="line">        fIsSelected               = isSelected;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Bounding box place holder.</span></div>
<div class="line">        updateBoundingBoxItems(subSceneOverride, container, subNodePrefix, wireColor, subNode);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Snap points</span></div>
<div class="line">        updateSnappingItems(subSceneOverride, container, subNodePrefix);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Dormant Wireframe</span></div>
<div class="line">        updateDormantWireItems(subSceneOverride, container, subNodePrefix, wireColor);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Active Wireframe</span></div>
<div class="line">        updateActiveWireItems(subSceneOverride, container, subNodePrefix, wireColor);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Shaded</span></div>
<div class="line">        updateShadedItems(subSceneOverride, container, subNodePrefix, shape,</div>
<div class="line">            sample-&gt;diffuseColor(), sample-&gt;numIndexGroups());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateVisibility(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span>          visibility,</div>
<div class="line"> <span class="keyword">const</span> ShapeData&amp;    shape)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Cache the sub-node visibility flag.</span></div>
<div class="line">        fVisibility = visibility;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Enable or disable render items.</span></div>
<div class="line">        toggleBoundingBoxItem();</div>
<div class="line">        toggleSnappingItem();</div>
<div class="line">        toggleDormantWireItem();</div>
<div class="line">        toggleActiveWireItem();</div>
<div class="line">        toggleShadedItems();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateWorldMatrix(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a>&amp;      matrix,</div>
<div class="line"> <span class="keyword">const</span> ShapeData&amp;    shape)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Set the world matrix.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fBoundingBoxItem) {</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">                shape.getSample(subSceneOverride.getTime());</div>
<div class="line"> <span class="keywordflow">if</span> (sample) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>&amp; boundingBox = sample-&gt;boundingBox();</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a> worldMatrix =</div>
<div class="line">                    UnitBoundingBox::boundingBoxMatrix(boundingBox) * matrix;</div>
<div class="line">                fBoundingBoxItem-&gt;setWorldMatrix(worldMatrix);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fSnappingItem) {</div>
<div class="line">            fSnappingItem-&gt;setWorldMatrix(matrix);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fDormantWireItem) {</div>
<div class="line">            fDormantWireItem-&gt;setWorldMatrix(matrix);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fActiveWireItem) {</div>
<div class="line">            fActiveWireItem-&gt;setWorldMatrix(matrix);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(RenderItemWrapper::Ptr&amp; shadedItem : fShadedItems) {</div>
<div class="line">            shadedItem-&gt;setWorldMatrix(matrix);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateStreams(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> ShapeData&amp;    shape)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">            shape.getSample(subSceneOverride.getTime());</div>
<div class="line"> <span class="keywordflow">if</span> (!sample) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If this sample is an empty poly, we disable all render items and return.</span></div>
<div class="line">        fValidPoly = sample-&gt;numVerts() &gt; 0 &amp;&amp;</div>
<div class="line">                     sample-&gt;numWires() &gt; 0 &amp;&amp;</div>
<div class="line">                     sample-&gt;numTriangles() &gt; 0 &amp;&amp;</div>
<div class="line">                     sample-&gt;positions();</div>
<div class="line"> <span class="comment">// Enable or disable render items.</span></div>
<div class="line">        toggleBoundingBoxItem();</div>
<div class="line">        toggleSnappingItem();</div>
<div class="line">        toggleDormantWireItem();</div>
<div class="line">        toggleActiveWireItem();</div>
<div class="line">        toggleShadedItems();</div>
<div class="line"> <span class="keywordflow">if</span> (!fValidPoly) {</div>
<div class="line"> <span class="comment">// Nothing to do. Render items are disabled.</span></div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fSnappingItem) {</div>
<div class="line"> <span class="comment">// The snapping item is fully sequential and does not</span></div>
<div class="line"> <span class="comment">// require an index buffer.</span></div>
<div class="line">            fSnappingItem-&gt;setBuffers(</div>
<div class="line">                subSceneOverride,</div>
<div class="line">                std::shared_ptr&lt;const IndexBuffer&gt;(),</div>
<div class="line">                sample-&gt;positions(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                sample-&gt;boundingBox()</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the wireframe streams.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fDormantWireItem) {</div>
<div class="line">            fDormantWireItem-&gt;setBuffers(</div>
<div class="line">                subSceneOverride,</div>
<div class="line">                sample-&gt;wireVertIndices(),</div>
<div class="line">                sample-&gt;positions(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                sample-&gt;boundingBox()</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fActiveWireItem) {</div>
<div class="line">            fActiveWireItem-&gt;setBuffers(</div>
<div class="line">                subSceneOverride,</div>
<div class="line">                sample-&gt;wireVertIndices(),</div>
<div class="line">                sample-&gt;positions(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                sample-&gt;boundingBox()</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the shaded streams.</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> groupId = 0; groupId &lt; sample-&gt;numIndexGroups(); groupId++) {</div>
<div class="line"> <span class="keywordflow">if</span> (groupId &gt;= fShadedItems.size()) <span class="keywordflow">break</span>;  <span class="comment">// background loading</span></div>
<div class="line"></div>
<div class="line">            assert(fShadedItems[groupId]);</div>
<div class="line"> <span class="keywordflow">if</span> (!fShadedItems[groupId]) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            fShadedItems[groupId]-&gt;setBuffers(</div>
<div class="line">                subSceneOverride,</div>
<div class="line">                sample-&gt;triangleVertIndices(groupId),</div>
<div class="line">                sample-&gt;positions(),</div>
<div class="line">                sample-&gt;normals(),</div>
<div class="line">                sample-&gt;uvs(),</div>
<div class="line">                sample-&gt;boundingBox()</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateMaterials(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> ShapeData&amp;    shape)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">            shape.getSample(subSceneOverride.getTime());</div>
<div class="line"> <span class="keywordflow">if</span> (!sample) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> groupId = 0; groupId &lt; sample-&gt;numIndexGroups(); groupId++) {</div>
<div class="line"> <span class="keywordflow">if</span> (groupId &gt;= fShadedItems.size()) <span class="keywordflow">break</span>;  <span class="comment">// background loading</span></div>
<div class="line"> <span class="keywordflow">if</span> (groupId &gt;= fSharedDiffuseColorShaders.size()) <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (groupId &gt;= fUniqueDiffuseColorShaders.size()) <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (groupId &gt;= fMaterialShaders.size()) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">            assert(fShadedItems[groupId]);</div>
<div class="line"> <span class="keywordflow">if</span> (!fShadedItems[groupId]) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// First, check if the shader instance is created from a MaterialGraph.</span></div>
<div class="line">            ShaderInstancePtr shader = fMaterialShaders[groupId];</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Nothing to do.</span></div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Then, check if the shader instance is already unique to the render item.</span></div>
<div class="line">            shader = fUniqueDiffuseColorShaders[groupId];</div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// Unique shader instance belongs to this render item.</span></div>
<div class="line"> <span class="comment">// Set the diffuse color directly.</span></div>
<div class="line">                setDiffuseColor(shader.get(), sample-&gt;diffuseColor());</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Then, get a shared shader instance from cache.</span></div>
<div class="line">            shader = ShaderInstanceCache::getInstance().getSharedDiffuseColorShader(</div>
<div class="line">                sample-&gt;diffuseColor());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// If the shared shader instance is different from the existing one,</span></div>
<div class="line"> <span class="comment">// there is diffuse color animation.</span></div>
<div class="line"> <span class="comment">// We promote the shared shader instance to a unique shader instance.</span></div>
<div class="line">            assert(fSharedDiffuseColorShaders[groupId]);  <span class="comment">// set in updateRenderItems()</span></div>
<div class="line"> <span class="keywordflow">if</span> (shader != fSharedDiffuseColorShaders[groupId]) {</div>
<div class="line">                shader = ShaderInstanceCache::getInstance().getUniqueDiffuseColorShader(</div>
<div class="line">                    sample-&gt;diffuseColor());</div>
<div class="line"></div>
<div class="line">                fSharedDiffuseColorShaders[groupId].reset();</div>
<div class="line">                fUniqueDiffuseColorShaders[groupId] = shader;</div>
<div class="line"></div>
<div class="line">                fShadedItems[groupId]-&gt;setShader(shader);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateBoundingBoxItems(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;      subNodePrefix,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp;       wireColor,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;      subNode)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (!fIsBoundingBoxPlaceHolder) {</div>
<div class="line"> <span class="comment">// This shape is no longer a bounding box place holder.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fBoundingBoxItem) {</div>
<div class="line">                fBoundingBoxItem-&gt;removeFromContainer(container);</div>
<div class="line">                fBoundingBoxItem.reset();</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Bounding box place holder render item.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fBoundingBoxItem) {</div>
<div class="line"> <span class="comment">// Create the bounding box render item.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> boundingBoxItemName = subNodePrefix + <span class="stringliteral">":boundingBox"</span>;</div>
<div class="line">            fBoundingBoxItem.reset(<span class="keyword">new</span> RenderItemWrapper(</div>
<div class="line">                boundingBoxItemName,</div>
<div class="line">                MRenderItem::NonMaterialSceneItem,</div>
<div class="line">                MGeometry::kLines</div>
<div class="line">            ));</div>
<div class="line">            fBoundingBoxItem-&gt;setDrawMode((<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3">MGeometry::DrawMode</a>)(MGeometry::kWireframe | MGeometry::kShaded | MGeometry::kTextured));</div>
<div class="line">            fBoundingBoxItem-&gt;setDepthPriority(MRenderItem::sDormantWireDepthPriority);</div>
<div class="line">            fBoundingBoxItem-&gt;setCompatibleWithMayaInstancer(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set the shader so that we can fill the geometry data.</span></div>
<div class="line">            ShaderInstancePtr boundingBoxShader = </div>
<div class="line">                ShaderInstanceCache::getInstance().getSharedBoundingBoxPlaceHolderShader(wireColor);</div>
<div class="line"> <span class="keywordflow">if</span> (boundingBoxShader) {</div>
<div class="line">                fBoundingBoxItem-&gt;setShader(boundingBoxShader);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add to the container.</span></div>
<div class="line">            fBoundingBoxItem-&gt;addToContainer(container);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set unit bounding box buffer.</span></div>
<div class="line">            fBoundingBoxItem-&gt;setBuffers(</div>
<div class="line">                subSceneOverride,</div>
<div class="line">                UnitBoundingBox::indices(),</div>
<div class="line">                UnitBoundingBox::positions(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                UnitBoundingBox::boundingBox()</div>
<div class="line">            );</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add a custom data to indicate the sub-node.</span></div>
<div class="line">            fBoundingBoxItem-&gt;setCustomData(</div>
<div class="line">                std::make_shared&lt;SubNodeUserData&gt;(subNode)</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update shader color.</span></div>
<div class="line">        ShaderInstancePtr boundingBoxShader = </div>
<div class="line">            ShaderInstanceCache::getInstance().getSharedBoundingBoxPlaceHolderShader(wireColor);</div>
<div class="line"> <span class="keywordflow">if</span> (boundingBoxShader) {</div>
<div class="line">            fBoundingBoxItem-&gt;setShader(boundingBoxShader);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        toggleBoundingBoxItem();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateSnappingItems(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;      subNodePrefix)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fIsBoundingBoxPlaceHolder) {</div>
<div class="line"> <span class="comment">// This shape is a bounding box place holder.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fSnappingItem) fSnappingItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update snapping item.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fSnappingItem) {</div>
<div class="line"> <span class="comment">// Create the snapping render item.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> snappingItemName = subNodePrefix + <span class="stringliteral">":snapping"</span>;</div>
<div class="line">            fSnappingItem.reset(<span class="keyword">new</span> RenderItemWrapper(</div>
<div class="line">                snappingItemName,</div>
<div class="line">                MRenderItem::DecorationItem,</div>
<div class="line">                MGeometry::kPoints</div>
<div class="line">            ));</div>
<div class="line">            fSnappingItem-&gt;setDrawMode(<a name="a79"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3a3b28d66a728ec358f3aae323b2c24fa9">MHWRender::MGeometry::kSelectionOnly</a>);</div>
<div class="line">            fSnappingItem-&gt;setDepthPriority(MRenderItem::sSelectionDepthPriority);</div>
<div class="line">            fSnappingItem-&gt;setSnappingSelectionMask();</div>
<div class="line">            fSnappingItem-&gt;setCompatibleWithMayaInstancer(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add to the container</span></div>
<div class="line">            fSnappingItem-&gt;addToContainer(container);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Hardware instancing.</span></div>
<div class="line">        std::shared_ptr&lt;HardwareInstanceManager&gt;&amp; hwInstanceManager = </div>
<div class="line">            subSceneOverride.hardwareInstanceManager();</div>
<div class="line"> <span class="keywordflow">if</span> (hwInstanceManager) {</div>
<div class="line">            hwInstanceManager-&gt;installHardwareInstanceData(fSnappingItem);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        toggleSnappingItem();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Snapping item is never displayed.</span></div>
<div class="line">        ShaderInstancePtr snappingShader = ShaderInstanceCache::getInstance().getSharedPointShader();</div>
<div class="line"> <span class="keywordflow">if</span> (snappingShader) {</div>
<div class="line">            fSnappingItem-&gt;setShader(snappingShader);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateDormantWireItems(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;      subNodePrefix,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp;       wireColor)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fIsBoundingBoxPlaceHolder) {</div>
<div class="line"> <span class="comment">// This shape is a bounding box place holder.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fDormantWireItem) fDormantWireItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update dormant wireframe item.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fDormantWireItem) {</div>
<div class="line"> <span class="comment">// Create the dormant wireframe render item.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> dormantWireItemName = subNodePrefix + <span class="stringliteral">":dormantWire"</span>;</div>
<div class="line">            fDormantWireItem.reset(<span class="keyword">new</span> RenderItemWrapper(</div>
<div class="line">                dormantWireItemName,</div>
<div class="line">                MRenderItem::DecorationItem,</div>
<div class="line">                MGeometry::kLines</div>
<div class="line">            ));</div>
<div class="line">            fDormantWireItem-&gt;setDrawMode(MGeometry::kWireframe);</div>
<div class="line">            fDormantWireItem-&gt;setDepthPriority(MRenderItem::sDormantWireDepthPriority);</div>
<div class="line">            fDormantWireItem-&gt;setCompatibleWithMayaInstancer(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add to the container</span></div>
<div class="line">            fDormantWireItem-&gt;addToContainer(container);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Hardware instancing.</span></div>
<div class="line">        std::shared_ptr&lt;HardwareInstanceManager&gt;&amp; hwInstanceManager = </div>
<div class="line">            subSceneOverride.hardwareInstanceManager();</div>
<div class="line"> <span class="keywordflow">if</span> (hwInstanceManager) {</div>
<div class="line">            hwInstanceManager-&gt;installHardwareInstanceData(fDormantWireItem);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        toggleDormantWireItem();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Dormant wireframe color.</span></div>
<div class="line">        ShaderInstancePtr dormantWireShader =</div>
<div class="line">            (DisplayPref::wireframeOnShadedMode() == DisplayPref::kWireframeOnShadedFull)</div>
<div class="line">            ? ShaderInstanceCache::getInstance().getSharedWireShader(wireColor)</div>
<div class="line">            : ShaderInstanceCache::getInstance().getSharedWireShaderWithCB(wireColor);</div>
<div class="line"> <span class="keywordflow">if</span> (dormantWireShader) {</div>
<div class="line">            fDormantWireItem-&gt;setShader(dormantWireShader);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateActiveWireItems(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;      subNodePrefix,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp;       wireColor)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fIsBoundingBoxPlaceHolder) {</div>
<div class="line"> <span class="comment">// This shape is a bounding box place holder or unselected.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fActiveWireItem)  fActiveWireItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!fActiveWireItem) {</div>
<div class="line"> <span class="comment">// Create the active wireframe render item.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> activeWireItemName = subNodePrefix + <span class="stringliteral">":activeWire"</span>;</div>
<div class="line">            fActiveWireItem.reset(<span class="keyword">new</span> RenderItemWrapper(</div>
<div class="line">                activeWireItemName,</div>
<div class="line">                MRenderItem::DecorationItem,</div>
<div class="line">                MGeometry::kLines</div>
<div class="line">            ));</div>
<div class="line">            fActiveWireItem-&gt;setDrawMode((<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3">MGeometry::DrawMode</a>)(MGeometry::kWireframe | MGeometry::kShaded | MGeometry::kTextured));</div>
<div class="line">            fActiveWireItem-&gt;setDepthPriority(MRenderItem::sActiveWireDepthPriority);</div>
<div class="line">            fActiveWireItem-&gt;setCompatibleWithMayaInstancer(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add to the container.</span></div>
<div class="line">            fActiveWireItem-&gt;addToContainer(container);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Hardware instancing.</span></div>
<div class="line">        std::shared_ptr&lt;HardwareInstanceManager&gt;&amp; hwInstanceManager = </div>
<div class="line">            subSceneOverride.hardwareInstanceManager();</div>
<div class="line"> <span class="keywordflow">if</span> (hwInstanceManager) {</div>
<div class="line">            hwInstanceManager-&gt;installHardwareInstanceData(fActiveWireItem);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        toggleActiveWireItem();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Active wireframe color.</span></div>
<div class="line">        ShaderInstancePtr activeWireShader =</div>
<div class="line">            (DisplayPref::wireframeOnShadedMode() == DisplayPref::kWireframeOnShadedFull)</div>
<div class="line">            ? ShaderInstanceCache::getInstance().getSharedWireShader(wireColor)</div>
<div class="line">            : ShaderInstanceCache::getInstance().getSharedWireShaderWithCB(wireColor);</div>
<div class="line"> <span class="keywordflow">if</span> (activeWireShader) {</div>
<div class="line">            fActiveWireItem-&gt;setShader(activeWireShader);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateShadedItems(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;      subNodePrefix,</div>
<div class="line"> <span class="keyword">const</span> ShapeData&amp;    shape,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp;       diffuseColor,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">size_t</span>        nbIndexGroups)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Shaded render items.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fIsBoundingBoxPlaceHolder) {</div>
<div class="line"> <span class="comment">// This shape is a bounding box place holder.</span></div>
<div class="line"> <span class="keywordflow">for</span>(RenderItemWrapper::Ptr&amp; item : fShadedItems) {</div>
<div class="line">                item-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fShadedItems.empty()) {</div>
<div class="line"> <span class="comment">// Create a render item for each index group.</span></div>
<div class="line">            fShadedItems.reserve(nbIndexGroups);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Each render item has an associated MShaderInstance.</span></div>
<div class="line">            fSharedDiffuseColorShaders.reserve(nbIndexGroups);</div>
<div class="line">            fUniqueDiffuseColorShaders.reserve(nbIndexGroups);</div>
<div class="line">            fMaterialShaders.reserve(nbIndexGroups);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> groupId = 0; groupId &lt; nbIndexGroups; groupId++) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> shadedItemName = subNodePrefix + <span class="stringliteral">":shaded"</span> + (int)groupId;</div>
<div class="line">                RenderItemWrapper::Ptr renderItem(<span class="keyword">new</span> RenderItemWrapper(</div>
<div class="line">                    shadedItemName,</div>
<div class="line">                    MRenderItem::MaterialSceneItem,</div>
<div class="line">                    MGeometry::kTriangles</div>
<div class="line">                ));</div>
<div class="line">                renderItem-&gt;setDrawMode((<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a9a325db332d24e6105fe3b48a94604c3">MGeometry::DrawMode</a>)(MGeometry::kShaded | MGeometry::kTextured));</div>
<div class="line">                renderItem-&gt;setExcludedFromPostEffects(<span class="keyword">false</span>);  <span class="comment">// SSAO, etc..</span></div>
<div class="line">                renderItem-&gt;setCompatibleWithMayaInstancer(<span class="keyword">true</span>);</div>
<div class="line">                fShadedItems.push_back(renderItem);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if we have any material that is assigned to this index group.</span></div>
<div class="line">                ShaderInstancePtr shader;</div>
<div class="line"> <span class="keyword">const</span> std::vector&lt;MString&gt;&amp;  materialsAssignment = shape.getMaterials();</div>
<div class="line"> <span class="keyword">const</span> MaterialGraphMap::Ptr&amp; materials = subSceneOverride.getMaterial();</div>
<div class="line"> <span class="keywordflow">if</span> (materials &amp;&amp; groupId &lt; materialsAssignment.size()) {</div>
<div class="line"> <span class="keyword">const</span> MaterialGraph::Ptr graph = materials-&gt;find(materialsAssignment[groupId]);</div>
<div class="line"> <span class="keywordflow">if</span> (graph) {</div>
<div class="line">                        shader = ShaderInstanceCache::getInstance().getSharedShadedMaterialShader(</div>
<div class="line">                            graph, subSceneOverride.getTime()</div>
<div class="line">                        );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (shader) {</div>
<div class="line"> <span class="comment">// We have successfully created a material shader.</span></div>
<div class="line">                    renderItem-&gt;setShader(shader);</div>
<div class="line"></div>
<div class="line">                    fMaterialShaders.push_back(shader);</div>
<div class="line">                    fSharedDiffuseColorShaders.push_back(ShaderInstancePtr());</div>
<div class="line">                    fUniqueDiffuseColorShaders.push_back(ShaderInstancePtr());</div>
<div class="line">                }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// There is no materials. Fallback to diffuse color.</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Let's assume that the diffuse color is not animated at beginning.</span></div>
<div class="line"> <span class="comment">// If the diffuse color changes, we will promote the shared shader to</span></div>
<div class="line"> <span class="comment">// a unique shader.</span></div>
<div class="line">                    ShaderInstancePtr sharedShader =</div>
<div class="line">                        ShaderInstanceCache::getInstance().getSharedDiffuseColorShader(diffuseColor);</div>
<div class="line"> <span class="keywordflow">if</span> (sharedShader) {</div>
<div class="line">                        renderItem-&gt;setShader(sharedShader);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    fMaterialShaders.push_back(ShaderInstancePtr());</div>
<div class="line">                    fSharedDiffuseColorShaders.push_back(sharedShader);</div>
<div class="line">                    fUniqueDiffuseColorShaders.push_back(ShaderInstancePtr());</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add to the container.</span></div>
<div class="line">                renderItem-&gt;addToContainer(container);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if we can cast/receive shadows and hardware instancing.</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> castsShadows   = subSceneOverride.castsShadows();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> receiveShadows = subSceneOverride.receiveShadows();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(RenderItemWrapper::Ptr&amp; renderItem : fShadedItems) {</div>
<div class="line"> <span class="comment">// Set Casts Shadows and Receives Shadows.</span></div>
<div class="line">            renderItem-&gt;setCastsShadows(castsShadows);</div>
<div class="line">            renderItem-&gt;setReceivesShadows(receiveShadows);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Hardware instancing.</span></div>
<div class="line">            std::shared_ptr&lt;HardwareInstanceManager&gt;&amp; hwInstanceManager = </div>
<div class="line">                subSceneOverride.hardwareInstanceManager();</div>
<div class="line"> <span class="keywordflow">if</span> (hwInstanceManager &amp;&amp; renderItem-&gt;shader() &amp;&amp; !renderItem-&gt;shader()-&gt;isTransparent()) {</div>
<div class="line">                hwInstanceManager-&gt;installHardwareInstanceData(renderItem);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        toggleShadedItems();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Enable or disable bounding box place holder item.</span></div>
<div class="line"> <span class="keywordtype">void</span> toggleBoundingBoxItem()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fBoundingBoxItem) {</div>
<div class="line"> <span class="keywordflow">if</span> (fIsBoundingBoxPlaceHolder) {</div>
<div class="line">                fBoundingBoxItem-&gt;setEnabled(fVisibility);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                fBoundingBoxItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Enable or disable snapping item.</span></div>
<div class="line"> <span class="keywordtype">void</span> toggleSnappingItem()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fSnappingItem) {</div>
<div class="line"> <span class="keywordflow">if</span> (fIsBoundingBoxPlaceHolder) {</div>
<div class="line">                fSnappingItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                fSnappingItem-&gt;setEnabled(fVisibility &amp;&amp; fValidPoly);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Enable or disable dormant wireframe item.</span></div>
<div class="line"> <span class="keywordtype">void</span> toggleDormantWireItem()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fDormantWireItem) {</div>
<div class="line"> <span class="keywordflow">if</span> (fIsBoundingBoxPlaceHolder) {</div>
<div class="line">                fDormantWireItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                fDormantWireItem-&gt;setEnabled(fVisibility &amp;&amp; fValidPoly &amp;&amp; !fIsSelected);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Enable or disable active wireframe item.</span></div>
<div class="line"> <span class="keywordtype">void</span> toggleActiveWireItem()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (fActiveWireItem) {</div>
<div class="line"> <span class="keywordflow">if</span> (fIsBoundingBoxPlaceHolder) {</div>
<div class="line">                fActiveWireItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                fActiveWireItem-&gt;setEnabled(fVisibility &amp;&amp; fValidPoly &amp;&amp; fIsSelected);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Enable or disable shaded items.</span></div>
<div class="line"> <span class="keywordtype">void</span> toggleShadedItems()</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">for</span>(RenderItemWrapper::Ptr&amp; shadedItem : fShadedItems) {</div>
<div class="line"> <span class="keywordflow">if</span> (fIsBoundingBoxPlaceHolder) {</div>
<div class="line">                shadedItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">                shadedItem-&gt;setEnabled(fVisibility &amp;&amp; fValidPoly);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> hideRenderItems()</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Simply disable all render items.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fActiveWireItem) {</div>
<div class="line">            fActiveWireItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fDormantWireItem) {</div>
<div class="line">            fDormantWireItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fSnappingItem) {</div>
<div class="line">            fSnappingItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fBoundingBoxItem) {</div>
<div class="line">            fBoundingBoxItem-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(RenderItemWrapper::Ptr&amp; item : fShadedItems) {</div>
<div class="line">            item-&gt;setEnabled(<span class="keyword">false</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> destroyRenderItems(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Destroy all render items.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fActiveWireItem) {</div>
<div class="line">            fActiveWireItem-&gt;removeFromContainer(container);</div>
<div class="line">            fActiveWireItem.reset();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fDormantWireItem) {</div>
<div class="line">            fDormantWireItem-&gt;removeFromContainer(container);</div>
<div class="line">            fDormantWireItem.reset();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fSnappingItem) {</div>
<div class="line">            fSnappingItem-&gt;removeFromContainer(container);</div>
<div class="line">            fSnappingItem.reset();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fBoundingBoxItem) {</div>
<div class="line">            fBoundingBoxItem-&gt;removeFromContainer(container);</div>
<div class="line">            fBoundingBoxItem.reset();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(RenderItemWrapper::Ptr&amp; item : fShadedItems) {</div>
<div class="line">            item-&gt;removeFromContainer(container);</div>
<div class="line">            item.reset();</div>
<div class="line">        }</div>
<div class="line">        fShadedItems.clear();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="comment">// Render items for this sub-node.</span></div>
<div class="line">    RenderItemWrapper::Ptr               fBoundingBoxItem;</div>
<div class="line">    RenderItemWrapper::Ptr               fActiveWireItem;</div>
<div class="line">    RenderItemWrapper::Ptr               fDormantWireItem;</div>
<div class="line">    RenderItemWrapper::Ptr               fSnappingItem;</div>
<div class="line">    std::vector&lt;RenderItemWrapper::Ptr&gt;  fShadedItems;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The following flags control the enable/disable state of render items.</span></div>
<div class="line"> <span class="keywordtype">bool</span> fIsBoundingBoxPlaceHolder; <span class="comment">// The sub-node has not been loaded.</span></div>
<div class="line"> <span class="keywordtype">bool</span> fIsSelected;               <span class="comment">// Selection state for this sub-node.</span></div>
<div class="line"> <span class="keywordtype">bool</span> fVisibility;               <span class="comment">// Visibility for this sub-node.</span></div>
<div class="line"> <span class="keywordtype">bool</span> fValidPoly;                <span class="comment">// False if the poly has 0 vertices.</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Shader instances for shaded render items.</span></div>
<div class="line">    std::vector&lt;ShaderInstancePtr&gt;  fSharedDiffuseColorShaders;</div>
<div class="line">    std::vector&lt;ShaderInstancePtr&gt;  fUniqueDiffuseColorShaders;</div>
<div class="line">    std::vector&lt;ShaderInstancePtr&gt;  fMaterialShaders;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::UpdateRenderItemsVisitor</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Update the render items.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::UpdateRenderItemsVisitor : <span class="keyword">public</span> SubNodeVisitor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    UpdateRenderItemsVisitor(SubSceneOverride&amp;      subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;    container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;         instancePrefix,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp;          wireColor,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span>             isSelected,</div>
<div class="line">                             SubNodeRenderItemList&amp; subNodeItems)</div>
<div class="line">        : fSubSceneOverride(subSceneOverride),</div>
<div class="line">          fContainer(container),</div>
<div class="line">          fWireColor(wireColor),</div>
<div class="line">          fIsSelected(isSelected),</div>
<div class="line">          fSubNodeItems(subNodeItems),</div>
<div class="line">          fLongName(instancePrefix),</div>
<div class="line">          fSubNodeIndex(0)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~UpdateRenderItemsVisitor()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp;   xform,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// We use the hierarchical name to represent the unique render item name.</span></div>
<div class="line">        ScopedGuard&lt;MString&gt; longNameGuard(fLongName);</div>
<div class="line"> <span class="keywordtype">bool</span> isTop = subNode.getParents().empty() &amp;&amp; subNode.getName() == <span class="stringliteral">"|"</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (!isTop) {</div>
<div class="line">            fLongName += <span class="stringliteral">"|"</span>;</div>
<div class="line">            fLongName += subNode.getName();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Recursive calls into children</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> SubNode::Ptr&amp; child : subNode.getChildren()) {</div>
<div class="line">            child-&gt;accept(*<span class="keyword">this</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> ShapeData&amp;   shape,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// We use the hierarchical name to represent the unique render item name.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> prevName = fLongName;</div>
<div class="line">        fLongName += <span class="stringliteral">"|"</span>;</div>
<div class="line">        fLongName += subNode.getName();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update render items for this sub-node.</span></div>
<div class="line">        updateRenderItems(shape, subNode);</div>
<div class="line">        fSubNodeIndex++;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Restore to the previous name.</span></div>
<div class="line">        fLongName = prevName;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateRenderItems(<span class="keyword">const</span> ShapeData&amp; shape, <span class="keyword">const</span> SubNode&amp; subNode)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Create new sub-node render items.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fSubNodeIndex &gt;= fSubNodeItems.size()) {</div>
<div class="line">            fSubNodeItems.push_back(std::make_shared&lt;SubNodeRenderItems&gt;());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the render items for this sub-node.</span></div>
<div class="line">        fSubNodeItems[fSubNodeIndex]-&gt;updateRenderItems(</div>
<div class="line">            fSubSceneOverride,</div>
<div class="line">            fContainer,</div>
<div class="line">            fLongName,</div>
<div class="line">            fWireColor,</div>
<div class="line">            shape,</div>
<div class="line">            subNode,</div>
<div class="line">            fIsSelected</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    SubSceneOverride&amp;      fSubSceneOverride;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;    fContainer;</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a>&amp;          fWireColor;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span>             fIsSelected;</div>
<div class="line">    SubNodeRenderItemList&amp; fSubNodeItems;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> fLongName;</div>
<div class="line"> <span class="keywordtype">size_t</span>  fSubNodeIndex;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::UpdateVisitorWithPrune</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class is a visitor for the sub-node hierarchy and allowing to prune</span></div>
<div class="line"><span class="comment">// a sub part of it.</span></div>
<div class="line"><span class="comment">// Curiously recurring template pattern.</span></div>
<div class="line"><span class="comment">// The derived class should implement the following two methods:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Test if this sub-node and its descendants can be pruned.</span></div>
<div class="line"><span class="comment">// bool canPrune(const HierarchyStat::SubNodeStat&amp; stat);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Update the shape sub-node.</span></div>
<div class="line"><span class="comment">// void update(const ShapeData&amp;         shape,</span></div>
<div class="line"><span class="comment">//             const SubNode&amp;           subNode,</span></div>
<div class="line"><span class="comment">//             SubNodeRenderItems::Ptr&amp; subNodeItems);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DERIVED&gt;</div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::UpdateVisitorWithPrune : <span class="keyword">public</span> SubNodeVisitor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    UpdateVisitorWithPrune(SubSceneOverride&amp;      subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;    container,</div>
<div class="line">                           SubNodeRenderItemList&amp; subNodeItems)</div>
<div class="line">        : fSubSceneOverride(subSceneOverride),</div>
<div class="line">          fContainer(container),</div>
<div class="line">          fSubNodeItems(subNodeItems),</div>
<div class="line">          fDontPrune(false),</div>
<div class="line">          fTraverseInvisible(false),</div>
<div class="line">          fSubNodeIndex(0),</div>
<div class="line">          fShapeSubNodeIndex(0)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~UpdateVisitorWithPrune()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{}</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Disable prune.</span></div>
<div class="line"> <span class="keywordtype">void</span> setDontPrune(<span class="keywordtype">bool</span> dontPrune)</div>
<div class="line">    {</div>
<div class="line">        fDontPrune = dontPrune;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Traverse invisible sub-nodes.</span></div>
<div class="line"> <span class="keywordtype">void</span> setTraverseInvisible(<span class="keywordtype">bool</span> traverseInvisible)</div>
<div class="line">    {</div>
<div class="line">        fTraverseInvisible = traverseInvisible;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp;   xform,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Try to prune this sub-hierarchy.</span></div>
<div class="line"> <span class="keyword">const</span> HierarchyStat::Ptr&amp; hierarchyStat = fSubSceneOverride.getHierarchyStat();</div>
<div class="line"> <span class="keywordflow">if</span> (hierarchyStat) {</div>
<div class="line"> <span class="keyword">const</span> HierarchyStat::SubNodeStat&amp; stat = hierarchyStat-&gt;stat(fSubNodeIndex);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!fDontPrune) {</div>
<div class="line"> <span class="keywordflow">if</span> (static_cast&lt;DERIVED*&gt;(<span class="keyword">this</span>)-&gt;canPrune(stat)) {</div>
<div class="line"> <span class="comment">// Prune this sub-hierarchy.</span></div>
<div class="line"> <span class="comment">// Fast-forward to the next sub-node.</span></div>
<div class="line">                    fSubNodeIndex      = stat.nextSubNodeIndex;</div>
<div class="line">                    fShapeSubNodeIndex = stat.nextShapeSubNodeIndex;</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!fTraverseInvisible) {</div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>
<div class="line">                        xform.getSample(fSubSceneOverride.getTime());</div>
<div class="line"> <span class="keywordflow">if</span> (sample &amp;&amp; !sample-&gt;visibility()) {</div>
<div class="line"> <span class="comment">// Invisible sub-node. Prune this sub-hierarchy.</span></div>
<div class="line"> <span class="comment">// Fast-forward to the next sub-node.</span></div>
<div class="line">                        fSubNodeIndex      = stat.nextSubNodeIndex;</div>
<div class="line">                        fShapeSubNodeIndex = stat.nextShapeSubNodeIndex;</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fSubNodeIndex++;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Recursive calls into children.</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keyword">const</span> SubNode::Ptr&amp; child : subNode.getChildren()) {</div>
<div class="line">            child-&gt;accept(*<span class="keyword">this</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> ShapeData&amp;   shape,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Update the sub-node.</span></div>
<div class="line">        assert(fShapeSubNodeIndex &lt; fSubNodeItems.size());</div>
<div class="line"> <span class="keywordflow">if</span> (fShapeSubNodeIndex &lt; fSubNodeItems.size()) {</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>DERIVED*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;update(shape, subNode, fSubNodeItems[fShapeSubNodeIndex]);</div>
<div class="line">        }</div>
<div class="line">        fSubNodeIndex++;</div>
<div class="line">        fShapeSubNodeIndex++;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    SubSceneOverride&amp;      fSubSceneOverride;</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;    fContainer;</div>
<div class="line">    SubNodeRenderItemList&amp; fSubNodeItems;</div>
<div class="line"> <span class="keywordtype">bool</span>                   fDontPrune;</div>
<div class="line"> <span class="keywordtype">bool</span>                   fTraverseInvisible;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">size_t</span>  fSubNodeIndex;</div>
<div class="line"> <span class="keywordtype">size_t</span>  fShapeSubNodeIndex;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::UpdateVisibilityVisitor</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Update the visibility.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::UpdateVisibilityVisitor :</div>
<div class="line"> <span class="keyword">public</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateVisibilityVisitor&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateVisibilityVisitor&gt; ParentClass;</div>
<div class="line"></div>
<div class="line">    UpdateVisibilityVisitor(SubSceneOverride&amp;      subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;    container,</div>
<div class="line">                            SubNodeRenderItemList&amp; subNodeItems,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span>             outOfViewFrustum)</div>
<div class="line">        : ParentClass(subSceneOverride, container, subNodeItems),</div>
<div class="line">          fVisibility(!outOfViewFrustum)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// The visibility visitor should always traverse into invisible sub-nodes</span></div>
<div class="line"> <span class="comment">// because we have to disable the render items for these invisible sub-nodes.</span></div>
<div class="line">        setTraverseInvisible(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~UpdateVisibilityVisitor()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> canPrune(<span class="keyword">const</span> HierarchyStat::SubNodeStat&amp; stat)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> !stat.isVisibilityAnimated;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> update(<span class="keyword">const</span> ShapeData&amp;         shape,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;           subNode,</div>
<div class="line">                SubNodeRenderItems::Ptr&amp; subNodeItems)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Get the shape sample.</span></div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const ShapeSample&gt;&amp; sample =</div>
<div class="line">            shape.getSample(fSubSceneOverride.getTime());</div>
<div class="line"> <span class="keywordflow">if</span> (!sample) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Shape visibility.</span></div>
<div class="line"> <span class="keywordtype">bool</span> visibility = fVisibility &amp;&amp; sample-&gt;visibility();</div>
<div class="line"></div>
<div class="line">        subNodeItems-&gt;updateVisibility(</div>
<div class="line">            fSubSceneOverride,</div>
<div class="line">            fContainer,</div>
<div class="line">            visibility,</div>
<div class="line">            shape</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp;   xform,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Get the xform sample.</span></div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>
<div class="line">            xform.getSample(fSubSceneOverride.getTime());</div>
<div class="line"> <span class="keywordflow">if</span> (!sample) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Push visibility.</span></div>
<div class="line">        ScopedGuard&lt;bool&gt; guard(fVisibility);</div>
<div class="line">        fVisibility = fVisibility &amp;&amp; sample-&gt;visibility();</div>
<div class="line"></div>
<div class="line">        ParentClass::visit(xform, subNode);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="keywordtype">bool</span> fVisibility;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::UpdateWorldMatrixVisitor</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Update the world matrices.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::UpdateWorldMatrixVisitor :</div>
<div class="line"> <span class="keyword">public</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateWorldMatrixVisitor&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateWorldMatrixVisitor&gt; ParentClass;</div>
<div class="line"></div>
<div class="line">    UpdateWorldMatrixVisitor(SubSceneOverride&amp;      subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;    container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a>&amp;         dagMatrix,</div>
<div class="line">                             SubNodeRenderItemList&amp; subNodeItems)</div>
<div class="line">        : ParentClass(subSceneOverride, container, subNodeItems),</div>
<div class="line">          fMatrix(dagMatrix)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~UpdateWorldMatrixVisitor()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> canPrune(<span class="keyword">const</span> HierarchyStat::SubNodeStat&amp; stat)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> !stat.isXformAnimated;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> update(<span class="keyword">const</span> ShapeData&amp;         shape,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;           subNode,</div>
<div class="line">                SubNodeRenderItems::Ptr&amp; subNodeItems)</div>
<div class="line">    {</div>
<div class="line">        subNodeItems-&gt;updateWorldMatrix(</div>
<div class="line">            fSubSceneOverride,</div>
<div class="line">            fContainer,</div>
<div class="line">            fMatrix,</div>
<div class="line">            shape</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> visit(<span class="keyword">const</span> XformData&amp;   xform,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;     subNode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line"> <span class="comment">// Get the xform sample.</span></div>
<div class="line"> <span class="keyword">const</span> std::shared_ptr&lt;const XformSample&gt;&amp; sample =</div>
<div class="line">            xform.getSample(fSubSceneOverride.getTime());</div>
<div class="line"> <span class="keywordflow">if</span> (!sample) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Push matrix.</span></div>
<div class="line">        ScopedGuard&lt;MMatrix&gt; guard(fMatrix);</div>
<div class="line">        fMatrix = sample-&gt;xform() * fMatrix;</div>
<div class="line"></div>
<div class="line">        ParentClass::visit(xform, subNode);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <a class="code" href="./class_m_matrix.html">MMatrix</a> fMatrix;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::UpdateStreamsVisitor</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Update the streams.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::UpdateStreamsVisitor :</div>
<div class="line"> <span class="keyword">public</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateStreamsVisitor&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateStreamsVisitor&gt; ParentClass;</div>
<div class="line"></div>
<div class="line">    UpdateStreamsVisitor(SubSceneOverride&amp;      subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;    container,</div>
<div class="line">                         SubNodeRenderItemList&amp; subNodeItems)</div>
<div class="line">        : ParentClass(subSceneOverride, container, subNodeItems)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~UpdateStreamsVisitor()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> canPrune(<span class="keyword">const</span> HierarchyStat::SubNodeStat&amp; stat)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> !stat.isShapeAnimated;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> update(<span class="keyword">const</span> ShapeData&amp;         shape,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;           subNode,</div>
<div class="line">                SubNodeRenderItems::Ptr&amp; subNodeItems)</div>
<div class="line">    {</div>
<div class="line">        subNodeItems-&gt;updateStreams(</div>
<div class="line">            fSubSceneOverride,</div>
<div class="line">            fContainer,</div>
<div class="line">            shape</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::UpdateDiffuseColorVisitor</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Update the streams.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::UpdateDiffuseColorVisitor :</div>
<div class="line"> <span class="keyword">public</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateDiffuseColorVisitor&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> SubSceneOverride::UpdateVisitorWithPrune&lt;SubSceneOverride::UpdateDiffuseColorVisitor&gt; ParentClass;</div>
<div class="line"></div>
<div class="line">    UpdateDiffuseColorVisitor(SubSceneOverride&amp;      subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;    container,</div>
<div class="line">                              SubNodeRenderItemList&amp; subNodeItems)</div>
<div class="line">        : ParentClass(subSceneOverride, container, subNodeItems)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~UpdateDiffuseColorVisitor()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"> </span>{}</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> canPrune(<span class="keyword">const</span> HierarchyStat::SubNodeStat&amp; stat)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">return</span> !stat.isDiffuseColorAnimated;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> update(<span class="keyword">const</span> ShapeData&amp;         shape,</div>
<div class="line"> <span class="keyword">const</span> SubNode&amp;           subNode,</div>
<div class="line">                SubNodeRenderItems::Ptr&amp; subNodeItems)</div>
<div class="line">    {</div>
<div class="line">        subNodeItems-&gt;updateMaterials(</div>
<div class="line">            fSubSceneOverride,</div>
<div class="line">            fContainer,</div>
<div class="line">            shape</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride::InstanceRenderItems</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This class contains the render items for an instance of gpuCache node.</span></div>
<div class="line"><span class="keyword">class </span>SubSceneOverride::InstanceRenderItems</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">typedef</span> std::shared_ptr&lt;InstanceRenderItems&gt; Ptr;</div>
<div class="line"></div>
<div class="line">    InstanceRenderItems()</div>
<div class="line">        : fVisibility(true),</div>
<div class="line">          fVisibilityValid(false),</div>
<div class="line">          fWorldMatrixValid(false),</div>
<div class="line">          fStreamsValid(false),</div>
<div class="line">          fMaterialsValid(false)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    ~InstanceRenderItems()</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    InstanceRenderItems(<span class="keyword">const</span> InstanceRenderItems&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    InstanceRenderItems&amp; operator=(<span class="keyword">const</span> InstanceRenderItems&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the bounding box render item.</span></div>
<div class="line"> <span class="keywordtype">void</span> updateRenderItems(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp;     dagPath,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp;      instancePrefix)</div>
<div class="line">    {</div>
<div class="line">        assert(dagPath.<a class="code" href="./class_m_dag_path.html#a095ae34296e81703965265a42ee783ca">isValid</a>());</div>
<div class="line"> <span class="keywordflow">if</span> (!dagPath.<a class="code" href="./class_m_dag_path.html#a095ae34296e81703965265a42ee783ca">isValid</a>()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set the path of this instance.</span></div>
<div class="line">        fDagPath = dagPath;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if we can see the DAG node.</span></div>
<div class="line">        fVisibility = dagPath.<a name="a80"></a><a class="code" href="./class_m_dag_path.html#a27f324b7f2643119a7542e39101601d1">isVisible</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Early out if we can't see this instance.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fVisibility) {</div>
<div class="line"> <span class="comment">// Disable all render items that belong to this instance.</span></div>
<div class="line"> <span class="keywordflow">for</span>(SubNodeRenderItemList::value_type&amp; items : fSubNodeItems) {</div>
<div class="line">                items-&gt;hideRenderItems();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We have disabled all render items that belong to this instance.</span></div>
<div class="line"> <span class="comment">// When the DAG object is visible again, we need to restore visibility.</span></div>
<div class="line">            fVisibilityValid = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if this instance is selected.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bca">DisplayStatus</a> displayStatus =</div>
<div class="line">            MGeometryUtilities::displayStatus(dagPath);</div>
<div class="line">        fIsSelected = (displayStatus == <a class="code" href="./namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bcaab6a8784b4cf96692e0d71d19c44ce732">kActive</a>) ||</div>
<div class="line">                      (displayStatus == kLead)   ||</div>
<div class="line">                      (displayStatus == <a class="code" href="./namespace_m_h_w_render.html#ad9c34c5373567566950642c16a7c4bcaa88694d85749c9c85738c56c4912c385a">kHilite</a>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the wireframe color for the whole gpuCache node.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_color.html">MColor</a> wireColor = MGeometryUtilities::wireframeColor(dagPath);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the bounding box render item.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fBoundingBoxItem) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> boundingBoxName = instancePrefix + <span class="stringliteral">"BoundingBox"</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Create the bounding box render item.</span></div>
<div class="line">            fBoundingBoxItem.reset(<span class="keyword">new</span> RenderItemWrapper(</div>
<div class="line">                boundingBoxName,</div>
<div class="line">                MRenderItem::NonMaterialSceneItem,</div>
<div class="line">                MGeometry::kLines</div>
<div class="line">            ));</div>
<div class="line">            fBoundingBoxItem-&gt;setDrawMode(MGeometry::kBoundingBox);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set the shader so that we can fill geometry data.</span></div>
<div class="line">            fBoundingBoxShader =</div>
<div class="line">                ShaderInstanceCache::getInstance().getSharedWireShader(wireColor);</div>
<div class="line"> <span class="keywordflow">if</span> (fBoundingBoxShader) {</div>
<div class="line">                fBoundingBoxItem-&gt;setShader(fBoundingBoxShader);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add to the container.</span></div>
<div class="line">            fBoundingBoxItem-&gt;addToContainer(container);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set unit bounding box buffer.</span></div>
<div class="line">            fBoundingBoxItem-&gt;setBuffers(</div>
<div class="line">                subSceneOverride,</div>
<div class="line">                UnitBoundingBox::indices(),</div>
<div class="line">                UnitBoundingBox::positions(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                std::shared_ptr&lt;const VertexBuffer&gt;(),</div>
<div class="line">                UnitBoundingBox::boundingBox()</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Bounding box color</span></div>
<div class="line">        fBoundingBoxShader =</div>
<div class="line">            ShaderInstanceCache::getInstance().getSharedWireShader(wireColor);</div>
<div class="line"> <span class="keywordflow">if</span> (fBoundingBoxShader) {</div>
<div class="line">            fBoundingBoxItem-&gt;setShader(fBoundingBoxShader);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Bounding box depth priority</span></div>
<div class="line">        fBoundingBoxItem-&gt;setDepthPriority(</div>
<div class="line">            fIsSelected ?</div>
<div class="line">                MRenderItem::sActiveWireDepthPriority :</div>
<div class="line">                MRenderItem::sDormantWireDepthPriority</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">        fBoundingBoxItem-&gt;setEnabled(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the sub-node render items.</span></div>
<div class="line">        UpdateRenderItemsVisitor visitor(subSceneOverride, container,</div>
<div class="line">            instancePrefix, wireColor, fIsSelected, fSubNodeItems);</div>
<div class="line">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateVisibility(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span>          outOfViewFrustum)</div>
<div class="line">    {</div>
<div class="line">        assert(fDagPath.isValid());</div>
<div class="line"> <span class="keywordflow">if</span> (!fDagPath.isValid()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Early out if we can't see this instance.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fVisibility) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Disable visibility animation checks so that we turn off all render</span></div>
<div class="line"> <span class="comment">// items when the geometry goes out of the view frustum. Otherwise,</span></div>
<div class="line"> <span class="comment">// only visibility-animated render items are updated..</span></div>
<div class="line"> <span class="comment">// Visibility is updated once when the geometry moves out of the view</span></div>
<div class="line"> <span class="comment">// frustum. requiresUpdate() should return false for the following</span></div>
<div class="line"> <span class="comment">// frames so disable the check won't affect performance when the</span></div>
<div class="line"> <span class="comment">// render items are view-frustum-culled.</span></div>
<div class="line"> <span class="keywordflow">if</span> (outOfViewFrustum) {</div>
<div class="line">            fVisibilityValid = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the sub-node visibility.</span></div>
<div class="line">        UpdateVisibilityVisitor visitor(subSceneOverride, container, fSubNodeItems, outOfViewFrustum);</div>
<div class="line">        visitor.setDontPrune(!fVisibilityValid);</div>
<div class="line">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>
<div class="line">        fVisibilityValid = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Keep the visibility animation checks off so the visibility will be</span></div>
<div class="line"> <span class="comment">// updated again when the geometry moves into the view frustum.</span></div>
<div class="line"> <span class="keywordflow">if</span> (outOfViewFrustum) {</div>
<div class="line">            fVisibilityValid = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateWorldMatrix(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        assert(fDagPath.isValid());</div>
<div class="line"> <span class="keywordflow">if</span> (!fDagPath.isValid()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Early out if we can't see this instance.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fVisibility) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The DAG node's world matrix.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a> pathMatrix = fDagPath.inclusiveMatrix();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> pathMatrixChanged = fMatrix != pathMatrix;</div>
<div class="line">        fMatrix = pathMatrix;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the bounding box render item's world matrix.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fBoundingBoxItem) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a> boundingBox = BoundingBoxVisitor::boundingBox(</div>
<div class="line">                subSceneOverride.getGeometry(),</div>
<div class="line">                subSceneOverride.getTime()</div>
<div class="line">            );</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a> worldMatrix =</div>
<div class="line">                UnitBoundingBox::boundingBoxMatrix(boundingBox) * fMatrix;</div>
<div class="line">            fBoundingBoxItem-&gt;setWorldMatrix(worldMatrix);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the sub-node world matrices</span></div>
<div class="line">        UpdateWorldMatrixVisitor visitor(subSceneOverride, container,</div>
<div class="line">            fMatrix, fSubNodeItems);</div>
<div class="line">        visitor.setDontPrune(pathMatrixChanged || !fWorldMatrixValid);  <span class="comment">// The DAG object's matrix has changed.</span></div>
<div class="line">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>
<div class="line">        fWorldMatrixValid = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateStreams(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        assert(fDagPath.isValid());</div>
<div class="line"> <span class="keywordflow">if</span> (!fDagPath.isValid()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Early out if we can't see this instance.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fVisibility) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the sub-node streams.</span></div>
<div class="line">        UpdateStreamsVisitor visitor(subSceneOverride, container, fSubNodeItems);</div>
<div class="line">        visitor.setDontPrune(!fStreamsValid);</div>
<div class="line">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>
<div class="line">        fStreamsValid = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> updateMaterials(SubSceneOverride&amp;   subSceneOverride,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line">        assert(fDagPath.isValid());</div>
<div class="line"> <span class="keywordflow">if</span> (!fDagPath.isValid()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Early out if we can't see this instance.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fVisibility) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the sub-node diffuse color materials.</span></div>
<div class="line">        UpdateDiffuseColorVisitor visitor(subSceneOverride, container, fSubNodeItems);</div>
<div class="line">        visitor.setDontPrune(!fMaterialsValid);</div>
<div class="line">        subSceneOverride.getGeometry()-&gt;accept(visitor);</div>
<div class="line">        fMaterialsValid = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> destroyRenderItems(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Destroy the bounding box render item for this instance.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fBoundingBoxItem) {</div>
<div class="line">            fBoundingBoxItem-&gt;removeFromContainer(container);</div>
<div class="line">            fBoundingBoxItem.reset();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Destroy the sub node render items.</span></div>
<div class="line"> <span class="keywordflow">for</span>(SubNodeRenderItems::Ptr&amp; subNodeItem : fSubNodeItems) {</div>
<div class="line">            subNodeItem-&gt;destroyRenderItems(container);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <a class="code" href="./class_m_dag_path.html">MDagPath</a>               fDagPath;</div>
<div class="line"> <span class="keywordtype">bool</span>                   fIsSelected;</div>
<div class="line"> <span class="keywordtype">bool</span>                   fVisibility;</div>
<div class="line"> <a class="code" href="./class_m_matrix.html">MMatrix</a>                fMatrix;</div>
<div class="line">    RenderItemWrapper::Ptr fBoundingBoxItem;</div>
<div class="line">    ShaderInstancePtr      fBoundingBoxShader;</div>
<div class="line">    SubNodeRenderItemList  fSubNodeItems;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> fVisibilityValid;</div>
<div class="line"> <span class="keywordtype">bool</span> fWorldMatrixValid;</div>
<div class="line"> <span class="keywordtype">bool</span> fStreamsValid;</div>
<div class="line"> <span class="keywordtype">bool</span> fMaterialsValid;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS SubSceneOverride</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><a name="_a81"></a><a class="code" href="./class_m_h_w_render_1_1_m_px_sub_scene_override.html">MPxSubSceneOverride</a>* SubSceneOverride::creator(<span class="keyword">const</span> <a class="code" href="./class_m_object.html">MObject</a>&amp; <span class="keywordtype">object</span>)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">new</span> SubSceneOverride(<span class="keywordtype">object</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::clear()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Delete the buffers in the cache.</span></div>
<div class="line">    BuffersCache::getInstance().clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a>* SubSceneOverride::lookup(<span class="keyword">const</span> std::shared_ptr&lt;const IndexBuffer&gt;&amp; indices)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Find the corresponding index buffer.</span></div>
<div class="line"> <span class="keywordflow">return</span> BuffersCache::getInstance().lookup(indices);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a>* SubSceneOverride::lookup(<span class="keyword">const</span> std::shared_ptr&lt;const VertexBuffer&gt;&amp; vertices)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Find the corresponding vertex buffer.</span></div>
<div class="line"> <span class="keywordflow">return</span> BuffersCache::getInstance().lookup(vertices);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">SubSceneOverride::SubSceneOverride(<span class="keyword">const</span> <a class="code" href="./class_m_object.html">MObject</a>&amp; <span class="keywordtype">object</span>)</div>
<div class="line">    : <a class="code" href="./class_m_h_w_render_1_1_m_px_sub_scene_override.html">MPxSubSceneOverride</a>(object),</div>
<div class="line">      fObject(object),</div>
<div class="line">      fShapeNode(NULL),</div>
<div class="line">      fUpdateRenderItemsRequired(true),</div>
<div class="line">      fUpdateVisibilityRequired(true),</div>
<div class="line">      fUpdateWorldMatrixRequired(true),</div>
<div class="line">      fUpdateStreamsRequired(true),</div>
<div class="line">      fUpdateMaterialsRequired(true),</div>
<div class="line">      fOutOfViewFrustum(false),</div>
<div class="line">      fOutOfViewFrustumUpdated(false),</div>
<div class="line">      fWireOnShadedMode(DisplayPref::kWireframeOnShadedFull)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Extract the ShapeNode pointer.</span></div>
<div class="line"> <a class="code" href="./class_m_fn_dag_node.html">MFnDagNode</a> dagNode(<span class="keywordtype">object</span>);</div>
<div class="line">    fShapeNode = (<span class="keyword">const</span> ShapeNode*)dagNode.<a class="code" href="./class_m_fn_dependency_node.html#a4f2c53c9d1dcf25a6462c70fb25aead1">userNode</a>();</div>
<div class="line">    assert(fShapeNode);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get all DAG paths.</span></div>
<div class="line">    resetDagPaths();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache the non-networked plugs.</span></div>
<div class="line">    fCastsShadowsPlug   = dagNode.<a name="a82"></a><a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(<span class="stringliteral">"castsShadows"</span>, <span class="keyword">false</span>);</div>
<div class="line">    fReceiveShadowsPlug = dagNode.<a class="code" href="./class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(<span class="stringliteral">"receiveShadows"</span>, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Register callbacks</span></div>
<div class="line"> <a class="code" href="./class_m_dag_path.html">MDagPath</a> dagPath;</div>
<div class="line"> <a name="a83"></a><a class="code" href="./class_m_dag_path.html#a422aa5ec02565f757c13fe2873ed25d7">MDagPath::getAPathTo</a>(<span class="keywordtype">object</span>, dagPath);  <span class="comment">// any path</span></div>
<div class="line">    fInstanceAddedCallback = <a name="a84"></a><a class="code" href="./class_m_dag_message.html#a9c301d5a30d9424eea522166b283a98d">MDagMessage::addInstanceAddedDagPathCallback</a>(</div>
<div class="line">        dagPath, InstanceChangedCallback, <span class="keyword">this</span>);</div>
<div class="line">    fInstanceRemovedCallback = <a name="a85"></a><a class="code" href="./class_m_dag_message.html#aafe921878a14c3ae07f6a453773c59e2">MDagMessage::addInstanceRemovedDagPathCallback</a>(</div>
<div class="line">        dagPath, InstanceChangedCallback, <span class="keyword">this</span>);</div>
<div class="line">    fWorldMatrixChangedCallback = <a name="a86"></a><a class="code" href="./class_m_dag_message.html#a33a28fd9c6b6fbaa4fefe2c849f76636">MDagMessage::addWorldMatrixModifiedCallback</a>(</div>
<div class="line">        dagPath, WorldMatrixChangedCallback, <span class="keyword">this</span>);</div>
<div class="line">    registerNodeDirtyCallbacks();</div>
<div class="line">    ModelCallbacks::getInstance().registerSubSceneOverride(fShapeNode, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">    fUpdateTime = clock();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">SubSceneOverride::~SubSceneOverride()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Deregister callbacks</span></div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fInstanceAddedCallback);</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fInstanceRemovedCallback);</div>
<div class="line"> <a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(fWorldMatrixChangedCallback);</div>
<div class="line"> <a name="a87"></a><a class="code" href="./class_m_message.html#ac637287cc26b707b9e1a175a32f44e29">MMessage::removeCallbacks</a>(fNodeDirtyCallbacks);</div>
<div class="line">    ModelCallbacks::getInstance().deregisterSubSceneOverride(fShapeNode);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Destroy render items.</span></div>
<div class="line">    fInstanceRenderItems.clear();</div>
<div class="line">    fHardwareInstanceManager.reset();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49">MHWRender::DrawAPI</a> SubSceneOverride::supportedDrawAPIs()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="comment">// We support both OpenGL and DX11 in VP2.0!</span></div>
<div class="line"> <span class="keywordflow">return</span> <a name="a88"></a><a class="code" href="./namespace_m_h_w_render.html#ad970d5c990d4803d0e9d73c1ff4fda49a98fc59e3a63859014185d6ff7f574a3b">MHWRender::kAllDevices</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> SubSceneOverride::requiresUpdate(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp; container,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a89"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html">MFrameContext</a>&amp;      frameContext)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    assert(fShapeNode);</div>
<div class="line"> <span class="keywordflow">if</span> (!fShapeNode) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Cache the DAG paths for all instances.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fInstanceDagPaths.length() == 0) {</div>
<div class="line">        SubSceneOverride* nonConstThis = <span class="keyword">const_cast&lt;</span>SubSceneOverride*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);</div>
<div class="line"> <a name="a90"></a><a class="code" href="./class_m_dag_path.html#a6e4195497a9d3f031d159ddb60f94e74">MDagPath::getAllPathsTo</a>(fObject, nonConstThis-&gt;fInstanceDagPaths);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Turn on/off hardware instancing.</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> hwInstancing = useHardwareInstancing();</div>
<div class="line"> <span class="keywordflow">if</span> ((hwInstancing &amp;&amp; !fHardwareInstanceManager) ||</div>
<div class="line">            (!hwInstancing &amp;&amp; fHardwareInstanceManager)) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the cached geometry and materials.</span></div>
<div class="line">    SubNode::Ptr          geometry = fShapeNode-&gt;getCachedGeometry();</div>
<div class="line">    MaterialGraphMap::Ptr material = fShapeNode-&gt;getCachedMaterial();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if the cached geometry or materials have been changed.</span></div>
<div class="line"> <span class="keywordflow">if</span> (geometry != fGeometry || material != fMaterial) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if the Wireframe on Shaded mode has been changed.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fWireOnShadedMode != DisplayPref::wireframeOnShadedMode()) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Skip update if all instances are out of view frustum.</span></div>
<div class="line"> <span class="comment">// Only cull when we are using default lights.</span></div>
<div class="line"> <span class="comment">// Shadow map generation requires the update() even if the whole</span></div>
<div class="line"> <span class="comment">// DAG object is out of the camera view frustum.</span></div>
<div class="line"> <span class="keywordflow">if</span> (geometry &amp;&amp; frameContext.<a name="a91"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#a376f1eeaa26e24a893afacff7db169bc">getLightingMode</a>() == MFrameContext::kLightDefault) {</div>
<div class="line"> <span class="comment">// The world view proj inv matrix.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a> viewProjInv = frameContext.<a name="a92"></a><a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html#a71cbe2a3f2dfa967ebc43b5e97456ccb">getMatrix</a>(MFrameContext::kViewProjInverseMtx);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The bounding box in local DAG transform space.</span></div>
<div class="line">        BoundingBoxVisitor visitor(<a name="a93"></a><a class="code" href="./class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().as(<a name="a94"></a><a class="code" href="./class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>));</div>
<div class="line">        geometry-&gt;accept(visitor);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> outOfViewFrustum = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fInstanceDagPaths.length(); i++) {</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_matrix.html">MMatrix</a> worldInv = fInstanceDagPaths[i].inclusiveMatrixInverse();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Test view frustum.</span></div>
<div class="line">            Frustum frustum(viewProjInv * worldInv,</div>
<div class="line">                renderer-&gt;<a name="a95"></a><a class="code" href="./class_m_h_w_render_1_1_m_renderer.html#aac2a5827e6a0ce3333e62ffa7751ba5e">drawAPIIsOpenGL</a>() ? Frustum::kOpenGL : Frustum::kDirectX);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (frustum.test(visitor.boundingBox()) != Frustum::kOutside) {</div>
<div class="line">                outOfViewFrustum = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We know all the render items are going to be culled so skip update them.</span></div>
<div class="line"> <span class="keywordflow">if</span> (outOfViewFrustum) {</div>
<div class="line"> <span class="comment">// It's important to call update() once after the shape is out of the view frustum.</span></div>
<div class="line"> <span class="comment">// This will make sure all render items are going to be culled.</span></div>
<div class="line"> <span class="comment">// If the render items are still going to be culled in this frame,</span></div>
<div class="line"> <span class="comment">// we can then skip calling update().</span></div>
<div class="line"> <span class="keywordflow">if</span> (fOutOfViewFrustum &amp;&amp; fOutOfViewFrustumUpdated) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        SubSceneOverride* nonConstThis = <span class="keyword">const_cast&lt;</span>SubSceneOverride*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (fOutOfViewFrustum ^ outOfViewFrustum) {</div>
<div class="line"> <span class="comment">// Update the visibility of render items when the geometry moves</span></div>
<div class="line"> <span class="comment">// into the view frustum or when it goes out of the view frustum.</span></div>
<div class="line">            nonConstThis-&gt;dirtyVisibility();</div>
<div class="line">        }</div>
<div class="line">        nonConstThis-&gt;fOutOfViewFrustum        = outOfViewFrustum;</div>
<div class="line">        nonConstThis-&gt;fOutOfViewFrustumUpdated = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// Reset view frustum culling flags</span></div>
<div class="line">        SubSceneOverride* nonConstThis = <span class="keyword">const_cast&lt;</span>SubSceneOverride*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (fOutOfViewFrustum) {</div>
<div class="line">            nonConstThis-&gt;dirtyVisibility();</div>
<div class="line">        }</div>
<div class="line">        nonConstThis-&gt;fOutOfViewFrustum        = <span class="keyword">false</span>;</div>
<div class="line">        nonConstThis-&gt;fOutOfViewFrustumUpdated = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if we are loading geometry in background.</span></div>
<div class="line">    CacheFileEntry::BackgroundReadingState readingState = fShapeNode-&gt;backgroundReadingState();</div>
<div class="line"> <span class="keywordflow">if</span> (readingState != fReadingState) {</div>
<div class="line"> <span class="comment">// Force an update when reading is done.</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (readingState != CacheFileEntry::kReadingDone) {</div>
<div class="line"> <span class="comment">// Don't update too frequently.</span></div>
<div class="line">        clock_t currentTime = clock();</div>
<div class="line"> <span class="keywordtype">int</span> total_milliseconds = (currentTime - fUpdateTime) * 1000 /CLOCKS_PER_SEC;</div>
<div class="line"> <span class="keywordflow">if</span> (total_milliseconds &gt;= (<span class="keywordtype">int</span>)(Config::backgroundReadingRefresh() / 2)) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> fUpdateRenderItemsRequired ||</div>
<div class="line">            fUpdateVisibilityRequired ||</div>
<div class="line">            fUpdateWorldMatrixRequired ||</div>
<div class="line">            fUpdateStreamsRequired ||</div>
<div class="line">            fUpdateMaterialsRequired;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::update(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MSubSceneContainer</a>&amp;  container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html">MFrameContext</a>&amp; frameContext)</div>
<div class="line">{</div>
<div class="line">    assert(fShapeNode);</div>
<div class="line"> <span class="keywordflow">if</span> (!fShapeNode) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Register node dirty callbacks if necessary.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fNodeDirtyCallbacks.length() == 0) {</div>
<div class="line">        registerNodeDirtyCallbacks();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update hardware instances.</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> hwInstancing = useHardwareInstancing();</div>
<div class="line"> <span class="keywordflow">if</span> (hwInstancing &amp;&amp; !fHardwareInstanceManager) {</div>
<div class="line"> <span class="comment">// Turn on hardware instancing.</span></div>
<div class="line">        dirtyRenderItems();     <span class="comment">// force updating</span></div>
<div class="line">        fHardwareInstanceManager.reset(<span class="keyword">new</span> HardwareInstanceManager(*<span class="keyword">this</span>));</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!hwInstancing &amp;&amp; fHardwareInstanceManager) {</div>
<div class="line"> <span class="comment">// Turn off hardware instancing.</span></div>
<div class="line">        fHardwareInstanceManager-&gt;resetInstances(container);</div>
<div class="line">        fHardwareInstanceManager.reset();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Shrink the buffer cache to make room for new buffers.</span></div>
<div class="line"> <span class="comment">// When the total size of the buffers is hitting the threshold,</span></div>
<div class="line"> <span class="comment">// buffers that are not used by any render items will be evicted.</span></div>
<div class="line">    BuffersCache::getInstance().shrink();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Get the cached geometry and materials.</span></div>
<div class="line">    SubNode::Ptr          geometry = fShapeNode-&gt;getCachedGeometry();</div>
<div class="line">    MaterialGraphMap::Ptr material = fShapeNode-&gt;getCachedMaterial();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Remember the current time.</span></div>
<div class="line">    fUpdateTime = clock();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if the cached geometry or materials have been changed.</span></div>
<div class="line"> <span class="keywordflow">if</span> (geometry != fGeometry || material != fMaterial) {</div>
<div class="line"> <span class="comment">// Set the cached geometry and materials.</span></div>
<div class="line">        fGeometry = geometry;</div>
<div class="line">        fMaterial = material;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Rebuild render items.</span></div>
<div class="line">        fInstanceRenderItems.clear();</div>
<div class="line">        container.<a name="a96"></a><a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>();</div>
<div class="line">        fHierarchyStat.reset();</div>
<div class="line">        dirtyEverything();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check if we are loading geometry in background.</span></div>
<div class="line">    CacheFileEntry::BackgroundReadingState readingState = fShapeNode-&gt;backgroundReadingState();</div>
<div class="line"> <span class="keywordflow">if</span> (readingState != fReadingState || readingState != CacheFileEntry::kReadingDone) {</div>
<div class="line"> <span class="comment">// Background reading has not finished. Update all render items.</span></div>
<div class="line"> <span class="comment">// (Remove bounding box render items and add shaded/wire render items.)</span></div>
<div class="line">        fReadingState = readingState;</div>
<div class="line">        dirtyEverything();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the render items to match the Wireframe on Shaded mode.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fWireOnShadedMode != DisplayPref::wireframeOnShadedMode()) {</div>
<div class="line">        fWireOnShadedMode = DisplayPref::wireframeOnShadedMode();</div>
<div class="line">        dirtyRenderItems();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Current time in seconds</span></div>
<div class="line">    fTimeInSeconds = <a class="code" href="./class_m_anim_control.html#a8cb1e013d828c1d012fee789b14e0060">MAnimControl::currentTime</a>().<a name="a97"></a><a class="code" href="./class_m_time.html#a105d41236561f4d4be6383ced757a429">as</a>(<a class="code" href="./class_m_time.html#abceb2331ad056e3c5ad27894199a49eda3091d1a096c28d4993507f167253ebc7">MTime::kSeconds</a>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the render items.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fUpdateRenderItemsRequired) {</div>
<div class="line">        updateRenderItems(container, frameContext);</div>
<div class="line">        fUpdateRenderItemsRequired = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the visibility.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fUpdateVisibilityRequired) {</div>
<div class="line">        updateVisibility(container, frameContext);</div>
<div class="line">        fUpdateVisibilityRequired = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the world matrices.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fUpdateWorldMatrixRequired) {</div>
<div class="line">        updateWorldMatrix(container, frameContext);</div>
<div class="line">        fUpdateWorldMatrixRequired = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update streams.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fUpdateStreamsRequired) {</div>
<div class="line">        updateStreams(container, frameContext);</div>
<div class="line">        fUpdateStreamsRequired = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update materials.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fUpdateMaterialsRequired) {</div>
<div class="line">        updateMaterials(container, frameContext);</div>
<div class="line">        fUpdateMaterialsRequired = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Analysis the sub-node hierarchy so that we can prune it.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fHierarchyStat &amp;&amp; fReadingState == CacheFileEntry::kReadingDone &amp;&amp; fGeometry) {</div>
<div class="line">        HierarchyStatVisitor visitor(fGeometry);</div>
<div class="line">        fGeometry-&gt;accept(visitor);</div>
<div class="line">        fHierarchyStat = visitor.getStat();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The geometry is fully loaded. Recompute the shadow map.</span></div>
<div class="line">        MRenderer::setLightsAndShadowsDirty();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update hardware instancing.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fHardwareInstanceManager) {</div>
<div class="line">        fHardwareInstanceManager-&gt;processInstances(container);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We have done update() when the shape is out of view frustum.</span></div>
<div class="line"> <span class="keywordflow">if</span> (fOutOfViewFrustum) {</div>
<div class="line"> <span class="comment">// There is a situation that both the render items and the camera are</span></div>
<div class="line"> <span class="comment">// animated and the render items are out-of-view-frustum for frames.</span></div>
<div class="line"> <span class="comment">// We skip update() for performance so we don't have chances to update</span></div>
<div class="line"> <span class="comment">// the matrix or geometry of the render item. We need to turn off the</span></div>
<div class="line"> <span class="comment">// render items until the render items appear in the view frustum again.</span></div>
<div class="line"> <span class="comment">// MRenderItem::enable(false) is called in updateVisibility() method.</span></div>
<div class="line">        fOutOfViewFrustumUpdated = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> SubSceneOverride::getInstancedSelectionPath(<span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>&amp; renderItem, <span class="keyword">const</span> <a name="_a98"></a><a class="code" href="./class_m_h_w_render_1_1_m_intersection.html">MHWRender::MIntersection</a>&amp; intersection, <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; dagPath)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pathIndex = -1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// When using hardware accelerated instancing, the InstanceID</span></div>
<div class="line"> <span class="comment">// information will be found in the intersection:</span></div>
<div class="line"> <span class="keywordtype">int</span> hardwareInstanceIndex = intersection.<a name="a99"></a><a class="code" href="./class_m_h_w_render_1_1_m_intersection.html#a35ab9f5cd2b7e3c46d5c661d9cd73571">instanceID</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (hardwareInstanceIndex &gt;= 0)</div>
<div class="line">    {</div>
<div class="line">        pathIndex = fHardwareInstanceManager-&gt;instancePathIndex(renderItem, hardwareInstanceIndex);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// The path to the instance is encoded in the render item name:</span></div>
<div class="line"> <a class="code" href="./class_m_string_array.html">MStringArray</a> renderItemParts;</div>
<div class="line">        renderItem.<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#aca2cba4630391c78dcf1a828986160da">name</a>().<a class="code" href="./class_m_string.html#ac914d138fc96d7065c687a4f8b40c263">split</a>(<span class="charliteral">':'</span>, renderItemParts);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (renderItemParts.<a class="code" href="./class_m_string_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 1 &amp;&amp; renderItemParts[0].isUnsigned())</div>
<div class="line">        {</div>
<div class="line">            pathIndex = renderItemParts[0].asUnsigned();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (pathIndex &lt; fInstanceDagPaths.length())</div>
<div class="line">    {</div>
<div class="line">            dagPath.<a name="a100"></a><a class="code" href="./class_m_dag_path.html#a0803071a27de28ea0eee7fdc7812de95">set</a>(fInstanceDagPaths[pathIndex]);</div>
<div class="line"> <span class="keywordflow">if</span> (dagPath.<a name="a101"></a><a class="code" href="./class_m_dag_path.html#af321be336f1f2d96ac2273a87cb3c8ab">length</a>() &gt; 1)</div>
<div class="line">                dagPath.<a name="a102"></a><a class="code" href="./class_m_dag_path.html#ac71eca2b78b8cfc088adc9af6f851dfd">pop</a>(); <span class="comment">// from shape to xform.</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::updateSelectionGranularity(<span class="keyword">const</span> <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; path, <a name="_a103"></a><a class="code" href="./class_m_h_w_render_1_1_m_selection_context.html">MHWRender::MSelectionContext</a>&amp; selectionContext)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// We do allow snapping, even though vertex are not selectable as components.</span></div>
<div class="line"> <span class="keywordflow">if</span> (pointSnappingActive())</div>
<div class="line">    {</div>
<div class="line">        selectionContext.<a name="a104"></a><a class="code" href="./class_m_h_w_render_1_1_m_selection_context.html#ab1ead3c2bb71ebaaaa7b94b8a1dcaa3b">setSelectionLevel</a>(<a name="a105"></a><a class="code" href="./class_m_h_w_render_1_1_m_selection_context.html#a9bf800a895c6bfc0ef3fce84fb30625da02fee4c0e0e6f1b7ab7a678d61627461">MHWRender::MSelectionContext::kComponent</a>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::dirtyEverything()</div>
<div class="line">{</div>
<div class="line">    dirtyRenderItems();</div>
<div class="line">    dirtyVisibility();</div>
<div class="line">    dirtyWorldMatrix();</div>
<div class="line">    dirtyStreams();</div>
<div class="line">    dirtyMaterials();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::dirtyRenderItems()</div>
<div class="line">{</div>
<div class="line">    fUpdateRenderItemsRequired = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::dirtyVisibility()</div>
<div class="line">{</div>
<div class="line">    fUpdateVisibilityRequired = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::dirtyWorldMatrix()</div>
<div class="line">{</div>
<div class="line">    fUpdateWorldMatrixRequired = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::dirtyStreams()</div>
<div class="line">{</div>
<div class="line">    fUpdateStreamsRequired = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::dirtyMaterials()</div>
<div class="line">{</div>
<div class="line">    fUpdateMaterialsRequired = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::resetDagPaths()</div>
<div class="line">{</div>
<div class="line">    fInstanceDagPaths.clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::registerNodeDirtyCallbacks()</div>
<div class="line">{</div>
<div class="line">    assert(!fObject.isNull());</div>
<div class="line"> <span class="keywordflow">if</span> (fObject.isNull()) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Register callbacks to all parents.</span></div>
<div class="line"> <a name="_a106"></a><a class="code" href="./class_m_dag_path_array.html">MDagPathArray</a> paths;</div>
<div class="line"> <a class="code" href="./class_m_dag_path.html#a6e4195497a9d3f031d159ddb60f94e74">MDagPath::getAllPathsTo</a>(fObject, paths);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; paths.<a name="a107"></a><a class="code" href="./class_m_dag_path_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>(); i++) {</div>
<div class="line"> <a class="code" href="./class_m_dag_path.html">MDagPath</a> dagPath = paths[i];</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Register callbacks for this instance.</span></div>
<div class="line"> <span class="keywordflow">while</span> (dagPath.<a class="code" href="./class_m_dag_path.html#a095ae34296e81703965265a42ee783ca">isValid</a>() &amp;&amp; dagPath.<a class="code" href="./class_m_dag_path.html#af321be336f1f2d96ac2273a87cb3c8ab">length</a>() &gt; 0) {</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> node = dagPath.<a name="a108"></a><a class="code" href="./class_m_dag_path.html#ae024049dad815f2f186e6a4fead8be51">node</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Monitor the parents and re-register callbacks.</span></div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> parentAddedCallback = <a name="a109"></a><a class="code" href="./class_m_dag_message.html#a0cbf1f7d7670e5c7843dc1b8e021664d">MDagMessage::addParentAddedDagPathCallback</a>(</div>
<div class="line">                dagPath, ParentChangedCallback, <span class="keyword">this</span>);</div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> parentRemovedCallback = <a name="a110"></a><a class="code" href="./class_m_dag_message.html#a7b9f16fb02898efdb74ef8e2106f1d53">MDagMessage::addParentRemovedDagPathCallback</a>(</div>
<div class="line">                dagPath, ParentChangedCallback, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Monitor parent display status changes.</span></div>
<div class="line"> <a class="code" href="./_m_message_8h.html#a42e6e9d54a954c3e2d798a156091ca1d">MCallbackId</a> nodeDirtyCallback = <a name="a111"></a><a class="code" href="./class_m_node_message.html#a54c088182daaef8a244e375bc4124458">MNodeMessage::addNodeDirtyPlugCallback</a>(</div>
<div class="line">                node, NodeDirtyCallback, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add to array.</span></div>
<div class="line">            fNodeDirtyCallbacks.append(parentAddedCallback);</div>
<div class="line">            fNodeDirtyCallbacks.append(parentRemovedCallback);</div>
<div class="line">            fNodeDirtyCallbacks.append(nodeDirtyCallback);</div>
<div class="line"></div>
<div class="line">            dagPath.<a class="code" href="./class_m_dag_path.html#ac71eca2b78b8cfc088adc9af6f851dfd">pop</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::clearNodeDirtyCallbacks()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (fNodeDirtyCallbacks.length() &gt; 0) {</div>
<div class="line"> <a class="code" href="./class_m_message.html#ac637287cc26b707b9e1a175a32f44e29">MMessage::removeCallbacks</a>(fNodeDirtyCallbacks);</div>
<div class="line">        fNodeDirtyCallbacks.clear();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::updateRenderItems(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MHWRender::MSubSceneContainer</a>&amp;  container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html">MHWRender::MFrameContext</a>&amp; frameContext)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Early out if the gpuCache node has no cached data.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fGeometry) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Match the number of the instances.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instanceCount = fInstanceDagPaths.length();</div>
<div class="line"> <span class="keywordflow">if</span> (instanceCount &gt; fInstanceRenderItems.size()) {</div>
<div class="line"> <span class="comment">// Instance Added.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> difference = (<span class="keywordtype">unsigned</span> int)(instanceCount - fInstanceRenderItems.size());</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; difference; i++) {</div>
<div class="line">            fInstanceRenderItems.push_back(</div>
<div class="line">                std::make_shared&lt;InstanceRenderItems&gt;());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Recompute shadow map.</span></div>
<div class="line">        MRenderer::setLightsAndShadowsDirty();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (instanceCount &lt; fInstanceRenderItems.size()) {</div>
<div class="line"> <span class="comment">// Instance Removed.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> difference = (<span class="keywordtype">unsigned</span> int)(fInstanceRenderItems.size() - instanceCount);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; difference; i++) {</div>
<div class="line">            fInstanceRenderItems.back()-&gt;destroyRenderItems(container);</div>
<div class="line">            fInstanceRenderItems.pop_back();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Recompute shadow map.</span></div>
<div class="line">        MRenderer::setLightsAndShadowsDirty();</div>
<div class="line">    }</div>
<div class="line">    assert(fInstanceDagPaths.length() == fInstanceRenderItems.size());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The MDagPath and MMatrix (world matrix) are the differences among instances.</span></div>
<div class="line"> <span class="comment">// We don't care the the instance number mapping. Just update the path and matrix.</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fInstanceRenderItems.size(); i++) {</div>
<div class="line">        assert(fInstanceRenderItems[i]);</div>
<div class="line"> <span class="comment">// The name prefix for all render items of this instance</span></div>
<div class="line"> <span class="comment">// e.g. "1:" stands for the 2nd instance of the gpuCache node.</span></div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a> instancePrefix = <a class="code" href="./class_m_string.html">MString</a>(<span class="stringliteral">""</span>) + i + <span class="stringliteral">":"</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the bounding box render item.</span></div>
<div class="line">        fInstanceRenderItems[i]-&gt;updateRenderItems(</div>
<div class="line">            *<span class="keyword">this</span>, container, fInstanceDagPaths[i], instancePrefix);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::updateVisibility(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MHWRender::MSubSceneContainer</a>&amp;  container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html">MHWRender::MFrameContext</a>&amp; frameContext)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Early out if the gpuCache node has no cached data.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fGeometry) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the visibility for all instances.</span></div>
<div class="line"> <span class="keywordflow">for</span>(InstanceRenderItems::Ptr&amp; instance : fInstanceRenderItems) {</div>
<div class="line">        instance-&gt;updateVisibility(*<span class="keyword">this</span>, container, fOutOfViewFrustum);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::updateWorldMatrix(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MHWRender::MSubSceneContainer</a>&amp;  container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html">MHWRender::MFrameContext</a>&amp; frameContext)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Early out if the gpuCache node has no cached data.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fGeometry) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the world matrix for all instances.</span></div>
<div class="line"> <span class="keywordflow">for</span>(InstanceRenderItems::Ptr&amp; instance : fInstanceRenderItems) {</div>
<div class="line">        instance-&gt;updateWorldMatrix(*<span class="keyword">this</span>, container);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::updateStreams(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MHWRender::MSubSceneContainer</a>&amp;  container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html">MHWRender::MFrameContext</a>&amp; frameContext)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Early out if the gpuCache node has no cached data.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fGeometry) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the streams for all instances.</span></div>
<div class="line"> <span class="keywordflow">for</span>(InstanceRenderItems::Ptr&amp; instance : fInstanceRenderItems) {</div>
<div class="line">        instance-&gt;updateStreams(*<span class="keyword">this</span>, container);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> SubSceneOverride::updateMaterials(<a class="code" href="./class_m_h_w_render_1_1_m_sub_scene_container.html">MHWRender::MSubSceneContainer</a>&amp;  container,</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_frame_context.html">MHWRender::MFrameContext</a>&amp; frameContext)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Early out if the gpuCache node has no cached data.</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fGeometry) {</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the diffuse color materials for all instances.</span></div>
<div class="line"> <span class="keywordflow">for</span>(InstanceRenderItems::Ptr&amp; instance : fInstanceRenderItems) {</div>
<div class="line">        instance-&gt;updateMaterials(*<span class="keyword">this</span>, container);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">//Update the materials.</span></div>
<div class="line">    ShaderInstanceCache::getInstance().updateCachedShadedShaders(fTimeInSeconds);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>

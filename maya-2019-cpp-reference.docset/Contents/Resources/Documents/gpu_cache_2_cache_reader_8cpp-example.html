<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../scripts/utils/adsk.redirect.js"></script>
      <title>gpuCache/CacheReader.cpp</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2_cache_reader_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>gpuCache/CacheReader.cpp</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/files.html"><span>Files</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">gpuCache/CacheReader.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;CacheReader.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheShapeNode.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheUtil.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/bimap.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/bimap/list_of.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/bimap/unordered_set_of.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/multi_index_container.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/multi_index/sequenced_index.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/multi_index/identity.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/multi_index/mem_fun.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/multi_index/hashed_index.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;time.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;condition_variable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tbb/task.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="preprocessor">    #include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">    #include &lt;sys/resource.h&gt;</span></div>
<div class="line"><span class="preprocessor">    #include &lt;limits.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDagNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MViewport2Renderer.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>GPUCache;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>GlobalReaderCache::Impl {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Impl(<span class="keywordtype">int</span> initNumFileHandles)</div>
<div class="line">        :  fMaxNumFileHandles(initNumFileHandles), fHitCount(0), fGetCount(0)</div>
<div class="line">    {</div>
<div class="line">        assert(fMaxNumFileHandles &gt; 10);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~Impl()</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;CacheReader&gt; getCacheReader(<span class="keyword">const</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Bimap: fileName -&gt; ownershipCount with CacheReader</span></div>
<div class="line">        <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> resolvedFullName = file.<a name="a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a9484f49594e6f95729f1be1608a6ae8f">resolvedFullName</a>();</div>
<div class="line">        std::string key = resolvedFullName.<a name="a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">        std::shared_ptr&lt;CacheReader&gt; value;</div>
<div class="line"></div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(fMutex);</div>
<div class="line">        <span class="keywordflow">while</span> (!value)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// look up the bimap</span></div>
<div class="line">            <span class="keyword">const</span> LeftIterator iter = fData.left.find(key);</div>
<div class="line">            <span class="keywordflow">if</span> (iter == fData.left.end()) {</div>
<div class="line">                <span class="comment">// miss</span></div>
<div class="line">                <span class="comment">// if the cache has reached its capacity, we try to</span></div>
<div class="line">                <span class="comment">// close the least-recent-used reader</span></div>
<div class="line">                <span class="comment">// the reader should not be in use</span></div>
<div class="line">                <span class="keywordflow">if</span> (fData.size() == (size_t)fMaxNumFileHandles) {</div>
<div class="line">                    <span class="comment">// try to close one reader</span></div>
<div class="line">                    RightIterator leastUsed;</div>
<div class="line">                    <span class="keywordflow">for</span> (leastUsed = fData.right.begin();</div>
<div class="line">                            leastUsed != fData.right.end(); ++leastUsed) {</div>
<div class="line">                        <span class="keywordflow">if</span> ((*leastUsed).get_right() == 0) {</div>
<div class="line">                            <span class="comment">// we have found a reader not in use</span></div>
<div class="line">                            <span class="keywordflow">break</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> (leastUsed != fData.right.end()) {</div>
<div class="line">                        <span class="comment">// got one reader to close</span></div>
<div class="line">                        fData.right.erase(leastUsed);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (fData.size() &lt; (size_t)fMaxNumFileHandles) {</div>
<div class="line">                    <span class="comment">// safe to insert a new reader</span></div>
<div class="line">                    value = createReader(file);</div>
<div class="line">                    fData.left[key] = 1;</div>
<div class="line">                    fData.right.back().info = value;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// hit cache, we move the reader to the end of</span></div>
<div class="line">                <span class="comment">// the LRU list</span></div>
<div class="line">                fData.right.relocate(fData.right.end(),</div>
<div class="line">                    fData.project_right(iter));</div>
<div class="line">                value = (*iter).info;</div>
<div class="line">                ++(*iter).get_right();</div>
<div class="line">                ++fHitCount;</div>
<div class="line">            }</div>
<div class="line">            ++fGetCount;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// failed to create a reader because all readers are currently</span></div>
<div class="line">            <span class="comment">// in use and the cache has reached its capacity</span></div>
<div class="line">            <span class="comment">// wait for some time and try again</span></div>
<div class="line">            <span class="keywordflow">if</span> (!value) {</div>
<div class="line">                fCond.wait(lock);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> increaseFileRef(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> resolvedFullName = file.<a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a9484f49594e6f95729f1be1608a6ae8f">resolvedFullName</a>();</div>
<div class="line">        std::string key = resolvedFullName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// look up the file ref count</span></div>
<div class="line">        FileRefCountIterator fileRefCountIter = fFileRefCount.find(key);</div>
<div class="line">        <span class="keywordflow">if</span> (fileRefCountIter != fFileRefCount.end()) {</div>
<div class="line">            <span class="comment">// increase the file ref count</span></div>
<div class="line">            ++(*fileRefCountIter).second;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// insert a new entry for file ref count</span></div>
<div class="line">            fFileRefCount[key] = 1;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> decreaseFileRef(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> resolvedFullName = file.<a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a9484f49594e6f95729f1be1608a6ae8f">resolvedFullName</a>();</div>
<div class="line">        std::string key = resolvedFullName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// look up the file ref count</span></div>
<div class="line">        FileRefCountIterator fileRefCountIter = fFileRefCount.find(key);</div>
<div class="line">        <span class="keywordflow">if</span> (fileRefCountIter != fFileRefCount.end()) {</div>
<div class="line">            <span class="comment">// decrease the file ref count</span></div>
<div class="line">            <span class="keywordflow">if</span> (--(*fileRefCountIter).second == 0) {</div>
<div class="line">                <span class="comment">// file ref count reaches 0</span></div>
<div class="line">                <span class="comment">// purge this reader from cache since the reader won&#39;t</span></div>
<div class="line">                <span class="comment">// be referenced any more</span></div>
<div class="line">                <span class="comment">// the reader may already be closed because of the capacity</span></div>
<div class="line">                fFileRefCount.erase(fileRefCountIter);</div>
<div class="line">                LeftIterator iter = fData.left.find(key);</div>
<div class="line">                <span class="keywordflow">if</span> (iter != fData.left.end()) {</div>
<div class="line">                    fData.left.erase(iter);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;CacheReader&gt; acquireOwnership(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// make sure the reader is cached</span></div>
<div class="line">        <span class="keywordflow">return</span> getCacheReader(file);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> releaseOwnership(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> resolvedFullName = file.<a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a9484f49594e6f95729f1be1608a6ae8f">resolvedFullName</a>();</div>
<div class="line">        std::string key = resolvedFullName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// look up the cache</span></div>
<div class="line">        <span class="keyword">const</span> LeftIterator iter = fData.left.find(key);</div>
<div class="line">        <span class="keywordflow">if</span> (iter != fData.left.end()) {</div>
<div class="line">            <span class="comment">// decrease the ownership count</span></div>
<div class="line">            <span class="keywordflow">if</span> (--(*iter).get_right() == 0) {</div>
<div class="line">                <span class="comment">// there is one reader that is able to be closed</span></div>
<div class="line">                fCond.notify_one();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// acquire/release mismatch!</span></div>
<div class="line">            assert(iter != fData.left.end());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> print()</div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// dump the cache</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;File Reader Cache&quot;</span> &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;    Get Count: &quot;</span> &lt;&lt; fGetCount &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;    Hit Count: &quot;</span> &lt;&lt; fHitCount &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;    Hit Ratio: &quot;</span> &lt;&lt; (1.0f * fHitCount / fGetCount) &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;LRU list: &quot;</span> &lt;&lt; fData.size() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">for</span> (RightIterator iter = fData.right.begin(); iter != fData.right.end(); iter++) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; (*iter).get_left() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Prohibited and not implemented.</span></div>
<div class="line">    Impl(<span class="keyword">const</span> Impl&amp;);</div>
<div class="line">    <span class="keyword">const</span> Impl&amp; operator= (<span class="keyword">const</span> Impl&amp;);</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;CacheReader&gt; createReader(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> CacheReader::create(<span class="stringliteral">&quot;Alembic&quot;</span>, file);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> boost::bimaps::unordered_set_of&lt;std::string&gt;   LeftViewType;</div>
<div class="line">    <span class="keyword">typedef</span> boost::bimaps::list_of&lt;int&gt;                    RightViewType;</div>
<div class="line">    <span class="keyword">typedef</span> boost::bimaps::with_info&lt;std::shared_ptr&lt;CacheReader&gt; &gt; InfoViewType;</div>
<div class="line">    <span class="keyword">typedef</span> boost::bimap&lt;LeftViewType, RightViewType, InfoViewType&gt;   BimapType;</div>
<div class="line">    <span class="keyword">typedef</span> BimapType::value_type      BimapValueType;</div>
<div class="line">    <span class="keyword">typedef</span> BimapType::left_iterator   LeftIterator;</div>
<div class="line">    <span class="keyword">typedef</span> BimapType::right_iterator  RightIterator;</div>
<div class="line">    <span class="keyword">typedef</span> std::map&lt;std::string,int&gt;  FileRefCountType;</div>
<div class="line">    <span class="keyword">typedef</span> FileRefCountType::iterator FileRefCountIterator;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span>              fMaxNumFileHandles;</div>
<div class="line">    BimapType        fData;</div>
<div class="line">    FileRefCountType fFileRefCount;</div>
<div class="line"></div>
<div class="line">    std::mutex                  fMutex;</div>
<div class="line">    std::condition_variable     fCond;</div>
<div class="line">    <span class="keywordtype">int</span>        fHitCount;</div>
<div class="line">    <span class="keywordtype">int</span>        fGetCount;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="preprocessor">#define DEBUG_SCHEDULER 1</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This is the scheduler for background reading of cache files.</span></div>
<div class="line"><span class="comment">// This class maintains a queue for the scheduled read tasks and</span></div>
<div class="line"><span class="comment">// execute them one by one.</span></div>
<div class="line"><span class="comment">// Once the task is finished, it will notify the shape node to </span></div>
<div class="line"><span class="comment">// update its internal state.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>GlobalReaderCache::Scheduler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// The root task for reading hierarchy.</span></div>
<div class="line">    <span class="keyword">class </span>BGReadHierarchyTask : <span class="keyword">public</span> tbb::task</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        BGReadHierarchyTask(Scheduler*             scheduler,</div>
<div class="line">                            <span class="keyword">const</span> CacheFileEntry*  entry,</div>
<div class="line">                            CacheReaderProxy::Ptr&amp; proxy,</div>
<div class="line">                            <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;         geometryPath)</div>
<div class="line">            : fScheduler(scheduler),</div>
<div class="line">              fCacheFileEntry(entry),</div>
<div class="line">              fProxy(proxy), </div>
<div class="line">              fGeometryPath(geometryPath)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        ~BGReadHierarchyTask()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{}</div>
<div class="line"></div>
<div class="line">        task* execute()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="comment">// Read the cache file</span></div>
<div class="line">            SubNode::Ptr          geometry;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>               validatedGeometryPath = fGeometryPath;</div>
<div class="line">            MaterialGraphMap::Ptr materials;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                CacheReaderHolder holder(fProxy);</div>
<div class="line">                <span class="keyword">const</span> std::shared_ptr&lt;CacheReader&gt; cacheReader = holder.getCacheReader();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (cacheReader &amp;&amp; cacheReader-&gt;valid()) {</div>
<div class="line">                    <span class="comment">// Validate the input geometry path</span></div>
<div class="line">                    cacheReader-&gt;validateGeomPath(fGeometryPath, validatedGeometryPath);</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Read the hierarchy</span></div>
<div class="line">                    geometry = cacheReader-&gt;readHierarchy(</div>
<div class="line">                        validatedGeometryPath, !Config::isIgnoringUVs());</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Read the materials</span></div>
<div class="line">                    materials = cacheReader-&gt;readMaterials();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">catch</span> (CacheReaderInterruptException&amp;) {</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SCHEDULER</span></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;[gpuCache] Background reading is interrupted&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">catch</span> (std::exception&amp;) {</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SCHEDULER</span></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;[gpuCache] Background reading is interrupted for unknown reason&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Callback to scheduler that this task is finished.</span></div>
<div class="line">            fScheduler-&gt;hierarchyTaskFinished(fCacheFileEntry, </div>
<div class="line">                geometry, validatedGeometryPath, materials, fProxy);</div>
<div class="line">            fProxy.reset();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        Scheduler*            fScheduler;</div>
<div class="line">        <span class="keyword">const</span> CacheFileEntry* fCacheFileEntry;</div>
<div class="line">        CacheReaderProxy::Ptr fProxy;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>               fGeometryPath;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The root task for reading shape data.</span></div>
<div class="line">    <span class="keyword">class </span>BGReadShapeTask : <span class="keyword">public</span> tbb::task</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        BGReadShapeTask(Scheduler*             scheduler,</div>
<div class="line">                        <span class="keyword">const</span> CacheFileEntry*  entry,</div>
<div class="line">                        CacheReaderProxy::Ptr&amp; proxy,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;         prefix,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;         geometryPath)</div>
<div class="line">            : fScheduler(scheduler),</div>
<div class="line">              fCacheFileEntry(entry),</div>
<div class="line">              fProxy(proxy), </div>
<div class="line">              fPrefix(prefix),</div>
<div class="line">              fGeometryPath(geometryPath)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        ~BGReadShapeTask()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{}</div>
<div class="line"></div>
<div class="line">        task* execute()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="comment">// Read the cache file for the specified geometry path</span></div>
<div class="line">            SubNode::Ptr geometry;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                CacheReaderHolder holder(fProxy);</div>
<div class="line">                <span class="keyword">const</span> std::shared_ptr&lt;CacheReader&gt; cacheReader = holder.getCacheReader();</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (cacheReader &amp;&amp; cacheReader-&gt;valid()) {</div>
<div class="line">                    <span class="comment">// Read the specified shape</span></div>
<div class="line">                    geometry = cacheReader-&gt;readShape(fPrefix + fGeometryPath, !Config::isIgnoringUVs());</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">catch</span> (CacheReaderInterruptException&amp;) {</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SCHEDULER</span></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;[gpuCache] Background reading is interrupted&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">catch</span> (std::exception&amp;) {</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SCHEDULER</span></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;[gpuCache] Background reading is interrupted for unknown reason&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Must release the reader proxy here so the CacheReader can be destroyed early.</span></div>
<div class="line">            fProxy.reset();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Callback to scheduler that this task is finished.</span></div>
<div class="line">            fScheduler-&gt;shapeTaskFinished(fCacheFileEntry, geometry, fGeometryPath);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        Scheduler*            fScheduler;</div>
<div class="line">        <span class="keyword">const</span> CacheFileEntry* fCacheFileEntry;</div>
<div class="line">        CacheReaderProxy::Ptr fProxy;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>               fPrefix;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>               fGeometryPath;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">class </span>WorkItem</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> std::shared_ptr&lt;WorkItem&gt; Ptr;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">enum</span> WorkItemType {</div>
<div class="line">            kHierarchyWorkItem,</div>
<div class="line">            kShapeWorkItem,</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        WorkItem(Scheduler*             scheduler,</div>
<div class="line">                 <span class="keyword">const</span> CacheFileEntry*  entry, </div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;         geometryPath,</div>
<div class="line">                 CacheReaderProxy::Ptr&amp; proxy)</div>
<div class="line">            : fCacheFileEntry(entry), </div>
<div class="line">              fSubNode(NULL),</div>
<div class="line">              fValidatedGeometryPath(geometryPath), </div>
<div class="line">              fCancelled(false),</div>
<div class="line">              fType(kHierarchyWorkItem)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Create task for reading hierarchy</span></div>
<div class="line">            fTask = <span class="keyword">new</span> (tbb::task::allocate_root())</div>
<div class="line">                BGReadHierarchyTask(scheduler, entry, proxy, geometryPath);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        WorkItem(Scheduler*             scheduler,</div>
<div class="line">                 <span class="keyword">const</span> CacheFileEntry*  entry, </div>
<div class="line">                 <span class="keyword">const</span> SubNode*         subNode,</div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;         prefix,</div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;         geometryPath,</div>
<div class="line">                 CacheReaderProxy::Ptr&amp; proxy)</div>
<div class="line">            : fCacheFileEntry(entry), </div>
<div class="line">              fSubNode(subNode),</div>
<div class="line">              fValidatedGeometryPath(geometryPath), </div>
<div class="line">              fCancelled(false),</div>
<div class="line">              fType(kShapeWorkItem)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Create task for reading shape</span></div>
<div class="line">            fTask = <span class="keyword">new</span> (tbb::task::allocate_root())</div>
<div class="line">                BGReadShapeTask(scheduler, entry, proxy, prefix, geometryPath);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        ~WorkItem()</div>
<div class="line">        { </div>
<div class="line">            <span class="comment">// The task has not been scheduled to run. Delete it.</span></div>
<div class="line">            <span class="keywordflow">if</span> (fTask) {</div>
<div class="line">                assert(fTask-&gt;state() != tbb::task::executing);</div>
<div class="line">                tbb::task::destroy(*fTask);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> startTask()</div>
<div class="line">        {</div>
<div class="line">            assert(fTask);</div>
<div class="line">            <span class="keywordflow">if</span> (fTask) {</div>
<div class="line">                tbb::task::enqueue(*fTask);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> cancelTask()</div>
<div class="line">        {</div>
<div class="line">            assert(fTask);</div>
<div class="line">            fCancelled = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> finishTask(SubNode::Ptr&amp; geometry, </div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; validatedGeometryPath, </div>
<div class="line">                        MaterialGraphMap::Ptr&amp; materials)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// fTask will be automatically destroyed by TBB after execute()</span></div>
<div class="line">            fTask = NULL;</div>
<div class="line">            fGeometry = geometry;</div>
<div class="line">            fMaterials = materials;</div>
<div class="line">            fValidatedGeometryPath = validatedGeometryPath;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> CacheFileEntry*       cacheFileEntry()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> fCacheFileEntry; }</div>
<div class="line">        <span class="keyword">const</span> SubNode*              subNode()<span class="keyword">   const  </span>{ <span class="keywordflow">return</span> fSubNode;  }</div>
<div class="line">        SubNode::Ptr&amp;               geometry()         { <span class="keywordflow">return</span> fGeometry; }</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;              validatedGeometryPath()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fValidatedGeometryPath; }</div>
<div class="line">        MaterialGraphMap::Ptr&amp;      materials()     { <span class="keywordflow">return</span> fMaterials; }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">bool</span>          isCancelled()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fCancelled; }</div>
<div class="line">        WorkItemType  type()<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> fType; }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keyword">const</span> CacheFileEntry* fCacheFileEntry;</div>
<div class="line">        <span class="keyword">const</span> SubNode*        fSubNode;</div>
<div class="line">        tbb::task*            fTask;</div>
<div class="line">        SubNode::Ptr          fGeometry;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>               fValidatedGeometryPath;</div>
<div class="line">        MaterialGraphMap::Ptr fMaterials;</div>
<div class="line">        <span class="keywordtype">bool</span>                  fCancelled;</div>
<div class="line">        WorkItemType          fType;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Scheduler()</div>
<div class="line">    {</div>
<div class="line">        fInterrupted = <span class="keyword">false</span>;</div>
<div class="line">        fPaused      = <span class="keyword">false</span>;</div>
<div class="line">        fRefreshTime = clock();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~Scheduler() {}</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Schedule an async read. This function will return immediately.</span></div>
<div class="line">    <span class="keywordtype">bool</span> scheduleRead(<span class="keyword">const</span> CacheFileEntry*  entry, </div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;         geometryPath,</div>
<div class="line">                      CacheReaderProxy::Ptr&amp; proxy</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Assumption: Called from the main thread.</span></div>
<div class="line">        assert(entry &amp;&amp; proxy);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Lock the scheduler</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fBigMutex);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!entry) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Create a new work item for reading hierarchy</span></div>
<div class="line">        WorkItem::Ptr item(<span class="keyword">new</span> WorkItem(<span class="keyword">this</span>, entry, geometryPath, proxy));</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SCHEDULER</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> fileName = entry-&gt;fCacheFileName;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[gpuCache] Schedule background reading of &quot;</span> &lt;&lt; fileName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>() &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (fTaskRunning) {</div>
<div class="line">            <span class="comment">// We have a running task, push to pending queue</span></div>
<div class="line">            fHierarchyTaskQueue.push_back(item);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// No task running, start this task</span></div>
<div class="line">            fTaskRunning = item;</div>
<div class="line">            fTaskRunning-&gt;startTask();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pull the hierarchy data.</span></div>
<div class="line">    <span class="keywordtype">bool</span> pullHierarchy(<span class="keyword">const</span> CacheFileEntry*  entry, </div>
<div class="line">                       SubNode::Ptr&amp;          geometry,</div>
<div class="line">                       <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;               validatedGeometryPath,</div>
<div class="line">                       MaterialGraphMap::Ptr&amp; materials</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Assumption: Called from the main thread.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Lock the scheduler</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fBigMutex);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!entry) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Find the hierarchy task. We have exactly 1 task for reading hierarchy.</span></div>
<div class="line">        WorkItem::Ptr resultItem;</div>
<div class="line">        HierarchyItemPtrListHashIterator iter = fHierarchyTaskDone.get&lt;1&gt;().find(entry);</div>
<div class="line">        <span class="keywordflow">if</span> (iter != fHierarchyTaskDone.get&lt;1&gt;().end()) {</div>
<div class="line">            resultItem = *iter;</div>
<div class="line">            fHierarchyTaskDone.get&lt;1&gt;().erase(iter);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Background read complete</span></div>
<div class="line">        <span class="keywordflow">if</span> (resultItem) {</div>
<div class="line">            assert(resultItem-&gt;type() == WorkItem::kHierarchyWorkItem);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SCHEDULER</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> fileName = entry-&gt;fCacheFileName;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;[gpuCache] Background reading (hierarchy) of &quot;</span> &lt;&lt; name.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>() &lt;&lt; <span class="stringliteral">&quot; finished.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">// Return the sub-node hierarchy and validated geometry path.</span></div>
<div class="line">            geometry              = resultItem-&gt;geometry();</div>
<div class="line">            validatedGeometryPath = resultItem-&gt;validatedGeometryPath();</div>
<div class="line">            materials             = resultItem-&gt;materials();</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line">        <span class="comment">// Make sure that the read is really in progress</span></div>
<div class="line">        <span class="keywordtype">bool</span> inProgress = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (fTaskRunning &amp;&amp; fTaskRunning-&gt;cacheFileEntry() == entry) {</div>
<div class="line">            inProgress = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (fHierarchyTaskQueue.get&lt;1&gt;().find(entry) != fHierarchyTaskQueue.get&lt;1&gt;().end()) {</div>
<div class="line">            inProgress = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        assert(inProgress);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Background read in progress</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pull the shape data.</span></div>
<div class="line">    <span class="keywordtype">bool</span> pullShape(<span class="keyword">const</span> CacheFileEntry*   entry, </div>
<div class="line">                   GPUCache::SubNode::Ptr&amp; geometry</div>
<div class="line">    )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Assumption: Called from the main thread.</span></div>
<div class="line">        assert(geometry);</div>
<div class="line">        <span class="keywordflow">if</span> (!geometry) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Lock the scheduler</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fBigMutex);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!entry) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// A list of finished tasks</span></div>
<div class="line">        std::vector&lt;WorkItem::Ptr&gt; resultItems;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Find the entry tasks, we have one or more tasks for reading shapes</span></div>
<div class="line">        std::pair&lt;ShapeItemPtrListHashIterator,ShapeItemPtrListHashIterator&gt; range =</div>
<div class="line">                fShapeTaskDone.get&lt;1&gt;().equal_range(entry);</div>
<div class="line">        <span class="keywordflow">for</span> (ShapeItemPtrListHashIterator iter = range.first; iter != range.second; iter++) {</div>
<div class="line">            resultItems.push_back(*iter);</div>
<div class="line">        }</div>
<div class="line">        fShapeTaskDone.get&lt;1&gt;().erase(range.first, range.second);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Background read complete</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> WorkItem::Ptr&amp; item : resultItems) {</div>
<div class="line">            assert(item-&gt;type() == WorkItem::kShapeWorkItem);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SCHEDULER</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> fileName = entry-&gt;fCacheFileName;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;[gpuCache] Background reading (shape) of &quot;</span> &lt;&lt; fileName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>() &lt;&lt; <span class="stringliteral">&quot; finished.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">// Replace the shape node data.</span></div>
<div class="line">            SubNode::Ptr shape = item-&gt;geometry();</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>      path  = item-&gt;validatedGeometryPath();</div>
<div class="line">            <span class="keywordflow">if</span> (shape &amp;&amp; path.<a name="a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0) {</div>
<div class="line">                ReplaceSubNodeData(geometry, shape, path);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If we replace shape node data, update the transparent type.</span></div>
<div class="line">        <span class="keywordflow">if</span> (!resultItems.empty()) {</div>
<div class="line">            SubNodeTransparentTypeVisitor transparentTypeVisitor;</div>
<div class="line">            geometry-&gt;accept(transparentTypeVisitor);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check if we still have task in progress or queued</span></div>
<div class="line">        <span class="keywordtype">bool</span> inProgress = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (fTaskRunning &amp;&amp; fTaskRunning-&gt;cacheFileEntry() == entry) {</div>
<div class="line">            inProgress = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (fShapeTaskQueue.get&lt;1&gt;().find(entry) != fShapeTaskQueue.get&lt;1&gt;().end()) {</div>
<div class="line">            inProgress = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Return false if we still have shape tasks in progress or queued</span></div>
<div class="line">        <span class="keywordflow">return</span> !inProgress;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> hintShapeReadOrder(<span class="keyword">const</span> SubNode&amp; subNode)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Lock the scheduler</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fBigMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Note that the (const SubNode*) is ONLY used for comparison.</span></div>
<div class="line">        SubNodePtrList::nth_index&lt;1&gt;::type::iterator iter = </div>
<div class="line">            fShapeTaskOrder.get&lt;1&gt;().find(&amp;subNode);</div>
<div class="line">        <span class="keywordflow">if</span> (iter == fShapeTaskOrder.get&lt;1&gt;().end()) {</div>
<div class="line">            <span class="comment">// This subNode does not exist in the order list.</span></div>
<div class="line">            <span class="comment">// Insert it to the front.</span></div>
<div class="line">            fShapeTaskOrder.push_front(&amp;subNode);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// This subNode exists. Move it to the front.</span></div>
<div class="line">            fShapeTaskOrder.get&lt;1&gt;().erase(iter);</div>
<div class="line">            fShapeTaskOrder.push_front(&amp;subNode);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cancel the async read.</span></div>
<div class="line">    <span class="keywordtype">void</span> cancelRead(<span class="keyword">const</span> CacheFileEntry* entry)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Assumption: Called from the main thread.</span></div>
<div class="line">        assert(entry);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Lock the scheduler</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fBigMutex);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!entry) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SCHEDULER</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> fileName = entry-&gt;fCacheFileName;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[gpuCache] Background reading of &quot;</span> &lt;&lt; fileName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>() &lt;&lt; <span class="stringliteral">&quot; canceled&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remove the queued hierarchy task</span></div>
<div class="line">        fHierarchyTaskQueue.get&lt;1&gt;().erase(entry);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remove the finished hierarchy task</span></div>
<div class="line">        fHierarchyTaskDone.get&lt;1&gt;().erase(entry);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remove the queued shape tasks</span></div>
<div class="line">        fShapeTaskQueue.get&lt;1&gt;().erase(entry);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remove the finished shape tasks</span></div>
<div class="line">        fShapeTaskDone.get&lt;1&gt;().erase(entry);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check the current running task</span></div>
<div class="line">        <span class="keywordflow">if</span> (fTaskRunning &amp;&amp; fTaskRunning-&gt;cacheFileEntry() == entry) {</div>
<div class="line">            fTaskRunning-&gt;cancelTask();</div>
<div class="line">            fInterrupted = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Notify there are task cancelled</span></div>
<div class="line">        fCondition.notify_all();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> waitForRead(<span class="keyword">const</span> CacheFileEntry* entry)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Assumption: Called from the main thread.</span></div>
<div class="line">        assert(entry);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Lock the scheduler</span></div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(fBigMutex);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!entry) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SCHEDULER</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> fileName = entry-&gt;fCacheFileName;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[gpuCache] Waiting for background reading of &quot;</span> &lt;&lt; fileName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>() &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">            <span class="comment">// Find the task</span></div>
<div class="line">            <span class="keywordtype">bool</span> inProgress = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">if</span> (fTaskRunning &amp;&amp; fTaskRunning-&gt;cacheFileEntry() == entry) {</div>
<div class="line">                inProgress = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (fHierarchyTaskQueue.get&lt;1&gt;().find(entry) != fHierarchyTaskQueue.get&lt;1&gt;().end()) {</div>
<div class="line">                inProgress = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (fShapeTaskQueue.get&lt;1&gt;().find(entry) != fShapeTaskQueue.get&lt;1&gt;().end()) {</div>
<div class="line">                inProgress = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Return if the task is done.</span></div>
<div class="line">            <span class="keywordflow">if</span> (!inProgress) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Wait until the in progress task finishes</span></div>
<div class="line">            fCondition.wait_for(lock, std::chrono::seconds(3));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> isInterrupted()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fInterrupted;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> pauseRead()</div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fPauseMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set the &quot;Paused&quot; flag to true.</span></div>
<div class="line">        <span class="comment">// If the reader supports pause/resume, </span></div>
<div class="line">        <span class="comment">// it should check this flag by calling isPaused() and pauseUntilNotified().</span></div>
<div class="line">        assert(!fPaused);</div>
<div class="line">        fPaused = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> resumeRead()</div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fPauseMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Clear the &quot;Paused&quot; flag.</span></div>
<div class="line">        assert(fPaused);</div>
<div class="line">        fPaused = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Resume the worker thread...</span></div>
<div class="line">        fPauseCond.notify_all();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> isPaused()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fPaused;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> pauseUntilNotified()</div>
<div class="line">    {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(fPauseMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If the &quot;Paused&quot; flag is true, pause the worker thread by waiting on the mutex.</span></div>
<div class="line">        <span class="keywordflow">if</span> (fPaused) {</div>
<div class="line">            <span class="comment">// Pause this worker thread.</span></div>
<div class="line">            fPauseCond.wait(lock);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span>WorkItem;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> hierarchyTaskFinished(<span class="keyword">const</span> CacheFileEntry*  entry, </div>
<div class="line">                               SubNode::Ptr&amp;          geometry, </div>
<div class="line">                               <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;         validatedGeometryPath,</div>
<div class="line">                               MaterialGraphMap::Ptr&amp; materials,</div>
<div class="line">                               CacheReaderProxy::Ptr&amp; proxy)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Assumption: Called from worker thread.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Lock the scheduler</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fBigMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The task must be the running task</span></div>
<div class="line">        assert(fTaskRunning);</div>
<div class="line">        assert(fTaskRunning-&gt;cacheFileEntry() == entry);</div>
<div class="line">        assert(fTaskRunning-&gt;type() == WorkItem::kHierarchyWorkItem);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The hierarchy task is finished</span></div>
<div class="line">        fTaskRunning-&gt;finishTask(geometry, validatedGeometryPath, materials);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Move the task to done queue</span></div>
<div class="line">        <span class="keywordtype">bool</span> isCancelled = fTaskRunning-&gt;isCancelled();</div>
<div class="line">        <span class="keywordflow">if</span> (!isCancelled) {</div>
<div class="line">            fHierarchyTaskDone.push_back(fTaskRunning);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Extract the shape paths</span></div>
<div class="line">            ShapePathVisitor::ShapePathAndSubNodeList shapeGeomPaths;</div>
<div class="line">            <span class="keywordflow">if</span> (geometry) {</div>
<div class="line">                ShapePathVisitor shapePathVisitor(shapeGeomPaths);</div>
<div class="line">                geometry-&gt;accept(shapePathVisitor);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The absolute shape path in the archive is prefix+shapePath</span></div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> prefix;</div>
<div class="line">            <span class="keywordtype">int</span> lastStep = validatedGeometryPath.<a name="a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#a8b323761724ea9659348e33b0fea356b">rindexW</a>(<span class="charliteral">&#39;|&#39;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (lastStep &gt; 0) {</div>
<div class="line">                prefix = validatedGeometryPath.<a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#ad748626e545fa6db3afc2f61644b5d62">substringW</a>(0, lastStep - 1);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Create shape tasks</span></div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">const</span> ShapePathVisitor::ShapePathAndSubNode&amp; pair : shapeGeomPaths) {</div>
<div class="line">                WorkItem::Ptr item(<span class="keyword">new</span> WorkItem(</div>
<div class="line">                    <span class="keyword">this</span>, </div>
<div class="line">                    entry, </div>
<div class="line">                    pair.second,   <span class="comment">// The SubNode pointer. Hint the shape read order</span></div>
<div class="line">                    prefix,        <span class="comment">// prefix+pair.first is the absolute path in the archive</span></div>
<div class="line">                    pair.first,    <span class="comment">// The relative path from root sub node</span></div>
<div class="line">                    proxy</div>
<div class="line">                ));</div>
<div class="line">                fShapeTaskQueue.push_back(item);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        fTaskRunning.reset();</div>
<div class="line">        fInterrupted = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Start the next task</span></div>
<div class="line">        startNextTask();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Dirty VP2 geometry</span></div>
<div class="line">        ShapeNode::dirtyVP2Geometry( entry-&gt;fResolvedCacheFileName );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Notify a task has just finished</span></div>
<div class="line">        fCondition.notify_all();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Schedule a refresh</span></div>
<div class="line">        postRefresh();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> shapeTaskFinished(<span class="keyword">const</span> CacheFileEntry* entry, </div>
<div class="line">                           SubNode::Ptr&amp;         geometry, </div>
<div class="line">                           <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;        geometryPath)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Assumption: Called from worker thread.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Lock the scheduler</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(fBigMutex);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The task must be the running task</span></div>
<div class="line">        assert(fTaskRunning);</div>
<div class="line">        assert(fTaskRunning-&gt;cacheFileEntry() == entry);</div>
<div class="line">        assert(fTaskRunning-&gt;type() == WorkItem::kShapeWorkItem);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The hierarchy task is finished</span></div>
<div class="line">        MaterialGraphMap::Ptr noMaterials;</div>
<div class="line">        fTaskRunning-&gt;finishTask(geometry, geometryPath, noMaterials);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Move the task to done queue</span></div>
<div class="line">        <span class="keywordtype">bool</span> isCancelled = fTaskRunning-&gt;isCancelled();</div>
<div class="line">        <span class="keywordflow">if</span> (!isCancelled) {</div>
<div class="line">            fShapeTaskDone.push_back(fTaskRunning);</div>
<div class="line">        }</div>
<div class="line">        fTaskRunning.reset();</div>
<div class="line">        fInterrupted = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Start the next task</span></div>
<div class="line">        startNextTask();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Notify a task has just finished</span></div>
<div class="line">        fCondition.notify_all();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Schedule a refresh</span></div>
<div class="line">        postRefresh();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> startNextTask()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Hierarchy task take the precedence over shape tasks</span></div>
<div class="line">        <span class="keywordflow">if</span> (!fHierarchyTaskQueue.empty()) {</div>
<div class="line">            fTaskRunning = fHierarchyTaskQueue.front();</div>
<div class="line">            fTaskRunning-&gt;startTask();</div>
<div class="line">            fHierarchyTaskQueue.pop_front();</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Pick up a shape task in the order list.</span></div>
<div class="line">        <span class="keywordflow">while</span> (!fShapeTaskOrder.empty()) {</div>
<div class="line">            <span class="keyword">const</span> SubNode* subNode = fShapeTaskOrder.front();</div>
<div class="line">            assert(subNode);</div>
<div class="line">            fShapeTaskOrder.pop_front();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Search the shape task list for the shape</span></div>
<div class="line">            ShapeItemPtrListSubNodeHashIterator iter = fShapeTaskQueue.get&lt;2&gt;().find(subNode);</div>
<div class="line">            <span class="keywordflow">if</span> (iter != fShapeTaskQueue.get&lt;2&gt;().end()) {</div>
<div class="line">                fTaskRunning = *iter;</div>
<div class="line">                fTaskRunning-&gt;startTask();</div>
<div class="line">                fShapeTaskQueue.get&lt;2&gt;().erase(iter);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check if we have shape task</span></div>
<div class="line">        <span class="keywordflow">if</span> (!fShapeTaskQueue.empty()) {</div>
<div class="line">            fTaskRunning = fShapeTaskQueue.front();</div>
<div class="line">            fTaskRunning-&gt;startTask();</div>
<div class="line">            fShapeTaskQueue.pop_front();</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> postRefresh()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Get current time</span></div>
<div class="line">        clock_t currentTime = clock();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Last hierarchy or shape task, force a refresh</span></div>
<div class="line">        <span class="keywordflow">if</span> (!fTaskRunning) {</div>
<div class="line">            fRefreshTime = currentTime;</div>
<div class="line">            <a name="a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#a2c877a6e116f8fd3a6e76387403c023a">MGlobal::executeCommandOnIdle</a>(<span class="stringliteral">&quot;refresh -f;&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check refresh interval</span></div>
<div class="line">        <span class="keywordtype">int</span> total_milliseconds = (currentTime - fRefreshTime)*1000/ CLOCKS_PER_SEC;</div>
<div class="line">        <span class="keywordflow">if</span> (total_milliseconds &gt;= (<span class="keywordtype">int</span>)Config::backgroundReadingRefresh()) {</div>
<div class="line">            fRefreshTime = currentTime;</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_global.html#a2c877a6e116f8fd3a6e76387403c023a">MGlobal::executeCommandOnIdle</a>(<span class="stringliteral">&quot;refresh -f;&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::mutex                   fBigMutex;</div>
<div class="line">    std::condition_variable      fCondition;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// A list of work items with (const CacheFileEntry*) as hash key</span></div>
<div class="line">    <span class="keyword">typedef</span> boost::multi_index_container&lt;</div>
<div class="line">        WorkItem::Ptr,</div>
<div class="line">        boost::multi_index::indexed_by&lt;</div>
<div class="line">            boost::multi_index::sequenced&lt;&gt;,</div>
<div class="line">            boost::multi_index::hashed_unique&lt;BOOST_MULTI_INDEX_CONST_MEM_FUN(WorkItem,const CacheFileEntry*,cacheFileEntry)&gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt; HierarchyItemPtrList;</div>
<div class="line">    <span class="keyword">typedef</span> HierarchyItemPtrList::nth_index&lt;1&gt;::type::iterator HierarchyItemPtrListHashIterator;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// A list of work items with (const CacheFileEntry*) as hash key (multi)</span></div>
<div class="line">    <span class="keyword">typedef</span> boost::multi_index_container&lt;</div>
<div class="line">        WorkItem::Ptr,</div>
<div class="line">        boost::multi_index::indexed_by&lt;</div>
<div class="line">            boost::multi_index::sequenced&lt;&gt;,</div>
<div class="line">            boost::multi_index::hashed_non_unique&lt;BOOST_MULTI_INDEX_CONST_MEM_FUN(WorkItem,const CacheFileEntry*,cacheFileEntry)&gt;,</div>
<div class="line">            boost::multi_index::hashed_unique&lt;BOOST_MULTI_INDEX_CONST_MEM_FUN(WorkItem,const SubNode*,subNode)&gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt; ShapeItemPtrList;</div>
<div class="line">    <span class="keyword">typedef</span> ShapeItemPtrList::nth_index&lt;1&gt;::type::iterator ShapeItemPtrListHashIterator;</div>
<div class="line">    <span class="keyword">typedef</span> ShapeItemPtrList::nth_index&lt;2&gt;::type::iterator ShapeItemPtrListSubNodeHashIterator;</div>
<div class="line"></div>
<div class="line">    WorkItem::Ptr        fTaskRunning;</div>
<div class="line">    HierarchyItemPtrList fHierarchyTaskQueue;</div>
<div class="line">    HierarchyItemPtrList fHierarchyTaskDone;</div>
<div class="line">    ShapeItemPtrList     fShapeTaskQueue;</div>
<div class="line">    ShapeItemPtrList     fShapeTaskDone;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> boost::multi_index_container&lt;</div>
<div class="line">        <span class="keyword">const</span> SubNode*,</div>
<div class="line">        boost::multi_index::indexed_by&lt;</div>
<div class="line">            boost::multi_index::sequenced&lt;&gt;,</div>
<div class="line">            boost::multi_index::hashed_unique&lt;boost::multi_index::identity&lt;const SubNode*&gt; &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt; SubNodePtrList;</div>
<div class="line">    SubNodePtrList fShapeTaskOrder;</div>
<div class="line"></div>
<div class="line">    std::atomic&lt;bool&gt;        fInterrupted;</div>
<div class="line">    clock_t                  fRefreshTime;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Pause and resume the worker thread.</span></div>
<div class="line">    std::atomic&lt;bool&gt;           fPaused;</div>
<div class="line">    std::mutex                  fPauseMutex;</div>
<div class="line">    std::condition_variable     fPauseCond;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS CacheFileEntry</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>CacheFileEntry::MakeSharedEnabler: <span class="keyword">public</span> CacheFileEntry {</div>
<div class="line">    MakeSharedEnabler(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; fileName): CacheFileEntry(fileName) {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">CacheFileEntry::CacheFileEntry()</div>
<div class="line">:   fCachedGeometry()</div>
<div class="line">,   fCachedMaterial()</div>
<div class="line">,   fCacheReaderProxy()</div>
<div class="line">,   fReadState(CacheFileEntry::kReadingDone)</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">CacheFileEntry::CacheFileEntry( <span class="keyword">const</span> CacheFileEntry&amp; rhs )</div>
<div class="line">{</div>
<div class="line">    (*this) = rhs;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">CacheFileEntry::CacheFileEntry( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; fileName )</div>
<div class="line">:   fCacheFileName(fileName)</div>
<div class="line">,   fCachedGeometry()</div>
<div class="line">,   fCachedMaterial()</div>
<div class="line">,   fCacheReaderProxy()</div>
<div class="line">,   fReadState(CacheFileEntry::kReadingDone)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create the CacheReaderProxy</span></div>
<div class="line">    <span class="keywordflow">if</span>( fileName.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0 )</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a> cacheFile;</div>
<div class="line">        cacheFile.<a name="a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#ac14aefbfe38c2711256eb8c14a3194ee">setRawFullName</a>(fileName);</div>
<div class="line">        cacheFile.<a name="a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a4b3d5deec3dc9475f712c8e0f2f4d9a2">setResolveMethod</a>(<a name="a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#af71e719034e8e9a4c69adcc174ca9049ac1ce1604eaae6e61df873510a9254fb3">MFileObject::kInputFile</a>);</div>
<div class="line">        fResolvedCacheFileName = cacheFile.<a class="code" href="#!/url=./cpp_ref/class_m_file_object.html#a9484f49594e6f95729f1be1608a6ae8f">resolvedFullName</a>();</div>
<div class="line">        fCacheReaderProxy = GlobalReaderCache::theCache().getCacheReaderProxy(cacheFile);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">CacheFileEntry::~CacheFileEntry()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">CacheFileEntry&amp; CacheFileEntry::operator=( <span class="keyword">const</span> CacheFileEntry&amp; rhs )</div>
<div class="line">{</div>
<div class="line">    fCacheFileName = rhs.fCacheFileName;</div>
<div class="line">    fCachedGeometry = rhs.fCachedGeometry;</div>
<div class="line">    fCachedMaterial = rhs.fCachedMaterial;</div>
<div class="line">    fCacheReaderProxy = rhs.fCacheReaderProxy;</div>
<div class="line">    fReadState = rhs.fReadState;</div>
<div class="line">    <span class="keywordflow">return</span> (*<span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">CacheFileEntry::MPtr CacheFileEntry::create( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; fileName )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> std::make_shared&lt;MakeSharedEnabler&gt;(fileName);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS CacheFileRegistry</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">CacheFileRegistry CacheFileRegistry::fsSingleton;</div>
<div class="line">CacheFileRegistry::Map CacheFileRegistry::fMap;</div>
<div class="line"></div>
<div class="line">CacheFileRegistry::CacheFileRegistry()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">CacheFileRegistry::~CacheFileRegistry()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">CacheFileRegistry&amp; CacheFileRegistry::theCache()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fsSingleton;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> CacheFileRegistry::getAll( std::vector&lt;CacheFileEntry::MPtr&gt;&amp; entries )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    entries.<a name="a11"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>();</div>
<div class="line"></div>
<div class="line">    Map::iterator it = fMap.begin();</div>
<div class="line">    <span class="keywordflow">for</span>( ; it != fMap.end(); it++ )</div>
<div class="line">    {</div>
<div class="line">        entries.push_back(it-&gt;second);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">CacheFileEntry::MPtr CacheFileRegistry::find( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; key )</div>
<div class="line">{</div>
<div class="line">    Map::iterator it = fMap.find(key);</div>
<div class="line">    <span class="keywordflow">if</span>( it != fMap.end() )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> CacheFileEntry::MPtr();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> CacheFileRegistry::insert( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; key, <span class="keyword">const</span> CacheFileEntry::MPtr&amp; entry )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Search for an existing entry before insertion</span></div>
<div class="line">    Map::iterator it = fMap.find(key);</div>
<div class="line">    <span class="keywordflow">if</span>( it != fMap.end() )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Update the existing entry.</span></div>
<div class="line">        it-&gt;second = entry;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Not found, insert new item.</span></div>
<div class="line">    Map::value_type item( key, entry );</div>
<div class="line">    <span class="keywordflow">return</span> fMap.insert( item ).second;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> CacheFileRegistry::remove( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; key )</div>
<div class="line">{</div>
<div class="line">    Map::iterator it = fMap.find(key);</div>
<div class="line">    <span class="keywordflow">if</span>( it != fMap.end() )</div>
<div class="line">    {</div>
<div class="line">        fMap.erase(it);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">size_t</span> CacheFileRegistry::size()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> fMap.size();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> CacheFileRegistry::cleanUp( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; key )</div>
<div class="line">{</div>
<div class="line">    Map::iterator it = fMap.find(key);</div>
<div class="line">    <span class="keywordflow">if</span>( it != fMap.end() )</div>
<div class="line">    {</div>
<div class="line">        CacheFileEntry::MPtr&amp; entry = it-&gt;second;</div>
<div class="line">        <span class="keywordflow">if</span>( entry.use_count() == 1 )</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// This entry now only has one reference to it: this map.</span></div>
<div class="line">            <span class="comment">// Cancel any pending read and remove the entry.</span></div>
<div class="line">            <span class="keywordflow">if</span>( entry-&gt;fReadState != CacheFileEntry::kReadingDone )</div>
<div class="line">            {</div>
<div class="line">                GlobalReaderCache::theCache().cancelRead(entry.get());</div>
<div class="line">                entry-&gt;fReadState = CacheFileEntry::kReadingDone;</div>
<div class="line">            }</div>
<div class="line">            fMap.erase(it);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> CacheFileRegistry::clear()</div>
<div class="line">{</div>
<div class="line">    fMap.clear();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS GlobalReaderCache</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">GlobalReaderCache&amp; GlobalReaderCache::theCache()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> GlobalReaderCache gsReaderCache;</div>
<div class="line">    <span class="keywordflow">return</span> gsReaderCache;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> GlobalReaderCache::maxNumOpenFiles()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// an estimate on the max number of open files when gpuCache command is executed</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> mayaOpenFiles = 100;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// query the current soft limit and raise the soft limit if possible</span></div>
<div class="line">    <span class="keywordtype">int</span> softLimit;</div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line">    <span class="comment">// MSVC limits the max open files to 2048</span></div>
<div class="line">    _setmaxstdio(2048);</div>
<div class="line">    softLimit = _getmaxstdio();</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    <span class="comment">// query the soft limit and hard limit on MAC/Linux</span></div>
<div class="line">    rlimit rlp;</div>
<div class="line">    getrlimit(RLIMIT_NOFILE, &amp;rlp);</div>
<div class="line">    <span class="comment">// try to raise the soft limit to hard limit</span></div>
<div class="line">    rlp.rlim_cur = rlp.rlim_max;</div>
<div class="line">    setrlimit(RLIMIT_NOFILE, &amp;rlp);</div>
<div class="line">    getrlimit(RLIMIT_NOFILE, &amp;rlp);</div>
<div class="line">    <span class="keywordflow">if</span> (rlp.rlim_cur &lt; rlp.rlim_max) {</div>
<div class="line">        <span class="comment">// raise to hard limit failed, try 8000</span></div>
<div class="line">        rlp.rlim_cur = (rlp.rlim_max &gt; 0 &amp;&amp; rlp.rlim_max &lt;= 8000) ? rlp.rlim_max : 8000;</div>
<div class="line">        setrlimit(RLIMIT_NOFILE, &amp;rlp);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// query the new soft limit</span></div>
<div class="line">    getrlimit(RLIMIT_NOFILE, &amp;rlp);</div>
<div class="line">    softLimit = (rlp.rlim_cur &gt; INT_MAX) ? INT_MAX : (<span class="keywordtype">int</span>)rlp.rlim_cur;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    softLimit -= (mayaOpenFiles + 3);</div>
<div class="line">    <span class="keywordflow">return</span> softLimit;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS GlobalReaderCache::CacheReaderProxy</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">GlobalReaderCache::CacheReaderProxy::CacheReaderProxy(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">    : fFile(file)</div>
<div class="line">{</div>
<div class="line">    GlobalReaderCache::theCache().increaseFileRef(fFile);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">GlobalReaderCache::CacheReaderProxy::~CacheReaderProxy()</div>
<div class="line">{</div>
<div class="line">    GlobalReaderCache::theCache().decreaseFileRef(fFile);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS GlobalReaderCache::CacheReaderHolder</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">GlobalReaderCache::CacheReaderHolder::CacheReaderHolder(std::shared_ptr&lt;CacheReaderProxy&gt; proxy)</div>
<div class="line">    : fProxy(proxy)</div>
<div class="line">{</div>
<div class="line">    fReader = GlobalReaderCache::theCache().acquireOwnership(fProxy-&gt;file());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">GlobalReaderCache::CacheReaderHolder::~CacheReaderHolder()</div>
<div class="line">{</div>
<div class="line">    GlobalReaderCache::theCache().releaseOwnership(fProxy-&gt;file());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;CacheReader&gt; GlobalReaderCache::CacheReaderHolder::getCacheReader()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fReader;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS GlobalReaderCache</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>GlobalReaderCache::CacheReaderProxy::MakeSharedEnabler: <span class="keyword">public</span> GlobalReaderCache::CacheReaderProxy {</div>
<div class="line">    MakeSharedEnabler(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file): CacheReaderProxy(file) {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">GlobalReaderCache::GlobalReaderCache()</div>
<div class="line">    : fImpl(new Impl(maxNumOpenFiles())), fScheduler(new Scheduler())</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">GlobalReaderCache::~GlobalReaderCache()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;GlobalReaderCache::CacheReaderProxy&gt;</div>
<div class="line">    GlobalReaderCache::getCacheReaderProxy(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;CacheReaderProxy::MakeSharedEnabler&gt;(file);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> GlobalReaderCache::scheduleRead(</div>
<div class="line">    <span class="keyword">const</span> CacheFileEntry*  entry, </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;         geometryPath,</div>
<div class="line">    CacheReaderProxy::Ptr&amp; proxy</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fScheduler-&gt;scheduleRead(entry, geometryPath, proxy);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> GlobalReaderCache::pullHierarchy(</div>
<div class="line">    <span class="keyword">const</span> CacheFileEntry*  entry,</div>
<div class="line">    SubNode::Ptr&amp;          geometry,</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp;               validatedGeometryPath,</div>
<div class="line">    MaterialGraphMap::Ptr&amp; materials</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fScheduler-&gt;pullHierarchy(entry, geometry, validatedGeometryPath, materials);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> GlobalReaderCache::pullShape(</div>
<div class="line">    <span class="keyword">const</span> CacheFileEntry*   entry,</div>
<div class="line">    GPUCache::SubNode::Ptr&amp; geometry</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fScheduler-&gt;pullShape(entry, geometry);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GlobalReaderCache::hintShapeReadOrder(<span class="keyword">const</span> GPUCache::SubNode&amp; subNode)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fScheduler-&gt;hintShapeReadOrder(subNode);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GlobalReaderCache::cancelRead(<span class="keyword">const</span> CacheFileEntry* entry)</div>
<div class="line">{</div>
<div class="line">    fScheduler-&gt;cancelRead(entry);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GlobalReaderCache::waitForRead(<span class="keyword">const</span> CacheFileEntry* entry)</div>
<div class="line">{</div>
<div class="line">    fScheduler-&gt;waitForRead(entry);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> GlobalReaderCache::isInterrupted()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fScheduler-&gt;isInterrupted();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GlobalReaderCache::pauseRead()</div>
<div class="line">{</div>
<div class="line">    fScheduler-&gt;pauseRead();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GlobalReaderCache::resumeRead()</div>
<div class="line">{</div>
<div class="line">    fScheduler-&gt;resumeRead();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> GlobalReaderCache::isPaused()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fScheduler-&gt;isPaused();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GlobalReaderCache::pauseUntilNotified()</div>
<div class="line">{</div>
<div class="line">    fScheduler-&gt;pauseUntilNotified();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GlobalReaderCache::increaseFileRef(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">{</div>
<div class="line">    fImpl-&gt;increaseFileRef(file);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GlobalReaderCache::decreaseFileRef(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">{</div>
<div class="line">    fImpl-&gt;decreaseFileRef(file);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;CacheReader&gt; GlobalReaderCache::acquireOwnership(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fImpl-&gt;acquireOwnership(file);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> GlobalReaderCache::releaseOwnership(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">{</div>
<div class="line">    fImpl-&gt;releaseOwnership(file);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS CacheReader</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">std::map&lt;std::string,CacheReader::CreateFunction*&gt; CacheReader::fsRegistry;</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;CacheReader&gt; CacheReader::create(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; impl,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a>&amp; file)</div>
<div class="line">{</div>
<div class="line">    std::string key = impl.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">    std::map&lt;std::string,CreateFunction*&gt;::iterator iter = fsRegistry.find(key);</div>
<div class="line">    <span class="keywordflow">if</span> (iter != fsRegistry.end()) {</div>
<div class="line">        <span class="keywordflow">return</span> ((*iter).second)(file);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    assert(<span class="stringliteral">&quot;not implemented&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::shared_ptr&lt;CacheReader&gt;();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> CacheReader::registerReader(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&amp; impl, CreateFunction* func)</div>
<div class="line">{</div>
<div class="line">    std::string key = impl.<a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">    fsRegistry[key] = func;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

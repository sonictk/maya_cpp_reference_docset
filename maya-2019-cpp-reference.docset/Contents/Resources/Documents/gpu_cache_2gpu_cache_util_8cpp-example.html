<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../scripts/utils/adsk.redirect.js"></script>
      <title>gpuCache/gpuCacheUtil.cpp</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2gpu_cache_util_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>gpuCache/gpuCacheUtil.cpp</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/files.html"><span>Files</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">gpuCache/gpuCacheUtil.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;gpuCacheUtil.h&quot;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>GPUCache {</div>
<div class="line"></div>
<div class="line"><span class="comment">/*==============================================================================</span></div>
<div class="line"><span class="comment"> * CLASS InstanceMaterialLookup</span></div>
<div class="line"><span class="comment"> *============================================================================*/</span></div>
<div class="line"></div>
<div class="line">InstanceMaterialLookup::InstanceMaterialLookup(<span class="keyword">const</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a>&amp; dagPath)</div>
<div class="line">    : fInstObjGroupsPlug(findInstObjGroupsPlug(dagPath))</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">InstanceMaterialLookup::~InstanceMaterialLookup()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> InstanceMaterialLookup::hasWholeObjectMaterial()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Default Viewport behavior:</span></div>
<div class="line">    <span class="comment">//   If instObjGroups[x] is connected, it&#39;s whole object material assignment.</span></div>
<div class="line">    <span class="keywordflow">return</span> fInstObjGroupsPlug.isSource();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> InstanceMaterialLookup::findWholeObjectShadingGroup()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Not a whole object material assignment.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!hasWholeObjectMaterial()) {</div>
<div class="line">        <span class="keywordflow">return</span> <a name="a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the destination shading group</span></div>
<div class="line">    <span class="keywordflow">return</span> findShadingGroupByPlug(fInstObjGroupsPlug);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> InstanceMaterialLookup::findWholeObjectSurfaceMaterial()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Not a whole object material assignment.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!hasWholeObjectMaterial()) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the shading group node.</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> shadingGroup = findWholeObjectShadingGroup();</div>
<div class="line">    <span class="keywordflow">if</span> (shadingGroup.<a name="a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>()) <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the source surface material.</span></div>
<div class="line">    <span class="keywordflow">return</span> findSurfaceMaterialByShadingGroup(shadingGroup);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> InstanceMaterialLookup::hasComponentMaterials()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Find instObjGroups[instanceNumber].objectGroup[X] plugs</span></div>
<div class="line">    std::vector&lt;MPlug&gt; ogPlugs;</div>
<div class="line">    findObjectGroupsPlug(fInstObjGroupsPlug, ogPlugs);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If any of the objectGroup[X] plug is connected, this is a </span></div>
<div class="line">    <span class="comment">// per-component material assignment.</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <a name="_a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; ogPlug : ogPlugs) {</div>
<div class="line">        <span class="keywordflow">if</span> (ogPlug.isSource()) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> InstanceMaterialLookup::findShadingGroups(std::vector&lt;MObject&gt;&amp; shadingGroups)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Not a per-component material assignment.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!hasComponentMaterials()) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the objectGroup[X] plugs.</span></div>
<div class="line">    std::vector&lt;MPlug&gt; ogPlugs;</div>
<div class="line">    findObjectGroupsPlug(fInstObjGroupsPlug, ogPlugs);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the destination shading groups for each objectGroup[X]</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; ogPlug : ogPlugs) {</div>
<div class="line">        shadingGroups.push_back(findShadingGroupByPlug(ogPlug));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> InstanceMaterialLookup::findSurfaceMaterials(std::vector&lt;MObject&gt;&amp; surfaceMaterials)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Not a per-component material assignment.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!hasComponentMaterials()) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the connected shading groups.</span></div>
<div class="line">    std::vector&lt;MObject&gt; shadingGroups;</div>
<div class="line">    <span class="keywordflow">if</span> (!findShadingGroups(shadingGroups)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the source surface materials for each shading group.</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; shadingGroup : shadingGroups) {</div>
<div class="line">        surfaceMaterials.push_back(findSurfaceMaterialByShadingGroup(shadingGroup));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">// We will eventually support per-face material assignment. </span></div>
<div class="line"><span class="comment">// This will require a change to the usage of MGeometryExtract to generate</span></div>
<div class="line"><span class="comment">// index groups first.</span></div>
<div class="line"><span class="comment">// Comment out the code for now.</span></div>
<div class="line"><span class="comment">std::vector&lt;MObject&gt; InstanceMaterialLookup::findComponents()</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">    // Find objectGroup plugs</span></div>
<div class="line"><span class="comment">    std::vector&lt;MPlug&gt; ogPlugs;</span></div>
<div class="line"><span class="comment">    findObjectGroupsPlug(fInstObjGroupsPlug);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    std::vector&lt;MObject&gt; mergedComponents;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    for(MPlug&amp; ogPlug : ogPlugs) {</span></div>
<div class="line"><span class="comment">        // Find objectGrpCompList plug</span></div>
<div class="line"><span class="comment">        MPlug gclPlug = ogPlug.child(0);</span></div>
<div class="line"><span class="comment">        MFnComponentListData compList(gclPlug.asMObject());</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (compList.length() == 0) {</span></div>
<div class="line"><span class="comment">            mergedComponents.push_back(MObject::kNullObj);</span></div>
<div class="line"><span class="comment">            continue;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (compList[0].hasFn(MFn::kMeshPolygonComponent)) {</span></div>
<div class="line"><span class="comment">            // Merge mesh face component</span></div>
<div class="line"><span class="comment">            MFnSingleIndexedComponent mergedComp;</span></div>
<div class="line"><span class="comment">            mergedComp.create(MFn::kMeshPolygonComponent);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">            for (unsigned int i = 0; i &lt; compList.length(); i++) {</span></div>
<div class="line"><span class="comment">                MFnSingleIndexedComponent comp(compList[i]);</span></div>
<div class="line"><span class="comment">                for (int j = 0; j &lt; comp.elementCount(); j++) {</span></div>
<div class="line"><span class="comment">                    mergedComp.addElement(j);</span></div>
<div class="line"><span class="comment">                }</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">            mergedComponents.push_back(mergedComp.object());</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">        else {</span></div>
<div class="line"><span class="comment">            assert(0); // per-patch not supported now</span></div>
<div class="line"><span class="comment">            mergedComponents.push_back(MObject::kNullObj);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    return mergedComponents;</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> InstanceMaterialLookup::findInstObjGroupsPlug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a>&amp; dagPath)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// The path must be derived from a shape.</span></div>
<div class="line">    assert(dagPath.<a name="a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html#ae024049dad815f2f186e6a4fead8be51">node</a>().<a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a750b5e8123336c2306a300249b57201d">MFn::kShape</a>));</div>
<div class="line"></div>
<div class="line">    <a name="_a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    <a name="_a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dag_node.html">MFnDagNode</a> dagNode(dagPath, &amp;status);</div>
<div class="line">    assert(status == MS::kSuccess);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the instObjGroups array plug (instanced attribute).</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> plug = dagNode.<a name="a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#aac29b4a3b51c9d236175e955638f7153">findPlug</a>(<span class="stringliteral">&quot;instObjGroups&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line">    assert(!plug.<a name="a11"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Select the instance number.</span></div>
<div class="line">    plug.<a name="a12"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a732963807cfd727b7e90eb1342121ce9">selectAncestorLogicalIndex</a>(dagPath.<a name="a13"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html#ac908055bb978bce38fcb5f1af6620760">instanceNumber</a>());</div>
<div class="line">    <span class="keywordflow">return</span> plug;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> InstanceMaterialLookup::findShadingGroupByPlug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; srcPlug)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (srcPlug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>()) <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// shape.srcPlug -&gt; shadingGroup.dagSetMember</span></div>
<div class="line">    <span class="keywordflow">if</span> (srcPlug.<a name="a14"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a8f309041326143da44ce7e362fed5feb">isSource</a>()) {</div>
<div class="line">        <span class="comment">// List the destination plugs.</span></div>
<div class="line">        <a name="_a15"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html">MPlugArray</a> plugArray;</div>
<div class="line">        srcPlug.<a name="a16"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#acf1340576a4a0a78a0045e67ee4155bf">connectedTo</a>(plugArray, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line">        assert(plugArray.<a name="a17"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 1);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The destination node is the shading group.</span></div>
<div class="line">        <span class="keywordflow">if</span> (plugArray.<a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0) {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> shadingGroup = plugArray[0].node();</div>
<div class="line">            assert(shadingGroup.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a name="a18"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a1fe410ba33fcc24e08a319ee3db38896">MFn::kShadingEngine</a>));</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (shadingGroup.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a1fe410ba33fcc24e08a319ee3db38896">MFn::kShadingEngine</a>)) {</div>
<div class="line">                <span class="keywordflow">return</span> shadingGroup;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> InstanceMaterialLookup::findSurfaceMaterialByShadingGroup(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; shadingGroup)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (shadingGroup.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>()) <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>;</div>
<div class="line">    assert(shadingGroup.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#af0af77f14f96d1134fb8e8e60dc7e420">hasFn</a>(<a class="code" href="#!/url=./cpp_ref/class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a1fe410ba33fcc24e08a319ee3db38896">MFn::kShadingEngine</a>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Find the surfaceShader plug.</span></div>
<div class="line">    <a name="_a19"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html">MFnDependencyNode</a> dgNode(shadingGroup);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> ssPlug = dgNode.findPlug(<span class="stringliteral">&quot;surfaceShader&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line">    assert(!ssPlug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// material.outColor -&gt; shadingGroup.surfaceShader</span></div>
<div class="line">    <span class="keywordflow">if</span> (ssPlug.<a name="a20"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a45b5260464fc2426b6d5806c9658e1e2">isDestination</a>()) {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html">MPlugArray</a> plugArray;</div>
<div class="line">        ssPlug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#acf1340576a4a0a78a0045e67ee4155bf">connectedTo</a>(plugArray, <span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="line">        assert(plugArray.<a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() == 1);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The source node is the surface material.</span></div>
<div class="line">        <span class="keywordflow">if</span> (plugArray.<a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html#a580388f31f60c46fac867ca48a48da1e">length</a>() &gt; 0) {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> shader = plugArray[0].node();</div>
<div class="line">            assert(!shader.<a class="code" href="#!/url=./cpp_ref/class_m_object.html#ac02f2a4d7312eb91f40980adfd4e31b2">isNull</a>());</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> shader;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63">MObject::kNullObj</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> InstanceMaterialLookup::findObjectGroupsPlug(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; iogPlug, std::vector&lt;MPlug&gt;&amp; ogPlugs)</div>
<div class="line">{</div>
<div class="line">    assert(!iogPlug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// 0th child is objectGroups</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> ogPlug = iogPlug.<a name="a21"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a482274cc996238a9a9e77be5781caa90">child</a>(0);</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ogPlugCount = ogPlug.<a name="a22"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ae98c3fdbce1daefa127bae2fe66a187c">numElements</a>();</div>
<div class="line">    ogPlugs.reserve(ogPlugCount);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ogPlugCount; i++) {</div>
<div class="line">        <span class="comment">// plug = instObjGroups[which].objectGroups[i]</span></div>
<div class="line">        ogPlugs.push_back(ogPlug[i]);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*==============================================================================</span></div>
<div class="line"><span class="comment"> * CLASS ShadedModeColor</span></div>
<div class="line"><span class="comment"> *============================================================================*/</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ShadedModeColor::evaluateBool(</div>
<div class="line">    <span class="keyword">const</span> MaterialProperty::Ptr&amp; prop,</div>
<div class="line">    <span class="keywordtype">double</span>                       timeInSeconds</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    assert(prop &amp;&amp; prop-&gt;type() == MaterialProperty::kBool);</div>
<div class="line">    <span class="keywordflow">if</span> (!prop || prop-&gt;type() != MaterialProperty::kBool) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> MaterialNode::Ptr     srcNode = prop-&gt;srcNode();</div>
<div class="line">    <span class="keyword">const</span> MaterialProperty::Ptr srcProp = prop-&gt;srcProp();</div>
<div class="line">    <span class="keywordflow">if</span> (srcNode &amp;&amp; srcProp) {</div>
<div class="line">        <span class="comment">// If there is a connection, we use the default value.</span></div>
<div class="line">        <span class="keywordflow">return</span> prop-&gt;getDefaultAsBool();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Otherwise, we use the value in the property.</span></div>
<div class="line">        <span class="keywordflow">return</span> prop-&gt;asBool(timeInSeconds);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> ShadedModeColor::evaluateFloat(</div>
<div class="line">    <span class="keyword">const</span> MaterialProperty::Ptr&amp; prop,</div>
<div class="line">    <span class="keywordtype">double</span>                       timeInSeconds</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    assert(prop &amp;&amp; prop-&gt;type() == MaterialProperty::kFloat);</div>
<div class="line">    <span class="keywordflow">if</span> (!prop || prop-&gt;type() != MaterialProperty::kFloat) {</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> MaterialNode::Ptr     srcNode = prop-&gt;srcNode();</div>
<div class="line">    <span class="keyword">const</span> MaterialProperty::Ptr srcProp = prop-&gt;srcProp();</div>
<div class="line">    <span class="keywordflow">if</span> (srcNode &amp;&amp; srcProp) {</div>
<div class="line">        <span class="comment">// If there is a connection, we use the default value.</span></div>
<div class="line">        <span class="keywordflow">return</span> prop-&gt;getDefaultAsFloat();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Otherwise, we use the value in the property.</span></div>
<div class="line">        <span class="keywordflow">return</span> prop-&gt;asFloat(timeInSeconds);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a name="_a23"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> ShadedModeColor::evaluateDefaultColor(</div>
<div class="line">    <span class="keyword">const</span> MaterialProperty::Ptr&amp; prop,</div>
<div class="line">    <span class="keywordtype">double</span>                       timeInSeconds</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    assert(prop &amp;&amp; prop-&gt;type() == MaterialProperty::kRGB);</div>
<div class="line">    <span class="keywordflow">if</span> (!prop || prop-&gt;type() != MaterialProperty::kRGB) {</div>
<div class="line">        <span class="keywordflow">return</span> <a name="a24"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html#a7adf58ad74b346fd7d2839354f07c390">MColor::kOpaqueBlack</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check source connections.</span></div>
<div class="line">    <span class="keyword">const</span> MaterialNode::Ptr     srcNode = prop-&gt;srcNode();</div>
<div class="line">    <span class="keyword">const</span> MaterialProperty::Ptr srcProp = prop-&gt;srcProp();</div>
<div class="line">    <span class="keywordflow">if</span> (srcNode &amp;&amp; srcProp) {</div>
<div class="line">        <span class="comment">// There is a source connection. Let&#39;s check if it&#39;s a texture2d node.</span></div>
<div class="line">        <span class="keyword">const</span> std::shared_ptr&lt;const Texture2d&gt; srcTex = </div>
<div class="line">            std::dynamic_pointer_cast&lt;<span class="keyword">const</span> Texture2d&gt;(srcNode);</div>
<div class="line">        <span class="keywordflow">if</span> (srcTex &amp;&amp; srcTex-&gt;OutColor == srcProp) {</div>
<div class="line">            <span class="comment">// This property has a source texture2d node and the output</span></div>
<div class="line">            <span class="comment">// of the texture2d node is outColor.</span></div>
<div class="line">            <span class="comment">// We use the Default Color as the outColor.</span></div>
<div class="line">            <span class="keywordflow">return</span> srcTex-&gt;DefaultColor-&gt;asColor(timeInSeconds);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// The source is not texture2d.outColor.</span></div>
<div class="line">            <span class="comment">// We use the default value instead.</span></div>
<div class="line">            <span class="keywordflow">return</span> prop-&gt;getDefaultAsColor();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// No source connection. We use the value in the property directly.</span></div>
<div class="line">    <span class="keywordflow">return</span> prop-&gt;asColor(timeInSeconds);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> ShadedModeColor::evaluateColor(</div>
<div class="line">    <span class="keyword">const</span> MaterialProperty::Ptr&amp; prop,</div>
<div class="line">    <span class="keywordtype">double</span>                       timeInSeconds</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    assert(prop &amp;&amp; prop-&gt;type() == MaterialProperty::kRGB);</div>
<div class="line">    <span class="keywordflow">if</span> (!prop || prop-&gt;type() != MaterialProperty::kRGB) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_color.html#a7adf58ad74b346fd7d2839354f07c390">MColor::kOpaqueBlack</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check source connections.</span></div>
<div class="line">    <span class="keyword">const</span> MaterialNode::Ptr     srcNode = prop-&gt;srcNode();</div>
<div class="line">    <span class="keyword">const</span> MaterialProperty::Ptr srcProp = prop-&gt;srcProp();</div>
<div class="line">    <span class="keywordflow">if</span> (srcNode &amp;&amp; srcProp) {</div>
<div class="line">        <span class="comment">// If there is a connection, we use the default value.</span></div>
<div class="line">        <span class="keywordflow">return</span> prop-&gt;getDefaultAsColor();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Otherwise, we use the value in the property.</span></div>
<div class="line">        <span class="keywordflow">return</span> prop-&gt;asColor(timeInSeconds);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace GPUCache</span></div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

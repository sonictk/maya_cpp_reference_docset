<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../scripts/utils/adsk.redirect.js"></script>
      <title>MTextureManager Class Reference</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_h_w_render_1_1_m_texture_manager.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>MTextureManager Class Reference</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/files.html"><span>Files</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="#!/url=./cpp_ref/classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="#!/url=./cpp_ref/hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="#!/url=./cpp_ref/functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  
  <div class="headertitle">
<div class="title">MTextureManager Class Reference<div class="ingroups"><a class="el" translate="no" href="#!/url=./cpp_ref/group___open_maya_render.html">OpenMayaRender - API module for rendering</a></div></div>  </div>
<div id="OverviewLinksDiv"><div id="dynsection-overview" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><img id="dynsection-overview-trigger" src="cpp_ref/closed.png" alt="+"> Related help topics: </div><div id="dynsection-overview-content" class="dyncontent" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016 Extension 2</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2/C-API-Changes-in-Maya-2016.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016 &gt; C++ API Changes in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/Autodesk-Maya-2015.html">What&#39;s New / What&#39;s Changed? &gt; Autodesk Maya 2015</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/Autodesk-Maya-2014.html">What&#39;s New / What&#39;s Changed? &gt; Autodesk Maya 2014</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/Extension-for-Autodesk-Maya-2013.html">What&#39;s New / What&#39;s Changed? &gt; Extension for Autodesk Maya 2013</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/API-constructs/Texture-creation-and-texture.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; API constructs &gt; Texture creation and texture manager</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/The-Renderer-1.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Plug-in Entry Points &gt; The Renderer</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Draw-Overrides.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Plug-in Entry Points &gt; Draw Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Profile-Viewport-2-0-rendering.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Profile Viewport 2.0 rendering events</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_h_w_render_1_1_m_texture_manager.html#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_h_w_render_1_1_m_texture_manager.html#pub-static-methods">Static Public Member Functions</a>  </div></div><!--header-->
<div class="contents">

<p><code>#include &lt;MTextureManager.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><p>Class which manages texture. </p>
<dl class="section "><div id="dynsection-example0" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example0-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example0-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#_a49">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/blast2_cmd_2blast2_cmd_8cpp-example.html#_a35">blast2Cmd/blast2Cmd.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8cpp-example.html#_a12">cgFx/cgfxShaderNode.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_image_plane_2custom_image_plane_8cpp-example.html#_a22">customImagePlane/customImagePlane.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8cpp-example.html#_a33">customTextureShader/customTextureShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#_a165">dx11Shader/dx11Shader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/file_texture_2file_texture_8cpp-example.html#_a68">fileTexture/fileTexture.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_8cpp-example.html#_a145">glslShader/GLSLShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hlsl_shader_2hlsl_shader_8cpp-example.html#_a189">hlslShader/hlslShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_api_texture_test_2hw_api_texture_test_8cpp-example.html#_a23">hwApiTextureTest/hwApiTextureTest.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_api_texture_test_2hw_renderer_helper_8cpp-example.html#_a6">hwApiTextureTest/hwRendererHelper.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/simple_noise_shader_2simple_noise_shader_override_8cpp-example.html#_a7">simpleNoiseShader/simpleNoiseShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#_a7">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_d_x11_device_access_2view_d_x11_device_access_8cpp-example.html#_a20">viewDX11DeviceAccess/viewDX11DeviceAccess.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_image_blit_override_2view_image_blit_override_8cpp-example.html#_a3">viewImageBlitOverride/viewImageBlitOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_image_blit_override_2view_image_blit_override_8h-example.html#_a5">viewImageBlitOverride/viewImageBlitOverride.h</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_override_track_texture_2view_override_track_texture_8cpp-example.html#_a3">viewOverrideTrackTexture/viewOverrideTrackTexture.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_2view_render_override_operations_8cpp-example.html#_a132">viewRenderOverride/viewRenderOverrideOperations.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_frame_cache_2view_render_override_frame_cache_8cpp-example.html#_a6">viewRenderOverrideFrameCache/viewRenderOverrideFrameCache.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_point_light_shadows_2view_render_override_point_light_shadows_8cpp-example.html#_a66">viewRenderOverridePointLightShadows/viewRenderOverridePointLightShadows.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_shadows_2view_render_override_shadows_8cpp-example.html#_a66">viewRenderOverrideShadows/viewRenderOverrideShadows.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_targets_2view_render_override_targets_8cpp-example.html#_a35">viewRenderOverrideTargets/viewRenderOverrideTargets.cpp</a>.</dd></div>
</dl></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a96a66b439082bd98a67d92eeac95f6fe"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a96a66b439082bd98a67d92eeac95f6fe">addImagePath</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;path)</td></tr>
<tr class="memdesc:a96a66b439082bd98a67d92eeac95f6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds an additional search path for looking up images on disk.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a96a66b439082bd98a67d92eeac95f6fe">More...</a><br></td></tr>
<tr class="separator:a96a66b439082bd98a67d92eeac95f6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2229894741132d96312fba448be4e7e1"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a2229894741132d96312fba448be4e7e1">imagePaths</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> &amp;paths) const </td></tr>
<tr class="memdesc:a2229894741132d96312fba448be4e7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current set of image search paths can be retrieved using this method.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a2229894741132d96312fba448be4e7e1">More...</a><br></td></tr>
<tr class="separator:a2229894741132d96312fba448be4e7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aa3cfef217948abc8edd0f19565f95"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a04aa3cfef217948abc8edd0f19565f95">acquireTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;filePath, int mipmapLevels=0, bool useExposureControl=true, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;layerName=<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(), int alphaChannelIdx=-1)</td></tr>
<tr class="memdesc:a04aa3cfef217948abc8edd0f19565f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">obsolete, use the one with contextNodeFullName param  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a04aa3cfef217948abc8edd0f19565f95">More...</a><br></td></tr>
<tr class="separator:a04aa3cfef217948abc8edd0f19565f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e588992f3f613fbafa506a93a2d1b27"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a9e588992f3f613fbafa506a93a2d1b27">acquireTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_arguments.html">MTextureArguments</a> &amp;args)</td></tr>
<tr class="memdesc:a9e588992f3f613fbafa506a93a2d1b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the renderer to acquire a hardware texture.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a9e588992f3f613fbafa506a93a2d1b27">More...</a><br></td></tr>
<tr class="separator:a9e588992f3f613fbafa506a93a2d1b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3f5e1f048ddaabba355bd2cfc09c41"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#aef3f5e1f048ddaabba355bd2cfc09c41">acquireTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;filePath, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;contextNodeFullName, int mipmapLevels=0, bool useExposureControl=true, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;layerName=<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>(), int alphaChannelIdx=-1)</td></tr>
<tr class="memdesc:aef3f5e1f048ddaabba355bd2cfc09c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the renderer to acquire a hardware texture.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#aef3f5e1f048ddaabba355bd2cfc09c41">More...</a><br></td></tr>
<tr class="separator:aef3f5e1f048ddaabba355bd2cfc09c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f4c544e21e9c33f9dbf992cd98ac01"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#aa7f4c544e21e9c33f9dbf992cd98ac01">acquireTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;textureName, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;plug, int width, int height, bool generateMipMaps=true)</td></tr>
<tr class="memdesc:aa7f4c544e21e9c33f9dbf992cd98ac01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the shading network connected to a plug to produce a texture.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#aa7f4c544e21e9c33f9dbf992cd98ac01">More...</a><br></td></tr>
<tr class="separator:aa7f4c544e21e9c33f9dbf992cd98ac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4f7a2c5c6048953059b829eccc1511"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a7b4f7a2c5c6048953059b829eccc1511">acquireTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;textureNode, bool allowBackgroundLoad=false)</td></tr>
<tr class="memdesc:a7b4f7a2c5c6048953059b829eccc1511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the texture associated with a given texture node.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a7b4f7a2c5c6048953059b829eccc1511">More...</a><br></td></tr>
<tr class="separator:a7b4f7a2c5c6048953059b829eccc1511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4418e66d2ef92619dafb7d960222d3fe"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a4418e66d2ef92619dafb7d960222d3fe">acquireTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;textureName, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_description.html">MHWRender::MTextureDescription</a> &amp;textureDesc, const void *pixelData, bool generateMipMaps=true)</td></tr>
<tr class="memdesc:a4418e66d2ef92619dafb7d960222d3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the renderer to acquire a hardware texture by providing a texture description and a block of system memory data which matches the texture description.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a4418e66d2ef92619dafb7d960222d3fe">More...</a><br></td></tr>
<tr class="separator:a4418e66d2ef92619dafb7d960222d3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5abfba35c825b4740a5ddf20518fda6"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#aa5abfba35c825b4740a5ddf20518fda6">acquireTiledTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> textureName, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> &amp;tilePaths, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> &amp;tilePositions, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> &amp;undefinedColor, unsigned int width, unsigned int height, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> &amp;failedTilePaths, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> &amp;uvScaleOffset)</td></tr>
<tr class="memdesc:aa5abfba35c825b4740a5ddf20518fda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the renderer to acquire a tiled hardware texture.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#aa5abfba35c825b4740a5ddf20518fda6">More...</a><br></td></tr>
<tr class="separator:aa5abfba35c825b4740a5ddf20518fda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069050f9521fe273263d287139a33fee"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a069050f9521fe273263d287139a33fee">acquireDepthTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;textureName, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_image.html">MImage</a> &amp;image, bool generateMipMaps, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html">MDepthNormalizationDescription</a> *normalizationDesc)</td></tr>
<tr class="memdesc:a069050f9521fe273263d287139a33fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the renderer to acquire a hardware texture from an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_image.html" title="Image manipulation. ">MImage</a>'s depth buffer.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a069050f9521fe273263d287139a33fee">More...</a><br></td></tr>
<tr class="separator:a069050f9521fe273263d287139a33fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe458cdd3168d83e99484cb59636af80"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#afe458cdd3168d83e99484cb59636af80">acquireDepthTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;textureName, float *pixelData, unsigned int width, unsigned int height, bool generateMipMaps, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html">MDepthNormalizationDescription</a> *normalizationDesc)</td></tr>
<tr class="memdesc:afe458cdd3168d83e99484cb59636af80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the renderer to acquire a hardware texture from an array of depth values.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#afe458cdd3168d83e99484cb59636af80">More...</a><br></td></tr>
<tr class="separator:afe458cdd3168d83e99484cb59636af80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d198d9b895a67d774077d67073d22a"><td class="memItemLeft" translate="no" align="right" valign="top">void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a">releaseTexture</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *texture) const </td></tr>
<tr class="memdesc:a82d198d9b895a67d774077d67073d22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> and releases the reference to the underlying texture which is held by the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> object.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a">More...</a><br></td></tr>
<tr class="separator:a82d198d9b895a67d774077d67073d22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1874d1e1c278aee93e49a4f0e477973f"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a1874d1e1c278aee93e49a4f0e477973f">saveTexture</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *texture, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;filePath)</td></tr>
<tr class="memdesc:a1874d1e1c278aee93e49a4f0e477973f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the renderer to save a hardware texture to disk.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a1874d1e1c278aee93e49a4f0e477973f">More...</a><br></td></tr>
<tr class="separator:a1874d1e1c278aee93e49a4f0e477973f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d56d3a0cf7e5930142ae742b43c64b4"><td class="memItemLeft" translate="no" align="right" valign="top"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a3d56d3a0cf7e5930142ae742b43c64b4">findTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;textureName)</td></tr>
<tr class="memdesc:a3d56d3a0cf7e5930142ae742b43c64b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the texture caching system for a previously cached texture with the given name.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a3d56d3a0cf7e5930142ae742b43c64b4">More...</a><br></td></tr>
<tr class="separator:a3d56d3a0cf7e5930142ae742b43c64b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memItemLeft" translate="no" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this class.  <a href="class_m_h_w_render_1_1_m_texture_manager.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a96a66b439082bd98a67d92eeac95f6fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> addImagePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method adds an additional search path for looking up images on disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Image search path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The path was added. </li>
<li><b>MS::kFailure</b> The path could not be added. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example1" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example1-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example1-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#a167">dx11Shader/dx11Shader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_8cpp-example.html#a147">glslShader/GLSLShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/view_d_x11_device_access_2view_d_x11_device_access_8cpp-example.html#a50">viewDX11DeviceAccess/viewDX11DeviceAccess.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a2229894741132d96312fba448be4e7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> imagePaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> &amp;&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current set of image search paths can be retrieved using this method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">paths</td><td>A string array to be filled in with image path strings. Each array element will contain one image path string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The image paths could be retrieved. </li>
<li><b>MS::kFailure</b> The image paths could not be retrieved. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a04aa3cfef217948abc8edd0f19565f95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * acquireTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mipmapLevels</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useExposureControl</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>layerName</em> = <code><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alphaChannelIdx</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obsolete, use the one with contextNodeFullName param </p>
<p><b>This method is obsolete.</b></p>
<p><b>This method is obsolete.</b> [From Maya 2019] </p><dl class="deprecated"><dt><b><a class="el" translate="no" href="#!/url=./cpp_ref/deprecated.html#_deprecated000400">Deprecated:</a></b></dt><dd>Use the one with the contextNodeFullName input parameter instead. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" translate="no" href="#!/url=./cpp_ref/deprecated.html#_deprecated000399">Deprecated:</a></b></dt><dd>Context (owner Node full name) must be provided to the Maya resolver. Use the one with the contextNodeFullName input parameter.</dd></dl>
<p>Ask the renderer to acquire a hardware texture. The input data is read from an image file.</p>
<p>The renderer will add 1 reference to this texture on creation. If the texture has already been acquired then no new texture will be created, and a new reference will be added. To release the reference, call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a" title="Deletes the MTexture and releases the reference to the underlying texture which is held by the MTextu...">releaseTexture()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureName</td><td>Image file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mipmapLevels</td><td>Mipmap generation levels <ul>
<li>"mipmapLevels!=1" == create and populate all possible levels, using file contents if available </li>
<li>"mipmapLevels==1" == no mipmap chain </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useExposureControl</td><td>Use linear exposure control to convert HDR images </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerName</td><td>The name of the layer to load, this is only relevant for PSD files, otherwise it will have no effect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphaChannelIdx</td><td>The index of the alpha channel to load, this is only relevant for PSD files, otherwise it will have no effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> pointer </dd></dl>
<dl class="section "><div id="dynsection-example2" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example2-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example2-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#a136">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8cpp-example.html#a90">cgFx/cgfxShaderNode.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_image_plane_2custom_image_plane_8cpp-example.html#a27">customImagePlane/customImagePlane.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_sprite_shader_2custom_sprite_shader_8cpp-example.html#a32">customSpriteShader/customSpriteShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_texture_shader_2custom_texture_shader_override_8cpp-example.html#a36">customTextureShader/customTextureShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#a443">dx11Shader/dx11Shader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/file_texture_2file_texture_8cpp-example.html#a71">fileTexture/fileTexture.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_8cpp-example.html#a288">glslShader/GLSLShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hlsl_shader_2hlsl_shader_8cpp-example.html#a194">hlslShader/hlslShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_api_texture_test_2hw_api_texture_test_8cpp-example.html#a36">hwApiTextureTest/hwApiTextureTest.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_api_texture_test_2hw_renderer_helper_8cpp-example.html#a31">hwApiTextureTest/hwRendererHelper.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/simple_noise_shader_2simple_noise_shader_override_8cpp-example.html#a43">simpleNoiseShader/simpleNoiseShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#a47">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_d_x11_device_access_2view_d_x11_device_access_8cpp-example.html#a51">viewDX11DeviceAccess/viewDX11DeviceAccess.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_image_blit_override_2view_image_blit_override_8cpp-example.html#a16">viewImageBlitOverride/viewImageBlitOverride.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/view_override_track_texture_2view_override_track_texture_8cpp-example.html#a15">viewOverrideTrackTexture/viewOverrideTrackTexture.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a9e588992f3f613fbafa506a93a2d1b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * acquireTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_arguments.html">MTextureArguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the renderer to acquire a hardware texture. </p>
<p>The input data is read from an image file.</p>
<p>To enable texture background loading, set the associated file texture node by calling <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_arguments.html#ac1ef5310e158fc1056d346afc434af94" title="Set the file texture node associated with the texture. ">MTextureArguments::setFileTextureNode()</a>.</p>
<p>The renderer will add 1 reference to this texture on creation. If the texture has already been acquired then no new texture will be created, and a new reference will be added. To release the reference, call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a" title="Deletes the MTexture and releases the reference to the underlying texture which is held by the MTextu...">releaseTexture()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The structure containing the arguments to acquire a texture from disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> pointer </dd></dl>

</div>
</div>
<a class="anchor" id="aef3f5e1f048ddaabba355bd2cfc09c41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * acquireTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>contextNodeFullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mipmapLevels</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useExposureControl</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>layerName</em> = <code><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alphaChannelIdx</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the renderer to acquire a hardware texture. </p>
<p>The input data is read from an image file. This version of acquireTexture provides context (owner Node full name) to the Maya file resolvers.</p>
<p>The renderer will add 1 reference to this texture on creation. If the texture has already been acquired then no new texture will be created, and a new reference will be added. To release the reference, call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a" title="Deletes the MTexture and releases the reference to the underlying texture which is held by the MTextu...">releaseTexture()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureName</td><td>Image file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextNodeFullName</td><td>full name of the texture owner Node to be provided as a context to the Maya resolver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mipmapLevels</td><td>Mipmap generation levels <ul>
<li>"mipmapLevels!=1" == create and populate all possible levels, using file contents if available </li>
<li>"mipmapLevels==1" == no mipmap chain </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useExposureControl</td><td>Use linear exposure control to convert HDR images </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerName</td><td>The name of the layer to load, this is only relevant for PSD files, otherwise it will have no effect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphaChannelIdx</td><td>The index of the alpha channel to load, this is only relevant for PSD files, otherwise it will have no effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> pointer </dd></dl>

</div>
</div>
<a class="anchor" id="aa7f4c544e21e9c33f9dbf992cd98ac01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * acquireTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;&#160;</td>
          <td class="paramname"><em>plug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateMipMaps</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample the shading network connected to a plug to produce a texture. </p>
<p>If a plug to a file texture node is provided then the name, width, height and generateMipMaps parameters will be ignored as this information will be based on the image on disk associated with texture node. If uv tiling is enabled, currently only the first tile will be returned.</p>
<p>Otherwise, an attempt to "bake" a texture will be made using the Maya's software renderer "convert-to-solid-texture" functionality.</p>
<p>In this case: </p><ul>
<li>
<p class="startli">The sample resolution is the specified width and height input parameters.</p>
<p class="endli">
</li>
<li>
<p class="startli">If the texure name provided is an empty string then the texture will not be cached as part of the internal texture caching system. Thus each such call to this method will create a new texture.</p>
<p class="endli">
</li>
<li>
If a non-empty texture name is specified then the caching system will attempt to return any previously cached texture with that name. </li>
</ul>
<p>The renderer will add 1 reference to this texture on creation. If the texture has already been acquired then no new texture will be created, and a new reference will be added. To release the reference, call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a" title="Deletes the MTexture and releases the reference to the underlying texture which is held by the MTextu...">releaseTexture()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureName</td><td>Name of the texture to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plug</td><td>Plug which is attached with a texture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the texture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the texture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generateMipMaps</td><td>Generate the mipmap levels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a7b4f7a2c5c6048953059b829eccc1511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * acquireTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>textureNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowBackgroundLoad</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire the texture associated with a given texture node. </p>
<p>Currently only file texture nodes are supported. If uv tiling is enabled, currently only the first tile will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureNode</td><td>Node to acquire texture from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowBackgroundLoad</td><td>Allow for background texture loading. The default value is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> if successful. Otherwise a null pointer is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a4418e66d2ef92619dafb7d960222d3fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * acquireTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_description.html">MHWRender::MTextureDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>textureDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pixelData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateMipMaps</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the renderer to acquire a hardware texture by providing a texture description and a block of system memory data which matches the texture description. </p>
<p>If the texure name provided is an empty string then the texture will not be cached as part of the internal texture caching system. Thus each such call to this method will create a new texture.</p>
<p>If a non-empty texture name is specified then the caching system will attempt to return any previously cached texture with that name.</p>
<p>The renderer will add 1 reference to the texture for each method call. If the texture resides in the cache then no new texture will be created, but a new reference will still be added. To release the reference, call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a" title="Deletes the MTexture and releases the reference to the underlying texture which is held by the MTextu...">releaseTexture()</a>.</p>
<p>The creation of a new texture involves copying the block of system memory data to a hardware texture. The caller is free to deallocate the system memory as the renderer itself does not keep any references to it.</p>
<p>It is generally faster to update a texture using the update() method on <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> than to try and discard a previous version, and then acquire a new version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureName</td><td>Name of the texture to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textureDesc</td><td>Description of the texture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelData</td><td>Block of system memory data which matches the texture description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generateMipMaps</td><td>Generate the mipmap levels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> pointer </dd></dl>

</div>
</div>
<a class="anchor" id="aa5abfba35c825b4740a5ddf20518fda6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * acquireTiledTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> &amp;&#160;</td>
          <td class="paramname"><em>tilePaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> &amp;&#160;</td>
          <td class="paramname"><em>tilePositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> &amp;&#160;</td>
          <td class="paramname"><em>undefinedColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> &amp;&#160;</td>
          <td class="paramname"><em>failedTilePaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> &amp;&#160;</td>
          <td class="paramname"><em>uvScaleOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the renderer to acquire a tiled hardware texture. </p>
<p>If the texture name provided is an empty string then the texture will not be cached as part of the internal texture caching system. Thus each such call to this method will create a new texture.</p>
<p>If a non-empty texture name is specified then the caching system will attempt to return any previously cached texture with that name.</p>
<p>The renderer will add 1 reference to this texture on creation. If the texture has already been acquired then no new texture will be created, and a new reference will be added. To release the reference, call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a" title="Deletes the MTexture and releases the reference to the underlying texture which is held by the MTextu...">releaseTexture()</a>.</p>
<p>If no pre-existing cached texture exists, then a new texture is created by tiling a set of images on disk. The images are specified by a set of file names and their tile position. The input images must be 2D textures.</p>
<p>The tile position is the lower left coordinate of each tile in UV space. The coordinates are assumed to be in a flat array of floats such that for tile 'n', the coordinate is given by : (tilePositions[n*2], tilePositions[n*2+1]).</p>
<p>Note that the function <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a8b8c405e8dbbe4776c5a6bdc64945337" title="Attempts to resolve all the paths to UV tiles for the given file texture node into absolute paths to ...">MRenderUtil::exactFileTextureUvTileData()</a> can be used to retrieve a set of file texture names and positions from a file texture node.</p>
<p>The ordering of the file path names determines the order that tiles are written to the output texture. Tiles written later will overwrite any previously written tiles.</p>
<p>Any region in the output texture which are not covered by a tile will be filled with the specified 'undefined' color. If the image specified by the file name cannot be loaded or if the image does not represent a 2D texture then the 'undefined' color will be written to the output texture.</p>
<p>The maximum dimensions of the output texture are entered as input parameters. </p><ul>
<li>
<p class="startli">These values are used to compute the dimensions of a tile, such that all tiles have identical size and are square. The actual output dimensions are computed as a multiple of the tile dimensions, and the number of tiles in U and V.</p>
<p class="endli">
</li>
<li>
<p class="startli">For example, if the maximum output dimensions provided are {256,256} and there are 5 tiles in U (width) and 6 tiles in V (height), the computed output tile dimensions would be {42,42}, and the computed output dimensions would be {5*42 = 210, 6*42=252}.</p>
<p class="endli">
</li>
<li>
To help prevent image distortion it is suggested to provide input values which will result in a square output texture, and that the size is an even multiple of the number of tiles in U and V. </li>
</ul>
<p>A scale and offset is returned which can be used to map a texture coordinate into the uv range of the texture. Any texture coordinate used to look up into this texture should undergo the following transform: </p><pre>
Transformed UV = ( UV + offset ) * scale
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureName</td><td>Name to give to the texture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tilePaths</td><td>Set of path names to UV tiles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tilePositions</td><td>Set of lower left coordinates for each UV tile. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">undefinedColor</td><td>Color to fill tile region with if the image for a given UV tile cannot be acquired. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxWidth</td><td>Maximum width of the output texture. The value is clamped to a minimum of 256. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxHeight</td><td>Maximum height of the output texture. The value is clamped to a minimum of 256. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">failedTilePaths</td><td>List of files which were not written to the output texture. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uvScaleOffset</td><td>Transform to map to the uv range of the output texture. If the acquire is successful then 4 elements will be returned. The first 2 elements represent the scale in U and V, and the latter 2 elements represent the offset in U and V.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> pointer </dd></dl>
<dl class="section "><div id="dynsection-example3" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example3-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example3-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/hw_api_texture_test_2hw_api_texture_test_8cpp-example.html#a47">hwApiTextureTest/hwApiTextureTest.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a069050f9521fe273263d287139a33fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * acquireDepthTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_image.html">MImage</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateMipMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html">MDepthNormalizationDescription</a> *&#160;</td>
          <td class="paramname"><em>normalizationDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the renderer to acquire a hardware texture from an <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_image.html" title="Image manipulation. ">MImage</a>'s depth buffer. </p>
<ul>
<li>
If there is a depth buffer associated with the data in the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_image.html" title="Image manipulation. ">MImage</a> then a new single channel 32-bit floating point texture will be created. </li>
<li>
If the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_image.html" title="Image manipulation. ">MImage</a> does not contain a depth buffer then a NULL pointer will be returned. </li>
</ul>
<p>There is the option to normalize the data to the [0..1] range during creation.</p>
<p>If the texure name provided is an empty string then the texture will not be cached as part of the internal texture caching system. Thus each such call to this method will create a new texture.</p>
<p>If a non-empty texture name is specified then the caching system will attempt to return any previously cached texture with that name.</p>
<p>The renderer will add 1 reference to the texture for each method call. If the texture resides in the cache then no new texture will be created, but a new reference will still be added. To release the reference, call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a" title="Deletes the MTexture and releases the reference to the underlying texture which is held by the MTextu...">releaseTexture()</a>.</p>
<p>The creation of a new texture involves copying the block of system memory data stored in the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_image.html" title="Image manipulation. ">MImage</a> to a hardware texture. The caller is free to deallocate the system memory as the renderer itself does not keep any references to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureName</td><td>Name of the texture to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>Contains block of system memory data containing depth map information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generateMipMaps</td><td>Generate the mipmap levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalizationDesc</td><td>Optional information to perform normalization on the depth values. Default value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> pointer </dd></dl>
<dl class="section "><div id="dynsection-example4" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example4-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example4-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/view_image_blit_override_2view_image_blit_override_8cpp-example.html#a23">viewImageBlitOverride/viewImageBlitOverride.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="afe458cdd3168d83e99484cb59636af80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * acquireDepthTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pixelData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateMipMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_depth_normalization_description.html">MDepthNormalizationDescription</a> *&#160;</td>
          <td class="paramname"><em>normalizationDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the renderer to acquire a hardware texture from an array of depth values. </p>
<p>If sucessful, a new single channel 32-bit floating point texture will be created. There is the option to normalize the data to the [0..1] range during creation.</p>
<p>If the texure name provided is an empty string then the texture will not be cached as part of the internal texture caching system. Thus each such call to this method will create a new texture.</p>
<p>If a non-empty texture name is specified then the caching system will attempt to return any previously cached texture with that name.</p>
<p>The renderer will add 1 reference to the texture for each method call. If the texture resides in the cache then no new texture will be created, but a new reference will still be added. To release the reference, call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a" title="Deletes the MTexture and releases the reference to the underlying texture which is held by the MTextu...">releaseTexture()</a>.</p>
<p>The creation of a new texture involves copying the block of system memory data to a hardware texture. The caller is free to deallocate the system memory as the renderer itself does not keep any references to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureName</td><td>Name of the texture to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pixelData</td><td>Contains block of system memory data containing depth information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the texture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the texture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generateMipMaps</td><td>Generate the mipmap levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalizationDesc</td><td>Optional information to perform normalization on the depth values. Default value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a82d198d9b895a67d774077d67073d22a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void releaseTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> and releases the reference to the underlying texture which is held by the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> object. </p>
<p>After calling this method it is an error to try to use the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> and attempting to do so will result in instability. The underlying texture might not be deleted immediately if it is in use by the renderer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">texture</td><td>The texture to release </td></tr>
  </table>
  </dd>
</dl>
<dl class="section "><div id="dynsection-example5" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example5-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example5-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/api_mesh_shape_2api_mesh_geometry_override_8cpp-example.html#a51">apiMeshShape/apiMeshGeometryOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/blast2_cmd_2blast2_cmd_8cpp-example.html#a40">blast2Cmd/blast2Cmd.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/cg_fx_2cgfx_shader_node_8cpp-example.html#a14">cgFx/cgfxShaderNode.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/custom_image_plane_2custom_image_plane_8cpp-example.html#a24">customImagePlane/customImagePlane.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/dx11_shader_2dx11_shader_8cpp-example.html#a444">dx11Shader/dx11Shader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/file_texture_2file_texture_8cpp-example.html#a74">fileTexture/fileTexture.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/glsl_shader_2_g_l_s_l_shader_8cpp-example.html#a316">glslShader/GLSLShader.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_api_texture_test_2hw_api_texture_test_8cpp-example.html#a39">hwApiTextureTest/hwApiTextureTest.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/simple_noise_shader_2simple_noise_shader_override_8cpp-example.html#a9">simpleNoiseShader/simpleNoiseShaderOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/tessellated_quad_2_tessellated_quad_geom_override_8cpp-example.html#a48">tessellatedQuad/TessellatedQuadGeomOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_d_x11_device_access_2view_d_x11_device_access_8cpp-example.html#a22">viewDX11DeviceAccess/viewDX11DeviceAccess.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_image_blit_override_2view_image_blit_override_8cpp-example.html#a5">viewImageBlitOverride/viewImageBlitOverride.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_override_track_texture_2view_override_track_texture_8cpp-example.html#a5">viewOverrideTrackTexture/viewOverrideTrackTexture.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_2view_render_override_operations_8cpp-example.html#a134">viewRenderOverride/viewRenderOverrideOperations.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_frame_cache_2view_render_override_frame_cache_8cpp-example.html#a9">viewRenderOverrideFrameCache/viewRenderOverrideFrameCache.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_point_light_shadows_2view_render_override_point_light_shadows_8cpp-example.html#a68">viewRenderOverridePointLightShadows/viewRenderOverridePointLightShadows.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_shadows_2view_render_override_shadows_8cpp-example.html#a68">viewRenderOverrideShadows/viewRenderOverrideShadows.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_targets_2view_render_override_targets_8cpp-example.html#a37">viewRenderOverrideTargets/viewRenderOverrideTargets.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a1874d1e1c278aee93e49a4f0e477973f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> saveTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the renderer to save a hardware texture to disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">texture</td><td><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filePath</td><td>Image file name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The texture was successfuly saved to disk. </li>
<li><b>MS::kFailure</b> The texture was could not be saved. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example6" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example6-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example6-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/blast2_cmd_2blast2_cmd_8cpp-example.html#a39">blast2Cmd/blast2Cmd.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/hw_api_texture_test_2hw_api_texture_test_8cpp-example.html#a38">hwApiTextureTest/hwApiTextureTest.cpp</a>, <a class="el" translate="no" href="#!/url=./cpp_ref/view_override_track_texture_2view_override_track_texture_8cpp-example.html#a17">viewOverrideTrackTexture/viewOverrideTrackTexture.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/view_render_override_frame_cache_2view_render_override_frame_cache_8cpp-example.html#a31">viewRenderOverrideFrameCache/viewRenderOverrideFrameCache.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a3d56d3a0cf7e5930142ae742b43c64b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html">MTexture</a> * findTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>textureName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the texture caching system for a previously cached texture with the given name. </p>
<p>The renderer will add one reference to the texture for the returned <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture.html" title="Class which includes texture data. ">MTexture</a> instance. To release the reference, call <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_texture_manager.html#a82d198d9b895a67d774077d67073d22a" title="Deletes the MTexture and releases the reference to the underlying texture which is held by the MTextu...">releaseTexture()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureName</td><td>Name of the texture to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the texture if found, NULL otherwise </dd></dl>
<dl class="section "><div id="dynsection-example7" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example7-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example7-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/simple_noise_shader_2simple_noise_shader_override_8cpp-example.html#a31">simpleNoiseShader/simpleNoiseShaderOverride.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a774cd5d8fbebe8e7ed82a5aa587d1f04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">const char * className </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of this class. </dd></dl>

</div>
</div>
<hr>The documentation for this class was generated from the following files:<ul>
<li>MTextureManager.h</li>
<li>MTextureManager.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

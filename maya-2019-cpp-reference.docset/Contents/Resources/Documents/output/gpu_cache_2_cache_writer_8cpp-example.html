<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><script src="../scripts/utils/adsk.redirect.js" type="text/javascript"></script>
<title>gpuCache/CacheWriter.cpp</title>
<meta content="C++" name="topic-subtype"/></head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"/><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('gpu_cache_2_cache_writer_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>gpuCache/CacheWriter.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./files.html"><span>Files</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">gpuCache/CacheWriter.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">// Copyright 2015 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk </span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download, </span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic </span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">//**************************************************************************/</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "CacheWriter.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheUtil.h"</span></div>
<div class="line"><span class="preprocessor">#include "gpuCacheStrings.h"</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDagNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MAnimControl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMeshData.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MIntArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatPointArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatVectorArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnMesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MUintArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHWGeometry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGeometryExtractor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnSingleIndexedComponent.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDagPathArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPlug.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnTransform.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span> <span class="comment">// for memcmp</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="./namespace_m_h_w_render.html">MHWRender</a>;</div>
<div class="line"><span class="keyword">using namespace </span>GPUCache;</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS CacheWriter</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">std::map&lt;std::string,void*&gt; CacheWriter::fsRegistry;</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;CacheWriter&gt; CacheWriter::create(<span class="keyword">const</span> <a name="_a0"></a><a class="code" href="./class_m_string.html">MString</a>&amp; impl,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a1"></a><a class="code" href="./class_m_file_object.html">MFileObject</a>&amp; file, <span class="keywordtype">char</span> compressLevel, <span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; dataFormat)</div>
<div class="line">{</div>
<div class="line">    std::string key = impl.<a name="a2"></a><a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">    std::map&lt;std::string,void*&gt;::iterator iter = fsRegistry.find(key);</div>
<div class="line"> <span class="keywordflow">if</span> (iter != fsRegistry.end()) {</div>
<div class="line"> <span class="keywordflow">return</span> ((CreateFunction*)(*iter).second)(file, compressLevel, dataFormat);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    assert(<span class="stringliteral">"not implemented"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> std::shared_ptr&lt;CacheWriter&gt;();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> CacheWriter::registerWriter(<span class="keyword">const</span> <a class="code" href="./class_m_string.html">MString</a>&amp; impl, CreateFunction func)</div>
<div class="line">{</div>
<div class="line">    std::string key = impl.<a class="code" href="./class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>();</div>
<div class="line">    fsRegistry[key] = (<span class="keywordtype">void</span>*)func;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS CacheXformSampler</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>CacheXformSampler::MakeSharedEnabler: <span class="keyword">public</span> CacheXformSampler {</div>
<div class="line">    MakeSharedEnabler(<span class="keyword">const</span> <a name="_a3"></a><a class="code" href="./class_m_object.html">MObject</a>&amp; xformObject): CacheXformSampler(xformObject) {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;CacheXformSampler&gt;</div>
<div class="line">CacheXformSampler::create(<span class="keyword">const</span> <a class="code" href="./class_m_object.html">MObject</a>&amp; xformObject)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> std::make_shared&lt;MakeSharedEnabler&gt;(xformObject);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">CacheXformSampler::CacheXformSampler(<span class="keyword">const</span> <a class="code" href="./class_m_object.html">MObject</a>&amp; xformObject)</div>
<div class="line">    : fXform(xformObject),</div>
<div class="line">      fIsFirstSample(true),</div>
<div class="line"> <span class="comment">// The first sample is always considered animated as we have to</span></div>
<div class="line"> <span class="comment">// capture its values.</span></div>
<div class="line">      fXformAnimated(true),</div>
<div class="line">      fVisibilitySample(false),</div>
<div class="line">      fVisibilityAnimated(true)</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">CacheXformSampler::~CacheXformSampler()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> CacheXformSampler::addSample()</div>
<div class="line">{</div>
<div class="line"> <a name="_a4"></a><a class="code" href="./class_m_matrix.html">MMatrix</a>      prevXformSample      = fXformSample;</div>
<div class="line"> <span class="keywordtype">bool</span>         prevVisibilitySample = fVisibilitySample;</div>
<div class="line"></div>
<div class="line">    fXformSample       = fXform.transformationMatrix();</div>
<div class="line">    fVisibilitySample  = ShapeVisibilityChecker(fXform.object()).isVisible();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (fIsFirstSample) {</div>
<div class="line"> <span class="comment">// The first sample is always considered animated as we have</span></div>
<div class="line"> <span class="comment">// to capture its values.</span></div>
<div class="line">        fIsFirstSample = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">        fXformAnimated = (prevXformSample != fXformSample);</div>
<div class="line">        fVisibilityAnimated = (prevVisibilitySample != fVisibilitySample);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;const XformSample&gt;</div>
<div class="line">CacheXformSampler::getSample(<span class="keywordtype">double</span> timeInSeconds)</div>
<div class="line">{</div>
<div class="line">    std::shared_ptr&lt;XformSample&gt; sample =</div>
<div class="line">        XformSample::create(</div>
<div class="line">            timeInSeconds,fXformSample, <a name="_a5"></a><a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>(), fVisibilitySample);</div>
<div class="line"> <span class="keywordflow">return</span> sample;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS CacheMeshSampler::AttributeSet</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line">CacheMeshSampler::AttributeSet::AttributeSet(</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> meshObject,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> visibility,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">typedef</span> IndexBuffer::index_t index_t;</div>
<div class="line"></div>
<div class="line">    MayaMeshExtractor&lt;index_t&gt; extractor(meshObject);</div>
<div class="line">    extractor.setWantUVs(needUVs);</div>
<div class="line">    extractor.compute();</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;Array&lt;index_t&gt; &gt; wireIndices     = extractor.wireIndices();</div>
<div class="line">    std::shared_ptr&lt;Array&lt;index_t&gt; &gt; triangleIndices = extractor.triangleIndices();</div>
<div class="line">    std::shared_ptr&lt;Array&lt;float&gt; &gt; positions = extractor.positions();</div>
<div class="line">    std::shared_ptr&lt;Array&lt;float&gt; &gt; normals   = extractor.normals();</div>
<div class="line">    std::shared_ptr&lt;Array&lt;float&gt; &gt; uvs;</div>
<div class="line"> <span class="keywordflow">if</span> (needUVs) {</div>
<div class="line">        uvs = extractor.uvs();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fNumWires     = wireIndices-&gt;size() / 2;</div>
<div class="line">    fNumTriangles = triangleIndices-&gt;size() / 3;</div>
<div class="line">    fNumVerts     = positions-&gt;size() / 3;</div>
<div class="line"></div>
<div class="line">    fWireVertIndices = IndexBuffer::create(wireIndices);</div>
<div class="line">    fTriangleVertIndices.push_back(IndexBuffer::create(triangleIndices));</div>
<div class="line"></div>
<div class="line">    fPositions = VertexBuffer::createPositions(positions);</div>
<div class="line">    fNormals   = VertexBuffer::createNormals(normals);</div>
<div class="line"> <span class="keywordflow">if</span> (needUVs) {</div>
<div class="line">        fUVs       = VertexBuffer::createUVs(uvs);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">float</span> minX = +std::numeric_limits&lt;float&gt;::max();</div>
<div class="line"> <span class="keywordtype">float</span> minY = +std::numeric_limits&lt;float&gt;::max();</div>
<div class="line"> <span class="keywordtype">float</span> minZ = +std::numeric_limits&lt;float&gt;::max();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">float</span> maxX = -std::numeric_limits&lt;float&gt;::max();</div>
<div class="line"> <span class="keywordtype">float</span> maxY = -std::numeric_limits&lt;float&gt;::max();</div>
<div class="line"> <span class="keywordtype">float</span> maxZ = -std::numeric_limits&lt;float&gt;::max();</div>
<div class="line"></div>
<div class="line">        VertexBuffer::ReadInterfacePtr readable = fPositions-&gt;readableInterface();</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* srcPositions = readable-&gt;get();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;fNumVerts; ++i) {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> x = srcPositions[3*i + 0];</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> y = srcPositions[3*i + 1];</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> z = srcPositions[3*i + 2];</div>
<div class="line"></div>
<div class="line">            minX = std::min(x, minX);</div>
<div class="line">            minY = std::min(y, minY);</div>
<div class="line">            minZ = std::min(z, minZ);</div>
<div class="line"></div>
<div class="line">            maxX = std::max(x, maxX);</div>
<div class="line">            maxY = std::max(y, maxY);</div>
<div class="line">            maxZ = std::max(z, maxZ);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        fBoundingBox = <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>(<a name="_a6"></a><a class="code" href="./class_m_point.html">MPoint</a>(minX, minY, minZ),</div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a>(maxX, maxY, maxZ));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    fVisibility  = visibility;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">CacheMeshSampler::AttributeSet::AttributeSet(</div>
<div class="line"> <a name="_a7"></a><a class="code" href="./class_m_fn_mesh.html">MFnMesh</a>&amp; mesh,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> useBaseTessellation</div>
<div class="line">)</div>
<div class="line">    :fNumWires(0),</div>
<div class="line">    fNumTriangles(0),</div>
<div class="line">    fNumVerts(0),</div>
<div class="line">    fVisibility(false)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Refresh the internal shape, otherwise topo changes make mesh.numPolygons() crash.</span></div>
<div class="line"> <span class="comment">// Note that buildShaderAssignmentGroups() also call mesh.numPolygons().</span></div>
<div class="line">    mesh.<a name="a8"></a><a class="code" href="./class_m_fn_mesh.html#a5e980be04112646bb555d4bb865581e7">syncObject</a>();</div>
<div class="line"></div>
<div class="line"> <a name="_a9"></a><a class="code" href="./class_m_dag_path.html">MDagPath</a> dagPath;</div>
<div class="line">    mesh.<a name="a10"></a><a class="code" href="./class_m_fn_dag_node.html#adfb40b1f56af23ad94c4ca77c9a147b5">getPath</a>(dagPath);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// build a geometry request and add requirements to it.</span></div>
<div class="line"> <a name="_a11"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html">MHWRender::MGeometryRequirements</a> geomRequirements;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Build descriptors to request the positions, normals and UVs  </span></div>
<div class="line"> <a name="_a12"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> posDesc(<span class="stringliteral">""</span>, MGeometry::kPosition, MGeometry::kFloat, 3);</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> normalDesc(<span class="stringliteral">""</span>, MGeometry::kNormal, MGeometry::kFloat, 3);</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> uvDesc(mesh.<a name="a13"></a><a class="code" href="./class_m_fn_mesh.html#a63648568635afc4b0935ee0c4d712565">currentUVSetName</a>(), MGeometry::kTexture, MGeometry::kFloat, 2);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// add the descriptors to the geometry requirements</span></div>
<div class="line">    geomRequirements.<a name="a14"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#a701ff08a8e58c9451fe6a3794e577027">addVertexRequirement</a>(posDesc);</div>
<div class="line">    geomRequirements.<a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#a701ff08a8e58c9451fe6a3794e577027">addVertexRequirement</a>(normalDesc);</div>
<div class="line"> <span class="keywordflow">if</span> (needUVs)</div>
<div class="line">        geomRequirements.<a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#a701ff08a8e58c9451fe6a3794e577027">addVertexRequirement</a>(uvDesc);</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> noName; <span class="comment">// we do not need custom named index buffers here.</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// create a component to include all elements.</span></div>
<div class="line"> <a name="_a15"></a><a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> comp;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> compObj = comp.<a name="a16"></a><a class="code" href="./class_m_fn_single_indexed_component.html#ae3b7a9c926f9770f786893bbea825d6b">create</a>(<a name="a17"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a5ddabf9726f89e07cff62014221fe6fb">MFn::kMeshPolygonComponent</a>);</div>
<div class="line">    comp.<a name="a18"></a><a class="code" href="./class_m_fn_single_indexed_component.html#ae4dcbac2a79082a32f18c613803a1c3f">setCompleteData</a>(mesh.<a name="a19"></a><a class="code" href="./class_m_fn_mesh.html#a3a7a28cf8f6a12dd19ab6ed0a639f9ed">numPolygons</a>());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// create edge component</span></div>
<div class="line"> <a class="code" href="./class_m_fn_single_indexed_component.html">MFnSingleIndexedComponent</a> edgeComp;</div>
<div class="line"> <a class="code" href="./class_m_object.html">MObject</a> edgeCompObj = edgeComp.<a class="code" href="./class_m_fn_single_indexed_component.html#ae3b7a9c926f9770f786893bbea825d6b">create</a>(<a name="a20"></a><a class="code" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a18f788d50a75ca81a0dc5a2538f364ae">MFn::kMeshEdgeComponent</a>);</div>
<div class="line">    edgeComp.<a class="code" href="./class_m_fn_single_indexed_component.html#ae4dcbac2a79082a32f18c613803a1c3f">setCompleteData</a>(mesh.<a name="a21"></a><a class="code" href="./class_m_fn_mesh.html#a742ce017199905f06ad07c178375a2d8">numEdges</a>());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Add the edge line index buffer to the requirements</span></div>
<div class="line"> <a name="_a22"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer_descriptor.html">MIndexBufferDescriptor</a> edgeDesc(MIndexBufferDescriptor::kEdgeLine, noName, MGeometry::kLines, 2, edgeCompObj);</div>
<div class="line">    geomRequirements.<a name="a23"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#ade8935319d3d2463ab9ff0499580e5a0">addIndexingRequirement</a>(edgeDesc);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// add a triangle buffer to the requirements</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_index_buffer_descriptor.html">MIndexBufferDescriptor</a> triangleDesc(MIndexBufferDescriptor::kTriangle, noName, MGeometry::kTriangles, 3, compObj);</div>
<div class="line">    geomRequirements.<a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#ade8935319d3d2463ab9ff0499580e5a0">addIndexingRequirement</a>(triangleDesc);</div>
<div class="line"></div>
<div class="line"> <span class="keyword">typedef</span> IndexBuffer::index_t index_t;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We ignore the Smooth Preview option on the mesh shape node when</span></div>
<div class="line"> <span class="comment">// using base tessellation.</span></div>
<div class="line"> <span class="keywordtype">int</span> extractorOptions = <a name="a24"></a><a class="code" href="./namespace_m_h_w_render.html#adc29c2ff13d900c2f185ee95427fb06ca6f4996143f966bf5534e8dae77fb015d">MHWRender::kPolyGeom_Normal</a>;</div>
<div class="line"> <span class="keywordflow">if</span> (useBaseTessellation) {</div>
<div class="line">        extractorOptions |= <a name="a25"></a><a class="code" href="./namespace_m_h_w_render.html#adc29c2ff13d900c2f185ee95427fb06caf9a84a63b26a2608789f2fc89e279a08">MHWRender::kPolyGeom_BaseMesh</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// create an extractor to get the geometry</span></div>
<div class="line"> <a name="_a26"></a><a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"> <a name="_a27"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_extractor.html">MHWRender::MGeometryExtractor</a> extractor(geomRequirements,dagPath, extractorOptions, &amp;status);</div>
<div class="line"> <span class="keywordflow">if</span> (MS::kFailure==status)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get the number of vertices from the extractor</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numVertices   = extractor.vertexCount();</div>
<div class="line"> <span class="comment">// get the number of primitives (triangles, lines, etc.)</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numWires = extractor.primitiveCount(edgeDesc);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// create the arrays that the generator will fill</span></div>
<div class="line">    GPUCache::shared_array&lt;float&gt; vertices(<span class="keyword">new</span> <span class="keywordtype">float</span>[numVertices*posDesc.stride()]);</div>
<div class="line">    GPUCache::shared_array&lt;float&gt; normals(<span class="keyword">new</span> <span class="keywordtype">float</span>[numVertices*normalDesc.stride()]);</div>
<div class="line">    GPUCache::shared_array&lt;float&gt; uvs(<span class="keyword">new</span> <span class="keywordtype">float</span>[numVertices*uvDesc.stride()]);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minBufferSize = extractor.minimumBufferSize(numWires, edgeDesc.primitive());</div>
<div class="line">    GPUCache::shared_array&lt;index_t&gt; wireframeIdx(<span class="keyword">new</span> index_t[minBufferSize]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// populate the index buffer for the edges</span></div>
<div class="line"> <span class="keywordflow">if</span> (MS::kFailure==extractor.populateIndexBuffer(wireframeIdx.get(), numWires, edgeDesc))</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"> <span class="comment">// populate the vertex buffers you are interested in. (pos, normal, and uv)</span></div>
<div class="line"> <span class="keywordflow">if</span> (MS::kFailure==extractor.populateVertexBuffer(vertices.get(), numVertices, posDesc))</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (MS::kFailure==extractor.populateVertexBuffer(normals.get(), numVertices, normalDesc))</div>
<div class="line"> <span class="keywordflow">return</span>; </div>
<div class="line"> <span class="keywordflow">if</span> (needUVs &amp;&amp; MS::kFailure==extractor.populateVertexBuffer(uvs.get(), numVertices, uvDesc))</div>
<div class="line"> <span class="keywordflow">return</span>; </div>
<div class="line"></div>
<div class="line"> <span class="comment">// populate the index buffers for all the triangle components</span></div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;std::shared_ptr&lt;Array&lt;index_t&gt; &gt; &gt; trgIdxGrps;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get the index buffer count from the extractor</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numTriangles = extractor.primitiveCount(triangleDesc);</div>
<div class="line">        minBufferSize = extractor.minimumBufferSize(numTriangles, triangleDesc.primitive());</div>
<div class="line">        GPUCache::shared_array&lt;index_t&gt; triangleIdx(<span class="keyword">new</span> index_t[minBufferSize]);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (numTriangles != 0) </div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">if</span> (MS::kFailure==extractor.populateIndexBuffer(triangleIdx.get(), numTriangles, triangleDesc))</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">            fNumTriangles += (size_t)numTriangles;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        trgIdxGrps.push_back(SharedArray&lt;index_t&gt;::create(</div>
<div class="line">            triangleIdx, 3 * numTriangles));</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0, offset=0; i&lt;trgIdxGrps.size(); ++i) {</div>
<div class="line">            fTriangleVertIndices.push_back(IndexBuffer::create(</div>
<div class="line">                trgIdxGrps[0], offset, offset + trgIdxGrps[i]-&gt;size()));</div>
<div class="line">            offset += trgIdxGrps[i]-&gt;size();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fNumWires     = (size_t)numWires;</div>
<div class="line">    fNumVerts     = (size_t)numVertices;</div>
<div class="line"></div>
<div class="line">    fWireVertIndices = IndexBuffer::create(</div>
<div class="line">        SharedArray&lt;index_t&gt;::create( wireframeIdx, 2 * fNumWires));   </div>
<div class="line"></div>
<div class="line">    fPositions = VertexBuffer::createPositions(</div>
<div class="line">        SharedArray&lt;float&gt;::create( vertices, 3 * fNumVerts));</div>
<div class="line"></div>
<div class="line">    fNormals = VertexBuffer::createNormals(</div>
<div class="line">        SharedArray&lt;float&gt;::create( normals, 3 * fNumVerts));</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (needUVs) {</div>
<div class="line">        fUVs = VertexBuffer::createUVs(</div>
<div class="line">            SharedArray&lt;float&gt;::create(uvs, 2 * fNumVerts));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fBoundingBox = mesh.<a name="a28"></a><a class="code" href="./class_m_fn_dag_node.html#a9efd77281910086e293d68b2ea568663">boundingBox</a>();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Check visibility </span></div>
<div class="line">    fVisibility = ShapeVisibilityChecker(mesh.<a name="a29"></a><a class="code" href="./class_m_fn_base.html#a01c802c0a7fc219b5a9beff9787bcfa2">object</a>()).isVisible();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> CacheMeshSampler::AttributeSet::updateAnimatedChannels(</div>
<div class="line"> <span class="keywordtype">bool</span>&amp; animated, <span class="keyword">const</span> AttributeSet&amp; newer</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> numWiresAnimated     = fNumWires     != newer.fNumWires;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> numTrianglesAnimated = fNumTriangles != newer.fNumTriangles;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> numVertsAnimated     = fNumVerts     != newer.fNumVerts;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> wiresAnimated = fWireVertIndices != newer.fWireVertIndices;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We reuse the triangulation from the previous sample</span></div>
<div class="line"> <span class="comment">// if the topology of the wire mesh is not changing. This is</span></div>
<div class="line"> <span class="comment">// done to avoid performance issue due to position dependent</span></div>
<div class="line"> <span class="comment">// triangulation of animated meshes. </span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> trianglesAnimated =</div>
<div class="line">        (!numWiresAnimated &amp;&amp; !numTrianglesAnimated &amp;&amp; !numVertsAnimated &amp;&amp;</div>
<div class="line">         !wiresAnimated) ?</div>
<div class="line"> <span class="keyword">false</span> :</div>
<div class="line">        (fTriangleVertIndices != newer.fTriangleVertIndices);</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> positionsAnimated = fPositions != newer.fPositions;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> normalsAnimated   = fNormals   != newer.fNormals;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> uvsAnimated       = fUVs       != newer.fUVs;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> boundingBoxAnimated =</div>
<div class="line">        (!fBoundingBox.min().isEquivalent(newer.fBoundingBox.min()) ||</div>
<div class="line">         !fBoundingBox.max().isEquivalent(newer.fBoundingBox.max()));</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> visibilityAnimated = fVisibility != newer.fVisibility;</div>
<div class="line"></div>
<div class="line">    fNumWires     = newer.fNumWires;</div>
<div class="line">    fNumTriangles = newer.fNumTriangles;</div>
<div class="line">    fNumVerts     = newer.fNumVerts;</div>
<div class="line"> </div>
<div class="line">    fWireVertIndices = wiresAnimated ? newer.fWireVertIndices : fWireVertIndices;</div>
<div class="line"></div>
<div class="line">    fTriangleVertIndices = trianglesAnimated ? newer.fTriangleVertIndices : fTriangleVertIndices;</div>
<div class="line"></div>
<div class="line">    fPositions = positionsAnimated ? newer.fPositions : fPositions;</div>
<div class="line">    fNormals   = normalsAnimated   ? newer.fNormals   : fNormals;</div>
<div class="line">    fUVs       = uvsAnimated       ? newer.fUVs       : fUVs;</div>
<div class="line"></div>
<div class="line">    fBoundingBox = newer.fBoundingBox;</div>
<div class="line"></div>
<div class="line">    fVisibility  = newer.fVisibility;</div>
<div class="line"> </div>
<div class="line">    animated =</div>
<div class="line">        numWiresAnimated || numTrianglesAnimated || numVertsAnimated ||</div>
<div class="line">        wiresAnimated || trianglesAnimated ||</div>
<div class="line">        positionsAnimated || normalsAnimated || uvsAnimated ||</div>
<div class="line">        boundingBoxAnimated || visibilityAnimated;</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"><span class="comment">// CLASS CacheMeshSampler</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>CacheMeshSampler::MakeSharedEnabler: <span class="keyword">public</span> CacheMeshSampler{</div>
<div class="line">    MakeSharedEnabler(<span class="keywordtype">bool</span> needUVs):CacheMeshSampler(needUVs){}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;CacheMeshSampler&gt; CacheMeshSampler::create(</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> std::make_shared&lt;MakeSharedEnabler&gt;(needUVs);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">CacheMeshSampler::CacheMeshSampler(<span class="keyword">const</span> <span class="keywordtype">bool</span> needUVs)</div>
<div class="line">    : fNeedUVs(needUVs), fUseBaseTessellation(false), fIsAnimated(true)</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line">CacheMeshSampler::~CacheMeshSampler()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> CacheMeshSampler::addSample(<a class="code" href="./class_m_object.html">MObject</a> meshObject, <span class="keywordtype">bool</span> visibility)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fAttributeSet.updateAnimatedChannels(</div>
<div class="line">        fIsAnimated, AttributeSet(meshObject, visibility, fNeedUVs));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> CacheMeshSampler::addSampleFromMesh(<a class="code" href="./class_m_fn_mesh.html">MFnMesh</a>&amp; mesh)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">return</span> fAttributeSet.updateAnimatedChannels(</div>
<div class="line">        fIsAnimated, AttributeSet(mesh, fNeedUVs, fUseBaseTessellation));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::shared_ptr&lt;const ShapeSample&gt;</div>
<div class="line">CacheMeshSampler::getSample(<span class="keywordtype">double</span> timeInSeconds, <span class="keyword">const</span> <a name="_a30"></a><a class="code" href="./class_m_color.html">MColor</a>&amp; diffuseColor)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!fAttributeSet.fVisibility) {</div>
<div class="line"> <span class="comment">// return an empty sample if the shape is invisible</span></div>
<div class="line">        std::shared_ptr&lt;ShapeSample&gt; sample = </div>
<div class="line">        ShapeSample::createEmptySample(timeInSeconds);</div>
<div class="line"> <span class="keywordflow">return</span> sample;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::shared_ptr&lt;ShapeSample&gt; sample =</div>
<div class="line">        ShapeSample::create(</div>
<div class="line">            timeInSeconds,</div>
<div class="line">            fAttributeSet.fNumWires,</div>
<div class="line">            fAttributeSet.fNumVerts,</div>
<div class="line">            fAttributeSet.fWireVertIndices,</div>
<div class="line">            fAttributeSet.fTriangleVertIndices,</div>
<div class="line">            fAttributeSet.fPositions,</div>
<div class="line">            fAttributeSet.fBoundingBox,</div>
<div class="line">            diffuseColor,</div>
<div class="line">            fAttributeSet.fVisibility</div>
<div class="line">        );</div>
<div class="line">    sample-&gt;setNormals(fAttributeSet.fNormals);</div>
<div class="line">    sample-&gt;setUVs(fAttributeSet.fUVs);</div>
<div class="line"> <span class="keywordflow">return</span> sample;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>

<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
<title>C++ API Reference: MPxSurfaceShape Class Reference</title>
</head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"/><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_px_surface_shape.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
<div>
<div class="head">
<h1>C++ API Reference: MPxSurfaceShape Class Reference</h1>
</div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>Main Page</span></a></li>
<li><a href="./pages.html"><span>Related Pages</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li class="current"><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
<li>
<div class="MSearchBoxInactive" id="MSearchBox">
<span class="left">
<img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="cpp_ref/search/mag_sel.png"/>
<input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
</span><span class="right">
<a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="cpp_ref/search/close.png"/></a>
</span>
</div>
</li>
</ul>
</div>
<div class="tabs2" id="navrow2">
<ul class="tablist">
<li><a href="./annotated.html"><span>Class List</span></a></li>
<li><a href="./classes.html"><span>Class Index</span></a></li>
<li><a href="./hierarchy.html"><span>Class Hierarchy</span></a></li>
<li><a href="./functions.html"><span>Class Members</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<!-- window showing the filter options -->
<!-- iframe showing the search results (closed by default) -->
<div class="header">
<div class="headertitle">
<div class="title">MPxSurfaceShape Class Reference<div class="ingroups"><a class="el" href="./group___open_maya.html">OpenMaya - API module for common classes</a> | <a class="el" href="./group___m_px.html">Proxy classes</a></div></div> </div>
<div id="OverviewLinksDiv"><div class="dynheader closed" id="dynsection-overview" onclick="return toggleVisibility(this)" style="cursor:pointer;"><img alt="+" id="dynsection-overview-trigger" src="cpp_ref/closed.png"/> Related help topics: </div><div class="dyncontent" id="dynsection-overview-content" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./dev_help/Dependency-graph-plug-ins/Base-dependency-node-classes.html">Dependency graph plug-ins &gt; Base dependency node classes</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Shapes/Shapes-in-Maya.html">Shapes &gt; Shapes in Maya</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Shapes/Shape-classes.html">Shapes &gt; Shape classes</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Shapes/Writing-a-shape.html">Shapes &gt; Writing a shape</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Shapes/Components.html">Shapes &gt; Components</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Shapes/Marking-Menus.html">Shapes &gt; Marking Menus</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Overview-of-the-Viewport-2-0-API/Scene-Overrides.html">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Scene Overrides</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Overview-of-the-Viewport-2-0-API/Transition-Guide.html">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Transition Guide</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Overview-of-the-Viewport-2-0-API/Developer-Kit-Samples.html">Viewport 2.0 API &gt; Overview of the Viewport 2.0 API &gt; Developer Kit Samples</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Handling-custom-renderables-for.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Handling custom renderables for object overrides</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Porting-Selection-from-Viewport.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Porting Selection from Viewport 1 to 2</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Maya-Python-API/Maya-Python-Plug-in-Learning/Dependency-Graph-Plug-in-Basics.html">Maya Python API &gt; Maya Python Plug-in Learning Path &gt; Dependency Graph Plug-in Basics</a></li>
<li class="overviewLink"><a href="#!/url=./dev_help/Maya-Python-API/Maya-Python-API-1-0/Using-the-Maya-Python-API.html">Maya Python API &gt; Maya Python API 1.0 &gt; Using the Maya Python API</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_px_surface_shape.html#pub-methods">Public Member Functions</a> |
<a href="class_m_px_surface_shape.html#pub-static-methods">Static Public Member Functions</a> |
<a href="class_m_px_surface_shape.html#pub-static-attribs">Static Public Attributes</a> |
<a href="./class_m_px_surface_shape-members.html">List of all members</a> </div></div><!--header-->
<div class="contents">
<p>Parent class of all user defined shapes.  
 <a href="./class_m_px_surface_shape.html#details">More...</a></p>
<p><code>#include &lt;MPxSurfaceShape.h&gt;</code></p>
<div class="dynheader closed" id="dynsection-0" onclick="return toggleVisibility(this)" style="cursor:pointer;">
<img alt="+" id="dynsection-0-trigger" src="cpp_ref/closed.png"/> Inheritance diagram for MPxSurfaceShape:</div>
<div class="dynsummary" id="dynsection-0-summary" style="display:block;">
</div>
<div class="dyncontent" id="dynsection-0-content" style="display:none;">
<div class="center">
<img alt="" src="cpp_ref/class_m_px_surface_shape.png" usemap="#MPxSurfaceShape_map"/>
<map id="MPxSurfaceShape_map" name="MPxSurfaceShape_map">
<area alt="MPxNode" coords="0,0,136,24" href="class_m_px_node.html" shape="rect" title="Base class for user defined dependency nodes. "/>
<area alt="MPxComponentShape" coords="0,112,136,136" href="class_m_px_component_shape.html" shape="rect" title="Component helper class for surface shapes. "/>
</map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a562fb3d6ffc0a5e86cd36bcd9556d929"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a562fb3d6ffc0a5e86cd36bcd9556d929">MPxSurfaceShape</a> ()</td></tr>
<tr class="memdesc:a562fb3d6ffc0a5e86cd36bcd9556d929"><td class="mdescLeft"> </td><td class="mdescRight">Class constructor.  <a href="class_m_px_surface_shape.html#a562fb3d6ffc0a5e86cd36bcd9556d929">More...</a><br/></td></tr>
<tr class="separator:a562fb3d6ffc0a5e86cd36bcd9556d929"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d29d2354237397d96b28e84b2deca38"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9d29d2354237397d96b28e84b2deca38"></a>
virtual </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a9d29d2354237397d96b28e84b2deca38">~MPxSurfaceShape</a> ()</td></tr>
<tr class="memdesc:a9d29d2354237397d96b28e84b2deca38"><td class="mdescLeft"> </td><td class="mdescRight">Class destructor. <br/></td></tr>
<tr class="separator:a9d29d2354237397d96b28e84b2deca38"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71bae20f7cb1d030904cf421f1c5eba2"><td align="right" class="memItemLeft" valign="top">virtual MPxNode::Type </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a71bae20f7cb1d030904cf421f1c5eba2">type</a> () const </td></tr>
<tr class="memdesc:a71bae20f7cb1d030904cf421f1c5eba2"><td class="mdescLeft"> </td><td class="mdescRight">Returns the type of node that this is.  <a href="class_m_px_surface_shape.html#a71bae20f7cb1d030904cf421f1c5eba2">More...</a><br/></td></tr>
<tr class="separator:a71bae20f7cb1d030904cf421f1c5eba2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4254418493ef1ab6847b9e5f395fa3de"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a4254418493ef1ab6847b9e5f395fa3de">isBounded</a> () const </td></tr>
<tr class="memdesc:a4254418493ef1ab6847b9e5f395fa3de"><td class="mdescLeft"> </td><td class="mdescRight">This method should be overridden to return true if the user supplies a bounding box routine.  <a href="class_m_px_surface_shape.html#a4254418493ef1ab6847b9e5f395fa3de">More...</a><br/></td></tr>
<tr class="separator:a4254418493ef1ab6847b9e5f395fa3de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a762dab569a9d88aa731f3c7229803e1e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_bounding_box.html">MBoundingBox</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a762dab569a9d88aa731f3c7229803e1e">boundingBox</a> () const </td></tr>
<tr class="memdesc:a762dab569a9d88aa731f3c7229803e1e"><td class="mdescLeft"> </td><td class="mdescRight">This method should be overridden to return a bounding box for the shape.  <a href="class_m_px_surface_shape.html#a762dab569a9d88aa731f3c7229803e1e">More...</a><br/></td></tr>
<tr class="separator:a762dab569a9d88aa731f3c7229803e1e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0c5bb0e48bb6fb231e04342190aae877"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0c5bb0e48bb6fb231e04342190aae877"></a>
 </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a0c5bb0e48bb6fb231e04342190aae877">OPENMAYA_ENUM</a> (MVertexCachingMode, kNoPointCaching, kSavePoints, kRestorePoints, kUpdatePoints, kTransformOriginalPoints)</td></tr>
<tr class="memdesc:a0c5bb0e48bb6fb231e04342190aae877"><td class="mdescLeft"> </td><td class="mdescRight">Vertex caching modes. <br/></td></tr>
<tr class="separator:a0c5bb0e48bb6fb231e04342190aae877"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac7ed3c12a9d58732798aa421249e2027"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#ac7ed3c12a9d58732798aa421249e2027">evalNodeAffectsDrawDb</a> (const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp;evaluationNode)</td></tr>
<tr class="memdesc:ac7ed3c12a9d58732798aa421249e2027"><td class="mdescLeft"> </td><td class="mdescRight">This method should be overridden to return true if the evaluationNode contains any dirty plugs that will affect the drawing of your plug-in.  <a href="class_m_px_surface_shape.html#ac7ed3c12a9d58732798aa421249e2027">More...</a><br/></td></tr>
<tr class="separator:ac7ed3c12a9d58732798aa421249e2027"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8c173b035e5039b8db8a25974f7b68f4"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a8c173b035e5039b8db8a25974f7b68f4">transformUsing</a> (const <a class="el" href="./class_m_matrix.html">MMatrix</a> &amp;mat, const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;componentList)</td></tr>
<tr class="memdesc:a8c173b035e5039b8db8a25974f7b68f4"><td class="mdescLeft"> </td><td class="mdescRight">Transform the given components using the specified transformation matrix.  <a href="class_m_px_surface_shape.html#a8c173b035e5039b8db8a25974f7b68f4">More...</a><br/></td></tr>
<tr class="separator:a8c173b035e5039b8db8a25974f7b68f4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5a0f241f5c9780c04ea636d318a30d46"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a5a0f241f5c9780c04ea636d318a30d46">transformUsing</a> (const <a class="el" href="./class_m_matrix.html">MMatrix</a> &amp;mat, const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;componentList, MVertexCachingMode cachingMode, <a class="el" href="./class_m_point_array.html">MPointArray</a> *pointCache)</td></tr>
<tr class="memdesc:a5a0f241f5c9780c04ea636d318a30d46"><td class="mdescLeft"> </td><td class="mdescRight">Transform the given components using the specified transformation matrix.  <a href="class_m_px_surface_shape.html#a5a0f241f5c9780c04ea636d318a30d46">More...</a><br/></td></tr>
<tr class="separator:a5a0f241f5c9780c04ea636d318a30d46"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a63d07adee03843317948fb8f92bb0ecd"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a63d07adee03843317948fb8f92bb0ecd">tweakUsing</a> (const <a class="el" href="./class_m_matrix.html">MMatrix</a> &amp;mat, const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;componentList, MVertexCachingMode cachingMode, <a class="el" href="./class_m_point_array.html">MPointArray</a> *pointCache, <a class="el" href="./class_m_array_data_handle.html">MArrayDataHandle</a> &amp;handle)</td></tr>
<tr class="memdesc:a63d07adee03843317948fb8f92bb0ecd"><td class="mdescLeft"> </td><td class="mdescRight">Transform the given components using the specified transformation matrix.  <a href="class_m_px_surface_shape.html#a63d07adee03843317948fb8f92bb0ecd">More...</a><br/></td></tr>
<tr class="separator:a63d07adee03843317948fb8f92bb0ecd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0b16bb5955cf8762e3a521686c72be04"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a0b16bb5955cf8762e3a521686c72be04">convertToTweakNodePlug</a> (<a class="el" href="./class_m_plug.html">MPlug</a> &amp;plug) const </td></tr>
<tr class="memdesc:a0b16bb5955cf8762e3a521686c72be04"><td class="mdescLeft"> </td><td class="mdescRight">Check if a tweak node is connected to this node.  <a href="class_m_px_surface_shape.html#a0b16bb5955cf8762e3a521686c72be04">More...</a><br/></td></tr>
<tr class="separator:a0b16bb5955cf8762e3a521686c72be04"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a66ccd127d36b5dc896459eddff2b7587"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a66ccd127d36b5dc896459eddff2b7587">weightedTransformUsing</a> (const <a class="el" href="./class_m_transformation_matrix.html">MTransformationMatrix</a> &amp;xform, const <a class="el" href="./class_m_matrix.html">MMatrix</a> *space, const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;componentList, MVertexCachingMode cachingMode, <a class="el" href="./class_m_point_array.html">MPointArray</a> *pointCache, const <a class="el" href="./class_m_plane.html">MPlane</a> *freezePlane)</td></tr>
<tr class="memdesc:a66ccd127d36b5dc896459eddff2b7587"><td class="mdescLeft"> </td><td class="mdescRight">Transform the given components with interpolation using the specified transformation matrix.  <a href="class_m_px_surface_shape.html#a66ccd127d36b5dc896459eddff2b7587">More...</a><br/></td></tr>
<tr class="separator:a66ccd127d36b5dc896459eddff2b7587"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa704affe596b61074b4eb2bf087e8092"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#aa704affe596b61074b4eb2bf087e8092">weightedTweakUsing</a> (const <a class="el" href="./class_m_transformation_matrix.html">MTransformationMatrix</a> &amp;xform, const <a class="el" href="./class_m_matrix.html">MMatrix</a> *space, const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;componentList, MVertexCachingMode cachingMode, <a class="el" href="./class_m_point_array.html">MPointArray</a> *pointCache, const <a class="el" href="./class_m_plane.html">MPlane</a> *freezePlane, <a class="el" href="./class_m_array_data_handle.html">MArrayDataHandle</a> &amp;handle)</td></tr>
<tr class="memdesc:aa704affe596b61074b4eb2bf087e8092"><td class="mdescLeft"> </td><td class="mdescRight">Transform the given components with interpolation using the specified transformation matrix.  <a href="class_m_px_surface_shape.html#aa704affe596b61074b4eb2bf087e8092">More...</a><br/></td></tr>
<tr class="separator:aa704affe596b61074b4eb2bf087e8092"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab5148df163f4dd97913f2a7ac73ac242"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab5148df163f4dd97913f2a7ac73ac242"></a>
 </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#ab5148df163f4dd97913f2a7ac73ac242">OPENMAYA_ENUM</a> (MVertexOffsetMode, kNormal, kUTangent, kVTangent, kUVNTriad)</td></tr>
<tr class="memdesc:ab5148df163f4dd97913f2a7ac73ac242"><td class="mdescLeft"> </td><td class="mdescRight">Vertex offset modes. <br/></td></tr>
<tr class="separator:ab5148df163f4dd97913f2a7ac73ac242"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a53b5c9f420f95352364d44af3cf1dc77"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a53b5c9f420f95352364d44af3cf1dc77">vertexOffsetDirection</a> (<a class="el" href="./class_m_object.html">MObject</a> &amp;component, <a class="el" href="./class_m_vector_array.html">MVectorArray</a> &amp;direction, MVertexOffsetMode mode, bool normalize)</td></tr>
<tr class="memdesc:a53b5c9f420f95352364d44af3cf1dc77"><td class="mdescLeft"> </td><td class="mdescRight">This method should be overridden if the shape supports components that can be moved in the direction of the normal or UV's using the move vertex normal tool.  <a href="class_m_px_surface_shape.html#a53b5c9f420f95352364d44af3cf1dc77">More...</a><br/></td></tr>
<tr class="separator:a53b5c9f420f95352364d44af3cf1dc77"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2698fc8bec46daa06a301e75eb3dff28"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a2698fc8bec46daa06a301e75eb3dff28">newControlPointComponent</a> () const </td></tr>
<tr class="memdesc:a2698fc8bec46daa06a301e75eb3dff28"><td class="mdescLeft"> </td><td class="mdescRight">The default action of this method is to return an <a class="el" href="./class_m_fn_single_indexed_component.html" title="Single indexed component function set. ">MFnSingleIndexedComponent</a> (of type <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  ">MFn::kMeshVertComponent</a>) in order to support rigid skinning binds.  <a href="class_m_px_surface_shape.html#a2698fc8bec46daa06a301e75eb3dff28">More...</a><br/></td></tr>
<tr class="separator:a2698fc8bec46daa06a301e75eb3dff28"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a500209ff59fdea62b1a898869fc4d976"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a500209ff59fdea62b1a898869fc4d976">componentToPlugs</a> (<a class="el" href="./class_m_object.html">MObject</a> &amp;component, <a class="el" href="./class_m_selection_list.html">MSelectionList</a> &amp;selectionList) const </td></tr>
<tr class="memdesc:a500209ff59fdea62b1a898869fc4d976"><td class="mdescLeft"> </td><td class="mdescRight">Converts the given component into a selection list of plugs.  <a href="class_m_px_surface_shape.html#a500209ff59fdea62b1a898869fc4d976">More...</a><br/></td></tr>
<tr class="separator:a500209ff59fdea62b1a898869fc4d976"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9b8d2823f22cfea3e77746d84a54e6c"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#aa9b8d2823f22cfea3e77746d84a54e6c">match</a> (const <a class="el" href="./class_m_selection_mask.html">MSelectionMask</a> &amp;mask, const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;componentList) const </td></tr>
<tr class="memdesc:aa9b8d2823f22cfea3e77746d84a54e6c"><td class="mdescLeft"> </td><td class="mdescRight">This method is used to check for matches between a selection type (or mask) and a given component.  <a href="class_m_px_surface_shape.html#aa9b8d2823f22cfea3e77746d84a54e6c">More...</a><br/></td></tr>
<tr class="separator:aa9b8d2823f22cfea3e77746d84a54e6c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad5b7d116bec47de181203ece3092f592"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#ad5b7d116bec47de181203ece3092f592">OPENMAYA_ENUM</a> (MatchResult, kMatchOk, kMatchNone, kMatchTooMany, kMatchInvalidName, kMatchInvalidAttribute, kMatchInvalidAttributeIndex, kMatchInvalidAttributeRange, kMatchInvalidAttributeDim)</td></tr>
<tr class="memdesc:ad5b7d116bec47de181203ece3092f592"><td class="mdescLeft"> </td><td class="mdescRight">Return values for the <a class="el" href="./class_m_px_surface_shape.html#a19499831f6a63ee7b57c942a23764abe" title="This method is used to convert the string representation of a component into a component object and t...">matchComponent()</a> method.  <a href="class_m_px_surface_shape.html#ad5b7d116bec47de181203ece3092f592">More...</a><br/></td></tr>
<tr class="separator:ad5b7d116bec47de181203ece3092f592"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a19499831f6a63ee7b57c942a23764abe"><td align="right" class="memItemLeft" valign="top">virtual MatchResult </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a19499831f6a63ee7b57c942a23764abe">matchComponent</a> (const <a class="el" href="./class_m_selection_list.html">MSelectionList</a> &amp;item, const <a class="el" href="./class_m_attribute_spec_array.html">MAttributeSpecArray</a> &amp;spec, <a class="el" href="./class_m_selection_list.html">MSelectionList</a> &amp;list)</td></tr>
<tr class="memdesc:a19499831f6a63ee7b57c942a23764abe"><td class="mdescLeft"> </td><td class="mdescRight">This method is used to convert the string representation of a component into a component object and to validate that the indices.  <a href="class_m_px_surface_shape.html#a19499831f6a63ee7b57c942a23764abe">More...</a><br/></td></tr>
<tr class="separator:a19499831f6a63ee7b57c942a23764abe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acedd5e97c21aacfc5f976499438c7fa8"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_selection_mask.html">MSelectionMask</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#acedd5e97c21aacfc5f976499438c7fa8">getShapeSelectionMask</a> () const </td></tr>
<tr class="memdesc:acedd5e97c21aacfc5f976499438c7fa8"><td class="mdescLeft"> </td><td class="mdescRight">This routine must be overridden if the shape is to support interactive object selection in Viewport 2.0 and should provide information about the selection mask of the shape.  <a href="class_m_px_surface_shape.html#acedd5e97c21aacfc5f976499438c7fa8">More...</a><br/></td></tr>
<tr class="separator:acedd5e97c21aacfc5f976499438c7fa8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8904f1188c606e05e32ffb20c92812bf"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_selection_mask.html">MSelectionMask</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a8904f1188c606e05e32ffb20c92812bf">getComponentSelectionMask</a> () const </td></tr>
<tr class="memdesc:a8904f1188c606e05e32ffb20c92812bf"><td class="mdescLeft"> </td><td class="mdescRight">This routine must be overridden if the shape is to support interactive component selection in Viewport 2.0 and should provide information about the selection mask of the shape component.  <a href="class_m_px_surface_shape.html#a8904f1188c606e05e32ffb20c92812bf">More...</a><br/></td></tr>
<tr class="separator:a8904f1188c606e05e32ffb20c92812bf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7c0d18be99d36fdf2c7f476c4b09990"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#aa7c0d18be99d36fdf2c7f476c4b09990">createFullVertexGroup</a> () const </td></tr>
<tr class="memdesc:aa7c0d18be99d36fdf2c7f476c4b09990"><td class="mdescLeft"> </td><td class="mdescRight">This method is used to create a component containing every vertex/CV in the object.  <a href="class_m_px_surface_shape.html#aa7c0d18be99d36fdf2c7f476c4b09990">More...</a><br/></td></tr>
<tr class="separator:aa7c0d18be99d36fdf2c7f476c4b09990"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36be424b47bb1fa94be27226b915add3"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a36be424b47bb1fa94be27226b915add3">createFullRenderGroup</a> () const </td></tr>
<tr class="memdesc:a36be424b47bb1fa94be27226b915add3"><td class="mdescLeft"> </td><td class="mdescRight">This method is used to create a component containing every renderable element in the object.  <a href="class_m_px_surface_shape.html#a36be424b47bb1fa94be27226b915add3">More...</a><br/></td></tr>
<tr class="separator:a36be424b47bb1fa94be27226b915add3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca3deb4f05d04c359d1ef81c54b2876f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7">MFn::Type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#aca3deb4f05d04c359d1ef81c54b2876f">renderGroupComponentType</a> () const </td></tr>
<tr class="memdesc:aca3deb4f05d04c359d1ef81c54b2876f"><td class="mdescLeft"> </td><td class="mdescRight">This method is used to return the type of renderable components for this shape.  <a href="class_m_px_surface_shape.html#aca3deb4f05d04c359d1ef81c54b2876f">More...</a><br/></td></tr>
<tr class="separator:aca3deb4f05d04c359d1ef81c54b2876f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a407741143a081e03cb2a832a3ef3c625"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a407741143a081e03cb2a832a3ef3c625">deleteComponents</a> (const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;componentList, <a class="el" href="./class_m_double_array.html">MDoubleArray</a> &amp;undoInfo)</td></tr>
<tr class="memdesc:a407741143a081e03cb2a832a3ef3c625"><td class="mdescLeft"> </td><td class="mdescRight">This method should be overridden if the shape is to support deletion of components.  <a href="class_m_px_surface_shape.html#a407741143a081e03cb2a832a3ef3c625">More...</a><br/></td></tr>
<tr class="separator:a407741143a081e03cb2a832a3ef3c625"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab8472cd960255565b5d9228e7297ab7a"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#ab8472cd960255565b5d9228e7297ab7a">undeleteComponents</a> (const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;componentList, <a class="el" href="./class_m_double_array.html">MDoubleArray</a> &amp;undoInfo)</td></tr>
<tr class="memdesc:ab8472cd960255565b5d9228e7297ab7a"><td class="mdescLeft"> </td><td class="mdescRight">This method should be overridden if the shape is to support undeletion of components.  <a href="class_m_px_surface_shape.html#ab8472cd960255565b5d9228e7297ab7a">More...</a><br/></td></tr>
<tr class="separator:ab8472cd960255565b5d9228e7297ab7a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1c8d40246a4373be0d73fe10430105f5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a1c8d40246a4373be0d73fe10430105f5">localShapeInAttr</a> () const </td></tr>
<tr class="memdesc:a1c8d40246a4373be0d73fe10430105f5"><td class="mdescLeft"> </td><td class="mdescRight">Returns the attribute containing the shape's input geometry in local space.  <a href="class_m_px_surface_shape.html#a1c8d40246a4373be0d73fe10430105f5">More...</a><br/></td></tr>
<tr class="separator:a1c8d40246a4373be0d73fe10430105f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7a2e324a06d14f1818abbab7129b557a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a7a2e324a06d14f1818abbab7129b557a">localShapeOutAttr</a> () const </td></tr>
<tr class="memdesc:a7a2e324a06d14f1818abbab7129b557a"><td class="mdescLeft"> </td><td class="mdescRight">Returns the attribute containing the shape's output geometry in local space.  <a href="class_m_px_surface_shape.html#a7a2e324a06d14f1818abbab7129b557a">More...</a><br/></td></tr>
<tr class="separator:a7a2e324a06d14f1818abbab7129b557a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abbae36badd1c32ac41370f6d4a47d374"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#abbae36badd1c32ac41370f6d4a47d374">worldShapeOutAttr</a> () const </td></tr>
<tr class="memdesc:abbae36badd1c32ac41370f6d4a47d374"><td class="mdescLeft"> </td><td class="mdescRight">Returns the attribute containing the shape's output geometry in world space.  <a href="class_m_px_surface_shape.html#abbae36badd1c32ac41370f6d4a47d374">More...</a><br/></td></tr>
<tr class="separator:abbae36badd1c32ac41370f6d4a47d374"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a125144a03fb8edcc5a26c3e242c10b47"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a125144a03fb8edcc5a26c3e242c10b47">cachedShapeAttr</a> () const </td></tr>
<tr class="memdesc:a125144a03fb8edcc5a26c3e242c10b47"><td class="mdescLeft"> </td><td class="mdescRight">Returns the attribute containing the shape's cached geometry, if it has one.  <a href="class_m_px_surface_shape.html#a125144a03fb8edcc5a26c3e242c10b47">More...</a><br/></td></tr>
<tr class="separator:a125144a03fb8edcc5a26c3e242c10b47"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a611239ed9089526e878940e0b3996a34"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a611239ed9089526e878940e0b3996a34">geometryData</a> () const </td></tr>
<tr class="memdesc:a611239ed9089526e878940e0b3996a34"><td class="mdescLeft"> </td><td class="mdescRight">Returns the geometry data of the shape.  <a href="class_m_px_surface_shape.html#a611239ed9089526e878940e0b3996a34">More...</a><br/></td></tr>
<tr class="separator:a611239ed9089526e878940e0b3996a34"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa1706bd45fb947b0de139420ea4dc4cf"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#aa1706bd45fb947b0de139420ea4dc4cf">canMakeLive</a> () const </td></tr>
<tr class="memdesc:aa1706bd45fb947b0de139420ea4dc4cf"><td class="mdescLeft"> </td><td class="mdescRight">This method is used by Maya to determine whether a surface can be made live.  <a href="class_m_px_surface_shape.html#aa1706bd45fb947b0de139420ea4dc4cf">More...</a><br/></td></tr>
<tr class="separator:aa1706bd45fb947b0de139420ea4dc4cf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaffee4c66169388f1b0c91ef0ef61c3e"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#aaffee4c66169388f1b0c91ef0ef61c3e">closestPoint</a> (const <a class="el" href="./class_m_point.html">MPoint</a> &amp;raySource, const <a class="el" href="./class_m_vector.html">MVector</a> &amp;rayDirection, <a class="el" href="./class_m_point.html">MPoint</a> &amp;theClosestPoint, <a class="el" href="./class_m_vector.html">MVector</a> &amp;theClosestNormal, bool findClosestOnMiss, double tolerance=MPoint_kTol)</td></tr>
<tr class="memdesc:aaffee4c66169388f1b0c91ef0ef61c3e"><td class="mdescLeft"> </td><td class="mdescRight">This method is used by Maya for snapping queries when your surface is live.  <a href="class_m_px_surface_shape.html#aaffee4c66169388f1b0c91ef0ef61c3e">More...</a><br/></td></tr>
<tr class="separator:aaffee4c66169388f1b0c91ef0ef61c3e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adcb63489b81036d767d32c346973437d"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#adcb63489b81036d767d32c346973437d">closestPoint</a> (const <a class="el" href="./class_m_point.html">MPoint</a> &amp;toThisPoint, <a class="el" href="./class_m_point.html">MPoint</a> &amp;theClosestPoint, double tolerance=MPoint_kTol)</td></tr>
<tr class="memdesc:adcb63489b81036d767d32c346973437d"><td class="mdescLeft"> </td><td class="mdescRight">This method is used by Maya in functions (such as select) that require closest point information from your surface.  <a href="class_m_px_surface_shape.html#adcb63489b81036d767d32c346973437d">More...</a><br/></td></tr>
<tr class="separator:adcb63489b81036d767d32c346973437d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af3169b96a15cf4e39c89fbd3a868775a"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#af3169b96a15cf4e39c89fbd3a868775a">pointAtParm</a> (const <a class="el" href="./class_m_point.html">MPoint</a> &amp;atThisParm, <a class="el" href="./class_m_point.html">MPoint</a> &amp;evaluatedPoint)</td></tr>
<tr class="memdesc:af3169b96a15cf4e39c89fbd3a868775a"><td class="mdescLeft"> </td><td class="mdescRight">This method is used by Maya in functions (such as select) that require point at parameter values.  <a href="class_m_px_surface_shape.html#af3169b96a15cf4e39c89fbd3a868775a">More...</a><br/></td></tr>
<tr class="separator:af3169b96a15cf4e39c89fbd3a868775a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ade7e3321672b8bddc2659ede72274b18"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_px_geometry_iterator.html">MPxGeometryIterator</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#ade7e3321672b8bddc2659ede72274b18">geometryIteratorSetup</a> (<a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;, <a class="el" href="./class_m_object.html">MObject</a> &amp;, bool forReadOnly=false)</td></tr>
<tr class="memdesc:ade7e3321672b8bddc2659ede72274b18"><td class="mdescLeft"> </td><td class="mdescRight">This method should be overridden by the user to return a geometry iterator compatible with the user's geometry.  <a href="class_m_px_surface_shape.html#ade7e3321672b8bddc2659ede72274b18">More...</a><br/></td></tr>
<tr class="separator:ade7e3321672b8bddc2659ede72274b18"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0896fe171fc5466e5bcd0ba02d5bad5c"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a0896fe171fc5466e5bcd0ba02d5bad5c">acceptsGeometryIterator</a> (bool writeable=true)</td></tr>
<tr class="memdesc:a0896fe171fc5466e5bcd0ba02d5bad5c"><td class="mdescLeft"> </td><td class="mdescRight">If the shape can supply a component iterator then then this method should be overridden to return true.  <a href="class_m_px_surface_shape.html#a0896fe171fc5466e5bcd0ba02d5bad5c">More...</a><br/></td></tr>
<tr class="separator:a0896fe171fc5466e5bcd0ba02d5bad5c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4e682eadd34b068eaca199c306d34313"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a4e682eadd34b068eaca199c306d34313">acceptsGeometryIterator</a> (<a class="el" href="./class_m_object.html">MObject</a> &amp;, bool writeable=true, bool forReadOnly=false)</td></tr>
<tr class="memdesc:a4e682eadd34b068eaca199c306d34313"><td class="mdescLeft"> </td><td class="mdescRight">If the shape can supply a component iterator then then this method should be overridden to return true.  <a href="class_m_px_surface_shape.html#a4e682eadd34b068eaca199c306d34313">More...</a><br/></td></tr>
<tr class="separator:a4e682eadd34b068eaca199c306d34313"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a822f8d99673dbe2f76d8672a1c60e753"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a822f8d99673dbe2f76d8672a1c60e753">excludeAsPluginShape</a> () const </td></tr>
<tr class="memdesc:a822f8d99673dbe2f76d8672a1c60e753"><td class="mdescLeft"> </td><td class="mdescRight">A Maya viewport can be set to not display "Plugin Shapes", which means shapes derived from <a class="el" href="./class_m_px_surface_shape.html" title="Parent class of all user defined shapes. ">MPxSurfaceShape</a>.  <a href="class_m_px_surface_shape.html#a822f8d99673dbe2f76d8672a1c60e753">More...</a><br/></td></tr>
<tr class="separator:a822f8d99673dbe2f76d8672a1c60e753"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5d0a5e76d641c2bd825f8d5d8e0d386e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="./class_m_object_array.html">MObjectArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a5d0a5e76d641c2bd825f8d5d8e0d386e">activeComponents</a> () const </td></tr>
<tr class="memdesc:a5d0a5e76d641c2bd825f8d5d8e0d386e"><td class="mdescLeft"> </td><td class="mdescRight">Returns a list of active (selected) components for the shape.  <a href="class_m_px_surface_shape.html#a5d0a5e76d641c2bd825f8d5d8e0d386e">More...</a><br/></td></tr>
<tr class="separator:a5d0a5e76d641c2bd825f8d5d8e0d386e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a168e1b383c958be627e8935a4ffdd7cb"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a168e1b383c958be627e8935a4ffdd7cb">hasActiveComponents</a> () const </td></tr>
<tr class="memdesc:a168e1b383c958be627e8935a4ffdd7cb"><td class="mdescLeft"> </td><td class="mdescRight">This method is used to determine whether or not the shape has active (selected) components.  <a href="class_m_px_surface_shape.html#a168e1b383c958be627e8935a4ffdd7cb">More...</a><br/></td></tr>
<tr class="separator:a168e1b383c958be627e8935a4ffdd7cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aecad73a1fa1b7e2df4a225b1fb3c9532"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#aecad73a1fa1b7e2df4a225b1fb3c9532">OPENMAYA_ENUM</a> (MChildChanged, kObjectChanged, kBoundingBoxChanged)</td></tr>
<tr class="memdesc:aecad73a1fa1b7e2df4a225b1fb3c9532"><td class="mdescLeft"> </td><td class="mdescRight">Scope of change.  <a href="class_m_px_surface_shape.html#aecad73a1fa1b7e2df4a225b1fb3c9532">More...</a><br/></td></tr>
<tr class="separator:aecad73a1fa1b7e2df4a225b1fb3c9532"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8084191b55d8207736e6196ad0c11a6"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#ad8084191b55d8207736e6196ad0c11a6">childChanged</a> (MChildChanged=kObjectChanged)</td></tr>
<tr class="memdesc:ad8084191b55d8207736e6196ad0c11a6"><td class="mdescLeft"> </td><td class="mdescRight">This method can be used to trigger the shape to recalculate its bounding box.  <a href="class_m_px_surface_shape.html#ad8084191b55d8207736e6196ad0c11a6">More...</a><br/></td></tr>
<tr class="separator:ad8084191b55d8207736e6196ad0c11a6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a802cfaa86ed0cccb33b78672baea87df"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a802cfaa86ed0cccb33b78672baea87df">isRenderable</a> () const </td></tr>
<tr class="memdesc:a802cfaa86ed0cccb33b78672baea87df"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if the shape is a renderable shape.  <a href="class_m_px_surface_shape.html#a802cfaa86ed0cccb33b78672baea87df">More...</a><br/></td></tr>
<tr class="separator:a802cfaa86ed0cccb33b78672baea87df"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4684716734528680f3c1087ecce3238"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#ad4684716734528680f3c1087ecce3238">setRenderable</a> (bool)</td></tr>
<tr class="memdesc:ad4684716734528680f3c1087ecce3238"><td class="mdescLeft"> </td><td class="mdescRight">Specifies whether the shape is a renderable shape.  <a href="class_m_px_surface_shape.html#ad4684716734528680f3c1087ecce3238">More...</a><br/></td></tr>
<tr class="separator:ad4684716734528680f3c1087ecce3238"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6d3c9b9ea9318edfc79729761232f10b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="./class_m_matrix.html">MMatrix</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a6d3c9b9ea9318edfc79729761232f10b">getWorldMatrix</a> (<a class="el" href="./class_m_data_block.html">MDataBlock</a> &amp;, unsigned int) const </td></tr>
<tr class="memdesc:a6d3c9b9ea9318edfc79729761232f10b"><td class="mdescLeft"> </td><td class="mdescRight">Returns <a class="el" href="./class_m_matrix.html" title="A matrix math class for 4x4 matrices of doubles. ">MMatrix</a> which takes a point from local object space to world space.  <a href="class_m_px_surface_shape.html#a6d3c9b9ea9318edfc79729761232f10b">More...</a><br/></td></tr>
<tr class="separator:a6d3c9b9ea9318edfc79729761232f10b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_class_m_px_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_px_node')"><img alt="-" src="cpp_ref/closed.png"/> Public Member Functions inherited from <a class="el" href="./class_m_px_node.html">MPxNode</a></td></tr>
<tr class="memitem:a8d91949acf0aac099d77b45a40902c44 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8d91949acf0aac099d77b45a40902c44"></a>
 </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a8d91949acf0aac099d77b45a40902c44">OPENMAYA_ENUM</a> (Type, kDependNode, kLocatorNode, kDeformerNode, kManipContainer, kSurfaceShape, kFieldNode, kEmitterNode, kSpringNode, kIkSolverNode, kHardwareShader, kHwShaderNode, kTransformNode, kObjectSet, kFluidEmitterNode, kImagePlaneNode, kParticleAttributeMapperNode, kCameraSetNode, kConstraintNode, kManipulatorNode, kMotionPathNode, kClientDeviceNode, kThreadedDeviceNode, kAssembly, kSkinCluster, kGeometryFilter, kBlendShape, kLast)</td></tr>
<tr class="memdesc:a8d91949acf0aac099d77b45a40902c44 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Defines the type of node. <br/></td></tr>
<tr class="separator:a8d91949acf0aac099d77b45a40902c44 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a48ffd6b0fe3d500d9954ccc623b3ec0e inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a48ffd6b0fe3d500d9954ccc623b3ec0e">MPxNode</a> ()</td></tr>
<tr class="memdesc:a48ffd6b0fe3d500d9954ccc623b3ec0e inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Constructor.  <a href="class_m_px_surface_shape.html#a48ffd6b0fe3d500d9954ccc623b3ec0e">More...</a><br/></td></tr>
<tr class="separator:a48ffd6b0fe3d500d9954ccc623b3ec0e inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a09bd20438981ff5cc2a0a69790cb3393 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a09bd20438981ff5cc2a0a69790cb3393"></a>
virtual </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a09bd20438981ff5cc2a0a69790cb3393">~MPxNode</a> ()</td></tr>
<tr class="memdesc:a09bd20438981ff5cc2a0a69790cb3393 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a09bd20438981ff5cc2a0a69790cb3393 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c13a6c88a839b5356861d1d09e820d9 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a5c13a6c88a839b5356861d1d09e820d9">postConstructor</a> ()</td></tr>
<tr class="memdesc:a5c13a6c88a839b5356861d1d09e820d9 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Post constructor.  <a href="class_m_px_surface_shape.html#a5c13a6c88a839b5356861d1d09e820d9">More...</a><br/></td></tr>
<tr class="separator:a5c13a6c88a839b5356861d1d09e820d9 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6e1aa1e50774080d5aee55f20ffa5503 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a6e1aa1e50774080d5aee55f20ffa5503">compute</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, <a class="el" href="./class_m_data_block.html">MDataBlock</a> &amp;)</td></tr>
<tr class="memdesc:a6e1aa1e50774080d5aee55f20ffa5503 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method should be overridden in user defined nodes.  <a href="class_m_px_surface_shape.html#a6e1aa1e50774080d5aee55f20ffa5503">More...</a><br/></td></tr>
<tr class="separator:a6e1aa1e50774080d5aee55f20ffa5503 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa88f4dd4cfd3e964e0806d6e5b253347 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aa88f4dd4cfd3e964e0806d6e5b253347">getInternalValue</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, <a class="el" href="./class_m_data_handle.html">MDataHandle</a> &amp;)</td></tr>
<tr class="memdesc:aa88f4dd4cfd3e964e0806d6e5b253347 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that store attribute data in some internal format.  <a href="class_m_px_surface_shape.html#aa88f4dd4cfd3e964e0806d6e5b253347">More...</a><br/></td></tr>
<tr class="separator:aa88f4dd4cfd3e964e0806d6e5b253347 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6caab4434e836748680958883564af35 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a6caab4434e836748680958883564af35">setInternalValue</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_data_handle.html">MDataHandle</a> &amp;)</td></tr>
<tr class="memdesc:a6caab4434e836748680958883564af35 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that store attribute data in some internal format.  <a href="class_m_px_surface_shape.html#a6caab4434e836748680958883564af35">More...</a><br/></td></tr>
<tr class="separator:a6caab4434e836748680958883564af35 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac6bea264655616f6d6d47dec0c4ecc46 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac6bea264655616f6d6d47dec0c4ecc46">internalArrayCount</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;) const </td></tr>
<tr class="memdesc:ac6bea264655616f6d6d47dec0c4ecc46 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that have internal array attributes which are not stored in Maya's datablock.  <a href="class_m_px_surface_shape.html#ac6bea264655616f6d6d47dec0c4ecc46">More...</a><br/></td></tr>
<tr class="separator:ac6bea264655616f6d6d47dec0c4ecc46 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca0f48b1467c0e3dc8643a18b0b855da inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aca0f48b1467c0e3dc8643a18b0b855da">copyInternalData</a> (<a class="el" href="./class_m_px_node.html">MPxNode</a> *)</td></tr>
<tr class="memdesc:aca0f48b1467c0e3dc8643a18b0b855da inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that store attribute data in some internal format.  <a href="class_m_px_surface_shape.html#aca0f48b1467c0e3dc8643a18b0b855da">More...</a><br/></td></tr>
<tr class="separator:aca0f48b1467c0e3dc8643a18b0b855da inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4a9dabb4ab821f67b0db6d2ee02b399 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ad4a9dabb4ab821f67b0db6d2ee02b399">legalConnection</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool asSrc, bool &amp;isLegal) const </td></tr>
<tr class="memdesc:ad4a9dabb4ab821f67b0db6d2ee02b399 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method allows you to check for legal connections being made to attributes of this node.  <a href="class_m_px_surface_shape.html#ad4a9dabb4ab821f67b0db6d2ee02b399">More...</a><br/></td></tr>
<tr class="separator:ad4a9dabb4ab821f67b0db6d2ee02b399 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ce5a410752aed82613f1cad8021d220 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a2ce5a410752aed82613f1cad8021d220">legalDisconnection</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool asSrc, bool &amp;isLegal) const </td></tr>
<tr class="memdesc:a2ce5a410752aed82613f1cad8021d220 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method allows you to check for legal disconnections being made to attributes of this node.  <a href="class_m_px_surface_shape.html#a2ce5a410752aed82613f1cad8021d220">More...</a><br/></td></tr>
<tr class="separator:a2ce5a410752aed82613f1cad8021d220 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abd7d1dad4e4f0b922bf5ac4fc9c0230a inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#abd7d1dad4e4f0b922bf5ac4fc9c0230a">setDependentsDirty</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;plug, <a class="el" href="./class_m_plug_array.html">MPlugArray</a> &amp;plugArray)</td></tr>
<tr class="memdesc:abd7d1dad4e4f0b922bf5ac4fc9c0230a inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method can be overridden in user defined nodes to specify which plugs should be set dirty based upon an input plug {<em>plugBeingDirtied}</em> which Maya is marking dirty.  <a href="class_m_px_surface_shape.html#abd7d1dad4e4f0b922bf5ac4fc9c0230a">More...</a><br/></td></tr>
<tr class="separator:abd7d1dad4e4f0b922bf5ac4fc9c0230a inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad40cff55ba4000788eda78c8b4258b3d inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ad40cff55ba4000788eda78c8b4258b3d">preEvaluation</a> (const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;context, const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp;evaluationNode)</td></tr>
<tr class="memdesc:ad40cff55ba4000788eda78c8b4258b3d inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Prepare a node's internal state for threaded evaluation.  <a href="class_m_px_surface_shape.html#ad40cff55ba4000788eda78c8b4258b3d">More...</a><br/></td></tr>
<tr class="separator:ad40cff55ba4000788eda78c8b4258b3d inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a93e355c11a2c9a0f19f8d7cfa887af2b inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a93e355c11a2c9a0f19f8d7cfa887af2b">postEvaluation</a> (const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;context, const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp;evaluationNode, PostEvaluationType evalType)</td></tr>
<tr class="memdesc:a93e355c11a2c9a0f19f8d7cfa887af2b inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Clean up node's internal state after threaded evaluation.  <a href="class_m_px_surface_shape.html#a93e355c11a2c9a0f19f8d7cfa887af2b">More...</a><br/></td></tr>
<tr class="separator:a93e355c11a2c9a0f19f8d7cfa887af2b inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71ebcb2013e0847d13c63dbdbb9973aa inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a71ebcb2013e0847d13c63dbdbb9973aa">OPENMAYA_ENUM</a> (SchedulingType, kParallel, kSerial, kGloballySerial, kUntrusted, kSchedulingTypeLast, kDefaultScheduling=kSerial, kSerialize=kSerial, kGloballySerialize=kGloballySerial)</td></tr>
<tr class="memdesc:a71ebcb2013e0847d13c63dbdbb9973aa inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Defines the degree of parallelism of a node.  <a href="class_m_px_surface_shape.html#a71ebcb2013e0847d13c63dbdbb9973aa">More...</a><br/></td></tr>
<tr class="separator:a71ebcb2013e0847d13c63dbdbb9973aa inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9c9e8bdcf0b5283a027a66a7671b7088 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual SchedulingType </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9c9e8bdcf0b5283a027a66a7671b7088">schedulingType</a> () const </td></tr>
<tr class="memdesc:a9c9e8bdcf0b5283a027a66a7671b7088 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">When overridden this method controls the degree of parallelism supported by the node during threaded evaluation.  <a href="class_m_px_surface_shape.html#a9c9e8bdcf0b5283a027a66a7671b7088">More...</a><br/></td></tr>
<tr class="separator:a9c9e8bdcf0b5283a027a66a7671b7088 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6f70ff175ac7ba65cb65aa3b5592f05b inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a6f70ff175ac7ba65cb65aa3b5592f05b">getCacheSetup</a> (const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp;, <a class="el" href="./class_m_node_cache_disabling_info.html">MNodeCacheDisablingInfo</a> &amp;, <a class="el" href="./class_m_node_cache_setup_info.html">MNodeCacheSetupInfo</a> &amp;, <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp;) const </td></tr>
<tr class="memdesc:a6f70ff175ac7ba65cb65aa3b5592f05b inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Provide node-specific setup info for the Cached Playback system.  <a href="class_m_px_surface_shape.html#a6f70ff175ac7ba65cb65aa3b5592f05b">More...</a><br/></td></tr>
<tr class="separator:a6f70ff175ac7ba65cb65aa3b5592f05b inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af7be6b397b65f1a96b201e899c923d12 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#af7be6b397b65f1a96b201e899c923d12">configCache</a> (const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp;, <a class="el" href="./class_m_cache_schema.html">MCacheSchema</a> &amp;) const </td></tr>
<tr class="memdesc:af7be6b397b65f1a96b201e899c923d12 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Defines the node's behavior when participating in Cached Playback.  <a href="class_m_px_surface_shape.html#af7be6b397b65f1a96b201e899c923d12">More...</a><br/></td></tr>
<tr class="separator:af7be6b397b65f1a96b201e899c923d12 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a68b5f4da814941edd141ca207d1c7369 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_time_range.html">MTimeRange</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a68b5f4da814941edd141ca207d1c7369">transformInvalidationRange</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;source, const <a class="el" href="./class_m_time_range.html">MTimeRange</a> &amp;input) const </td></tr>
<tr class="memdesc:a68b5f4da814941edd141ca207d1c7369 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Override this method to register this node as an Invalidation-Range-Transformation kernel (IRT kernel) An IRT kernel node will change the invalidation time range for its downstream nodes For example, Dynamics-solver will transform invalidation time range [a,b] to [a,+inf) And Clip-Time-Editor will send out the invalidation range for each of the clip [a,b] to ( [t0+a,t0+b] U [t1+a,t1+b] U [t2+a,t2+b] U ...  <a href="class_m_px_surface_shape.html#a68b5f4da814941edd141ca207d1c7369">More...</a><br/></td></tr>
<tr class="separator:a68b5f4da814941edd141ca207d1c7369 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16261c8f144b5ff3b27057602831138e inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a16261c8f144b5ff3b27057602831138e"></a>
bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a16261c8f144b5ff3b27057602831138e">hasInvalidationRangeTransformation</a> () const </td></tr>
<tr class="memdesc:a16261c8f144b5ff3b27057602831138e inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Checks if this <a class="el" href="./class_m_px_node.html" title="Base class for user defined dependency nodes. ">MPxNode</a> derived node overrides the <a class="el" href="./class_m_px_node.html#a68b5f4da814941edd141ca207d1c7369" title="Override this method to register this node as an Invalidation-Range-Transformation kernel (IRT kernel...">MPxNode::transformInvalidationRange</a> method. <br/></td></tr>
<tr class="separator:a16261c8f144b5ff3b27057602831138e inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a82d0d0e95d46b8f41c4fd4bea409c1b3 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a82d0d0e95d46b8f41c4fd4bea409c1b3">connectionMade</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool asSrc)</td></tr>
<tr class="memdesc:a82d0d0e95d46b8f41c4fd4bea409c1b3 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method gets called when connections are made to attributes of this node.  <a href="class_m_px_surface_shape.html#a82d0d0e95d46b8f41c4fd4bea409c1b3">More...</a><br/></td></tr>
<tr class="separator:a82d0d0e95d46b8f41c4fd4bea409c1b3 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2493af8700f32f6bc164414ac2b906d inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac2493af8700f32f6bc164414ac2b906d">connectionBroken</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool asSrc)</td></tr>
<tr class="memdesc:ac2493af8700f32f6bc164414ac2b906d inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method gets called when connections are broken with attributes of this node.  <a href="class_m_px_surface_shape.html#ac2493af8700f32f6bc164414ac2b906d">More...</a><br/></td></tr>
<tr class="separator:ac2493af8700f32f6bc164414ac2b906d inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9af8c4dfe96f9f03b7edd22be9dcd79a inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9af8c4dfe96f9f03b7edd22be9dcd79a">dependsOn</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool &amp;depends) const </td></tr>
<tr class="memdesc:a9af8c4dfe96f9f03b7edd22be9dcd79a inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method may be overridden by the user defined node.  <a href="class_m_px_surface_shape.html#a9af8c4dfe96f9f03b7edd22be9dcd79a">More...</a><br/></td></tr>
<tr class="separator:a9af8c4dfe96f9f03b7edd22be9dcd79a inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac24fcf77203181163ad3e581645f5d3b inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac24fcf77203181163ad3e581645f5d3b">isPassiveOutput</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;) const </td></tr>
<tr class="memdesc:ac24fcf77203181163ad3e581645f5d3b inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method may be overridden by the user defined node if it wants to provide output attributes which do not prevent value modifications to the destination attribute.  <a href="class_m_px_surface_shape.html#ac24fcf77203181163ad3e581645f5d3b">More...</a><br/></td></tr>
<tr class="separator:ac24fcf77203181163ad3e581645f5d3b inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac354fc704a7e79728b99e0570b4b51bf inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac354fc704a7e79728b99e0570b4b51bf">shouldSave</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, bool &amp;isSaving)</td></tr>
<tr class="memdesc:ac354fc704a7e79728b99e0570b4b51bf inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method may be overridden by the user defined node.  <a href="class_m_px_surface_shape.html#ac354fc704a7e79728b99e0570b4b51bf">More...</a><br/></td></tr>
<tr class="separator:ac354fc704a7e79728b99e0570b4b51bf inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adad125b5b4aadf8f7f9819fc590a78a6 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_plug.html">MPlug</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#adad125b5b4aadf8f7f9819fc590a78a6">passThroughToOne</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;) const </td></tr>
<tr class="memdesc:adad125b5b4aadf8f7f9819fc590a78a6 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method may be overridden by nodes that have a one-to-one relationship between an input attribute and a corresponding output attribute.  <a href="class_m_px_surface_shape.html#adad125b5b4aadf8f7f9819fc590a78a6">More...</a><br/></td></tr>
<tr class="separator:adad125b5b4aadf8f7f9819fc590a78a6 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aae65db50f0b2f6aae1d1bf99ed962362 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aae65db50f0b2f6aae1d1bf99ed962362">passThroughToMany</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, <a class="el" href="./class_m_plug_array.html">MPlugArray</a> &amp;) const </td></tr>
<tr class="memdesc:aae65db50f0b2f6aae1d1bf99ed962362 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is overridden by nodes that want to control the traversal behavior of some Maya search algorithms which traverse the history/future of shape nodes looking for directly related nodes.  <a href="class_m_px_surface_shape.html#aae65db50f0b2f6aae1d1bf99ed962362">More...</a><br/></td></tr>
<tr class="separator:aae65db50f0b2f6aae1d1bf99ed962362 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abf966a89078baf354c95638086e19d7a inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#abf966a89078baf354c95638086e19d7a">isAbstractClass</a> () const </td></tr>
<tr class="memdesc:abf966a89078baf354c95638086e19d7a inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Override this class to return true if this node is an abstract node.  <a href="class_m_px_surface_shape.html#abf966a89078baf354c95638086e19d7a">More...</a><br/></td></tr>
<tr class="separator:abf966a89078baf354c95638086e19d7a inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9e054d22b4addd21d5b92c969a7a1ee6 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9e054d22b4addd21d5b92c969a7a1ee6">isTrackingTopology</a> () const </td></tr>
<tr class="memdesc:a9e054d22b4addd21d5b92c969a7a1ee6 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Override this class to return true if this node wants to track topology.  <a href="class_m_px_surface_shape.html#a9e054d22b4addd21d5b92c969a7a1ee6">More...</a><br/></td></tr>
<tr class="separator:a9e054d22b4addd21d5b92c969a7a1ee6 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aae473f13648099a8046a067e45d35a2d inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_string_array.html">MStringArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aae473f13648099a8046a067e45d35a2d">getFilesToArchive</a> (bool shortName=false, bool unresolvedName=false, bool markCouldBeImageSequence=false) const </td></tr>
<tr class="memdesc:aae473f13648099a8046a067e45d35a2d inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Use this method to return all external files used by this node.  <a href="class_m_px_surface_shape.html#aae473f13648099a8046a067e45d35a2d">More...</a><br/></td></tr>
<tr class="separator:aae473f13648099a8046a067e45d35a2d inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abfc494661ea0f7f957a9e437cebb2642 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#abfc494661ea0f7f957a9e437cebb2642">getExternalContent</a> (<a class="el" href="./class_m_external_content_info_table.html">MExternalContentInfoTable</a> &amp;table) const </td></tr>
<tr class="memdesc:abfc494661ea0f7f957a9e437cebb2642 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the external content (files) that this node depends on.  <a href="class_m_px_surface_shape.html#abfc494661ea0f7f957a9e437cebb2642">More...</a><br/></td></tr>
<tr class="separator:abfc494661ea0f7f957a9e437cebb2642 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adcdb8e347afea83dbabcde3fe81fb853 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#adcdb8e347afea83dbabcde3fe81fb853">addExternalContentForFileAttr</a> (<a class="el" href="./class_m_external_content_info_table.html">MExternalContentInfoTable</a> &amp;, const <a class="el" href="./class_m_object.html">MObject</a> &amp;attr) const </td></tr>
<tr class="memdesc:adcdb8e347afea83dbabcde3fe81fb853 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Adds content info to the specified table from a file path attribute.  <a href="class_m_px_surface_shape.html#adcdb8e347afea83dbabcde3fe81fb853">More...</a><br/></td></tr>
<tr class="separator:adcdb8e347afea83dbabcde3fe81fb853 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a280288002cbae6c1e42cbfc7695048 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9a280288002cbae6c1e42cbfc7695048">setExternalContentForFileAttr</a> (const <a class="el" href="./class_m_object.html">MObject</a> &amp;attr, const <a class="el" href="./class_m_external_content_location_table.html">MExternalContentLocationTable</a> &amp;)</td></tr>
<tr class="memdesc:a9a280288002cbae6c1e42cbfc7695048 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Sets content info in the specified attribute from the table.  <a href="class_m_px_surface_shape.html#a9a280288002cbae6c1e42cbfc7695048">More...</a><br/></td></tr>
<tr class="separator:a9a280288002cbae6c1e42cbfc7695048 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a389fc88c7e5236aa2b9980a1b452cc49 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a389fc88c7e5236aa2b9980a1b452cc49">setExternalContent</a> (const <a class="el" href="./class_m_external_content_location_table.html">MExternalContentLocationTable</a> &amp;)</td></tr>
<tr class="memdesc:a389fc88c7e5236aa2b9980a1b452cc49 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Changes the location of external content in batch.  <a href="class_m_px_surface_shape.html#a389fc88c7e5236aa2b9980a1b452cc49">More...</a><br/></td></tr>
<tr class="separator:a389fc88c7e5236aa2b9980a1b452cc49 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a842aadc96ca39565ad68e366d6b83e inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_type_id.html">MTypeId</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9a842aadc96ca39565ad68e366d6b83e">typeId</a> () const </td></tr>
<tr class="memdesc:a9a842aadc96ca39565ad68e366d6b83e inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the TYPEID of this node.  <a href="class_m_px_surface_shape.html#a9a842aadc96ca39565ad68e366d6b83e">More...</a><br/></td></tr>
<tr class="separator:a9a842aadc96ca39565ad68e366d6b83e inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7aa522b0c9a8205c58893dc6bfe4c91f inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_string.html">MString</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a7aa522b0c9a8205c58893dc6bfe4c91f">typeName</a> () const </td></tr>
<tr class="memdesc:a7aa522b0c9a8205c58893dc6bfe4c91f inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the type name of this node.  <a href="class_m_px_surface_shape.html#a7aa522b0c9a8205c58893dc6bfe4c91f">More...</a><br/></td></tr>
<tr class="separator:a7aa522b0c9a8205c58893dc6bfe4c91f inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca2cba4630391c78dcf1a828986160da inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_string.html">MString</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aca2cba4630391c78dcf1a828986160da">name</a> () const </td></tr>
<tr class="memdesc:aca2cba4630391c78dcf1a828986160da inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of this particular instance of this class.  <a href="class_m_px_surface_shape.html#aca2cba4630391c78dcf1a828986160da">More...</a><br/></td></tr>
<tr class="separator:aca2cba4630391c78dcf1a828986160da inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16ef067edb19aa37866cbc7839dbb16e inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a16ef067edb19aa37866cbc7839dbb16e">thisMObject</a> () const </td></tr>
<tr class="memdesc:a16ef067edb19aa37866cbc7839dbb16e inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the <a class="el" href="./class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a> associated with this user defined node.  <a href="class_m_px_surface_shape.html#a16ef067edb19aa37866cbc7839dbb16e">More...</a><br/></td></tr>
<tr class="separator:a16ef067edb19aa37866cbc7839dbb16e inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab0ec8605b36618dc7975f6615ab27535 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ab0ec8605b36618dc7975f6615ab27535">setExistWithoutInConnections</a> (bool flag)</td></tr>
<tr class="memdesc:ab0ec8605b36618dc7975f6615ab27535 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method specifies whether or not the node can exist without input connections.  <a href="class_m_px_surface_shape.html#ab0ec8605b36618dc7975f6615ab27535">More...</a><br/></td></tr>
<tr class="separator:ab0ec8605b36618dc7975f6615ab27535 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a869cac8317d1de1582d987093cdf2a61 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a869cac8317d1de1582d987093cdf2a61">existWithoutInConnections</a> (<a class="el" href="./class_m_status.html">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a869cac8317d1de1582d987093cdf2a61 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not this node can exist without input connections.  <a href="class_m_px_surface_shape.html#a869cac8317d1de1582d987093cdf2a61">More...</a><br/></td></tr>
<tr class="separator:a869cac8317d1de1582d987093cdf2a61 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a17b7814993195215e83c55646b977681 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a17b7814993195215e83c55646b977681">setExistWithoutOutConnections</a> (bool flag)</td></tr>
<tr class="memdesc:a17b7814993195215e83c55646b977681 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method specifies whether or not the node can exist without output connections.  <a href="class_m_px_surface_shape.html#a17b7814993195215e83c55646b977681">More...</a><br/></td></tr>
<tr class="separator:a17b7814993195215e83c55646b977681 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc771613d9e8b85f9c00673473649521 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#adc771613d9e8b85f9c00673473649521">existWithoutOutConnections</a> (<a class="el" href="./class_m_status.html">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:adc771613d9e8b85f9c00673473649521 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether or not this node can exist without output connections.  <a href="class_m_px_surface_shape.html#adc771613d9e8b85f9c00673473649521">More...</a><br/></td></tr>
<tr class="separator:adc771613d9e8b85f9c00673473649521 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8698b3c96dd363071325966d592d5e7b inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a8698b3c96dd363071325966d592d5e7b">_setMPSafe</a> (bool isMPSafe)</td></tr>
<tr class="memdesc:a8698b3c96dd363071325966d592d5e7b inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_surface_shape.html#a8698b3c96dd363071325966d592d5e7b">More...</a><br/></td></tr>
<tr class="separator:a8698b3c96dd363071325966d592d5e7b inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9c932a98c4a7eca38372c8a0b84cec0f inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="./class_m_data_block.html">MDataBlock</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a9c932a98c4a7eca38372c8a0b84cec0f">_forceCache</a> (const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;)</td></tr>
<tr class="memdesc:a9c932a98c4a7eca38372c8a0b84cec0f inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_surface_shape.html#a9c932a98c4a7eca38372c8a0b84cec0f">More...</a><br/></td></tr>
<tr class="separator:a9c932a98c4a7eca38372c8a0b84cec0f inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69e8d487996ce0ab41fae7ce99498764 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a69e8d487996ce0ab41fae7ce99498764">getInternalValueInContext</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, <a class="el" href="./class_m_data_handle.html">MDataHandle</a> &amp;, <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;)</td></tr>
<tr class="memdesc:a69e8d487996ce0ab41fae7ce99498764 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_surface_shape.html#a69e8d487996ce0ab41fae7ce99498764">More...</a><br/></td></tr>
<tr class="separator:a69e8d487996ce0ab41fae7ce99498764 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa5a06a44ec1a168d304be997c81e3454 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aa5a06a44ec1a168d304be997c81e3454">setInternalValueInContext</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_data_handle.html">MDataHandle</a> &amp;, <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;)</td></tr>
<tr class="memdesc:aa5a06a44ec1a168d304be997c81e3454 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_surface_shape.html#aa5a06a44ec1a168d304be997c81e3454">More...</a><br/></td></tr>
<tr class="separator:aa5a06a44ec1a168d304be997c81e3454 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1adbb259ff7f9a698ae86a51c6f621a4 inherit pub_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual int </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a1adbb259ff7f9a698ae86a51c6f621a4">internalArrayCount</a> (const <a class="el" href="./class_m_plug.html">MPlug</a> &amp;, const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;) const </td></tr>
<tr class="memdesc:a1adbb259ff7f9a698ae86a51c6f621a4 inherit pub_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_surface_shape.html#a1adbb259ff7f9a698ae86a51c6f621a4">More...</a><br/></td></tr>
<tr class="separator:a1adbb259ff7f9a698ae86a51c6f621a4 inherit pub_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td align="right" class="memItemLeft" valign="top">static const char * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of this class.  <a href="class_m_px_surface_shape.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br/></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_static_methods_class_m_px_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_px_node')"><img alt="-" src="cpp_ref/closed.png"/> Static Public Member Functions inherited from <a class="el" href="./class_m_px_node.html">MPxNode</a></td></tr>
<tr class="memitem:a837094252166c0b365fafb53e4a0203b inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a837094252166c0b365fafb53e4a0203b">addAttribute</a> (const <a class="el" href="./class_m_object.html">MObject</a> &amp;attr)</td></tr>
<tr class="memdesc:a837094252166c0b365fafb53e4a0203b inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method adds a new attribute to a user defined node type during the type's initialization.  <a href="class_m_px_surface_shape.html#a837094252166c0b365fafb53e4a0203b">More...</a><br/></td></tr>
<tr class="separator:a837094252166c0b365fafb53e4a0203b inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a938700a96e8c37da6027fad6e3373c04 inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a938700a96e8c37da6027fad6e3373c04">inheritAttributesFrom</a> (const <a class="el" href="./class_m_string.html">MString</a> &amp;parentClassName)</td></tr>
<tr class="memdesc:a938700a96e8c37da6027fad6e3373c04 inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method allows a class of plugin node to inherit all of the attributes of a second class of plugin node.  <a href="class_m_px_surface_shape.html#a938700a96e8c37da6027fad6e3373c04">More...</a><br/></td></tr>
<tr class="separator:a938700a96e8c37da6027fad6e3373c04 inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aef755adb241fbe273368fefae14047a4 inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aef755adb241fbe273368fefae14047a4">attributeAffects</a> (const <a class="el" href="./class_m_object.html">MObject</a> &amp;whenChanges, const <a class="el" href="./class_m_object.html">MObject</a> &amp;isAffected)</td></tr>
<tr class="memdesc:aef755adb241fbe273368fefae14047a4 inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method specifies that a particular input attribute affects a specific output attribute.  <a href="class_m_px_surface_shape.html#aef755adb241fbe273368fefae14047a4">More...</a><br/></td></tr>
<tr class="separator:aef755adb241fbe273368fefae14047a4 inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a214deb1c971a5879657c8b1de4156422 inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a214deb1c971a5879657c8b1de4156422">attributeAffects</a> (const <a class="el" href="./class_m_object.html">MObject</a> &amp;whenChanges, const <a class="el" href="./class_m_object.html">MObject</a> &amp;isAffected, bool affectsTopology)</td></tr>
<tr class="memdesc:a214deb1c971a5879657c8b1de4156422 inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is an extension to the other version of the <em>attributeAffects</em> method.  <a href="class_m_px_surface_shape.html#a214deb1c971a5879657c8b1de4156422">More...</a><br/></td></tr>
<tr class="separator:a214deb1c971a5879657c8b1de4156422 inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">static const char * </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">Returns the name of this class.  <a href="class_m_px_surface_shape.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br/></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a10a14055fb8b34f1faf2aa86d9c221fc"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a10a14055fb8b34f1faf2aa86d9c221fc"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a10a14055fb8b34f1faf2aa86d9c221fc">mControlPoints</a></td></tr>
<tr class="memdesc:a10a14055fb8b34f1faf2aa86d9c221fc"><td class="mdescLeft"> </td><td class="mdescRight">Control points for the derived shapes. <br/></td></tr>
<tr class="separator:a10a14055fb8b34f1faf2aa86d9c221fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aed752553d559512251dd0e36df04c8af"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aed752553d559512251dd0e36df04c8af"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#aed752553d559512251dd0e36df04c8af">mControlValueX</a></td></tr>
<tr class="memdesc:aed752553d559512251dd0e36df04c8af"><td class="mdescLeft"> </td><td class="mdescRight">X value of a control point. <br/></td></tr>
<tr class="separator:aed752553d559512251dd0e36df04c8af"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b7e0f78480dcda45ebfd4d607c94098"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6b7e0f78480dcda45ebfd4d607c94098"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a6b7e0f78480dcda45ebfd4d607c94098">mControlValueY</a></td></tr>
<tr class="memdesc:a6b7e0f78480dcda45ebfd4d607c94098"><td class="mdescLeft"> </td><td class="mdescRight">Y value of a control point. <br/></td></tr>
<tr class="separator:a6b7e0f78480dcda45ebfd4d607c94098"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b22bb6eed20d3e999daa03ece5593de"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6b22bb6eed20d3e999daa03ece5593de"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a6b22bb6eed20d3e999daa03ece5593de">mControlValueZ</a></td></tr>
<tr class="memdesc:a6b22bb6eed20d3e999daa03ece5593de"><td class="mdescLeft"> </td><td class="mdescRight">Z value of a control point. <br/></td></tr>
<tr class="separator:a6b22bb6eed20d3e999daa03ece5593de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a360b4574bba76d3d8a12c72b08fc4ac1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a360b4574bba76d3d8a12c72b08fc4ac1"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a360b4574bba76d3d8a12c72b08fc4ac1">nodeBoundingBox</a></td></tr>
<tr class="memdesc:a360b4574bba76d3d8a12c72b08fc4ac1"><td class="mdescLeft"> </td><td class="mdescRight">bounding box attribute <br/></td></tr>
<tr class="separator:a360b4574bba76d3d8a12c72b08fc4ac1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a20781dbb7a5c1fc5d58365860247abc9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a20781dbb7a5c1fc5d58365860247abc9"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a20781dbb7a5c1fc5d58365860247abc9">nodeBoundingBoxMin</a></td></tr>
<tr class="memdesc:a20781dbb7a5c1fc5d58365860247abc9"><td class="mdescLeft"> </td><td class="mdescRight">bounding box minimum point <br/></td></tr>
<tr class="separator:a20781dbb7a5c1fc5d58365860247abc9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6c8585dfe5059d758249a667e4f02027"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6c8585dfe5059d758249a667e4f02027"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a6c8585dfe5059d758249a667e4f02027">nodeBoundingBoxMinX</a></td></tr>
<tr class="memdesc:a6c8585dfe5059d758249a667e4f02027"><td class="mdescLeft"> </td><td class="mdescRight">X component of boundingBoxMin. <br/></td></tr>
<tr class="separator:a6c8585dfe5059d758249a667e4f02027"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af2c8ef07fcf7424bfb131639f0d20a0a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af2c8ef07fcf7424bfb131639f0d20a0a"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#af2c8ef07fcf7424bfb131639f0d20a0a">nodeBoundingBoxMinY</a></td></tr>
<tr class="memdesc:af2c8ef07fcf7424bfb131639f0d20a0a"><td class="mdescLeft"> </td><td class="mdescRight">Y component of boundingBoxMin. <br/></td></tr>
<tr class="separator:af2c8ef07fcf7424bfb131639f0d20a0a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a672a6cb9f1d410398461e14822e34724"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a672a6cb9f1d410398461e14822e34724"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a672a6cb9f1d410398461e14822e34724">nodeBoundingBoxMinZ</a></td></tr>
<tr class="memdesc:a672a6cb9f1d410398461e14822e34724"><td class="mdescLeft"> </td><td class="mdescRight">Z component of boundingBoxMin. <br/></td></tr>
<tr class="separator:a672a6cb9f1d410398461e14822e34724"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a561dd332a87a898ad27c45f8df63ce5e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a561dd332a87a898ad27c45f8df63ce5e"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a561dd332a87a898ad27c45f8df63ce5e">nodeBoundingBoxMax</a></td></tr>
<tr class="memdesc:a561dd332a87a898ad27c45f8df63ce5e"><td class="mdescLeft"> </td><td class="mdescRight">bounding box maximum point <br/></td></tr>
<tr class="separator:a561dd332a87a898ad27c45f8df63ce5e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a72662727ce95f02e05786d28c9c02ccf"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a72662727ce95f02e05786d28c9c02ccf"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a72662727ce95f02e05786d28c9c02ccf">nodeBoundingBoxMaxX</a></td></tr>
<tr class="memdesc:a72662727ce95f02e05786d28c9c02ccf"><td class="mdescLeft"> </td><td class="mdescRight">X component of boundingBoxMax. <br/></td></tr>
<tr class="separator:a72662727ce95f02e05786d28c9c02ccf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adcccdf8f7313565565c34c3c557d1915"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="adcccdf8f7313565565c34c3c557d1915"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#adcccdf8f7313565565c34c3c557d1915">nodeBoundingBoxMaxY</a></td></tr>
<tr class="memdesc:adcccdf8f7313565565c34c3c557d1915"><td class="mdescLeft"> </td><td class="mdescRight">Y component of boundingBoxMax. <br/></td></tr>
<tr class="separator:adcccdf8f7313565565c34c3c557d1915"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a29cf529c4439683a9bab01bd5c086d44"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a29cf529c4439683a9bab01bd5c086d44"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a29cf529c4439683a9bab01bd5c086d44">nodeBoundingBoxMaxZ</a></td></tr>
<tr class="memdesc:a29cf529c4439683a9bab01bd5c086d44"><td class="mdescLeft"> </td><td class="mdescRight">Z component of boundingBoxMax. <br/></td></tr>
<tr class="separator:a29cf529c4439683a9bab01bd5c086d44"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a03452cb6c40f86d518ce42e3908d9214"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a03452cb6c40f86d518ce42e3908d9214"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a03452cb6c40f86d518ce42e3908d9214">nodeBoundingBoxSize</a></td></tr>
<tr class="memdesc:a03452cb6c40f86d518ce42e3908d9214"><td class="mdescLeft"> </td><td class="mdescRight">bounding box size vector <br/></td></tr>
<tr class="separator:a03452cb6c40f86d518ce42e3908d9214"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad7c9924095d10de622faf7b118800f2a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad7c9924095d10de622faf7b118800f2a"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#ad7c9924095d10de622faf7b118800f2a">nodeBoundingBoxSizeX</a></td></tr>
<tr class="memdesc:ad7c9924095d10de622faf7b118800f2a"><td class="mdescLeft"> </td><td class="mdescRight">X component of boundingBoxSize. <br/></td></tr>
<tr class="separator:ad7c9924095d10de622faf7b118800f2a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0b5182fb1b79d664919638051066b2b0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0b5182fb1b79d664919638051066b2b0"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a0b5182fb1b79d664919638051066b2b0">nodeBoundingBoxSizeY</a></td></tr>
<tr class="memdesc:a0b5182fb1b79d664919638051066b2b0"><td class="mdescLeft"> </td><td class="mdescRight">Y component of boundingBoxSize. <br/></td></tr>
<tr class="separator:a0b5182fb1b79d664919638051066b2b0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5ade8a376e398ac96281e7af043e24c1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5ade8a376e398ac96281e7af043e24c1"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a5ade8a376e398ac96281e7af043e24c1">nodeBoundingBoxSizeZ</a></td></tr>
<tr class="memdesc:a5ade8a376e398ac96281e7af043e24c1"><td class="mdescLeft"> </td><td class="mdescRight">Z component of boundingBoxSize. <br/></td></tr>
<tr class="separator:a5ade8a376e398ac96281e7af043e24c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1782a6717e36a9db600bd747c6707ecd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1782a6717e36a9db600bd747c6707ecd"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a1782a6717e36a9db600bd747c6707ecd">center</a></td></tr>
<tr class="memdesc:a1782a6717e36a9db600bd747c6707ecd"><td class="mdescLeft"> </td><td class="mdescRight">object center attribute <br/></td></tr>
<tr class="separator:a1782a6717e36a9db600bd747c6707ecd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7e061e3c5b2772679bdeda47008ee889"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7e061e3c5b2772679bdeda47008ee889"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a7e061e3c5b2772679bdeda47008ee889">boundingBoxCenterX</a></td></tr>
<tr class="memdesc:a7e061e3c5b2772679bdeda47008ee889"><td class="mdescLeft"> </td><td class="mdescRight">X component of boundingBoxCenter. <br/></td></tr>
<tr class="separator:a7e061e3c5b2772679bdeda47008ee889"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acbb8911972ddf1ecbdd4f7b37182e5a1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="acbb8911972ddf1ecbdd4f7b37182e5a1"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#acbb8911972ddf1ecbdd4f7b37182e5a1">boundingBoxCenterY</a></td></tr>
<tr class="memdesc:acbb8911972ddf1ecbdd4f7b37182e5a1"><td class="mdescLeft"> </td><td class="mdescRight">Y component of boundingBoxCenter. <br/></td></tr>
<tr class="separator:acbb8911972ddf1ecbdd4f7b37182e5a1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0acaa4a7ffe610981091d0097956c280"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0acaa4a7ffe610981091d0097956c280"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a0acaa4a7ffe610981091d0097956c280">boundingBoxCenterZ</a></td></tr>
<tr class="memdesc:a0acaa4a7ffe610981091d0097956c280"><td class="mdescLeft"> </td><td class="mdescRight">Z component of boundingBoxCenter. <br/></td></tr>
<tr class="separator:a0acaa4a7ffe610981091d0097956c280"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a03ffd0b722e887108a542da8a5936146"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a03ffd0b722e887108a542da8a5936146"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a03ffd0b722e887108a542da8a5936146">matrix</a></td></tr>
<tr class="memdesc:a03ffd0b722e887108a542da8a5936146"><td class="mdescLeft"> </td><td class="mdescRight">matrix attribute <br/></td></tr>
<tr class="separator:a03ffd0b722e887108a542da8a5936146"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2654111fc6ea20feea7625efab825cbe"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2654111fc6ea20feea7625efab825cbe"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a2654111fc6ea20feea7625efab825cbe">inverseMatrix</a></td></tr>
<tr class="memdesc:a2654111fc6ea20feea7625efab825cbe"><td class="mdescLeft"> </td><td class="mdescRight">inverse matrix attribute <br/></td></tr>
<tr class="separator:a2654111fc6ea20feea7625efab825cbe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aae8765de146707c69dc4c25709b15456"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aae8765de146707c69dc4c25709b15456"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#aae8765de146707c69dc4c25709b15456">worldMatrix</a></td></tr>
<tr class="memdesc:aae8765de146707c69dc4c25709b15456"><td class="mdescLeft"> </td><td class="mdescRight">world matrix attribute <br/></td></tr>
<tr class="separator:aae8765de146707c69dc4c25709b15456"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5750667fd6aab34b3019c86af66e56c1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5750667fd6aab34b3019c86af66e56c1"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a5750667fd6aab34b3019c86af66e56c1">worldInverseMatrix</a></td></tr>
<tr class="memdesc:a5750667fd6aab34b3019c86af66e56c1"><td class="mdescLeft"> </td><td class="mdescRight">inverse world matrix attribute <br/></td></tr>
<tr class="separator:a5750667fd6aab34b3019c86af66e56c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9dcee4efddda947e5dfa916e0e672ca9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9dcee4efddda947e5dfa916e0e672ca9"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a9dcee4efddda947e5dfa916e0e672ca9">parentMatrix</a></td></tr>
<tr class="memdesc:a9dcee4efddda947e5dfa916e0e672ca9"><td class="mdescLeft"> </td><td class="mdescRight">parent matrix attribute <br/></td></tr>
<tr class="separator:a9dcee4efddda947e5dfa916e0e672ca9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a60307c6c66af3a3e889bf0dde83ef54e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a60307c6c66af3a3e889bf0dde83ef54e"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a60307c6c66af3a3e889bf0dde83ef54e">parentInverseMatrix</a></td></tr>
<tr class="memdesc:a60307c6c66af3a3e889bf0dde83ef54e"><td class="mdescLeft"> </td><td class="mdescRight">inverse parent matrix attribute <br/></td></tr>
<tr class="separator:a60307c6c66af3a3e889bf0dde83ef54e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a44dfd2eb9073be34444d787b23345856"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a44dfd2eb9073be34444d787b23345856"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a44dfd2eb9073be34444d787b23345856">visibility</a></td></tr>
<tr class="memdesc:a44dfd2eb9073be34444d787b23345856"><td class="mdescLeft"> </td><td class="mdescRight">visibility attribute <br/></td></tr>
<tr class="separator:a44dfd2eb9073be34444d787b23345856"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64450fbec15c69d69923217759d0adf3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a64450fbec15c69d69923217759d0adf3"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a64450fbec15c69d69923217759d0adf3">intermediateObject</a></td></tr>
<tr class="memdesc:a64450fbec15c69d69923217759d0adf3"><td class="mdescLeft"> </td><td class="mdescRight">intermediate object attribute <br/></td></tr>
<tr class="separator:a64450fbec15c69d69923217759d0adf3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3180d822648060b5a400f85b77ad10a9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3180d822648060b5a400f85b77ad10a9"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a3180d822648060b5a400f85b77ad10a9">isTemplated</a></td></tr>
<tr class="memdesc:a3180d822648060b5a400f85b77ad10a9"><td class="mdescLeft"> </td><td class="mdescRight">template attribute <br/></td></tr>
<tr class="separator:a3180d822648060b5a400f85b77ad10a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae33f55850a42c251d52b2f63e58acdd7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae33f55850a42c251d52b2f63e58acdd7"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#ae33f55850a42c251d52b2f63e58acdd7">instObjGroups</a></td></tr>
<tr class="memdesc:ae33f55850a42c251d52b2f63e58acdd7"><td class="mdescLeft"> </td><td class="mdescRight">instances object group info attribute <br/></td></tr>
<tr class="separator:ae33f55850a42c251d52b2f63e58acdd7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1f6d0343b05ddc81f724513487a657d9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1f6d0343b05ddc81f724513487a657d9"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a1f6d0343b05ddc81f724513487a657d9">objectGroups</a></td></tr>
<tr class="memdesc:a1f6d0343b05ddc81f724513487a657d9"><td class="mdescLeft"> </td><td class="mdescRight">object groups attributes <br/></td></tr>
<tr class="separator:a1f6d0343b05ddc81f724513487a657d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abdc64f3b0c12aa2e5582a4c77f15b897"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abdc64f3b0c12aa2e5582a4c77f15b897"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#abdc64f3b0c12aa2e5582a4c77f15b897">objectGrpCompList</a></td></tr>
<tr class="memdesc:abdc64f3b0c12aa2e5582a4c77f15b897"><td class="mdescLeft"> </td><td class="mdescRight">component in object groups attribute <br/></td></tr>
<tr class="separator:abdc64f3b0c12aa2e5582a4c77f15b897"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7eebfe684c5005ecb6b607ea5ba05bbc"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7eebfe684c5005ecb6b607ea5ba05bbc"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a7eebfe684c5005ecb6b607ea5ba05bbc">objectGroupId</a></td></tr>
<tr class="memdesc:a7eebfe684c5005ecb6b607ea5ba05bbc"><td class="mdescLeft"> </td><td class="mdescRight">group id attribute <br/></td></tr>
<tr class="separator:a7eebfe684c5005ecb6b607ea5ba05bbc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0b6d8b9bfd2a0a151c58775e47ba9d19"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0b6d8b9bfd2a0a151c58775e47ba9d19"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a0b6d8b9bfd2a0a151c58775e47ba9d19">objectGroupColor</a></td></tr>
<tr class="memdesc:a0b6d8b9bfd2a0a151c58775e47ba9d19"><td class="mdescLeft"> </td><td class="mdescRight">group id attribute <br/></td></tr>
<tr class="separator:a0b6d8b9bfd2a0a151c58775e47ba9d19"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8bf641378645a2d25a9498c9104ae55b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8bf641378645a2d25a9498c9104ae55b"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a8bf641378645a2d25a9498c9104ae55b">useObjectColor</a></td></tr>
<tr class="memdesc:a8bf641378645a2d25a9498c9104ae55b"><td class="mdescLeft"> </td><td class="mdescRight">controls choice of wireframe dormant object color <br/></td></tr>
<tr class="separator:a8bf641378645a2d25a9498c9104ae55b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9edb9e827f6f659034c033a07b434dc7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9edb9e827f6f659034c033a07b434dc7"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_surface_shape.html#a9edb9e827f6f659034c033a07b434dc7">objectColor</a></td></tr>
<tr class="memdesc:a9edb9e827f6f659034c033a07b434dc7"><td class="mdescLeft"> </td><td class="mdescRight">the per object dormant wireframe color <br/></td></tr>
<tr class="separator:a9edb9e827f6f659034c033a07b434dc7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_static_attribs_class_m_px_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_m_px_node')"><img alt="-" src="cpp_ref/closed.png"/> Static Public Attributes inherited from <a class="el" href="./class_m_px_node.html">MPxNode</a></td></tr>
<tr class="memitem:ac4a5de65a3a8f057ea39cd749d38971e inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac4a5de65a3a8f057ea39cd749d38971e"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ac4a5de65a3a8f057ea39cd749d38971e">message</a></td></tr>
<tr class="memdesc:ac4a5de65a3a8f057ea39cd749d38971e inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">message attribute <br/></td></tr>
<tr class="separator:ac4a5de65a3a8f057ea39cd749d38971e inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca1ef7f3910c1afb1766960fa2a5375d inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aca1ef7f3910c1afb1766960fa2a5375d"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aca1ef7f3910c1afb1766960fa2a5375d">isHistoricallyInteresting</a></td></tr>
<tr class="memdesc:aca1ef7f3910c1afb1766960fa2a5375d inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">is historically interesting attribute <br/></td></tr>
<tr class="separator:aca1ef7f3910c1afb1766960fa2a5375d inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2415a0b1d38a0f851f801c4a18181f91 inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2415a0b1d38a0f851f801c4a18181f91"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a2415a0b1d38a0f851f801c4a18181f91">caching</a></td></tr>
<tr class="memdesc:a2415a0b1d38a0f851f801c4a18181f91 inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">caching attribute <br/></td></tr>
<tr class="separator:a2415a0b1d38a0f851f801c4a18181f91 inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab1315838f80fd570104dc41d834d8ff5 inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab1315838f80fd570104dc41d834d8ff5"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#ab1315838f80fd570104dc41d834d8ff5">state</a></td></tr>
<tr class="memdesc:ab1315838f80fd570104dc41d834d8ff5 inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">state attribute <br/></td></tr>
<tr class="separator:ab1315838f80fd570104dc41d834d8ff5 inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a73c48c31ea4fca53d389e96e5aadbb8f inherit pub_static_attribs_class_m_px_node"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a73c48c31ea4fca53d389e96e5aadbb8f"></a>
static <a class="el" href="./class_m_object.html">MObject</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a73c48c31ea4fca53d389e96e5aadbb8f">frozen</a></td></tr>
<tr class="memdesc:a73c48c31ea4fca53d389e96e5aadbb8f inherit pub_static_attribs_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">frozen attribute <br/></td></tr>
<tr class="separator:a73c48c31ea4fca53d389e96e5aadbb8f inherit pub_static_attribs_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_m_px_node"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_px_node')"><img alt="-" src="cpp_ref/closed.png"/> Protected Member Functions inherited from <a class="el" href="./class_m_px_node.html">MPxNode</a></td></tr>
<tr class="memitem:af455f77823c8e3803db82c9f80f2231b inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_data_block.html">MDataBlock</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#af455f77823c8e3803db82c9f80f2231b">forceCache</a> ()</td></tr>
<tr class="memdesc:af455f77823c8e3803db82c9f80f2231b inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">USE _forceCache() IN SCRIPT.  <a href="class_m_px_surface_shape.html#af455f77823c8e3803db82c9f80f2231b">More...</a><br/></td></tr>
<tr class="separator:af455f77823c8e3803db82c9f80f2231b inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02d5ad99659b3a4d33135ac436fbc162 inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_status.html">MStatus</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a02d5ad99659b3a4d33135ac436fbc162">setDoNotWrite</a> (bool flag)</td></tr>
<tr class="memdesc:a02d5ad99659b3a4d33135ac436fbc162 inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">USE _setDoNotWrite() IN SCRIPT.  <a href="class_m_px_surface_shape.html#a02d5ad99659b3a4d33135ac436fbc162">More...</a><br/></td></tr>
<tr class="separator:a02d5ad99659b3a4d33135ac436fbc162 inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a50cd371a9d27927032cd8dc6fd3f4710 inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#a50cd371a9d27927032cd8dc6fd3f4710">doNotWrite</a> (<a class="el" href="./class_m_status.html">MStatus</a> *ReturnStatus=NULL) const </td></tr>
<tr class="memdesc:a50cd371a9d27927032cd8dc6fd3f4710 inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">USE _doNotWrite() IN SCRIPT.  <a href="class_m_px_surface_shape.html#a50cd371a9d27927032cd8dc6fd3f4710">More...</a><br/></td></tr>
<tr class="separator:a50cd371a9d27927032cd8dc6fd3f4710 inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afc6e1f9ad83ed00627411828d91cc5cf inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#afc6e1f9ad83ed00627411828d91cc5cf">setMPSafe</a> (bool isMPSafe)</td></tr>
<tr class="memdesc:afc6e1f9ad83ed00627411828d91cc5cf inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_surface_shape.html#afc6e1f9ad83ed00627411828d91cc5cf">More...</a><br/></td></tr>
<tr class="separator:afc6e1f9ad83ed00627411828d91cc5cf inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aad11c80afa08f06d2ff9a0058b8e6152 inherit pro_methods_class_m_px_node"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="./class_m_data_block.html">MDataBlock</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="./class_m_px_node.html#aad11c80afa08f06d2ff9a0058b8e6152">forceCache</a> (const <a class="el" href="./class_m_d_g_context.html">MDGContext</a> &amp;)</td></tr>
<tr class="memdesc:aad11c80afa08f06d2ff9a0058b8e6152 inherit pro_methods_class_m_px_node"><td class="mdescLeft"> </td><td class="mdescRight">This method is obsolete.  <a href="class_m_px_surface_shape.html#aad11c80afa08f06d2ff9a0058b8e6152">More...</a><br/></td></tr>
<tr class="separator:aad11c80afa08f06d2ff9a0058b8e6152 inherit pro_methods_class_m_px_node"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parent class of all user defined shapes. </p>
<p><a class="el" href="./class_m_px_surface_shape.html" title="Parent class of all user defined shapes. ">MPxSurfaceShape</a> is the parent class of all user defined shapes. User defined shapes are dependency nodes (and DAG nodes) which contain overridable drawing, selection, and component methods.</p>
<p>This class can be used to implement new kinds of shapes within Maya that can have selectable/manipulatable components and behave in a similar manner to the default shapes in maya.</p>
<p>The UI dependent aspects of the shape should be implemented in a class derived from <a class="el" href="./class_m_px_surface_shape_u_i.html" title="drawing and selection for user defined shapes ">MPxSurfaceShapeUI</a>. This includes the drawing and interactive selection of the shape and any components that the shape implements. </p>
<dl class="section"><div class="dynheader closed" id="dynsection-example0" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example0-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example0-content" style="display:none;"><dd><a class="el" href="./api_directional_light_shape_2api_directional_light_shape_8h-example.html#_a0">apiDirectionalLightShape/apiDirectionalLightShape.h</a>, <a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#_a0">apiMeshShape/apiMeshShape.h</a>, <a class="el" href="./api_mesh_shape_2api_mesh_shape_u_i_8cpp-example.html#_a50">apiMeshShape/apiMeshShapeUI.cpp</a>, <a class="el" href="./geometry_override_example1_2geometry_override_example1_8h-example.html#_a0">geometryOverrideExample1/geometryOverrideExample1.h</a>, <a class="el" href="./geometry_override_example2_2geometry_override_example2_8h-example.html#_a0">geometryOverrideExample2/geometryOverrideExample2.h</a>, <a class="el" href="./geometry_replicator_2geometry_replicator_8cpp-example.html#_a0">geometryReplicator/geometryReplicator.cpp</a>, and <a class="el" href="./gpu_cache_2gpu_cache_shape_node_8h-example.html#_a0">gpuCache/gpuCacheShapeNode.h</a>.</dd></div>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a562fb3d6ffc0a5e86cd36bcd9556d929"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">OPENMAYA_MAJOR_NAMESPACE_OPEN <a class="el" href="./class_m_px_surface_shape.html">MPxSurfaceShape</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Class constructor. </p>
<p>Any calls the <a class="el" href="./class_m_px_surface_shape.html" title="Parent class of all user defined shapes. ">MPxSurfaceShape</a> methods must be done in the postConstructor method and not here. </p>
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a71bae20f7cb1d030904cf421f1c5eba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">MPxNode::Type type </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the type of node that this is. </p>
<p>This is used to differentiate user defined nodes that are derived off different MPx base classes.</p>
<p>It is not necessary to override this method.</p>
<dl class="section return"><dt>Returns</dt><dd>Type of the node (MPxNode::kSurfaceShape) </dd></dl>
<p>Reimplemented from <a class="el" href="./class_m_px_node.html#a71bae20f7cb1d030904cf421f1c5eba2">MPxNode</a>.</p>
</div>
</div>
<a class="anchor" id="a4254418493ef1ab6847b9e5f395fa3de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool isBounded </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should be overridden to return true if the user supplies a bounding box routine. </p>
<p>Supplying a bounding box routine makes refresh and selection more efficient.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether a bounding box routine has been supplied </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example1" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example1-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example1-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a50">apiMeshShape/apiMeshShape.h</a>, <a class="el" href="./geometry_override_example1_2geometry_override_example1_8h-example.html#a3">geometryOverrideExample1/geometryOverrideExample1.h</a>, and <a class="el" href="./geometry_override_example2_2geometry_override_example2_8h-example.html#a3">geometryOverrideExample2/geometryOverrideExample2.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a762dab569a9d88aa731f3c7229803e1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/boundingBox"></a><a class="el" href="./class_m_bounding_box.html">MBoundingBox</a> boundingBox </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should be overridden to return a bounding box for the shape. </p>
<p>If this method is overridden, then <a class="el" href="./class_m_px_surface_shape.html#a4254418493ef1ab6847b9e5f395fa3de" title="This method should be overridden to return true if the user supplies a bounding box routine...">MPxSurfaceShape::isBounded</a> should also be overridden to return true.</p>
<dl class="section return"><dt>Returns</dt><dd>The bounding box of the shape </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example2" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example2-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example2-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a52">apiMeshShape/apiMeshShape.h</a>, <a class="el" href="./api_mesh_shape_2api_mesh_shape_u_i_8cpp-example.html#a52">apiMeshShape/apiMeshShapeUI.cpp</a>, <a class="el" href="./geometry_override_example1_2geometry_override_example1_8h-example.html#a5">geometryOverrideExample1/geometryOverrideExample1.h</a>, and <a class="el" href="./geometry_override_example2_2geometry_override_example2_8h-example.html#a5">geometryOverrideExample2/geometryOverrideExample2.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ac7ed3c12a9d58732798aa421249e2027"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool evalNodeAffectsDrawDb </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_evaluation_node.html">MEvaluationNode</a> &amp; </td>
<td class="paramname"><em>evaluationNode</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should be overridden to return true if the evaluationNode contains any dirty plugs that will affect the drawing of your plug-in. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">evaluationNode</td><td>Evaluation information for this surface node</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the evaluationNode contains plugs that will affect drawing </dd></dl>
</div>
</div>
<a class="anchor" id="a8c173b035e5039b8db8a25974f7b68f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void transformUsing </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_matrix.html">MMatrix</a> &amp; </td>
<td class="paramname"><em>matrix</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp; </td>
<td class="paramname"><em>componentList</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Transform the given components using the specified transformation matrix. </p>
<p>This method should be overridden if the shape supports components that can be transformed using maya's move, scale, and rotate tools.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>the matrix representing the transformation that is to be applied to the components </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">componentList</td><td>a list of components to be tranformed. If the list is empty, it indicates that every point in the geometry should be transformed. </td></tr>
</table>
</dd>
</dl>
<p>Reimplemented in <a class="el" href="./class_m_px_component_shape.html#adb8b0687c23fe175635196ee3aba2e46">MPxComponentShape</a>.</p>
<dl class="section"><div class="dynheader closed" id="dynsection-example3" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example3-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example3-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a39">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a5a0f241f5c9780c04ea636d318a30d46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void transformUsing </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_matrix.html">MMatrix</a> &amp; </td>
<td class="paramname"><em>mat</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp; </td>
<td class="paramname"><em>componentList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">MVertexCachingMode </td>
<td class="paramname"><em>cachingMode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html">MPointArray</a> * </td>
<td class="paramname"><em>pointCache</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Transform the given components using the specified transformation matrix. </p>
<p>This method should be overridden if the shape supports components that can be transformed using maya's move, scale, and rotate tools.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>the matrix representing the transformation that is to be applied to the components </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">componentList</td><td>a list of components to be transformed. If the list is empty, it indicates that every point in the geometry should be transformed. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cachingMode</td><td>whether the points should be cached in the pointCache argument, or restored from the pointCache </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointCache</td><td>used to store for undo and restore points during undo </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a63d07adee03843317948fb8f92bb0ecd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void tweakUsing </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_matrix.html">MMatrix</a> &amp; </td>
<td class="paramname"><em>mat</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp; </td>
<td class="paramname"><em>componentList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">MVertexCachingMode </td>
<td class="paramname"><em>cachingMode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html">MPointArray</a> * </td>
<td class="paramname"><em>pointCache</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_array_data_handle.html">MArrayDataHandle</a> &amp; </td>
<td class="paramname"><em>handle</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Transform the given components using the specified transformation matrix. </p>
<p>This method should be overridden if the shape supports components that can be transformed using maya's move, scale, and rotate tools. This method is called when the shape has history &amp; connected to a tweak node. The most common reason why the shape would be connected to a tweak node is if it is being deformed. When a shape is connected to a tweak node, transformations applied to the points are placed in the tweak node rather than in the shape itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>the matrix representing the transformation that is to be applied to the components </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">componentList</td><td>a list of components to be tranformed. If the list is empty, it indicates that every point in the geometry should be transformed. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cachingMode</td><td>whether the points should be cached in the pointCache argument, or restored from the pointCache </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointCache</td><td>used to store for undo and restore points during undo </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>array data handle where the tweaks are stored </td></tr>
</table>
</dd>
</dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example4" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example4-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example4-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a42">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a0b16bb5955cf8762e3a521686c72be04"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool convertToTweakNodePlug </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_plug.html">MPlug</a> &amp; </td>
<td class="paramname"><em>plug</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Check if a tweak node is connected to this node. </p>
<p>If it is, then reset the supplied plug to contain the controlPoints attribute on the tweak node.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">plug</td><td>plug which will be set to point to the associated tweak node plug if a tweak node is connected</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a tweak node was found, false if the plug was unchanged </dd></dl>
</div>
</div>
<a class="anchor" id="a66ccd127d36b5dc896459eddff2b7587"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void weightedTransformUsing </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_transformation_matrix.html">MTransformationMatrix</a> &amp; </td>
<td class="paramname"><em>xform</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_matrix.html">MMatrix</a> * </td>
<td class="paramname"><em>space</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp; </td>
<td class="paramname"><em>componentList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">MVertexCachingMode </td>
<td class="paramname"><em>cachingMode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html">MPointArray</a> * </td>
<td class="paramname"><em>pointCache</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_plane.html">MPlane</a> * </td>
<td class="paramname"><em>freezePlane</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Transform the given components with interpolation using the specified transformation matrix. </p>
<p>If not overridden, then a default implementation will be used to perform the transformation and interpolation. The default implementation calls setPoint() for each transformed point.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">xform</td><td>the matrix representing the transformation that is to be applied to the components </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>the matrix representing the transformation space to perform the interpolated transformation. A value of NULL indicates it should be ignored. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">componentList</td><td>a list of components to be transformed and their weights. This list will not be empty. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cachingMode</td><td>whether the points should be added/updated in the pointCache, restored from the pointCache, or transform using use the original values in the pointCache. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointCache</td><td>used to store for undo and restore points during undo </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">freezePlane</td><td>used for symmetric transformation of components. A value of NULL indicates it is not used and there is no symmetric transformation. </td></tr>
</table>
</dd>
</dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example5" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example5-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example5-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8cpp-example.html#a90">apiMeshShape/apiMeshShape.cpp</a>, and <a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a44">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa704affe596b61074b4eb2bf087e8092"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void weightedTweakUsing </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_transformation_matrix.html">MTransformationMatrix</a> &amp; </td>
<td class="paramname"><em>xform</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_matrix.html">MMatrix</a> * </td>
<td class="paramname"><em>space</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp; </td>
<td class="paramname"><em>componentList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">MVertexCachingMode </td>
<td class="paramname"><em>cachingMode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point_array.html">MPointArray</a> * </td>
<td class="paramname"><em>pointCache</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_plane.html">MPlane</a> * </td>
<td class="paramname"><em>freezePlane</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_array_data_handle.html">MArrayDataHandle</a> &amp; </td>
<td class="paramname"><em>handle</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Transform the given components with interpolation using the specified transformation matrix. </p>
<p>This method is called for transforming components using maya's move, scale, and rotate tools when the shape has history and is connected to a tweak node. The most common reason why the shape would be connected to a tweak node is if it is being deformed. When a shape is connected to a tweak node, transformations applied to the points are placed in the tweak node rather than in the shape itself.</p>
<p>If not overridden, then a default implementation will be used to perform the transformation and interpolation. The default implementation calls setPoint() for each transformed point.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">xform</td><td>the matrix representing the transformation that is to be applied to the components </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>the matrix representing the transformation space to perform the interpolated transformation. A value of NULL indicates it should be ignored. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">componentList</td><td>a list of components to be transformed and their weights. This list will not be empty. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cachingMode</td><td>whether the points should be added/updated in the pointCache, restored from the pointCache, or transform using the original values in the pointCache. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pointCache</td><td>used to store for undo and restore points during undo </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">freezePlane</td><td>used for symmetric transformation of components. A value of NULL indicates it is not used and there is no symmetric transformation. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>array data handle where the tweaks are stored </td></tr>
</table>
</dd>
</dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example6" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example6-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example6-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8cpp-example.html#a100">apiMeshShape/apiMeshShape.cpp</a>, and <a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a47">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a53b5c9f420f95352364d44af3cf1dc77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool vertexOffsetDirection </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_object.html">MObject</a> &amp; </td>
<td class="paramname"><em>component</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector_array.html">MVectorArray</a> &amp; </td>
<td class="paramname"><em>direction</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">MVertexOffsetMode </td>
<td class="paramname"><em>mode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>normalize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should be overridden if the shape supports components that can be moved in the direction of the normal or UV's using the move vertex normal tool. </p>
<p>This method should calculate the offset direction for a vertex components. The direction vector array is an array of offsets corresponding to the elements in the component. The mode argument specifies the type of movement that is being performed.</p>
<p>The default for this method is to return false, i.e. no support for move normal tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">component</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The type of vertex movement</td></tr>
</table>
</dd>
</dl>
<ul>
<li>mode = 0 -&gt; normal </li>
<li>mode = 1 -&gt; U </li>
<li>mode = 2 -&gt; V </li>
<li>mode = 3 -&gt; UVN triad</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>specifies whether the offset vectors should be normalized</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the shape supports the current mode, false if the shape cannot do the requested vertex move </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example7" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example7-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example7-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a48">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a2698fc8bec46daa06a301e75eb3dff28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/newControlPointComponent"></a><a class="el" href="./class_m_object.html">MObject</a> newControlPointComponent </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>The default action of this method is to return an <a class="el" href="./class_m_fn_single_indexed_component.html" title="Single indexed component function set. ">MFnSingleIndexedComponent</a> (of type <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a040adaedfb9ad2fcc82cdeca1e214522" title="  ">MFn::kMeshVertComponent</a>) in order to support rigid skinning binds. </p>
<p>This method can be overridden to support other types of components such as <a class="el" href="./class_m_fn_double_indexed_component.html" title="Double indexed component function set. ">MFnDoubleIndexedComponent</a> and <a class="el" href="./class_m_fn_triple_indexed_component.html" title="Triple indexed component function set. ">MFnTripleIndexedComponent</a> and should return a new component of that type. The types allowed are those listed in the create() method docs for each MFn*IndexedComponent.</p>
<p>No argument is required.</p>
<p>The skinning code handles the deallocation of the new component.</p>
<dl class="section return"><dt>Returns</dt><dd>The new component </dd></dl>
</div>
</div>
<a class="anchor" id="a500209ff59fdea62b1a898869fc4d976"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void componentToPlugs </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_object.html">MObject</a> &amp; </td>
<td class="paramname"><em>component</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_selection_list.html">MSelectionList</a> &amp; </td>
<td class="paramname"><em>list</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Converts the given component into a selection list of plugs. </p>
<p>This method is used to associate a shapes components into the corresponding attributes (plugs) within the shape. For example, it gets called by the translate manipulator to determine which attributes should be driven by the manipulator, and by the setKeyframe command to determine where to connect animCurves for components.</p>
<p>This method should be overridden if the shape supports components that can be selected and moved in Maya.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">component</td><td>the component to be converted </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>a selection list where the plug should be added </td></tr>
</table>
</dd>
</dl>
<p>Reimplemented in <a class="el" href="./class_m_px_component_shape.html#ace46a05643774baa7dc8019e48a6c4dc">MPxComponentShape</a>.</p>
<dl class="section"><div class="dynheader closed" id="dynsection-example8" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example8-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example8-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a22">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa9b8d2823f22cfea3e77746d84a54e6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool match </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_selection_mask.html">MSelectionMask</a> &amp; </td>
<td class="paramname"><em>mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp; </td>
<td class="paramname"><em>componentList</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used to check for matches between a selection type (or mask) and a given component. </p>
<p>If your shape has components representing attributes then this method is used to match up your components with selection masks.</p>
<p>This is used by sets and deformers to make sure that the selected components fall into the "vertex only" category. This is useful when you want to make sure that only a particular component can be deformed.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>the selection mask to test against </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">componentList</td><td>a list of components to be tested</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> the match was successfull </li>
<li><b>false</b> the match failed </li>
</ul>
</dd></dl>
<p>Reimplemented in <a class="el" href="./class_m_px_component_shape.html#aa9b8d2823f22cfea3e77746d84a54e6c">MPxComponentShape</a>.</p>
<dl class="section"><div class="dynheader closed" id="dynsection-example9" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example9-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example9-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a27">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ad5b7d116bec47de181203ece3092f592"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">OPENMAYA_ENUM </td>
<td>(</td>
<td class="paramtype">MatchResult </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kMatchOk </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kMatchNone </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kMatchTooMany </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kMatchInvalidName </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kMatchInvalidAttribute </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kMatchInvalidAttributeIndex </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kMatchInvalidAttributeRange </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kMatchInvalidAttributeDim </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Return values for the <a class="el" href="./class_m_px_surface_shape.html#a19499831f6a63ee7b57c942a23764abe" title="This method is used to convert the string representation of a component into a component object and t...">matchComponent()</a> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">kMatchOk</td><td>The component was matched without error. </td></tr>
<tr><td class="paramname">kMatchNone</td><td>No component was matched. </td></tr>
<tr><td class="paramname">kMatchTooMany</td><td>Not used. </td></tr>
<tr><td class="paramname">kMatchInvalidName</td><td>One of the names in the attribute specification was not valid. </td></tr>
<tr><td class="paramname">kMatchInvalidAttribute</td><td>Not used. </td></tr>
<tr><td class="paramname">kMatchInvalidAttributeIndex</td><td>The attribute specification contained an index for a non-array attribute. </td></tr>
<tr><td class="paramname">kMatchInvalidAttributeRange</td><td>An attribute index was out of range. </td></tr>
<tr><td class="paramname">kMatchInvalidAttributeDim</td><td>The attribute specification provided the wrong number of dimensions for an attribute. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a19499831f6a63ee7b57c942a23764abe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">MPxSurfaceShape::MatchResult matchComponent </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_selection_list.html">MSelectionList</a> &amp; </td>
<td class="paramname"><em>item</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_attribute_spec_array.html">MAttributeSpecArray</a> &amp; </td>
<td class="paramname"><em>spec</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_selection_list.html">MSelectionList</a> &amp; </td>
<td class="paramname"><em>list</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used to convert the string representation of a component into a component object and to validate that the indices. </p>
<p>This method should be overridden if the shape has components.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>DAG selection item for the object being matched </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">spec</td><td>attribute specification object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>list to add components to</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component match result </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example10" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example10-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example10-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8cpp-example.html#a69">apiMeshShape/apiMeshShape.cpp</a>, and <a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a25">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="acedd5e97c21aacfc5f976499438c7fa8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/getShapeSelectionMask"></a><a class="el" href="./class_m_selection_mask.html">MSelectionMask</a> getShapeSelectionMask </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This routine must be overridden if the shape is to support interactive object selection in Viewport 2.0 and should provide information about the selection mask of the shape. </p>
<dl class="section return"><dt>Returns</dt><dd>The selection mask of the shape. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example11" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example11-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example11-content" style="display:none;"><dd><a class="el" href="./api_directional_light_shape_2api_directional_light_shape_8h-example.html#a6">apiDirectionalLightShape/apiDirectionalLightShape.h</a>, <a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a29">apiMeshShape/apiMeshShape.h</a>, <a class="el" href="./geometry_override_example1_2geometry_override_example1_8h-example.html#a7">geometryOverrideExample1/geometryOverrideExample1.h</a>, and <a class="el" href="./geometry_override_example2_2geometry_override_example2_8h-example.html#a7">geometryOverrideExample2/geometryOverrideExample2.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a8904f1188c606e05e32ffb20c92812bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/getComponentSelectionMask"></a><a class="el" href="./class_m_selection_mask.html">MSelectionMask</a> getComponentSelectionMask </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This routine must be overridden if the shape is to support interactive component selection in Viewport 2.0 and should provide information about the selection mask of the shape component. </p>
<dl class="section return"><dt>Returns</dt><dd>The selection mask of the shape components. </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example12" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example12-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example12-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a30">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa7c0d18be99d36fdf2c7f476c4b09990"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/createFullVertexGroup"></a><a class="el" href="./class_m_object.html">MObject</a> createFullVertexGroup </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used to create a component containing every vertex/CV in the object. </p>
<p>This method is supposed to return non-NULL only if the dag object contains vertices/CVs (control points), so derived classes that do should override this method.</p>
<p>Eg: use MFnSingleIndexedComponent::setCompleteData( numVertices ) to specify that a component represents all the vertices of the shape.</p>
<dl class="section return"><dt>Returns</dt><dd>A component containing all of the vertices in the shape. </dd></dl>
<p>Reimplemented in <a class="el" href="./class_m_px_component_shape.html#aa7c0d18be99d36fdf2c7f476c4b09990">MPxComponentShape</a>.</p>
<dl class="section"><div class="dynheader closed" id="dynsection-example13" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example13-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example13-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a31">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a36be424b47bb1fa94be27226b915add3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/createFullRenderGroup"></a><a class="el" href="./class_m_object.html">MObject</a> createFullRenderGroup </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used to create a component containing every renderable element in the object. </p>
<p>This method is supposed to return non-NULL only if the dag object contains renderable components. Type of the return component should is the same as the one returned by <a class="el" href="./class_m_px_surface_shape.html#aca3deb4f05d04c359d1ef81c54b2876f" title="This method is used to return the type of renderable components for this shape. ">MPxSurfaceShape::renderGroupComponentType()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="./class_m_px_surface_shape.html#aca3deb4f05d04c359d1ef81c54b2876f" title="This method is used to return the type of renderable components for this shape. ">MPxSurfaceShape::renderGroupComponentType()</a></dd></dl>
<p>Eg: use MFnSingleIndexedComponent::setCompleteData( numFaces ) to specify that a component represents all the faces of the shape.</p>
<dl class="section return"><dt>Returns</dt><dd>A component containing all of renderable elements in the shape. </dd></dl>
</div>
</div>
<a class="anchor" id="aca3deb4f05d04c359d1ef81c54b2876f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/renderGroupComponentType"></a><a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7">MFn::Type</a> renderGroupComponentType </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used to return the type of renderable components for this shape. </p>
<p>It should return a type among <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a5ddabf9726f89e07cff62014221fe6fb" title="  ">MFn::kMeshPolygonComponent</a>, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7ae58d322e687fb53fca9b415cc274fd84" title="  ">MFn::kSubdivFaceComponent</a> and <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a63da13bcc643b4250e9359c31af1b839" title="  ">MFn::kSurfaceFaceComponent</a>, which is used in the creation of per-face/patch shader assignment.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="./class_m_fn_set.html#acc97b8a71ab6bdf40e1a13494b356e0c" title="Add a new object (DAG node) to the set. ">MFnSet::addMember(const MDagPath &amp;, const MObject &amp;)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the type of renderable components for this shape. </dd></dl>
</div>
</div>
<a class="anchor" id="a407741143a081e03cb2a832a3ef3c625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool deleteComponents </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp; </td>
<td class="paramname"><em>componentList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_double_array.html">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>undoInfo</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should be overridden if the shape is to support deletion of components. </p>
<p>A list of components to be deleted will be passed in as well as an array of doubles where information about each deleted component can be stored for undo purposes. A typical use for this array is to store knot values or weights for control points that are deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">componentList</td><td>List of components to be deleted </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">undoInfo</td><td>Values used for undo purposes</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this method was successful, false otherwise </dd></dl>
</div>
</div>
<a class="anchor" id="ab8472cd960255565b5d9228e7297ab7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool undeleteComponents </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp; </td>
<td class="paramname"><em>componentList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_double_array.html">MDoubleArray</a> &amp; </td>
<td class="paramname"><em>undoInfo</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should be overridden if the shape is to support undeletion of components. </p>
<p>A list of components to be deleted will be passed in as well as an array of doubles where information about each deleted component is stored for undo purposes. A typical use for this array is to store knot values or weights for control points that are deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">componentList</td><td>List of components that were deleted </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">undoInfo</td><td>Values used for undo purposes</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this method was successful, false otherwise </dd></dl>
</div>
</div>
<a class="anchor" id="a1c8d40246a4373be0d73fe10430105f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/localShapeInAttr"></a><a class="el" href="./class_m_object.html">MObject</a> localShapeInAttr </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the attribute containing the shape's input geometry in local space. </p>
<p>The attribute must be writable and of a geometry data type (e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7aa76b89a7cf1b1a256b49d1a64e4cffe3" title="  ">MFn::kGeometryData</a>, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a7b482e0304838d31478838e303d3172c" title="Custom container for arbitrary Geometry type derived from MPxGeometryData. ">MFn::kPluginGeometryData</a>, etc).</p>
<p>This method will be called by Maya to determine if the shape has construction history and must be overridden if the shape is to support deformers.</p>
<dl class="section return"><dt>Returns</dt><dd>The input attribute </dd></dl>
<p>Reimplemented in <a class="el" href="./class_m_px_component_shape.html#a1c8d40246a4373be0d73fe10430105f5">MPxComponentShape</a>.</p>
<dl class="section"><div class="dynheader closed" id="dynsection-example14" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example14-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example14-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a32">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a7a2e324a06d14f1818abbab7129b557a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/localShapeOutAttr"></a><a class="el" href="./class_m_object.html">MObject</a> localShapeOutAttr </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the attribute containing the shape's output geometry in local space. </p>
<p>The attribute must be readable and of a geometry data type (e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7aa76b89a7cf1b1a256b49d1a64e4cffe3" title="  ">MFn::kGeometryData</a>, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a7b482e0304838d31478838e303d3172c" title="Custom container for arbitrary Geometry type derived from MPxGeometryData. ">MFn::kPluginGeometryData</a>, etc).</p>
<p>This method must be overridden if the shape is to support deformers.</p>
<dl class="section return"><dt>Returns</dt><dd>The output attribute </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example15" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example15-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example15-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a33">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="abbae36badd1c32ac41370f6d4a47d374"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/worldShapeOutAttr"></a><a class="el" href="./class_m_object.html">MObject</a> worldShapeOutAttr </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the attribute containing the shape's output geometry in world space. </p>
<p>The attribute must be readable and of a geometry data type (e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7aa76b89a7cf1b1a256b49d1a64e4cffe3" title="  ">MFn::kGeometryData</a>, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a7b482e0304838d31478838e303d3172c" title="Custom container for arbitrary Geometry type derived from MPxGeometryData. ">MFn::kPluginGeometryData</a>, etc).</p>
<p>This method must be overridden if the shape is to support deformers.</p>
<dl class="section return"><dt>Returns</dt><dd>The world space output attribute </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example16" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example16-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example16-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a34">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a125144a03fb8edcc5a26c3e242c10b47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/cachedShapeAttr"></a><a class="el" href="./class_m_object.html">MObject</a> cachedShapeAttr </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the attribute containing the shape's cached geometry, if it has one. </p>
<p>The attribute must be readable, writable and of a geometry data type (e.g. <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7aa76b89a7cf1b1a256b49d1a64e4cffe3" title="  ">MFn::kGeometryData</a>, <a class="el" href="./class_m_fn.html#a1d1cfd8ffb84e947f82999c682b666a7a7b482e0304838d31478838e303d3172c" title="Custom container for arbitrary Geometry type derived from MPxGeometryData. ">MFn::kPluginGeometryData</a>, etc).</p>
<dl class="section return"><dt>Returns</dt><dd>The attribute that stores the cached shape </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example17" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example17-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example17-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a35">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a611239ed9089526e878940e0b3996a34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/geometryData"></a><a class="el" href="./class_m_object.html">MObject</a> geometryData </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the geometry data of the shape. </p>
<p>The geometry data must be derived from the <a class="el" href="./class_m_px_geometry_data.html" title="Base Class for User-defined Dependency Graph Geometry Data Types. ">MPxGeometryData</a> class.</p>
<p>The data is used by Maya to add, edit and query component grouping (set) information for the shape. This set information is stored and managed by Maya's shape base class, geometryShape.</p>
<dl class="section return"><dt>Returns</dt><dd>The geometry data of the shape </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example18" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example18-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example18-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a36">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa1706bd45fb947b0de139420ea4dc4cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool canMakeLive </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used by Maya to determine whether a surface can be made live. </p>
<p>It can be overridden to return true if you wish to allow your surface to be made live. If you return true, you will also need to implement both <a class="el" href="./class_m_px_surface_shape.html#aaffee4c66169388f1b0c91ef0ef61c3e" title="This method is used by Maya for snapping queries when your surface is live. ">closestPoint()</a> overloads. The default is to return false.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the surface can be made live, false otherwise </dd></dl>
</div>
</div>
<a class="anchor" id="aaffee4c66169388f1b0c91ef0ef61c3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool closestPoint </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point.html">MPoint</a> &amp; </td>
<td class="paramname"><em>raySource</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="./class_m_vector.html">MVector</a> &amp; </td>
<td class="paramname"><em>rayDirection</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point.html">MPoint</a> &amp; </td>
<td class="paramname"><em>theClosestPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_vector.html">MVector</a> &amp; </td>
<td class="paramname"><em>theClosestNormal</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>findClosestOnMiss</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>tolerance</em> = <code>MPoint_kTol</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used by Maya for snapping queries when your surface is live. </p>
<p>If you override this method, you should set theClosestPoint to the closest point on your surface intersected by the ray defined by raySource and rayDirection. You should also populate the theClosestNormal parameter with the surface normal at that intersection point.</p>
<p>If no intersection is found and findClosestOnMiss is true, you should still provide a point on your surface closest to the ray defined by raySource and rayDirection. When used for live snapping, this allows the user to click and drag outside the bounds of a live surface and still have it snap to the nearest point on it within the viewport. Note, performing a pure 3D closest point of approach test in this situation may not give the most natural result for live mesh snapping. To provide behavior that matches Maya, you can project your surface onto the plane defined by the ray, then perform your calculations. This will account for view perspective and give accurate live snap points along the silhouette of the surface.</p>
<p>If findClosestOnMiss is false, you should not provide a point and normal when the ray misses.</p>
<p><a class="el" href="./class_m_px_surface_shape.html#aa1706bd45fb947b0de139420ea4dc4cf" title="This method is used by Maya to determine whether a surface can be made live. ">canMakeLive()</a> must also be overridden to return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">raySource</td><td>the origin of the ray to test against </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>the direction of the ray to test against </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">theClosestPoint</td><td>the closest point on your surface </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">theClosestNormal</td><td>the normal at the closest point on your surface </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">findClosestOnMiss</td><td>when true, you should calculate theClosestPoint and theClosestNormal even if the ray misses your surface. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>tolerance to use in your calculations</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if theClosestPoint and theClosestNormal have been set, false otherwise </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example19" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example19-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example19-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a37">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="adcb63489b81036d767d32c346973437d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void closestPoint </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point.html">MPoint</a> &amp; </td>
<td class="paramname"><em>toThisPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point.html">MPoint</a> &amp; </td>
<td class="paramname"><em>theClosestPoint</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>tolerance</em> = <code>MPoint_kTol</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used by Maya in functions (such as select) that require closest point information from your surface. </p>
<p>If you've overridden <a class="el" href="./class_m_px_surface_shape.html#aa1706bd45fb947b0de139420ea4dc4cf" title="This method is used by Maya to determine whether a surface can be made live. ">canMakeLive()</a> to return true, this method is also used by Maya for some snapping queries when your surface is live.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">toThisPoint</td><td>the point to test against </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">theClosestPoint</td><td>the closest point on your surface </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>tolerance to use in your calculations </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="af3169b96a15cf4e39c89fbd3a868775a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool pointAtParm </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="./class_m_point.html">MPoint</a> &amp; </td>
<td class="paramname"><em>atThisParm</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_point.html">MPoint</a> &amp; </td>
<td class="paramname"><em>evaluatedPoint</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used by Maya in functions (such as select) that require point at parameter values. </p>
<p>This only makes sense for parametric surfaces such as NURBS.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">atThisParm</td><td>the parameter to check </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">evaluatedPoint</td><td>the surface point</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a point was found, false otherwise </dd></dl>
</div>
</div>
<a class="anchor" id="ade7e3321672b8bddc2659ede72274b18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/geometryIteratorSetup"></a><a class="el" href="./class_m_px_geometry_iterator.html">MPxGeometryIterator</a> * geometryIteratorSetup </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_object_array.html">MObjectArray</a> &amp; </td>
<td class="paramname"><em>componentList</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="./class_m_object.html">MObject</a> &amp; </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>forReadOnly</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This method should be overridden by the user to return a geometry iterator compatible with the user's geometry. </p>
<p>A geometry iterator is used for iterating over the components of a shape, such as the vertices of a mesh, in a generic manner.</p>
<p>The components to be iterated over are passed to this function in on of two ways, as a list of components, or as a single component. Only one of these arguments is used at any particular time.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">componentList</td><td>a list of components to be iterated over </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">components</td><td>the components to be iterated over </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">forReadOnly</td><td>specifies whether the iterator is for read-only</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component match result </dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example20" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example20-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example20-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a54">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a0896fe171fc5466e5bcd0ba02d5bad5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool acceptsGeometryIterator </td>
<td>(</td>
<td class="paramtype">bool </td>
<td class="paramname"><em>writeable</em> = <code>true</code></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>If the shape can supply a component iterator then then this method should be overridden to return true. </p>
<p>The default is to return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">writeable</td><td>is this component type writable by an iterator</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> the shape can supply an iterator </li>
<li><b>false</b> the shape cannot supply an iterator </li>
</ul>
</dd></dl>
<dl class="section"><div class="dynheader closed" id="dynsection-example21" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img alt="+" id="dynsection-example21-trigger" src="cpp_ref/closed.png"/> <b>Examples: </b></dt></div><div class="dyncontent" id="dynsection-example21-content" style="display:none;"><dd><a class="el" href="./api_mesh_shape_2api_mesh_shape_8h-example.html#a55">apiMeshShape/apiMeshShape.h</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a4e682eadd34b068eaca199c306d34313"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool acceptsGeometryIterator </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_object.html">MObject</a> &amp; </td>
<td class="paramname"><em>component</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>writeable</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>forReadOnly</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>If the shape can supply a component iterator then then this method should be overridden to return true. </p>
<p>The default is to return false. The component argument can be used to when the shape has multiple components and not all of them can be iterator over.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">component</td><td>the component to test </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">writeable</td><td>is this component type writable by an iterator </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">forReadOnly</td><td>is this component type readable by an iterator</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> the shape can supply an iterator </li>
<li><b>false</b> the shape cannot supply an iterator </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="a822f8d99673dbe2f76d8672a1c60e753"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool excludeAsPluginShape </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>A Maya viewport can be set to not display "Plugin Shapes", which means shapes derived from <a class="el" href="./class_m_px_surface_shape.html" title="Parent class of all user defined shapes. ">MPxSurfaceShape</a>. </p>
<p>By overriding <a class="el" href="./class_m_px_surface_shape.html#a822f8d99673dbe2f76d8672a1c60e753" title='A Maya viewport can be set to not display "Plugin Shapes", which means shapes derived from MPxSurface...'>excludeAsPluginShape()</a> to return false, you can change that behaviour so that this shape is still displayed even when the display of "Plugin Shapes" is disabled.</p>
<p>The default implementation returns true.</p>
<dl class="section return"><dt>Returns</dt><dd>true to have this shape obey the "Plugin Shapes" settings in the viewport's "Show" menu; false to have it ignore that setting </dd></dl>
</div>
</div>
<a class="anchor" id="a5d0a5e76d641c2bd825f8d5d8e0d386e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/activeComponents"></a><a class="el" href="./class_m_object_array.html">MObjectArray</a> activeComponents </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a list of active (selected) components for the shape. </p>
<p>This method does not trigger evaluation.</p>
<dl class="section return"><dt>Returns</dt><dd>An array of active components </dd></dl>
</div>
</div>
<a class="anchor" id="a168e1b383c958be627e8935a4ffdd7cb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool hasActiveComponents </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>This method is used to determine whether or not the shape has active (selected) components. </p>
<p>This method does not trigger evaluation.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> there are active components </li>
<li><b>false</b> there are no active components </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="aecad73a1fa1b7e2df4a225b1fb3c9532"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">OPENMAYA_ENUM </td>
<td>(</td>
<td class="paramtype">MChildChanged </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kObjectChanged </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">kBoundingBoxChanged </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Scope of change. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">kObjectChanged</td><td>Object geometry changed. Internal caches need to be updated. </td></tr>
<tr><td class="paramname">kBoundingBoxChanged</td><td>Object geometry is unchanged but its bounding box has changed. This might happen if the object was moved or an offset changed. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad8084191b55d8207736e6196ad0c11a6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void childChanged </td>
<td>(</td>
<td class="paramtype">MChildChanged </td>
<td class="paramname"><em>state</em> = <code>kObjectChanged</code></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This method can be used to trigger the shape to recalculate its bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>the type of change that has occurred </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a802cfaa86ed0cccb33b78672baea87df"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool isRenderable </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns true if the shape is a renderable shape. </p>
<p>Making a shape renderable allows the shape to have shading group assignments.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> the shape is renderable </li>
<li><b>false</b> the shape is not renderable </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ad4684716734528680f3c1087ecce3238"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void setRenderable </td>
<td>(</td>
<td class="paramtype">bool </td>
<td class="paramname"><em>flag</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Specifies whether the shape is a renderable shape. </p>
<p>Making a shape renderable allows the shape to have shading group assignments.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>true if the shape is to be renderable, false otherwise </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6d3c9b9ea9318edfc79729761232f10b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="dashAnchor" name="//apple_ref/cpp/Function/getWorldMatrix"></a><a class="el" href="./class_m_matrix.html">MMatrix</a> getWorldMatrix </td>
<td>(</td>
<td class="paramtype"><a class="el" href="./class_m_data_block.html">MDataBlock</a> &amp; </td>
<td class="paramname"><em>block</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>instanceGeom</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="./class_m_matrix.html" title="A matrix math class for 4x4 matrices of doubles. ">MMatrix</a> which takes a point from local object space to world space. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>a <a class="el" href="./class_m_data_block.html" title="Dependency node data block. ">MDataBlock</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">instanceGeom</td><td>the instance this <a class="el" href="./class_m_px_surface_shape.html" title="Parent class of all user defined shapes. ">MPxSurfaceShape</a> corresponds to </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a774cd5d8fbebe8e7ed82a5aa587d1f04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const char * className </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class. </dd></dl>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>MPxSurfaceShape.h</li>
<li>MPxSurfaceShape.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>

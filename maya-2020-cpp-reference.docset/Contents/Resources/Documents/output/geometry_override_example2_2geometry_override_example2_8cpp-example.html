<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
<title>C++ API Reference: geometryOverrideExample2/geometryOverrideExample2.cpp</title>
</head>
<body height="100%"><div class="body_content" id="body-content"><link href="cpp_ref/navtree.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/doxygen.css" rel="stylesheet" type="text/css"/><link href="cpp_ref/tabs.css" rel="stylesheet" type="text/css"/><link href="style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('geometry_override_example2_2geometry_override_example2_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
<div>
<div class="head">
<h1>C++ API Reference: geometryOverrideExample2/geometryOverrideExample2.cpp</h1>
</div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>Main Page</span></a></li>
<li><a href="./pages.html"><span>Related Pages</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
<li>
<div class="MSearchBoxInactive" id="MSearchBox">
<span class="left">
<img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="cpp_ref/search/mag_sel.png"/>
<input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
</span><span class="right">
<a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="cpp_ref/search/close.png"/></a>
</span>
</div>
</li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<!-- window showing the filter options -->
<!-- iframe showing the search results (closed by default) -->
<div class="header">
<div class="headertitle">
<div class="title">geometryOverrideExample2/geometryOverrideExample2.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">//-</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">// Copyright 2018 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk</span></div>
<div class="line"><span class="comment">// license agreement provided at the time of installation or download,</span></div>
<div class="line"><span class="comment">// or which otherwise accompanies this software in either electronic</span></div>
<div class="line"><span class="comment">// or hard copy form.</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">//+</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This plug-in shows how to use MPxGeometryOverride to render geometry with Maya shader network.</span></div>
<div class="line"><span class="comment">// It will register a new type of node "geometryOverrideExample2_shape" that will generate </span></div>
<div class="line"><span class="comment">// the geometry and connect it to a MPxGeometryOverride.</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// The GeometryOverrideExample2_shape class derives from MPxSurfaceShape and it is responsible </span></div>
<div class="line"><span class="comment">// to generate the geometry data (Cube) and also enable the shape to be selectable in</span></div>
<div class="line"><span class="comment">// Viewport 2.0.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The GeometryOverrideExample2 class derives from MPxGeometryOverride and shows how to</span></div>
<div class="line"><span class="comment">// create / update different render items and fill vertex / index buffers to render the geometry </span></div>
<div class="line"><span class="comment">// of geometryOverrideExample2_shape.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// To use this plugin run the following mel or python commands once the plugin is loaded</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//      Mel script:</span></div>
<div class="line"><span class="comment">//          </span></div>
<div class="line"><span class="comment">//          $shapeNodeName = `createNode geometryOverrideExample2_shape`;</span></div>
<div class="line"><span class="comment">//          sets -add initialShadingGroup $shapeNodeName;</span></div>
<div class="line"><span class="comment">//  </span></div>
<div class="line"><span class="comment">//      Python script:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//          shapeNodeName = maya.cmds.createNode('geometryOverrideExample2_shape')</span></div>
<div class="line"><span class="comment">//          maya.cmds.sets(shapeNodeName, add = 'initialShadingGroup')</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Once the mel/python commands are executed, a lambert shader will be attached to the shading group</span></div>
<div class="line"><span class="comment">// of the shape. Of course, you can change the lambert shader to a different one.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment"></span><span class="preprocessor">#include &lt;maya/MFnPlugin.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDrawRegistry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include "geometryOverrideExample2.h"</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MShaderManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MSelectionMask.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDependencyNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFloatVector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> instancingChangedCallback(<a name="_a0"></a><a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; child, <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; parent, <span class="keywordtype">void</span>* clientData)</div>
<div class="line">{</div>
<div class="line"> <a name="a1"></a><a class="code" href="./class_m_global.html#acb043e7fc4eb7fc0f39833d31364b8a4">MGlobal::displayWarning</a>(<span class="stringliteral">"GeometryOverrideExample2 does't support instancing !"</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              geometryOverrideExample2_shape implementation</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"></div>
<div class="line"><a name="_a2"></a><a class="code" href="./class_m_type_id.html">MTypeId</a> GeometryOverrideExample2_shape::id = <a class="code" href="./class_m_type_id.html">MTypeId</a>(0x8003D);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">GeometryOverrideExample2_shape::GeometryOverrideExample2_shape()</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> cubeWidth = 1.0f;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> cubeHeight= 1.0f;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span> cubeDepth = 1.0f;</div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Define the cube's vertices data</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line">    fPositions.emplace_back(-cubeWidth, -cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth,  cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth,  cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth, -cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth, -cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth, -cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth,  cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth,  cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth,  cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth,  cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth,  cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth,  cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth, -cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth, -cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth, -cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth, -cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth, -cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth,  cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth,  cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back(-cubeWidth, -cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth, -cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth,  cubeHeight, -cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth,  cubeHeight,  cubeDepth);</div>
<div class="line">    fPositions.emplace_back( cubeWidth, -cubeHeight,  cubeDepth);</div>
<div class="line"></div>
<div class="line">    fNormals.emplace_back( 0.0f,  0.0f, -1.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  0.0f, -1.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  0.0f, -1.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  0.0f, -1.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  0.0f,  1.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  0.0f,  1.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  0.0f,  1.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  0.0f,  1.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  1.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  1.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  1.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f,  1.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f, -1.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f, -1.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f, -1.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 0.0f, -1.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back(-1.0f,  0.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back(-1.0f,  0.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back(-1.0f,  0.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back(-1.0f,  0.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 1.0f,  0.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 1.0f,  0.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 1.0f,  0.0f,  0.0f);</div>
<div class="line">    fNormals.emplace_back( 1.0f,  0.0f,  0.0f);</div>
<div class="line"></div>
<div class="line">    fTangents.emplace_back( 1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back( 1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back( 1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back( 1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back(-1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back(-1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back(-1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back(-1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back( 1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back( 1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back( 1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back( 1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back(-1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back(-1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back(-1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back(-1.0f, 0.0f,  0.0f);</div>
<div class="line">    fTangents.emplace_back( 0.0f, 0.0f, -1.0f);</div>
<div class="line">    fTangents.emplace_back( 0.0f, 0.0f, -1.0f);</div>
<div class="line">    fTangents.emplace_back( 0.0f, 0.0f, -1.0f);</div>
<div class="line">    fTangents.emplace_back( 0.0f, 0.0f, -1.0f);</div>
<div class="line">    fTangents.emplace_back( 0.0f, 0.0f,  1.0f);</div>
<div class="line">    fTangents.emplace_back( 0.0f, 0.0f,  1.0f);</div>
<div class="line">    fTangents.emplace_back( 0.0f, 0.0f,  1.0f);</div>
<div class="line">    fTangents.emplace_back( 0.0f, 0.0f,  1.0f);</div>
<div class="line"></div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 1.0f);</div>
<div class="line">    fTextureCoords.emplace_back(0.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 0.0f);</div>
<div class="line">    fTextureCoords.emplace_back(1.0f, 1.0f);</div>
<div class="line"></div>
<div class="line">    fBiTangents.resize(24);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 24; i++) </div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// cross product</span></div>
<div class="line"> <a name="_a3"></a><a class="code" href="./class_m_float_vector.html">MFloatVector</a> biTangents = <a class="code" href="./class_m_float_vector.html">MFloatVector</a>(fNormals[i].x,  fNormals[i].y,  fNormals[i]. z) ^ </div>
<div class="line"> <a class="code" href="./class_m_float_vector.html">MFloatVector</a>(fTangents[i].x, fTangents[i].y, fTangents[i].z);</div>
<div class="line">        fBiTangents[i].x = biTangents.<a name="a4"></a><a class="code" href="./class_m_float_vector.html#ad0da36b2558901e21e7a30f6c227a45e">x</a>;</div>
<div class="line">        fBiTangents[i].y = biTangents.<a name="a5"></a><a class="code" href="./class_m_float_vector.html#aa4f0d3eebc3c443f9be81bf48561a217">y</a>;</div>
<div class="line">        fBiTangents[i].z = biTangents.<a name="a6"></a><a class="code" href="./class_m_float_vector.html#af73583b1e980b0aa03f9884812e9fd4d">z</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fShadedIndices =</div>
<div class="line">    {</div>
<div class="line">        12, 13, 14, 12, 14, 15, <span class="comment">// bottom</span></div>
<div class="line">         8,  9, 10,  8, 10, 11, <span class="comment">// top</span></div>
<div class="line">        16, 17, 18, 16, 18, 19, <span class="comment">// left</span></div>
<div class="line">        20, 21, 22, 20, 22, 23, <span class="comment">// right</span></div>
<div class="line">         4,  5,  6,  4,  6,  7, <span class="comment">// back</span></div>
<div class="line">         0,  1,  2,  0,  2,  3, <span class="comment">// front</span></div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    fWireFrameIndices =</div>
<div class="line">    {</div>
<div class="line">        0, 1, 1, 2, 2, 3, 3, 0, <span class="comment">// bottom</span></div>
<div class="line">        4, 5, 5, 6, 6, 7, 7, 4, <span class="comment">// top</span></div>
<div class="line">        0, 4, 3, 5, 1, 7, 2, 6, <span class="comment">// left / right</span></div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">GeometryOverrideExample2_shape::~GeometryOverrideExample2_shape()</div>
<div class="line">{</div>
<div class="line"> <a name="a7"></a><a class="code" href="./class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">MMessage::removeCallback</a>(mInstanceAddedCallbackId);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  When instances of this node are created internally, the MObject associated</span></div>
<div class="line"><span class="comment">//  with the instance is not created until after the constructor of this class</span></div>
<div class="line"><span class="comment">//  is called. This means that no member functions of MPxSurfaceShape can</span></div>
<div class="line"><span class="comment">//  be called in the constructor.</span></div>
<div class="line"><span class="comment">//  The postConstructor solves this problem. Maya will call this function</span></div>
<div class="line"><span class="comment">//  after the internal object has been created.</span></div>
<div class="line"><span class="comment">//  As a general rule do all of your initialization in the postConstructor.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxSurfaceShape::postConstructor()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideExample2_shape::postConstructor()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// This call allows the shape to have shading groups assigned</span></div>
<div class="line">    setRenderable(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Add a callback that will be called when instance are added.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_dag_path.html">MDagPath</a> path;</div>
<div class="line"> <a name="a8"></a><a class="code" href="./class_m_dag_path.html#a422aa5ec02565f757c13fe2873ed25d7">MDagPath::getAPathTo</a>(thisMObject(), path);</div>
<div class="line">    mInstanceAddedCallbackId = <a name="a9"></a><a class="code" href="./class_m_dag_message.html#a9c301d5a30d9424eea522166b283a98d">MDagMessage::addInstanceAddedDagPathCallback</a>(const_cast&lt;MDagPath&amp;&gt;(path), &amp;instancingChangedCallback);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method is overriden to support interactive object selection in Viewport 2.0</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Returns The selection mask of the shaper.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxSurfaceShape::getShapeSelectionMask()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><a name="_a10"></a><a class="code" href="./class_m_selection_mask.html">MSelectionMask</a>  GeometryOverrideExample2_shape::getShapeSelectionMask()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    MSelectionMask::SelectionType selType = MSelectionMask::kSelectMeshes;</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_selection_mask.html">MSelectionMask</a>(selType);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Returns the bounding box for this object.</span></div>
<div class="line"><span class="comment">//  It is a good idea not to recompute here as this funcion is called often.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : This function is only called if MPxSurfaceShape::isBounded() return true.</span></div>
<div class="line"><span class="comment">//         For more information, see MPxSurfaceShape::boundingBox()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><a name="_a11"></a><a class="code" href="./class_m_bounding_box.html">MBoundingBox</a> GeometryOverrideExample2_shape::boundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <a name="_a12"></a><a class="code" href="./class_m_point.html">MPoint</a> corner1Point(fPositions[0].x, fPositions[0].y, fPositions[0].z); <span class="comment">// back-left-bottom vertex position</span></div>
<div class="line"> <a class="code" href="./class_m_point.html">MPoint</a> corner2Point(fPositions[6].x, fPositions[6].y, fPositions[6].z); <span class="comment">// front-right-top  vertex position</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./class_m_bounding_box.html">MBoundingBox</a>(corner1Point, corner2Point);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              GeometryOverrideExample2 implementation</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* GeometryOverrideExample2::sActiveWireframeRenderItemName = <span class="stringliteral">"GeometryOverrideExample2_ActiveWireframe"</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* GeometryOverrideExample2::sDormantWireframeRenderItemName = <span class="stringliteral">"GeometryOverrideExample2_DormantWireframe"</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* GeometryOverrideExample2::sShadedRenderItemName = <span class="stringliteral">"GeometryOverrideExample2_shaded"</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">GeometryOverrideExample2::GeometryOverrideExample2(<span class="keyword">const</span> <a name="_a13"></a><a class="code" href="./class_m_object.html">MObject</a>&amp; obj)</div>
<div class="line">    : <a class="code" href="./namespace_m_h_w_render.html">MHWRender</a>::MPxGeometryOverride(obj)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// get the real mesh object from the MObject</span></div>
<div class="line"> <a name="_a14"></a><a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"> <a name="_a15"></a><a class="code" href="./class_m_fn_dependency_node.html">MFnDependencyNode</a> node(obj, &amp;status);</div>
<div class="line"> <span class="keywordflow">if</span> (status)</div>
<div class="line">    {</div>
<div class="line">        fMesh = <span class="keyword">dynamic_cast&lt;</span>GeometryOverrideExample2_shape*<span class="keyword">&gt;</span>(node.userNode());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">GeometryOverrideExample2::~GeometryOverrideExample2()</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This function return draw API that is supported by this plugin.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::supportedDrawAPIs()</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line">MHWRender::DrawAPI GeometryOverrideExample2::supportedDrawAPIs()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">return</span>  (MHWRender::kOpenGL | MHWRender::kDirectX11 | MHWRender::kOpenGLCoreProfile);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Perform any work required to translate the geometry data that needs to get</span></div>
<div class="line"><span class="comment">//  information from the dependency graph.This should be the only place that</span></div>
<div class="line"><span class="comment">//  dependency graph evaluation occurs.Any data retrieved should be cached for</span></div>
<div class="line"><span class="comment">//  later stages.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::updateDG()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideExample2::updateDG()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// In this example, there is nothing to do here</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method is called once during each draw-preparation phase.  If this method returns true </span></div>
<div class="line"><span class="comment">//  then the associated DAG object will have a chance to update its render geometry this frame.</span></div>
<div class="line"><span class="comment">//  (Maya will call populateGeometry())</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::requiresGeometryUpdate()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideExample2::requiresGeometryUpdate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="comment">// In this example, we always return false because the node doesn't have </span></div>
<div class="line"> <span class="comment">// attributes that affect the geometry.</span></div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  If this method returns true then the MPxGeometryOverride will be considered</span></div>
<div class="line"><span class="comment">//  for Evaluation Manager Parallel Update.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::supportsEvaluationManagerParallelUpdate()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">bool</span> GeometryOverrideExample2::supportsEvaluationManagerParallelUpdate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  This method is called for each instance of the associated DAG object whenever </span></div>
<div class="line"><span class="comment">//  the object changes and receive the path to the instance and the current list </span></div>
<div class="line"><span class="comment">//  of render items associated with that instance. Implementations of this method </span></div>
<div class="line"><span class="comment">//  may add, remove or modify items in the list. As an alternative this method </span></div>
<div class="line"><span class="comment">//  can enable or disable items that must be used or not based on some properties.</span></div>
<div class="line"><span class="comment">//  </span></div>
<div class="line"><span class="comment">//  A render item represents a single renderable entity and contain many properties </span></div>
<div class="line"><span class="comment">//  to let the Viewport 2.0 to know how to render the entity. By example, A render </span></div>
<div class="line"><span class="comment">//  item contain a name, a type, the geometry primitive type, a set of geometry </span></div>
<div class="line"><span class="comment">//  buffers and a shader instance. </span></div>
<div class="line"><span class="comment">//  </span></div>
<div class="line"><span class="comment">//  In this example, this functions will create 2 render items to render the object's </span></div>
<div class="line"><span class="comment">//  geometry in wireframe mode. The first render item will be use to display the object </span></div>
<div class="line"><span class="comment">//  in wireframe with a single color only when the Viewport 2.0 is in wireframe mode. </span></div>
<div class="line"><span class="comment">//  The second render item will be use to render the object with a single color in </span></div>
<div class="line"><span class="comment">//  wireframe only when the object is selected independing of the Viewport 2.0 display </span></div>
<div class="line"><span class="comment">//  mode. Both wireframe render item will be enable or disable depending of the object </span></div>
<div class="line"><span class="comment">//  selection state. </span></div>
<div class="line"><span class="comment">//  </span></div>
<div class="line"><span class="comment">//  This example will not create a render item to display the geometry in shaded or </span></div>
<div class="line"><span class="comment">//  textured mode because Maya will do it when a material / shader will be assigned </span></div>
<div class="line"><span class="comment">//  to the object. This render item will be added in the list and can be edited </span></div>
<div class="line"><span class="comment">//  if desired. If no material is assigned, the object will not be visible in </span></div>
<div class="line"><span class="comment">//  Viewport 2.0 except if the node is selected in the outliner. In this situation,</span></div>
<div class="line"><span class="comment">//  only the edges of the object will be displayed because we are creating</span></div>
<div class="line"><span class="comment">//  a wireframe render item that will be used when the object is selected.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::updateRenderItems()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideExample2::updateRenderItems(<span class="keyword">const</span> <a class="code" href="./class_m_dag_path.html">MDagPath</a>&amp; path, <a name="_a16"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MHWRender::MRenderItemList</a>&amp; renderItems)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!path.<a name="a17"></a><a class="code" href="./class_m_dag_path.html#a095ae34296e81703965265a42ee783ca">isValid</a>())</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    MRenderer* renderer = MRenderer::theRenderer();</div>
<div class="line"> <span class="keywordflow">if</span> (!renderer)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> MShaderManager* shaderManager = renderer-&gt;getShaderManager();</div>
<div class="line"> <span class="keywordflow">if</span> (!shaderManager)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get the inherited DAG display properties.</span></div>
<div class="line"> <span class="keyword">auto</span> wireframeColor = <a name="a18"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#a6221bc7407b14246b14f79a751496276">MHWRender::MGeometryUtilities::wireframeColor</a>(path);</div>
<div class="line"> <span class="keyword">auto</span> displayStatus         = <a name="a19"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_utilities.html#aa2838b92c9f7db4a810690a986199134">MHWRender::MGeometryUtilities::displayStatus</a>(path);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the wireframe render item used when the object will be selected</span></div>
<div class="line"> <span class="keywordtype">bool</span> isWireFrameRenderItemEnabled = displayStatus == MHWRender::kLead || displayStatus == MHWRender::kActive;</div>
<div class="line">    updateWireframeItems(sActiveWireframeRenderItemName,</div>
<div class="line">        MHWRender::MGeometry::kAll,</div>
<div class="line"> <a name="a20"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#abf0686a71845159b7a473312fe05044a">MHWRender::MRenderItem::sSelectionDepthPriority</a>,</div>
<div class="line">        wireframeColor,</div>
<div class="line">        isWireFrameRenderItemEnabled,</div>
<div class="line">        renderItems,</div>
<div class="line">        *shaderManager);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Update the wireframe render item used when the object will not be selected</span></div>
<div class="line">    isWireFrameRenderItemEnabled = displayStatus == MHWRender::kDormant;</div>
<div class="line">    updateWireframeItems(sDormantWireframeRenderItemName,</div>
<div class="line">        MHWRender::MGeometry::kWireframe,</div>
<div class="line"> <a name="a21"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a6915079c9389d5b9354d5b40fb8112ca">MHWRender::MRenderItem::sDormantWireDepthPriority</a>,</div>
<div class="line">        wireframeColor,</div>
<div class="line">        isWireFrameRenderItemEnabled,</div>
<div class="line">        renderItems,</div>
<div class="line">        *shaderManager);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Fill in data and index streams based on the requirements passed in.</span></div>
<div class="line"><span class="comment">//  Associate indexing with the render items passed in.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::populateGeometry()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideExample2::populateGeometry(<span class="keyword">const</span> <a name="_a22"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html">MHWRender::MGeometryRequirements</a>&amp; requirements, <span class="keyword">const</span> <a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MHWRender::MRenderItemList</a>&amp; renderItems, <a name="_a23"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html">MHWRender::MGeometry</a>&amp; data)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!fMesh)</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keyword">const</span> MVertexBufferDescriptorList&amp;  vertexBufferDescriptorList = requirements.<a name="a24"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry_requirements.html#a960f411f65fde2d97da465a6b276d774">vertexRequirements</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vertexBufferDescriptorList.length(); i++)</div>
<div class="line">    {</div>
<div class="line">        MVertexBufferDescriptor desc{};</div>
<div class="line"> <span class="keywordflow">if</span> (!vertexBufferDescriptorList.getDescriptor(i, desc))</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; desc.semanticName().asChar() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">switch</span> (desc.semantic())</div>
<div class="line">        {</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kPosition:</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the vertex position buffer</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a name="_a25"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* positionBuffer = data.<a name="a26"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (positionBuffer)</div>
<div class="line">            {</div>
<div class="line">                GeometryOverrideExample2_shape::Float3Array positions = fMesh-&gt;getPositions();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* buffer = positionBuffer-&gt;<a name="a27"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(positions.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly */</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(GeometryOverrideExample2_shape::Float3Array::value_type) * positions.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, positions.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    positionBuffer-&gt;<a name="a28"></a><a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kNormal:</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the vertex normal buffer</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* normalsBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (normalsBuffer)</div>
<div class="line">            {</div>
<div class="line">                GeometryOverrideExample2_shape::Float3Array normals = fMesh-&gt;getNormals();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* buffer = normalsBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(normals.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(GeometryOverrideExample2_shape::Float3Array::value_type) * normals.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, normals.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    normalsBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kTangent:</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* tangentBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (tangentBuffer)</div>
<div class="line">            {</div>
<div class="line">                GeometryOverrideExample2_shape::Float3Array tangents = fMesh-&gt;getTangents();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* buffer = tangentBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(tangents.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(GeometryOverrideExample2_shape::Float3Array::value_type) * tangents.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, tangents.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    tangentBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kBitangent:</div>
<div class="line">        {</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* tangentBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (tangentBuffer)</div>
<div class="line">            {</div>
<div class="line">                GeometryOverrideExample2_shape::Float3Array tangents = fMesh-&gt;getBiTangents();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* buffer = tangentBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(tangents.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(GeometryOverrideExample2_shape::Float3Array::value_type) * tangents.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, tangents.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    tangentBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kTexture:</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the vertex texture coords buffer</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html">MHWRender::MVertexBuffer</a>* texCoordsBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(desc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (texCoordsBuffer)</div>
<div class="line">            {</div>
<div class="line">                GeometryOverrideExample2_shape::Float2Array texCoords = fMesh-&gt;getTexCoords();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* buffer = texCoordsBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(texCoords.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(GeometryOverrideExample2_shape::Float2Array::value_type) * texCoords.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, texCoords.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    texCoordsBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kColor:</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kTangentWithSign:</div>
<div class="line"> <span class="keywordflow">case</span> MGeometry::kInvalidSemantic:   <span class="comment">// avoid compiling error</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// In this example, we don't need to used those vertex informantions.</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">//   Update indexing data for all appropriate render items</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">const</span> <span class="keywordtype">int</span> numItems = renderItems.<a name="a29"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numItems; i++)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">const</span> <a name="_a30"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* item = renderItems.<a name="a31"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(i);</div>
<div class="line"> <span class="keywordflow">if</span> (!item)</div>
<div class="line"> <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (item-&gt;<a name="a32"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a0005764259795847274dba4c66e3661b">primitive</a>() == MHWRender::MGeometry::kTriangles)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the index buffer used to render triangles</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a name="_a33"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MHWRender::MIndexBuffer</a>* indexBuffer = data.<a name="a34"></a><a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a649d0f008cdfbd368a4157dcd47ede67">createIndexBuffer</a>(MHWRender::MGeometry::kUnsignedInt32);</div>
<div class="line"> <span class="keywordflow">if</span> (indexBuffer)</div>
<div class="line">            {</div>
<div class="line">                GeometryOverrideExample2_shape::IndexList indices = fMesh-&gt;getShadedIndices();</div>
<div class="line"> <span class="keywordtype">void</span>* buffer = indexBuffer-&gt;<a name="a35"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(indices.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(GeometryOverrideExample2_shape::IndexList::value_type) * indices.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, indices.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    indexBuffer-&gt;<a name="a36"></a><a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Associate index buffer with render item</span></div>
<div class="line">                    item-&gt;<a name="a37"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a7d0f067f76206a54f4f716f63bcb6b19">associateWithIndexBuffer</a>(indexBuffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (item-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a0005764259795847274dba4c66e3661b">primitive</a>() == MHWRender::MGeometry::kLines)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <span class="comment">// Create and fill the index buffer used to render lines (Wireframe)</span></div>
<div class="line"> <span class="comment">//</span></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html">MHWRender::MIndexBuffer</a>* indexBuffer = data.<a class="code" href="./class_m_h_w_render_1_1_m_geometry.html#a649d0f008cdfbd368a4157dcd47ede67">createIndexBuffer</a>(MHWRender::MGeometry::kUnsignedInt32);</div>
<div class="line"> <span class="keywordflow">if</span> (indexBuffer)</div>
<div class="line">            {</div>
<div class="line">                GeometryOverrideExample2_shape::IndexList indices = fMesh-&gt;getWireFrameIndices();</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span>* buffer = indexBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(indices.size(), <span class="keyword">true</span> <span class="comment">/*writeOnly*/</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (buffer)</div>
<div class="line">                {</div>
<div class="line"> <span class="keyword">const</span> std::size_t bufferSizeInByte =</div>
<div class="line"> <span class="keyword">sizeof</span>(GeometryOverrideExample2_shape::IndexList::value_type) * indices.size();</div>
<div class="line"></div>
<div class="line">                    memcpy(buffer, indices.data(), bufferSizeInByte);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Transfer from CPU to GPU memory.</span></div>
<div class="line">                    indexBuffer-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(buffer);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Associate index buffer with render item</span></div>
<div class="line">                    item-&gt;<a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a7d0f067f76206a54f4f716f63bcb6b19">associateWithIndexBuffer</a>(indexBuffer);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Clean up any cached data stored from the updateDG() phase.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : For more information, see MPxGeometryOverride::cleanUp()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideExample2::cleanUp()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Nothing here because the plugin doesn't keep any temporary data.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Update the wireframe render item named 'renderItemName' or create it</span></div>
<div class="line"><span class="comment">//  if it doesn't exists.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Note : Arguments drawMode and depthPriority are only used for creation of </span></div>
<div class="line"><span class="comment">//         the render item.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line"><span class="keywordtype">void</span> GeometryOverrideExample2::updateWireframeItems(<span class="keyword">const</span> <span class="keywordtype">char</span>* renderItemName, MGeometry::DrawMode drawMode,</div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> depthPriority, <a name="_a38"></a><a class="code" href="./class_m_color.html">MColor</a> color, <span class="keywordtype">bool</span> isEnable,</div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html">MHWRender::MRenderItemList</a>&amp; renderItemList,</div>
<div class="line"> <span class="keyword">const</span> <a name="_a39"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html">MHWRender::MShaderManager</a>&amp; shaderManager)</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./class_m_h_w_render_1_1_m_render_item.html">MHWRender::MRenderItem</a>* renderItem = <span class="keyword">nullptr</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Try to find the active wireframe render item.</span></div>
<div class="line"> <span class="comment">// If the returning index is smaller than 0, that means </span></div>
<div class="line"> <span class="comment">// the render item does't exists yet. So, create it.</span></div>
<div class="line"> <span class="keyword">auto</span> renderItemIndex = renderItemList.<a name="a40"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a4cfe9fc51a24bca06d2619a55542f689">indexOf</a>(renderItemName);</div>
<div class="line"> <span class="keywordflow">if</span> (renderItemIndex &lt; 0)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// Create the new render item with the given name.</span></div>
<div class="line"> <span class="comment">// We designate this item as a UI “decoration” and will not be</span></div>
<div class="line"> <span class="comment">// involved in rendering aspects such as casting shadows</span></div>
<div class="line"> <span class="comment">// The “topology” for the render item is a line list.</span></div>
<div class="line">        renderItem = <a name="a41"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#ac74a014f3346d8ddac693b7f034fa228">MHWRender::MRenderItem::Create</a>(renderItemName,</div>
<div class="line">            MHWRender::MRenderItem::DecorationItem,</div>
<div class="line">            MHWRender::MGeometry::kLines);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// We want this render item to show up when in all mode ( Wireframe, Shaded, Textured and BoundingBox)</span></div>
<div class="line">        renderItem-&gt;<a name="a42"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a8e28487092f00765128c2ffdd43d0fe4">setDrawMode</a>(drawMode);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Set selection priority: on top of everything</span></div>
<div class="line">        renderItem-&gt;<a name="a43"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a6e865e2cf5c9d818b1cbb99af2360c47">depthPriority</a>(depthPriority);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Get an instance of a 3dSolidShader from the shader manager.</span></div>
<div class="line"> <span class="comment">// The shader tells the graphics hardware how to draw the geometry. </span></div>
<div class="line"> <span class="comment">// The MShaderInstance is a reference to a shader along with the values for the shader parameters.</span></div>
<div class="line">        MShaderInstance* shader = shaderManager.<a name="a44"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a8e4ad27d691969622af2b05d8c6213d9">getStockShader</a>(MShaderManager::k3dSolidShader);</div>
<div class="line"> <span class="keywordflow">if</span> (shader)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Assign the shader to the render item. This adds a reference to that</span></div>
<div class="line"> <span class="comment">// shader.</span></div>
<div class="line">            renderItem-&gt;<a name="a45"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#ad283b157fa4f6c40bceb9d398c53a72a">setShader</a>(shader);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Once assigned, no need to hold on to shader instance</span></div>
<div class="line">            shaderManager.<a name="a46"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_manager.html#a0c7deb55edc231cbb2365b271ecd55f8">releaseShader</a>(shader);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// The item must be added to the persistent list to be considered</span></div>
<div class="line"> <span class="comment">// for update / rendering</span></div>
<div class="line">        renderItemList.<a name="a47"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a238f55e85f694b4f74535aaedc6ebe01">append</a>(renderItem);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        renderItem = renderItemList.<a class="code" href="./class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(renderItemIndex);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (renderItem)</div>
<div class="line">    {</div>
<div class="line"> <a name="_a48"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html">MHWRender::MShaderInstance</a>* shader = renderItem-&gt;<a name="a49"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#aa606047c9ccc32d66b93d07327b65be9">getShader</a>();</div>
<div class="line"> <span class="keywordflow">if</span> (shader)</div>
<div class="line">        {</div>
<div class="line"> <span class="comment">// Set the shader color parameter</span></div>
<div class="line">            shader-&gt;<a name="a50"></a><a class="code" href="./class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef">setParameter</a>(<span class="stringliteral">"solidColor"</span>, &amp;color.<a name="a51"></a><a class="code" href="./class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        renderItem-&gt;<a name="a52"></a><a class="code" href="./class_m_h_w_render_1_1_m_render_item.html#a1e9d2a5708b2231a8e72d22dc3be53fe">enable</a>(isEnable);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//              initialize / uninitialize plugin</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//===========================================================================</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line"> <a name="_a53"></a><a class="code" href="./class_m_string.html">MString</a> sDrawDbClassification(<span class="stringliteral">"drawdb/geometry/geometryOverrideExample2"</span>);</div>
<div class="line"> <a class="code" href="./class_m_string.html">MString</a> sDrawRegistrantId(<span class="stringliteral">"geometryOverrideExample2Plugin"</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> initializePlugin(<a class="code" href="./class_m_object.html">MObject</a> obj)</div>
<div class="line">{</div>
<div class="line"> <a name="_a54"></a><a class="code" href="./class_m_fn_plugin.html">MFnPlugin</a> plugin(obj, PLUGIN_COMPANY, <span class="stringliteral">"3.0"</span>, <span class="stringliteral">"Any"</span>);</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"></div>
<div class="line">    status = plugin.registerShape(<span class="stringliteral">"geometryOverrideExample2_shape"</span>,             <span class="comment">// the name of the new type of user defined shape node</span></div>
<div class="line">        GeometryOverrideExample2_shape::id,             <span class="comment">// a unique id that identifies this node</span></div>
<div class="line">        &amp;GeometryOverrideExample2_shape::creator,       <span class="comment">// function that will return a pointer to a new instance of the class </span></div>
<div class="line"> <span class="comment">// (derived from MPxSurfaceNode) that implements the new shape node type</span></div>
<div class="line">        &amp;GeometryOverrideExample2_shape::initialize,    <span class="comment">// function that will initialize all the attributes of the new shape node type</span></div>
<div class="line"> <span class="keyword">nullptr</span>,</div>
<div class="line">        &amp;sDrawDbClassification);</div>
<div class="line"> <span class="keywordflow">if</span> (!status)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Failed to register geometryOverrideExample2_shape."</span> &lt;&lt; std::endl;</div>
<div class="line"> <span class="keywordflow">return</span> status;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    status = <a name="a55"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_registry.html#a36f6ac92077e5064d897187608c9e548">MHWRender::MDrawRegistry::registerGeometryOverrideCreator</a>(sDrawDbClassification,</div>
<div class="line">        sDrawRegistrantId,</div>
<div class="line">        GeometryOverrideExample2::Creator);</div>
<div class="line"> <span class="keywordflow">if</span> (!status)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Failed to register Viewport 2.0 geometry override."</span> &lt;&lt; std::endl;</div>
<div class="line"> <span class="keywordflow">return</span> status;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> status;</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="./class_m_status.html">MStatus</a> uninitializePlugin(<a class="code" href="./class_m_object.html">MObject</a> obj)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="./class_m_fn_plugin.html">MFnPlugin</a> plugin(obj);</div>
<div class="line"> <a class="code" href="./class_m_status.html">MStatus</a> status;</div>
<div class="line"></div>
<div class="line">    status = <a name="a56"></a><a class="code" href="./class_m_h_w_render_1_1_m_draw_registry.html#a24f600902d1e1a22ccd8985f9eee39a1">MHWRender::MDrawRegistry::deregisterGeometryOverrideCreator</a>(sDrawDbClassification, sDrawRegistrantId);</div>
<div class="line"> <span class="keywordflow">if</span> (!status)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Failed to deregister geometry override."</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    status = plugin.deregisterNode(GeometryOverrideExample2_shape::id);</div>
<div class="line"> <span class="keywordflow">if</span> (!status)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Failed to deregister GeometryOverrideExample2_shape."</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>

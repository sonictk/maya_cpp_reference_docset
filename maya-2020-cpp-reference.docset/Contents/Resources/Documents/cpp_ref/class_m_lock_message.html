<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
      <title>C++ API Reference: MLockMessage Class Reference</title>
      
	  
      
      
      
      
      
      
      
    

</head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_lock_message.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
      <div>
         <div class="head">
            <h1>C++ API Reference: MLockMessage Class Reference</h1>
         </div>

<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->

  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="cpp_ref/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="cpp_ref/search/close.png" alt=""></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="#!/url=./cpp_ref/classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="#!/url=./cpp_ref/hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="#!/url=./cpp_ref/functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<!-- window showing the filter options -->


<!-- iframe showing the search results (closed by default) -->


<div class="header">
  
  <div class="headertitle">
<div class="title">MLockMessage Class Reference<div class="ingroups"><a class="el" href="#!/url=./cpp_ref/group___open_maya.html">OpenMaya - API module for common classes</a></div></div>  </div>
<div class="summary">
<a href="class_m_lock_message.html#pub-types">Public Types</a> &#124;
<a href="class_m_lock_message.html#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_lock_message.html#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#!/url=./cpp_ref/class_m_lock_message-members.html">List of all members</a>  </div></div><!--header-->
<div class="contents">

<p>Node and plug locking messages.  
 <a href="#!/url=./cpp_ref/class_m_lock_message.html#details">More...</a></p>

<p><code>#include &lt;MLockMessage.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="cpp_ref/closed.png" alt="+"> Inheritance diagram for MLockMessage:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="cpp_ref/class_m_lock_message.png" usemap="#MLockMessage_map" alt="">
  <map id="MLockMessage_map" name="MLockMessage_map">
<area href="class_m_message.html" title="Message base class. " alt="MMessage" shape="rect" coords="0,0,101,24">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abb201d9ec3d2a048854c7808bfd0da5b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#abb201d9ec3d2a048854c7808bfd0da5b">MLockEventFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;aux, void *clientData, MLockMessage::LockEvent eventType, bool &amp;decision)</td></tr>
<tr class="memdesc:abb201d9ec3d2a048854c7808bfd0da5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a dependency node lock event callback function.  <a href="class_m_lock_message.html#abb201d9ec3d2a048854c7808bfd0da5b">More...</a><br></td></tr>
<tr class="separator:abb201d9ec3d2a048854c7808bfd0da5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133557aa9faa0b6e3d3ccd0713dd198a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a133557aa9faa0b6e3d3ccd0713dd198a">MLockDagEventFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;dagPath, <a class="el" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;otherPath, void *clientData, MLockMessage::LockDAGEvent eventType, bool &amp;decision)</td></tr>
<tr class="memdesc:a133557aa9faa0b6e3d3ccd0713dd198a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a DAG lock event callback function.  <a href="class_m_lock_message.html#a133557aa9faa0b6e3d3ccd0713dd198a">More...</a><br></td></tr>
<tr class="separator:a133557aa9faa0b6e3d3ccd0713dd198a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f7c3225d27f3705acc502378810f6b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a88f7c3225d27f3705acc502378810f6b">MLockPlugEventFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;plug, <a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;otherPlug, void *clientData, MLockMessage::LockPlugEvent eventType, bool &amp;decision)</td></tr>
<tr class="memdesc:a88f7c3225d27f3705acc502378810f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a plug lock event callback function.  <a href="class_m_lock_message.html#a88f7c3225d27f3705acc502378810f6b">More...</a><br></td></tr>
<tr class="separator:a88f7c3225d27f3705acc502378810f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_m_message"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_m_message')"><img src="cpp_ref/closed.png" alt="-">&#160;Public Types inherited from <a class="el" href="#!/url=./cpp_ref/class_m_message.html">MMessage</a></td></tr>
<tr class="memitem:a37b1ad341738421024d94d7bb1032777 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a37b1ad341738421024d94d7bb1032777">MBasicFunction</a>) (void *clientData)</td></tr>
<tr class="memdesc:a37b1ad341738421024d94d7bb1032777 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a basic callback function.  <a href="class_m_lock_message.html#a37b1ad341738421024d94d7bb1032777">More...</a><br></td></tr>
<tr class="separator:a37b1ad341738421024d94d7bb1032777 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb12b47064efa561b8ee55c111e71f1b inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#afb12b47064efa561b8ee55c111e71f1b">MElapsedTimeFunction</a>) (float elapsedTime, float lastTime, void *clientData)</td></tr>
<tr class="memdesc:afb12b47064efa561b8ee55c111e71f1b inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to an elapsed time callback function.  <a href="class_m_lock_message.html#afb12b47064efa561b8ee55c111e71f1b">More...</a><br></td></tr>
<tr class="separator:afb12b47064efa561b8ee55c111e71f1b inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72042798fd9270c4aaa3e59f8df446a5 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a72042798fd9270c4aaa3e59f8df446a5">MCheckFunction</a>) (bool *retCode, void *clientData)</td></tr>
<tr class="memdesc:a72042798fd9270c4aaa3e59f8df446a5 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to callback function which returns a true/false result.  <a href="class_m_lock_message.html#a72042798fd9270c4aaa3e59f8df446a5">More...</a><br></td></tr>
<tr class="separator:a72042798fd9270c4aaa3e59f8df446a5 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dd48e7f07eb5d99f35bd418290340f inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a38dd48e7f07eb5d99f35bd418290340f">MCheckFileFunction</a>) (bool *retCode, <a class="el" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a> &amp;file, void *clientData)</td></tr>
<tr class="memdesc:a38dd48e7f07eb5d99f35bd418290340f inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a file object and returns a result.  <a href="class_m_lock_message.html#a38dd48e7f07eb5d99f35bd418290340f">More...</a><br></td></tr>
<tr class="separator:a38dd48e7f07eb5d99f35bd418290340f inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b79cba0923e95624e83c2a8a07bf6ee inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a0b79cba0923e95624e83c2a8a07bf6ee">MCheckPlugFunction</a>) (bool *retCode, <a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;plug, void *clientData)</td></tr>
<tr class="memdesc:a0b79cba0923e95624e83c2a8a07bf6ee inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a plug and returns a result.  <a href="class_m_lock_message.html#a0b79cba0923e95624e83c2a8a07bf6ee">More...</a><br></td></tr>
<tr class="separator:a0b79cba0923e95624e83c2a8a07bf6ee inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a349eb5a12282dfc9d7078ece93136 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#af8a349eb5a12282dfc9d7078ece93136">MComponentFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_uint_array.html">MUintArray</a> componentIds[], unsigned int count, void *clientData)</td></tr>
<tr class="memdesc:af8a349eb5a12282dfc9d7078ece93136 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes an array of component ids.  <a href="class_m_lock_message.html#af8a349eb5a12282dfc9d7078ece93136">More...</a><br></td></tr>
<tr class="separator:af8a349eb5a12282dfc9d7078ece93136 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982bfacac40884ca190fd0c93efa877f inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a982bfacac40884ca190fd0c93efa877f">MNodeFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, void *clientData)</td></tr>
<tr class="memdesc:a982bfacac40884ca190fd0c93efa877f inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a dependency node.  <a href="class_m_lock_message.html#a982bfacac40884ca190fd0c93efa877f">More...</a><br></td></tr>
<tr class="separator:a982bfacac40884ca190fd0c93efa877f inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff7182136730aac7d9aba3d5eebe373 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#adff7182136730aac7d9aba3d5eebe373">MStringFunction</a>) (const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str, void *clientData)</td></tr>
<tr class="memdesc:adff7182136730aac7d9aba3d5eebe373 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to callback function which takes a string.  <a href="class_m_lock_message.html#adff7182136730aac7d9aba3d5eebe373">More...</a><br></td></tr>
<tr class="separator:adff7182136730aac7d9aba3d5eebe373 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a8f5af4fb8a99d3556d98e0bee8d6d inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#aa5a8f5af4fb8a99d3556d98e0bee8d6d">MTwoStringFunction</a>) (const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str1, const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str2, void *clientData)</td></tr>
<tr class="memdesc:aa5a8f5af4fb8a99d3556d98e0bee8d6d inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes two strings.  <a href="class_m_lock_message.html#aa5a8f5af4fb8a99d3556d98e0bee8d6d">More...</a><br></td></tr>
<tr class="separator:aa5a8f5af4fb8a99d3556d98e0bee8d6d inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d4414eaf18fc0cebe02aaa52647a33 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#aa5d4414eaf18fc0cebe02aaa52647a33">MThreeStringFunction</a>) (const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str1, const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str2, const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str3, void *clientData)</td></tr>
<tr class="memdesc:aa5d4414eaf18fc0cebe02aaa52647a33 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes three strings.  <a href="class_m_lock_message.html#aa5d4414eaf18fc0cebe02aaa52647a33">More...</a><br></td></tr>
<tr class="separator:aa5d4414eaf18fc0cebe02aaa52647a33 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80e4dc274fe5ff11d5838cc861f2b5f inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#ae80e4dc274fe5ff11d5838cc861f2b5f">MStringIntBoolIntFunction</a>) (const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str, unsigned int index, bool flag, unsigned int type, void *clientData)</td></tr>
<tr class="memdesc:ae80e4dc274fe5ff11d5838cc861f2b5f inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to callback function which takes a string, an index, a flag and a type.  <a href="class_m_lock_message.html#ae80e4dc274fe5ff11d5838cc861f2b5f">More...</a><br></td></tr>
<tr class="separator:ae80e4dc274fe5ff11d5838cc861f2b5f inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa999696ee36dd7e79cc54a10cc15d8c8 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#aa999696ee36dd7e79cc54a10cc15d8c8">MStringIndexFunction</a>) (const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;, unsigned int index, void *clientData)</td></tr>
<tr class="memdesc:aa999696ee36dd7e79cc54a10cc15d8c8 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to callback function which takes a string and index.  <a href="class_m_lock_message.html#aa999696ee36dd7e79cc54a10cc15d8c8">More...</a><br></td></tr>
<tr class="separator:aa999696ee36dd7e79cc54a10cc15d8c8 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794521f8db8e5db6e2728cf6eac12660 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a794521f8db8e5db6e2728cf6eac12660">MNodeStringBoolFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;, bool, void *clientData)</td></tr>
<tr class="memdesc:a794521f8db8e5db6e2728cf6eac12660 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a node, a string and a boolean.  <a href="class_m_lock_message.html#a794521f8db8e5db6e2728cf6eac12660">More...</a><br></td></tr>
<tr class="separator:a794521f8db8e5db6e2728cf6eac12660 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1fc736d567cfe4d6bc2e0f7534a291 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a7a1fc736d567cfe4d6bc2e0f7534a291">MStateFunction</a>) (bool state, void *clientData)</td></tr>
<tr class="memdesc:a7a1fc736d567cfe4d6bc2e0f7534a291 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a boolean state.  <a href="class_m_lock_message.html#a7a1fc736d567cfe4d6bc2e0f7534a291">More...</a><br></td></tr>
<tr class="separator:a7a1fc736d567cfe4d6bc2e0f7534a291 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4045edfff524bf80d8e400b2ad61253a inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a4045edfff524bf80d8e400b2ad61253a">MTimeFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_time.html">MTime</a> &amp;time, void *clientData)</td></tr>
<tr class="memdesc:a4045edfff524bf80d8e400b2ad61253a inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to callback function which takes a time.  <a href="class_m_lock_message.html#a4045edfff524bf80d8e400b2ad61253a">More...</a><br></td></tr>
<tr class="separator:a4045edfff524bf80d8e400b2ad61253a inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e93cb1bbaba7a8c8f884d0514a486fa inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a3e93cb1bbaba7a8c8f884d0514a486fa">MPlugFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;srcPlug, <a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;destPlug, bool made, void *clientData)</td></tr>
<tr class="memdesc:a3e93cb1bbaba7a8c8f884d0514a486fa inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to plug connection callback function.  <a href="class_m_lock_message.html#a3e93cb1bbaba7a8c8f884d0514a486fa">More...</a><br></td></tr>
<tr class="separator:a3e93cb1bbaba7a8c8f884d0514a486fa inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2318bc51816347d22d387d86efbfbfaa inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a2318bc51816347d22d387d86efbfbfaa">MNodePlugFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;plug, void *clientData)</td></tr>
<tr class="memdesc:a2318bc51816347d22d387d86efbfbfaa inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a dependency node and a plug.  <a href="class_m_lock_message.html#a2318bc51816347d22d387d86efbfbfaa">More...</a><br></td></tr>
<tr class="separator:a2318bc51816347d22d387d86efbfbfaa inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae480438b66fdd45d7c0365ccc0c8c2b4 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#ae480438b66fdd45d7c0365ccc0c8c2b4">MNodeStringFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str, void *clientData)</td></tr>
<tr class="memdesc:ae480438b66fdd45d7c0365ccc0c8c2b4 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a dependency node and a string.  <a href="class_m_lock_message.html#ae480438b66fdd45d7c0365ccc0c8c2b4">More...</a><br></td></tr>
<tr class="separator:ae480438b66fdd45d7c0365ccc0c8c2b4 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afceee9fecb5e8860f82f29138d039ca2 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#afceee9fecb5e8860f82f29138d039ca2">MParentChildFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;child, <a class="el" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;parent, void *clientData)</td></tr>
<tr class="memdesc:afceee9fecb5e8860f82f29138d039ca2 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to to a callback function which takes two DAG nodes in a parent/child relationship.  <a href="class_m_lock_message.html#afceee9fecb5e8860f82f29138d039ca2">More...</a><br></td></tr>
<tr class="separator:afceee9fecb5e8860f82f29138d039ca2 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900ea5961bb704dc8fa1304886619271 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a900ea5961bb704dc8fa1304886619271">MModifierFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_d_g_modifier.html">MDGModifier</a> &amp;modifier, void *clientData)</td></tr>
<tr class="memdesc:a900ea5961bb704dc8fa1304886619271 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a DG modifier.  <a href="class_m_lock_message.html#a900ea5961bb704dc8fa1304886619271">More...</a><br></td></tr>
<tr class="separator:a900ea5961bb704dc8fa1304886619271 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2757e5f350fdd346d031bb710f0481f6 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a2757e5f350fdd346d031bb710f0481f6">MStringArrayFunction</a>) (const <a class="el" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> &amp;strs, void *clientData)</td></tr>
<tr class="memdesc:a2757e5f350fdd346d031bb710f0481f6 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a string array.  <a href="class_m_lock_message.html#a2757e5f350fdd346d031bb710f0481f6">More...</a><br></td></tr>
<tr class="separator:a2757e5f350fdd346d031bb710f0481f6 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19aa9de989e77882876922048b913922 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a19aa9de989e77882876922048b913922">MNodeModifierFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_d_g_modifier.html">MDGModifier</a> &amp;modifier, void *clientData)</td></tr>
<tr class="memdesc:a19aa9de989e77882876922048b913922 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a dependency node and a DG modifier.  <a href="class_m_lock_message.html#a19aa9de989e77882876922048b913922">More...</a><br></td></tr>
<tr class="separator:a19aa9de989e77882876922048b913922 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad4566b8e4423ddb85399bf9c0d7b30 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a1ad4566b8e4423ddb85399bf9c0d7b30">MObjArray</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object_array.html">MObjectArray</a> &amp;objects, void *clientData)</td></tr>
<tr class="memdesc:a1ad4566b8e4423ddb85399bf9c0d7b30 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes an array of objects.  <a href="class_m_lock_message.html#a1ad4566b8e4423ddb85399bf9c0d7b30">More...</a><br></td></tr>
<tr class="separator:a1ad4566b8e4423ddb85399bf9c0d7b30 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f69a6ec5adf763c60d75e9291d7fd41 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a8f69a6ec5adf763c60d75e9291d7fd41">MNodeObjArray</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_object_array.html">MObjectArray</a> &amp;objects, void *clientData)</td></tr>
<tr class="memdesc:a8f69a6ec5adf763c60d75e9291d7fd41 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a dependency node and an array of objects.  <a href="class_m_lock_message.html#a8f69a6ec5adf763c60d75e9291d7fd41">More...</a><br></td></tr>
<tr class="separator:a8f69a6ec5adf763c60d75e9291d7fd41 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f81f72253b59d06437e20193a79607f inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a7f81f72253b59d06437e20193a79607f">MStringNode</a>) (const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;str, <a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, void *clientData)</td></tr>
<tr class="memdesc:a7f81f72253b59d06437e20193a79607f inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a string and a dependency node.  <a href="class_m_lock_message.html#a7f81f72253b59d06437e20193a79607f">More...</a><br></td></tr>
<tr class="separator:a7f81f72253b59d06437e20193a79607f inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aaa52ae480a83a0db40f3ed2def939e inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a2aaa52ae480a83a0db40f3ed2def939e">MCameraLayerFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;cameraSetNode, unsigned int multiIndex, bool added, void *clientData)</td></tr>
<tr class="memdesc:a2aaa52ae480a83a0db40f3ed2def939e inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a dependency node, an unsigned integer, and a boolean value.  <a href="class_m_lock_message.html#a2aaa52ae480a83a0db40f3ed2def939e">More...</a><br></td></tr>
<tr class="separator:a2aaa52ae480a83a0db40f3ed2def939e inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c84f3afa3fdc6076045a767d8e8573 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#ab9c84f3afa3fdc6076045a767d8e8573">MCameraLayerCameraFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;cameraSetNode, unsigned int multiIndex, <a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;oldCamera, <a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;newCamera, void *clientData)</td></tr>
<tr class="memdesc:ab9c84f3afa3fdc6076045a767d8e8573 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a dependency node, an unsigned integer, and two camera transform nodes.  <a href="class_m_lock_message.html#ab9c84f3afa3fdc6076045a767d8e8573">More...</a><br></td></tr>
<tr class="separator:ab9c84f3afa3fdc6076045a767d8e8573 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a380320eaebf27ac10728c3788a35a0 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a9a380320eaebf27ac10728c3788a35a0">MConnFailFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;srcPlug, <a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;destPlug, const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;srcPlugName, const <a class="el" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;dstPlugName, void *clientData)</td></tr>
<tr class="memdesc:a9a380320eaebf27ac10728c3788a35a0 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to connection-failed callback function.  <a href="class_m_lock_message.html#a9a380320eaebf27ac10728c3788a35a0">More...</a><br></td></tr>
<tr class="separator:a9a380320eaebf27ac10728c3788a35a0 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754e3afbb3e20de2bbf9840f81cc5141 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a754e3afbb3e20de2bbf9840f81cc5141">MPlugsDGModFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_plug_array.html">MPlugArray</a> &amp;plugs, <a class="el" href="#!/url=./cpp_ref/class_m_d_g_modifier.html">MDGModifier</a> &amp;modifier, void *clientData)</td></tr>
<tr class="memdesc:a754e3afbb3e20de2bbf9840f81cc5141 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes an array of MPlugs and an <a class="el" href="#!/url=./cpp_ref/class_m_d_g_modifier.html" title="Dependency graph modifier. ">MDGModifier</a>.  <a href="class_m_lock_message.html#a754e3afbb3e20de2bbf9840f81cc5141">More...</a><br></td></tr>
<tr class="separator:a754e3afbb3e20de2bbf9840f81cc5141 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2fb25564ed3f8501423df873c9c17f inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a9e2fb25564ed3f8501423df873c9c17f">MNodeUuidFunction</a>) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, const <a class="el" href="#!/url=./cpp_ref/class_m_uuid.html">MUuid</a> &amp;uuid, void *clientData)</td></tr>
<tr class="memdesc:a9e2fb25564ed3f8501423df873c9c17f inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a dependency node and a UUID.  <a href="class_m_lock_message.html#a9e2fb25564ed3f8501423df873c9c17f">More...</a><br></td></tr>
<tr class="separator:a9e2fb25564ed3f8501423df873c9c17f inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b77f065ba68a88ba9605f356348a147 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef Action(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a4b77f065ba68a88ba9605f356348a147">MCheckNodeUuidFunction</a>) (bool doAction, <a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_uuid.html">MUuid</a> &amp;uuid, void *clientData)</td></tr>
<tr class="memdesc:a4b77f065ba68a88ba9605f356348a147 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes a dependency node and a UUID, and returns a result.  <a href="class_m_lock_message.html#a4b77f065ba68a88ba9605f356348a147">More...</a><br></td></tr>
<tr class="separator:a4b77f065ba68a88ba9605f356348a147 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c99bed68fadfc2187b7e31f3e752e3 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a50c99bed68fadfc2187b7e31f3e752e3">MObjectFileFunction</a>) (const <a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;object, const <a class="el" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a> &amp;file, void *clientData)</td></tr>
<tr class="memdesc:a50c99bed68fadfc2187b7e31f3e752e3 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes an object and a file object.  <a href="class_m_lock_message.html#a50c99bed68fadfc2187b7e31f3e752e3">More...</a><br></td></tr>
<tr class="separator:a50c99bed68fadfc2187b7e31f3e752e3 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150a2825c41c6ee9bcf33bda925392ed inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a150a2825c41c6ee9bcf33bda925392ed">MCheckObjectFileFunction</a>) (bool *retCode, const <a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;referenceNode, <a class="el" href="#!/url=./cpp_ref/class_m_file_object.html">MFileObject</a> &amp;file, void *clientData)</td></tr>
<tr class="memdesc:a150a2825c41c6ee9bcf33bda925392ed inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which takes an object and a file object and returns a result.  <a href="class_m_lock_message.html#a150a2825c41c6ee9bcf33bda925392ed">More...</a><br></td></tr>
<tr class="separator:a150a2825c41c6ee9bcf33bda925392ed inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f88d0672d0d163a75b44fb688dd74c9 inherit pub_types_class_m_message"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a9f88d0672d0d163a75b44fb688dd74c9">MRenderTileFunction</a>) (int originX, int originY, int tileMaxX, int tileMaxY, const void *tileData)</td></tr>
<tr class="memdesc:a9f88d0672d0d163a75b44fb688dd74c9 inherit pub_types_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a callback function which receives origin, size and image data.  <a href="class_m_lock_message.html#a9f88d0672d0d163a75b44fb688dd74c9">More...</a><br></td></tr>
<tr class="separator:a9f88d0672d0d163a75b44fb688dd74c9 inherit pub_types_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a92cfb927257c2835039df9975c17a624"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a92cfb927257c2835039df9975c17a624">OPENMAYA_ENUM</a> (LockPlugEvent, kInvalidPlug=0, kPlugLockAttr, kPlugUnlockAttr, kPlugAttrValChange, kPlugRemoveAttr, kPlugRenameAttr, kPlugConnect, kPlugDisconnect, kLastPlug)</td></tr>
<tr class="memdesc:a92cfb927257c2835039df9975c17a624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plug related locking events.  <a href="class_m_lock_message.html#a92cfb927257c2835039df9975c17a624">More...</a><br></td></tr>
<tr class="separator:a92cfb927257c2835039df9975c17a624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d3fa86f9221a2bdc9ac205b6b7c0e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a34d3fa86f9221a2bdc9ac205b6b7c0e4">OPENMAYA_ENUM</a> (LockDAGEvent, kInvalidDAG=0, kGroup, kUnGroup, kReparent, kChildReorder, kCreateNodeInstance, kCreateChildInstance, kCreateParentInstance, kLastDAG)</td></tr>
<tr class="memdesc:a34d3fa86f9221a2bdc9ac205b6b7c0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">DAG related locking events.  <a href="class_m_lock_message.html#a34d3fa86f9221a2bdc9ac205b6b7c0e4">More...</a><br></td></tr>
<tr class="separator:a34d3fa86f9221a2bdc9ac205b6b7c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a046d230f09745369741c6f0b6842f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a98a046d230f09745369741c6f0b6842f">OPENMAYA_ENUM</a> (LockEvent, kInvalid=0, kRename, kDelete, kLockNode, kUnlockNode, kAddAttr, kRemoveAttr, kRenameAttr, kUnlockAttr, kLockAttr, kLast)</td></tr>
<tr class="memdesc:a98a046d230f09745369741c6f0b6842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Miscellaneous lock event types.  <a href="class_m_lock_message.html#a98a046d230f09745369741c6f0b6842f">More...</a><br></td></tr>
<tr class="separator:a98a046d230f09745369741c6f0b6842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_message"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_message')"><img src="cpp_ref/closed.png" alt="-">&#160;Public Member Functions inherited from <a class="el" href="#!/url=./cpp_ref/class_m_message.html">MMessage</a></td></tr>
<tr class="memitem:a5fb904e092f58d5d84c41e8ab156bfa5 inherit pub_methods_class_m_message"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fb904e092f58d5d84c41e8ab156bfa5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a5fb904e092f58d5d84c41e8ab156bfa5">OPENMAYA_ENUM</a> (Action, kDefaultAction, kDoNotDoAction, kDoAction)</td></tr>
<tr class="memdesc:a5fb904e092f58d5d84c41e8ab156bfa5 inherit pub_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback result action codes. <br></td></tr>
<tr class="separator:a5fb904e092f58d5d84c41e8ab156bfa5 inherit pub_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aedfd1b17f9333f8cc45430fae689d540"><td class="memItemLeft" align="right" valign="top">static MCallbackId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#aedfd1b17f9333f8cc45430fae689d540">setNodeLockQueryCallback</a> (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#abb201d9ec3d2a048854c7808bfd0da5b">MLockMessage::MLockEventFunction</a> func, void *clientData=NULL, <a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *status=NULL)</td></tr>
<tr class="memdesc:aedfd1b17f9333f8cc45430fae689d540"><td class="mdescLeft">&#160;</td><td class="mdescRight">This methods registers a callback that is invoked in any locking condition on node properties, e.g.  <a href="class_m_lock_message.html#aedfd1b17f9333f8cc45430fae689d540">More...</a><br></td></tr>
<tr class="separator:aedfd1b17f9333f8cc45430fae689d540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de04b5d479a6a1ae58aa5c3642e6cbc"><td class="memItemLeft" align="right" valign="top">static MCallbackId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a0de04b5d479a6a1ae58aa5c3642e6cbc">setNodeLockDAGQueryCallback</a> (<a class="el" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;path, <a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a133557aa9faa0b6e3d3ccd0713dd198a">MLockMessage::MLockDagEventFunction</a> func, void *clientData=NULL, <a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *status=NULL)</td></tr>
<tr class="memdesc:a0de04b5d479a6a1ae58aa5c3642e6cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This methods registers a callback that is invoked in any situation involving a locking condition on DAG level changes.  <a href="class_m_lock_message.html#a0de04b5d479a6a1ae58aa5c3642e6cbc">More...</a><br></td></tr>
<tr class="separator:a0de04b5d479a6a1ae58aa5c3642e6cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e8657f446db107065ef13b68d92b37"><td class="memItemLeft" align="right" valign="top">static MCallbackId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a10e8657f446db107065ef13b68d92b37">setPlugLockQueryCallback</a> (<a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;plug, <a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a88f7c3225d27f3705acc502378810f6b">MLockMessage::MLockPlugEventFunction</a> func, void *clientData=NULL, <a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *status=NULL)</td></tr>
<tr class="memdesc:a10e8657f446db107065ef13b68d92b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a callback that is invoked in any locking condition on a plug, e.g.  <a href="class_m_lock_message.html#a10e8657f446db107065ef13b68d92b37">More...</a><br></td></tr>
<tr class="separator:a10e8657f446db107065ef13b68d92b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d6b6764584a809b6bb2be324c91dbb"><td class="memItemLeft" align="right" valign="top">static MCallbackId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a49d6b6764584a809b6bb2be324c91dbb">setPlugLockQueryCallback</a> (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a88f7c3225d27f3705acc502378810f6b">MLockMessage::MLockPlugEventFunction</a> func, void *clientData=NULL, <a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *status=NULL)</td></tr>
<tr class="memdesc:a49d6b6764584a809b6bb2be324c91dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a callback that is invoked in any locking condition on any plug of a given node, e.g.  <a href="class_m_lock_message.html#a49d6b6764584a809b6bb2be324c91dbb">More...</a><br></td></tr>
<tr class="separator:a49d6b6764584a809b6bb2be324c91dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this class.  <a href="class_m_lock_message.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_m_message"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_message')"><img src="cpp_ref/closed.png" alt="-">&#160;Static Public Member Functions inherited from <a class="el" href="#!/url=./cpp_ref/class_m_message.html">MMessage</a></td></tr>
<tr class="memitem:a50fe995add3ce133b8b56551abb4ed09 inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a50fe995add3ce133b8b56551abb4ed09">removeCallback</a> (MCallbackId id)</td></tr>
<tr class="memdesc:a50fe995add3ce133b8b56551abb4ed09 inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified callback from maya.  <a href="class_m_lock_message.html#a50fe995add3ce133b8b56551abb4ed09">More...</a><br></td></tr>
<tr class="separator:a50fe995add3ce133b8b56551abb4ed09 inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac637287cc26b707b9e1a175a32f44e29 inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#ac637287cc26b707b9e1a175a32f44e29">removeCallbacks</a> (<a class="el" href="#!/url=./cpp_ref/class_m_callback_id_array.html">MCallbackIdArray</a> &amp;ids)</td></tr>
<tr class="memdesc:ac637287cc26b707b9e1a175a32f44e29 inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all of the specified callbacks from maya.  <a href="class_m_lock_message.html#ac637287cc26b707b9e1a175a32f44e29">More...</a><br></td></tr>
<tr class="separator:ac637287cc26b707b9e1a175a32f44e29 inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853511c7461cc8f79d2e904ee74288b8 inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top">static MCallbackId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a853511c7461cc8f79d2e904ee74288b8">currentCallbackId</a> (<a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a853511c7461cc8f79d2e904ee74288b8 inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the callback ID of the currently executing callback.  <a href="class_m_lock_message.html#a853511c7461cc8f79d2e904ee74288b8">More...</a><br></td></tr>
<tr class="separator:a853511c7461cc8f79d2e904ee74288b8 inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2f799217b34ba828a297c79af01115 inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#ace2f799217b34ba828a297c79af01115">nodeCallbacks</a> (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_callback_id_array.html">MCallbackIdArray</a> &amp;ids)</td></tr>
<tr class="memdesc:ace2f799217b34ba828a297c79af01115 inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of callback IDs associated registered to a given node.  <a href="class_m_lock_message.html#ace2f799217b34ba828a297c79af01115">More...</a><br></td></tr>
<tr class="separator:ace2f799217b34ba828a297c79af01115 inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239948837628131c722f10f190abc253 inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a239948837628131c722f10f190abc253"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a239948837628131c722f10f190abc253">setRegisteringCallableScript</a> ()</td></tr>
<tr class="memdesc:a239948837628131c722f10f190abc253 inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark this <a class="el" href="#!/url=./cpp_ref/class_m_message.html" title="Message base class. ">MMessage</a> object as one that will be passed callbacks defined in script. <br></td></tr>
<tr class="separator:a239948837628131c722f10f190abc253 inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f586337760f98939702403c29950aff inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f586337760f98939702403c29950aff"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a5f586337760f98939702403c29950aff">registeringCallableScript</a> ()</td></tr>
<tr class="memdesc:a5f586337760f98939702403c29950aff inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="#!/url=./cpp_ref/class_m_message.html" title="Message base class. ">MMessage</a> object has its callbacks defined in script. <br></td></tr>
<tr class="separator:a5f586337760f98939702403c29950aff inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a75722f9e64825e5d372573176814ed inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a4a75722f9e64825e5d372573176814ed">stopRegisteringCallableScript</a> ()</td></tr>
<tr class="memdesc:a4a75722f9e64825e5d372573176814ed inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop this <a class="el" href="#!/url=./cpp_ref/class_m_message.html" title="Message base class. ">MMessage</a> object from being passed.  <a href="class_m_lock_message.html#a4a75722f9e64825e5d372573176814ed">More...</a><br></td></tr>
<tr class="separator:a4a75722f9e64825e5d372573176814ed inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this class.  <a href="class_m_lock_message.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04 inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6517de5896b9950bded3d097b380119 inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#ac6517de5896b9950bded3d097b380119">removeCallbacks</a> (<a class="el" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;ids)</td></tr>
<tr class="memdesc:ac6517de5896b9950bded3d097b380119 inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is obsolete.  <a href="class_m_lock_message.html#ac6517de5896b9950bded3d097b380119">More...</a><br></td></tr>
<tr class="separator:ac6517de5896b9950bded3d097b380119 inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e4ddbd1ae746ceafd9397d0986ec3c inherit pub_static_methods_class_m_message"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#!/url=./cpp_ref/class_m_message.html#a18e4ddbd1ae746ceafd9397d0986ec3c">nodeCallbacks</a> (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;ids)</td></tr>
<tr class="memdesc:a18e4ddbd1ae746ceafd9397d0986ec3c inherit pub_static_methods_class_m_message"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is obsolete.  <a href="class_m_lock_message.html#a18e4ddbd1ae746ceafd9397d0986ec3c">More...</a><br></td></tr>
<tr class="separator:a18e4ddbd1ae746ceafd9397d0986ec3c inherit pub_static_methods_class_m_message"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Node and plug locking messages. </p>
<p>Plug locking was implemented with Maya 1.0. Individual plugs can be locked so that their values cannot be changed. The locking state is held within the plug. The plug's locked state can be changed via the API with the method <a class="el" href="#!/url=./cpp_ref/class_m_plug.html#a0eb2f4f3be6845848e546709e1410be2" title="Sets the locked state for this plug&#39;s value. ">MPlug::setLocked(bool)</a>, or, in MEL, using the command "setAttr -l {on,off}".</p>
<p>The ability to lock nodes was added with Maya 4.5. Node locking prevents renaming, reparenting, deletion, and other node-related changes. It also restricts the ability to change the state of any plug locks. The intent is that the user relies upon plug locking first, to lock the desired plugs they don't want to change, and then uses node locking to lock the node itself. Node locking can be set via MEL command, "lockNode", or via <a class="el" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html#a0eb2f4f3be6845848e546709e1410be2" title="Locks or unlocks this node. ">MFnDependencyNode::setLocked(bool)</a></p>
<p><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html" title="Node and plug locking messages. ">MLockMessage</a> class allows the API user to register callbacks that control how Maya handles locks. The registered callbacks are invoked whenever a query to the lock state is involved. Therefore, the callback would be called even if the node was not locked.</p>
<p>When a callback is invoked, the API user will be given a decision variable where they can place their decision. This decision variable is a boolean, and the boolean can take on the following values:</p>
<ul>
<li><b>true</b> - accept the default behavior. When the node/plug is locked the default behavior is to obey the lock. When the node/plug is unlocked the default behavior is to do the action/edit. </li>
<li><b>false</b> - deny the default behavior. When the node/plug is locked the default behavior is to deny/override the lock; thus allowing the edit/action to occur. When the node/plug is unlocked the default behavior is make the node/plug locked - without physically setting the lock bit.</li>
</ul>
<p><b>Caveats</b></p>
<p>You must use caution when using these routines. The flow of execution is interrupted when these callbacks are invoked. Therefore, you should make your decision in a timely maanner or a serious performance penalty will result. Also, you should NEVER try to alter the DG state while executing within callback. This includes quering/assigning a plug's value. You may, however, examine state information like the lock state of the plug/node. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="abb201d9ec3d2a048854c7808bfd0da5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* MLockEventFunction) (<a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;node, <a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;aux, void *clientData, MLockMessage::LockEvent eventType, bool &amp;decision)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to a dependency node lock event callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">node</td><td>Node for which the lock event occurred. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aux</td><td>Auxiliary data used by some events. E.g. the attribute about to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientData</td><td>Pointer to user-defined data supplied when the callback was registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventType</td><td>Type of node lock event which occurred. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decision</td><td>Decision of the callback whether to allow (true) or disallow (false) the default action associated with the lock event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a133557aa9faa0b6e3d3ccd0713dd198a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* MLockDagEventFunction) (<a class="el" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;dagPath, <a class="el" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;otherPath, void *clientData, MLockMessage::LockDAGEvent eventType, bool &amp;decision)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to a DAG lock event callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dagPath</td><td>Path to the DAG node for which the lock event occurred. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">otherPath</td><td>Second DAG node used in some events. E.g. the new parent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientData</td><td>Pointer to user-defined data supplied when the callback was registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventType</td><td>Type of DAG node lock event which occurred. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decision</td><td>Decision of the callback whether to allow (true) or disallow (false) the default action associated with the lock event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88f7c3225d27f3705acc502378810f6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* MLockPlugEventFunction) (<a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;plug, <a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;otherPlug, void *clientData, MLockMessage::LockPlugEvent eventType, bool &amp;decision)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to a plug lock event callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plug</td><td>Plug for which the lock event occurred. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">otherPlug</td><td>Second plug used in some events. E.g. during connect and disconnect events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientData</td><td>Pointer to user-defined data supplied when the callback was registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventType</td><td>Type of plug lock event which occurred. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decision</td><td>Decision of the callback whether to allow (true) or disallow (false) the default action associated with the lock event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a92cfb927257c2835039df9975c17a624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OPENMAYA_ENUM </td>
          <td>(</td>
          <td class="paramtype">LockPlugEvent&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kInvalidPlug&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kPlugLockAttr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kPlugUnlockAttr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kPlugAttrValChange&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kPlugRemoveAttr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kPlugRenameAttr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kPlugConnect&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kPlugDisconnect&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kLastPlug&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plug related locking events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kInvalidPlug</td><td>An invalid plug event received. </td></tr>
    <tr><td class="paramname">kPlugLockAttr</td><td>User is trying to lock the plug. </td></tr>
    <tr><td class="paramname">kPlugUnlockAttr</td><td>User is trying to unlock the plug. </td></tr>
    <tr><td class="paramname">kPlugAttrValChange</td><td>Plug lock query on plug value change. </td></tr>
    <tr><td class="paramname">kPlugRemoveAttr</td><td>Plug lock query on a remove attribute event. </td></tr>
    <tr><td class="paramname">kPlugRenameAttr</td><td>Plug lock query on a rename attribute event. </td></tr>
    <tr><td class="paramname">kPlugConnect</td><td>Plug lock query on a connect to a locked attribute. </td></tr>
    <tr><td class="paramname">kPlugDisconnect</td><td>Plug lock query on a disconnect from a locked source attribute. </td></tr>
    <tr><td class="paramname">kLastPlug</td><td>Used for internal bounds checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34d3fa86f9221a2bdc9ac205b6b7c0e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OPENMAYA_ENUM </td>
          <td>(</td>
          <td class="paramtype">LockDAGEvent&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kInvalidDAG&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kGroup&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kUnGroup&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kReparent&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kChildReorder&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kCreateNodeInstance&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kCreateChildInstance&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kCreateParentInstance&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kLastDAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DAG related locking events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kInvalidDAG</td><td>Invalid DAG event received. </td></tr>
    <tr><td class="paramname">kGroup</td><td>Lock query on group action. </td></tr>
    <tr><td class="paramname">kUnGroup</td><td>Lock query on ungroup action. </td></tr>
    <tr><td class="paramname">kReparent</td><td>Lock query on reparent action. </td></tr>
    <tr><td class="paramname">kChildReorder</td><td>Lock query on a child add action. </td></tr>
    <tr><td class="paramname">kCreateNodeInstance</td><td>Lock query on an instance event. </td></tr>
    <tr><td class="paramname">kCreateChildInstance</td><td>Lock query on node whose children will be instanced. </td></tr>
    <tr><td class="paramname">kCreateParentInstance</td><td>Lock query on node whose parent will be instanced. </td></tr>
    <tr><td class="paramname">kLastDAG</td><td>Used for internal bounds checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98a046d230f09745369741c6f0b6842f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OPENMAYA_ENUM </td>
          <td>(</td>
          <td class="paramtype">LockEvent&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kInvalid&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kRename&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kDelete&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kLockNode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kUnlockNode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kAddAttr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kRemoveAttr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kRenameAttr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kUnlockAttr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kLockAttr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kLast&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Miscellaneous lock event types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kInvalid</td><td>Invalid node lock event received. </td></tr>
    <tr><td class="paramname">kRename</td><td>Lock query on a rename event. </td></tr>
    <tr><td class="paramname">kDelete</td><td>Lock query on a delete event. </td></tr>
    <tr><td class="paramname">kLockNode</td><td>Lock query on a lock event. </td></tr>
    <tr><td class="paramname">kUnlockNode</td><td>Lock query on an unlock event. </td></tr>
    <tr><td class="paramname">kAddAttr</td><td>Lock query on an add attribute event. </td></tr>
    <tr><td class="paramname">kRemoveAttr</td><td>Lock query on an remove attribute event. </td></tr>
    <tr><td class="paramname">kRenameAttr</td><td>Lock query on an rename attribute event. </td></tr>
    <tr><td class="paramname">kUnlockAttr</td><td>Lock query on an unlock attribute event. </td></tr>
    <tr><td class="paramname">kLockAttr</td><td>Lock query on a lock attribute event. </td></tr>
    <tr><td class="paramname">kLast</td><td>Used for internal bounds checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedfd1b17f9333f8cc45430fae689d540"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCallbackId setNodeLockQueryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#abb201d9ec3d2a048854c7808bfd0da5b">MLockMessage::MLockEventFunction</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>clientData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This methods registers a callback that is invoked in any locking condition on node properties, e.g. </p>
<p>name, lock status, etc. When called, the API user can make a decision on how to handle the given locking situation. The programmer can either accept the default action, or they can deny the default action. The decision is returned through a decision variable which is passed to the callback function.</p>
<p>The callback function takes the following parameters:</p>
<ul>
<li><b>node</b> - The node that triggered the callback. </li>
<li><b>aux</b> - Any auxiliary data that may be needed, e.g. the attribute about to be added. </li>
<li><b>clientData</b> - User defined data passed to the callback function. </li>
<li><b>eventType</b> - Description of the event. </li>
<li><b>decision</b> - The decision that is made by the registered callback. A value of true accepts the default behavior. A value of false denies the default action.</li>
</ul>
<p>The meanings of the <b>node</b> and <b>aux</b> parameters for each eventType, and default actions associated with those event types, are as follows:</p>
<p>kRename</p>
<ul>
<li>node - The node that the user is attempting to rename. </li>
<li>aux - <a class="el" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63" title="Null Object for use as default argument. ">MObject::kNullObj</a> </li>
<li>default actions - If <b>node</b> is locked then the default action is to not allow the rename. Otherwise, if <b>node</b> is unlocked then <b>node</b> can be renamed.</li>
</ul>
<p>kDelete</p>
<ul>
<li>node - The node that the user is attempting to delete. </li>
<li>aux - <a class="el" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63" title="Null Object for use as default argument. ">MObject::kNullObj</a> </li>
<li>default actions - If <b>node</b> is locked then the default action is to not allow the delete. If <b>node</b> is unlocked then the <b>node</b> can be deleted.</li>
</ul>
<p>kLockNode</p>
<ul>
<li>node - The node that the user is attempting to lock. </li>
<li>aux - <a class="el" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63" title="Null Object for use as default argument. ">MObject::kNullObj</a> </li>
<li>default actions - If <b>node</b> is unlocked then the default action is to ALLOW the node to be locked. The callback is not invoked when the user tries to unlock an already unlocked node.</li>
</ul>
<p>kUnlockNode</p>
<ul>
<li>node - The node that the user is attempting to unlock. </li>
<li>aux - <a class="el" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63" title="Null Object for use as default argument. ">MObject::kNullObj</a> </li>
<li>default actions - If <b>node</b> is locked then the default action is to ALLOW the unlock. The callback is not invoked when the user tries to unlock an already unlocked node.</li>
</ul>
<p>kAddAttr</p>
<ul>
<li>node - The node that is having an attribute added. </li>
<li>aux - <a class="el" href="#!/url=./cpp_ref/class_m_object.html" title="Generic Class for Accessing Internal Maya Objects. ">MObject</a> of the attribute to be added. Note: the attribute does not belong to the node yet. You can only access the attribute information using <a class="el" href="#!/url=./cpp_ref/class_m_fn_attribute.html" title="Dependency node attribute function set. ">MFnAttribute</a>. </li>
<li>default actions - If <b>node</b> is locked then the default action is to not allow to the addition of <b>aux</b>. If <b>node</b> is unlocked then <b>aux</b> can be added to the node.</li>
</ul>
<p>kRemoveAttr</p>
<ul>
<li>node - The node that is having an attribute removed. </li>
<li>aux - The attribute to be removed. In certain situations the user is allowed to do a global delete, e.g. "deleteAttr -at AttrName [nodes]". In these cases the plug is not created until checks have been performed; so <b>aux</b> == <a class="el" href="#!/url=./cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63" title="Null Object for use as default argument. ">MObject::kNullObj</a>. </li>
<li>default actions - If <b>node</b> is locked then the default action is to not allow the attribute removal. If <b>node</b> is unlocked then <b>aux</b> can be removed.</li>
</ul>
<p>kRenameAttr</p>
<ul>
<li>node - The node that is having an attribute renamed. </li>
<li>aux - The attribute. </li>
<li>default actions - If <b>node</b> is locked then the default action is to not allow the rename. If <b>node</b> is unlocked then <b>aux</b> can be renamed.</li>
</ul>
<p>kUnlockAttr</p>
<ul>
<li>node - The node that is having an attribute unlocked. </li>
<li>aux - The attribute to be unlocked. </li>
<li>default actions - If <b>node</b> is locked then the default action is to not allow the unlock. If <b>node</b> is unlocked then <b>aux</b> attribute can be unlocked.</li>
</ul>
<p>kLockAttr</p>
<ul>
<li>node - The node that is having an attribute locked. </li>
<li>aux - The attribute to be locked. </li>
<li>default actions - If <b>node</b> is locked then the default action is to not allow the locking of <b>aux</b>. If <b>node</b> is unlocked then <b>aux</b> can be locked.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>- The node to register the callback for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>- Pointer to the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientData</td><td>- Client data that should be passed back to the callback. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>- status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique id for the callback.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kFailure</b> - Error registering callback. This can occur when another lock decision callback is already attached to the node. </li>
<li><b>MS::kInsufficientMemory</b> - Not enough memory to register the callback. </li>
<li><b>MS::kInvalidParameter</b> - The given node is not a valid node to register the callback on. </li>
<li><b>MS::kSuccess</b> - Callback successfully added. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0de04b5d479a6a1ae58aa5c3642e6cbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OPENMAYA_MAJOR_NAMESPACE_OPEN MCallbackId setNodeLockDAGQueryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;&#160;</td>
          <td class="paramname"><em>dagPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a133557aa9faa0b6e3d3ccd0713dd198a">MLockMessage::MLockDagEventFunction</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>clientData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This methods registers a callback that is invoked in any situation involving a locking condition on DAG level changes. </p>
<p>When called, the API user can make a decision on how to handle the given locking situation. The programmer can either accept the default action, or they can deny the default action. The decision is returned through a decision variable which is passed to the callback function.</p>
<p>The callback function takes the following parameters:</p>
<ul>
<li><b>dagPath</b> - The DAG path that the event occurred on. </li>
<li><b>otherPath</b> - The other path involved, e.g. the new parent. </li>
<li><b>clientData</b> - User defined data passed to the callback function. </li>
<li><b>eventType</b> - Description of the event. </li>
<li><b>decision</b> - The decision that is made by the registered callback. A value of true accepts the default behavior. A value of false rejects the default action.</li>
</ul>
<p>The meanings of the <b>dagPath</b> and <b>otherPath</b> parameters for each eventType, and default actions associated with those event types, are as follows:</p>
<p>kGroup</p>
<ul>
<li>dagPath - Path of the node to be grouped. </li>
<li>otherPath - Path of the group node. </li>
<li>default actions - If <b>dagPath</b> is locked then the default action is to not allow the grouping. If <b>dagPath</b> is unlocked then <b>dagPath</b> can be grouped with <b>otherPath</b>.</li>
</ul>
<p>kUnGroup</p>
<ul>
<li>dagPath - Path of the node attempted to ungroup. </li>
<li>otherPath - Path of the group node. </li>
<li>default actions - If <b>dagPath</b> is locked then the default action is to not allow the ungrouping. If <b>dagPath</b> is unlocked then <b>dagPath</b> can be ungrouped from <b>otherPath</b>.</li>
</ul>
<p>kReparent</p>
<ul>
<li>dagPath - Path of the node which is being reparented. </li>
<li>otherPath - Path of the new parent, if any. When reparenting to the world, otherPath will be invalid. </li>
<li>default actions - If <b>dagPath</b> is locked then the default action is to not allow the reparenting. If <b>dagPath</b> is unlocked then <b>dagPath</b> can be parented to <b>otherPath</b>.</li>
</ul>
<p>kChildReorder</p>
<ul>
<li>dagPath - Path of the child node to be reordered. </li>
<li>otherPath - Path of the parent node. </li>
<li>default actions - If <b>dagPath</b> is locked then the default action is to not allow the reordering. If <b>dagPath</b> is unlocked then <b>dagPath</b> can be reordered on <b>otherPath</b>.</li>
</ul>
<p>kCreateNodeInstance</p>
<ul>
<li>dagPath - Path of the node which is being instanced. </li>
<li>otherPath - Invalid Path. </li>
<li>default actions - If <b>dagPath</b> is locked then the default action is to not allow the instance to be created. If <b>dagPath</b> is unlocked then <b>dagPath</b> can be instanced.</li>
</ul>
<p>kCreateChildInstance</p>
<ul>
<li>dagPath - Path of the node whose child is being instanced. </li>
<li>otherPath - Path of the child node. </li>
<li>default actions - If <b>dagPath</b> is locked then the default action is to not allow the instance to be created. If <b>dagPath</b> is unlocked then <b>dagPath</b> can be instanced.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dagPath</td><td>The path to attach the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>- Pointer to the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientData</td><td>Client data that should be passed back to the callback. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique id for the callback.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kFailure</b> - Error registering callback. This can occur when another DAG decision callback is already attached to the path. </li>
<li><b>MS::kInsufficientMemory</b> - Not enough memory to register the callback. </li>
<li><b>MS::kInvalidParameter</b> - The given path is not a valid path. </li>
<li><b>MS::kSuccess</b> - Callback successfully added. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a10e8657f446db107065ef13b68d92b37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCallbackId setPlugLockQueryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> &amp;&#160;</td>
          <td class="paramname"><em>plug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a88f7c3225d27f3705acc502378810f6b">MLockMessage::MLockPlugEventFunction</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>clientData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method registers a callback that is invoked in any locking condition on a plug, e.g. </p>
<p>plug unlock, plug lock, connections, etc. When the callback is invoked, the API programmer can make a decision on how to handle the given locking situation. The programmer can either accept the default action, or they can deny the default action. The decision is made through the decision variable described above.</p>
<p>The callback function takes the following parameters:</p>
<ul>
<li><b>plug</b> - The plug that triggered the callback. </li>
<li><b>otherPlug</b> - The other plug involved in the callback. This is only valid during connect and disconnect events. </li>
<li><b>clientData</b> - User defined data passed to the callback function. </li>
<li><b>eventType</b> - Description of the event. </li>
<li><b>decision</b> - The decision that is made by the registered callback. A value of true accepts the default behavior. A value of false denies the default action.</li>
</ul>
<p>The meanings of the <b>plug</b> and <b>otherPlug</b> parameters for each eventType, and default actions associated with those event types, are as follows:</p>
<p>kPlugLockAttr</p>
<ul>
<li>plug - The plug that the user is attempting to lock. </li>
<li>otherPlug - NULL plug. </li>
<li>default actions - If <b>plug</b> is unlocked then the default action is to allow the plug to be locked.</li>
</ul>
<p>kPlugUnlockAttr</p>
<ul>
<li>plug - The plug that the user is attempting to unlock. </li>
<li>otherPlug - NULL plug. </li>
<li>default actions - If <b>plug</b> is locked then the default action is to allow the plug to be unlocked.</li>
</ul>
<p>kPlugAttrValChange</p>
<ul>
<li>plug - The plug that the user is attempting to change. </li>
<li>otherPlug - NULL plug. </li>
<li>default actions - If <b>plug</b> is locked then the default action is to not allow <b>plug</b> to change. If <b>plug</b> is unlocked then <b>plug</b> can change.</li>
</ul>
<p>kPlugRemoveAttr</p>
<ul>
<li>plug - The plug that the user is attempting to remove. </li>
<li>otherPlug - NULL plug. </li>
<li>default actions - If <b>plug</b> is locked then the default action is to not allow removal. Otherwise, if <b>plug</b> is unlocked then <b>plug</b> can be removed.</li>
</ul>
<p>kPlugRenameAttr</p>
<ul>
<li>plug - The plug that the user is attempting to rename. </li>
<li>otherPlug - NULL plug. </li>
<li>default actions - If <b>plug</b> is locked then the default action is to not allow the rename. Otherwise, if <b>plug</b> is unlocked then <b>plug</b> can be renamed.</li>
</ul>
<p>kPlugConnect</p>
<ul>
<li>plug - The plug that is to be connected (incoming connection). </li>
<li>otherPlug - The source plug of the connection being made. </li>
<li>default actions - If <b>plug</b> is locked then the connection is DENIED. If <b>plug</b> is unlocked then <b>otherPlug</b> can be connected to <b>plug</b>.</li>
</ul>
<p>kPlugDisconnect</p>
<ul>
<li>plug - The plug that it is having an incoming connection broken. </li>
<li>otherPlug - The source plug of the connection being made. </li>
<li>default actions - If <b>plug</b> is locked then the default action is to DENY the connection from being broken. If <b>plug</b> is unlocked then <b>otherPlug</b> can be disconnected from <b>plug</b>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plug</td><td>- The plug to attach the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>- Pointer to the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientData</td><td>- Client data that should be passed back to the callback. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>- status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique id for the callback.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kFailure</b> - Error registering callback. This can occur when another callback is already attached to the plug. to the plug. </li>
<li><b>MS::kInsufficientMemory</b> - Not enough memory to register the callback. </li>
<li><b>MS::kInvalidParameter</b> - The given plug is not a valid plug to register the callback on. </li>
<li><b>MS::kSuccess</b> - Callback successfully added. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a49d6b6764584a809b6bb2be324c91dbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCallbackId setPlugLockQueryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_lock_message.html#a88f7c3225d27f3705acc502378810f6b">MLockMessage::MLockPlugEventFunction</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>clientData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method registers a callback that is invoked in any locking condition on any plug of a given node, e.g. </p>
<p>plug unlock, plug lock, connections, etc. When the callback is invoked, the API programmer can make a decision on how to handle the given locking situation. The programmer can either accept the default action, or they can deny the default action. The decision is returned through a decision variable which is passed to the callback function.</p>
<p>The callback function takes the following parameters:</p>
<ul>
<li><b>plug</b> - The plug that triggered the callback. </li>
<li><b>otherPlug</b> - The other plug involved in the callback. This is only valid during connect and disconnect events. </li>
<li><b>clientData</b> - User defined data passed to the callback function. </li>
<li><b>eventType</b> - Description of the event. </li>
<li><b>decision</b> - The decision that is made by the registered callback. A value of true accepts the default behavior. A value of false denies the default action.</li>
</ul>
<p>If a lock event occurs on a plug which has callbacks registered both on the plug itself, using the previous method, and on the entire node, using this method, then only the plug-specific callback will be called. This allows you to have both plug-specific and node-wide callbacks on a node while ensuring that the most specific callback is the one called.</p>
<p>The meanings of the <b>plug</b> and <b>otherPlug</b> parameters for each eventType, and the default actions associated with those event types, are described in the plug-specific version of the method, above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>- The node to attach the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>- Pointer to the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientData</td><td>- Client data that should be passed back to the callback. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>- status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique id for the callback.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd></dd></dl>
<ul>
<li><b>MS::kFailure</b> - Error registering callback. This can occur when a global watcher is already attached to the node. </li>
<li><b>MS::kInsufficientMemory</b> - Not enough memory to register the callback. </li>
<li><b>MS::kInvalidParameter</b> - The given node is not a valid node to register the callback on. </li>
<li><b>MS::kSuccess</b> - Callback successfully added. </li>
</ul>

</div>
</div>
<a class="anchor" id="a774cd5d8fbebe8e7ed82a5aa587d1f04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * className </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class. </dd></dl>

</div>
</div>
<hr>The documentation for this class was generated from the following files:<ul>
<li>MLockMessage.h</li>
<li>MLockMessage.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->

      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

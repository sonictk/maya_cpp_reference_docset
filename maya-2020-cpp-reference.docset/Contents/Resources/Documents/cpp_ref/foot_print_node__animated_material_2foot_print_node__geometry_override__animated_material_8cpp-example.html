<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script>
      <title>C++ API Reference: footPrintNode_AnimatedMaterial/footPrintNode_GeometryOverride_AnimatedMaterial.cpp</title>
      
	  
      
      
      
      
      
      
      
    

</head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('foot_print_node__animated_material_2foot_print_node__geometry_override__animated_material_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script>
      <div>
         <div class="head">
            <h1>C++ API Reference: footPrintNode_AnimatedMaterial/footPrintNode_GeometryOverride_AnimatedMaterial.cpp</h1>
         </div>

<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->

  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="cpp_ref/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="cpp_ref/search/close.png" alt=""></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<!-- window showing the filter options -->


<!-- iframe showing the search results (closed by default) -->


<div class="header">
  <div class="headertitle">
<div class="title">footPrintNode_AnimatedMaterial/footPrintNode_GeometryOverride_AnimatedMaterial.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"><span class="comment">// Copyright 2019 Autodesk, Inc.  All rights reserved.</span></div>
<div class="line"><span class="comment">// Use of this software is subject to the terms of the Autodesk license agreement</span></div>
<div class="line"><span class="comment">// provided at the time of installation or download, or which otherwise</span></div>
<div class="line"><span class="comment">// accompanies this software in either electronic or hard copy form.</span></div>
<div class="line"><span class="comment">// ==========================================================================</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MString.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MTypeId.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPlug.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPlugArray.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDataBlock.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDataHandle.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MColor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnPlugin.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDistance.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnUnitAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnNumericAttribute.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MFnDependencyNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPxLocatorNode.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MGlobal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDagMessage.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MEvaluationManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MEvaluationNode.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Viewport 2.0 includes</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MDrawRegistry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MPxGeometryOverride.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MShaderManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHWGeometry.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MHWGeometryUtilities.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;maya/MUserData.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">TOPICS: Customized Rendering ; Animated Material ; Viewport Caching (VP2 Custom Caching)</span></div>
<div class="line"><span class="comment">DESCRIPTION:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">This plug-in demonstrates how to : </span></div>
<div class="line"><span class="comment">1. Draw simple Animated Material like animated color in an efficient and cache-friendly way.</span></div>
<div class="line"><span class="comment">2. Support Evaluation &amp; Viewport Cache for nodes with customized rendering.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">This plugin uses different techniques to optimize the performance of the foot print draw</span></div>
<div class="line"><span class="comment">in VP2.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Technique 1:</span></div>
<div class="line"><span class="comment">Forcing the renderer requested attributes to be evaluated and cached by EM.</span></div>
<div class="line"><span class="comment">Aka, define a &#39;rendering-required-attribute&#39;.</span></div>
<div class="line"><span class="comment">This is usually a must-have for any custom rendering nodes.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Technique 1.1:</span></div>
<div class="line"><span class="comment">Geometry-change tracking with &quot;always-return-true&quot; attribute.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Technique 2:</span></div>
<div class="line"><span class="comment">Use VP2 shader&#39;s PreDrawCallback to do simple animated material.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Technique 3:</span></div>
<div class="line"><span class="comment">Use Evaluation-cache to store the constant buffer + Viewport-cache to store the vertex buffer.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Code structure:</span></div>
<div class="line"><span class="comment">    - class FootPrintNode</span></div>
<div class="line"><span class="comment">        The DAG node that representing the customize rendering geometry.</span></div>
<div class="line"><span class="comment">        Evaluation caching should be fully implemented here.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    - class FootPrintGeometryOverrideAnimatedMaterial</span></div>
<div class="line"><span class="comment">        The customized rendering logic for FootPrintNode.</span></div>
<div class="line"><span class="comment">        Viewport caching is handled in here.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    - class AnimatedColorShader</span></div>
<div class="line"><span class="comment">        Helper class encapsulated a shader with a proper PreDrawCallback</span></div>
<div class="line"><span class="comment">        Which implemented Animated Material along with FootPrintGeometryOverrideAnimatedMaterial</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">USAGE:</span></div>
<div class="line"><span class="comment">```MEL</span></div>
<div class="line"><span class="comment">    loadPlugin footPrintNode_GeometryOverride_AnimatedMaterial;</span></div>
<div class="line"><span class="comment">    createNode footPrint_GeometryOverride_AnimatedMaterial;</span></div>
<div class="line"><span class="comment">```</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Plugin identifiers</span></div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gPluginNodeId                 = 0x00080033;</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>   gPluginNodeName[]             = <span class="stringliteral">&quot;footPrint_GeometryOverride_AnimatedMaterial&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>   gPluginDrawDbClassification[] = <span class="stringliteral">&quot;drawdb/geometry/footPrint_GeometryOverride_AnimatedMaterial&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>   gPluginDrawRegistrantId[]     = <span class="stringliteral">&quot;footPrintNode_GeometryOverride_AnimatedMaterialPlugin&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>   gPluginSelectionMask[]        = <span class="stringliteral">&quot;footPrintSelection&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>   gPluginNodeMessagePrefix[]    = <span class="stringliteral">&quot;FootPrintGeometryOverrideAnimatedMaterial: &quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Node implementation with standard viewport draw</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// Proxy node for drawing procedure foot print geometry</span></div>
<div class="line"><span class="comment">// This node contains two input attribute : &quot;Size&quot; and &quot;Color&quot;</span></div>
<div class="line"><span class="comment">// - Changing the &quot;Size&quot; attribute will cause the viewport to regenerate its geometry data (animated vertex buffer)</span></div>
<div class="line"><span class="comment">// - Changing the &quot;Color&quot; attribute reset the shader param without reseting the whole shader (animated material/constant-buffer)</span></div>
<div class="line"><span class="comment">// The rendering logic is specified in &quot;class FootPrintGeometryOverrideAnimatedMaterial&quot;</span></div>
<div class="line"><span class="keyword">class </span>FootPrintNode : <span class="keyword">public</span> <a name="_a0"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_locator_node.html">MPxLocatorNode</a> <span class="comment">// Or MPxSurfaceShape</span></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Node Attributes :</span></div>
<div class="line">    <span class="comment">// Attribute table                          //  &#39;Alias&#39;     I/O     Data-Type   Function body (in lambda format)</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Controls the size of the footprint geometry</span></div>
<div class="line">    <span class="keyword">static</span>  <a name="_a1"></a><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>         inputSize;          <span class="comment">// &#39;isz&#39;        Input   Distance</span></div>
<div class="line">    <span class="keyword">static</span>  <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>         outputSize;         <span class="comment">// &#39;sz&#39;         Output  Distance    : outputSize        = [](inputSize) -&gt; {return inputSize;}</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Controls the color of the footprint</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>          inputColor;         <span class="comment">// &#39;ic&#39;         Input   Color</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>          outputColor;        <span class="comment">// &#39;oc&#39;         Output  Color       : outputColor       = [](inputColor) -&gt; {return inputColor;}</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add your renderer-required-attributes here</span></div>
<div class="line">    <span class="comment">// static MObject          inputXX;</span></div>
<div class="line">    <span class="comment">// static MObject          outputXX;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Utility attribute for viewport</span></div>
<div class="line">    <span class="comment">// [[maya::storable(false)]] [[maya::connectable(false)]] [[maya::hidden]]</span></div>
<div class="line">    <span class="keyword">static</span>  <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>         geometryChanging;   <span class="comment">// &#39;gcg&#39;        Output  Bool        : geometryChanging  = [](inputSize) -&gt; {return true;} [*] check notes</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Attribute dependencies:</span></div>
<div class="line">    <span class="comment">//      inputColor  -&gt; outputColor</span></div>
<div class="line">    <span class="comment">//      inputSize   -&gt; outputSize</span></div>
<div class="line">    <span class="comment">//      inputSize   -&gt; geometryChanging </span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">//      * inputXX   -&gt; outputXX</span></div>
<div class="line">    <span class="comment">//      * inputXX   -&gt; geometryChanging (if XX affect the geometry)</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">// &quot;Logical&quot; dependencies (Technique 1):</span></div>
<div class="line">    <span class="comment">//      outputColor, outputSize, geometryChanging -&gt; [renderer]</span></div>
<div class="line">    <span class="comment">//      * outputXX -&gt; [renderer]</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">// Additional note:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Q :  Why is there outputSize / outputColor ? (Technique 1)</span></div>
<div class="line">    <span class="comment">// A :  Input attributes, like inputSize/inputColor cannot be cached by Evaluation Cache</span></div>
<div class="line">    <span class="comment">//      Check FootPrintNode::setDependentsDirty() for more details about this work-around</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Q :  &#39;outputXX&#39; is not updating in EM mode? (Technique 1)</span></div>
<div class="line">    <span class="comment">// A :  The virtual connections to [renderer] are not understand by EM.</span></div>
<div class="line">    <span class="comment">//      Add this connection to FootPrintNode::setDependentsDirty().</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Q :  &quot;geometryChanging&quot; always returns &#39;true&#39; ? (Technique 1.1)</span></div>
<div class="line">    <span class="comment">// A :  &quot;geometryChanging&quot; is a &quot;dirty flag attribute&quot; tracking if the node needs geometry-update</span></div>
<div class="line">    <span class="comment">//      If anything affecting it is changed, it will re-evaluate and return &#39;true&#39; </span></div>
<div class="line">    <span class="comment">//      This will notify the viewport that the geometry is changing, </span></div>
<div class="line">    <span class="comment">//      Then, it will be reset to &#39;false&#39; when geometry is updated (populateGeometry() is called)</span></div>
<div class="line">    <span class="comment">//      This allows us to track the dirty status without override setDependentsDirty() or postEvaluation()</span></div>
<div class="line">    <span class="comment">//      * Note, viewport will not reset its value in background evaluation (VP2 caching)</span></div>
<div class="line">    <span class="comment">//        Check requiresGeometryUpdate(), populateGeometry() for detail</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Override methods for depend node</span></div>
<div class="line">    FootPrintNode();</div>
<div class="line">    ~FootPrintNode() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <a name="_a2"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>         <a name="a3"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a6e1aa1e50774080d5aee55f20ffa5503">compute</a>( <span class="keyword">const</span> <a name="_a4"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, <a name="_a5"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a>&amp; data ) <span class="keyword">override</span>;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>         <a name="a6"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#abd7d1dad4e4f0b922bf5ac4fc9c0230a">setDependentsDirty</a>(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, <a name="_a7"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html">MPlugArray</a>&amp; plugArray) <span class="keyword">override</span>;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>         <a name="a8"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html#a93e355c11a2c9a0f19f8d7cfa887af2b">postEvaluation</a>(<span class="keyword">const</span>  <a name="_a9"></a><a class="code" href="#!/url=./cpp_ref/class_m_d_g_context.html">MDGContext</a>&amp; context, <span class="keyword">const</span> <a name="_a10"></a><a class="code" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a>&amp; evaluationNode, PostEvaluationType evalType) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span>            <a name="a11"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_locator_node.html#a7068b5cea353e8ed1ac2d27502f926ef">getCacheSetup</a>(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a>&amp; evalNode, <a name="_a12"></a><a class="code" href="#!/url=./cpp_ref/class_m_node_cache_disabling_info.html">MNodeCacheDisablingInfo</a>&amp; disablingInfo, <a name="_a13"></a><a class="code" href="#!/url=./cpp_ref/class_m_node_cache_setup_info.html">MNodeCacheSetupInfo</a>&amp; cacheSetupInfo, <a name="_a14"></a><a class="code" href="#!/url=./cpp_ref/class_m_object_array.html">MObjectArray</a>&amp; monitoredAttributes) <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Do not override postEvaluation() to force evaluating &#39;rendering-required-attribute&#39;.</span></div>
<div class="line">    <span class="comment">// Check Technique 1 for how to do this.</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span>            <a name="a15"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_locator_node.html#a4254418493ef1ab6847b9e5f395fa3de">isBounded</a>()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <a name="_a16"></a><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>    <a name="a17"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_locator_node.html#a762dab569a9d88aa731f3c7229803e1e">boundingBox</a>() <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line">    <a name="_a18"></a><a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html">MSelectionMask</a>  <a name="a19"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_locator_node.html#acedd5e97c21aacfc5f976499438c7fa8">getShapeSelectionMask</a>()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html">MSelectionMask</a>(gPluginSelectionMask); }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span>  <span class="keywordtype">void</span> *  creator() { <span class="keywordflow">return</span> <span class="keyword">new</span> FootPrintNode(); }</div>
<div class="line">    <span class="keyword">static</span>  <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> initialize();</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Data defines the custom shape, which decides the generated geometry&#39;s vertex buffer</span></div>
<div class="line">    <span class="comment">// This only contains geometry data, material and appearance data should not be contained here </span></div>
<div class="line">    <span class="comment">// E.g. Outer Radius R and inner radius r for a torus shape</span></div>
<div class="line">    <span class="keyword">struct </span>GeometryParameters</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">double</span> Size;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Methods for the renderer to call</span></div>
<div class="line">    <a name="_a20"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>              renderColor() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span>                isGeometryChanging() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span>                updateRenderAttributes();</div>
<div class="line">    GeometryParameters  updatingGeometry();</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span>    <a name="_a21"></a><a class="code" href="#!/url=./cpp_ref/class_m_type_id.html">MTypeId</a>     id;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span>    <a name="_a22"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>     drawDbClassification;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span>    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>     drawRegistrantId;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span>    <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a>     drawDbLightClassification;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> FootPrintNode::outputSize       = {};</div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> FootPrintNode::inputSize        = {};</div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> FootPrintNode::inputColor       = {};</div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> FootPrintNode::outputColor      = {};</div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> FootPrintNode::geometryChanging = {};</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_type_id.html">MTypeId</a> FootPrintNode::id                   = gPluginNodeId;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> FootPrintNode::drawDbClassification = gPluginDrawDbClassification;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> FootPrintNode::drawRegistrantId     = gPluginDrawRegistrantId;</div>
<div class="line"></div>
<div class="line">FootPrintNode::FootPrintNode() {}</div>
<div class="line">FootPrintNode::~FootPrintNode() {}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> FootPrintNode::compute( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, <a class="code" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a>&amp; data )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Check documentation in &quot;class FootPrintNode&quot; for descriptions about the attributes here</span></div>
<div class="line">    <span class="keywordflow">if</span> (plug.<a name="a23"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a3694e3dcc355fb7d654a0bb6a8a3ff1c">partialName</a>() == <span class="stringliteral">&quot;sz&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">        <a name="_a24"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html">MDataHandle</a> inputSizeHandle = data.<a name="a25"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(inputSize, &amp;status);</div>
<div class="line">        <span class="keywordflow">if</span> (status != <a name="a26"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) <span class="keywordflow">return</span> status;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html">MDataHandle</a> sizeHandle = data.<a name="a27"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(outputSize, &amp;status);</div>
<div class="line">        <span class="keywordflow">if</span> (status != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) <span class="keywordflow">return</span> status;</div>
<div class="line"></div>
<div class="line">        sizeHandle.<a name="a28"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#ac9331e2baa99db78393811c850c0afab">copy</a>(inputSizeHandle);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a3694e3dcc355fb7d654a0bb6a8a3ff1c">partialName</a>() == <span class="stringliteral">&quot;ocl&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html">MDataHandle</a> inputColorHandle = data.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(inputColor, &amp;status);</div>
<div class="line">        <span class="keywordflow">if</span> (status != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) <span class="keywordflow">return</span> status;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html">MDataHandle</a> colorHandle = data.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(outputColor, &amp;status);</div>
<div class="line">        <span class="keywordflow">if</span> (status != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) <span class="keywordflow">return</span> status;</div>
<div class="line"></div>
<div class="line">        colorHandle.<a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#ac9331e2baa99db78393811c850c0afab">copy</a>(inputColorHandle);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a3694e3dcc355fb7d654a0bb6a8a3ff1c">partialName</a>() == <span class="stringliteral">&quot;gcg&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html">MDataHandle</a> boolHandle = data.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(geometryChanging, &amp;status);</div>
<div class="line">        <span class="keywordflow">if</span> (status != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) <span class="keywordflow">return</span> status;</div>
<div class="line">        boolHandle.<a name="a29"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#ad1c723b684b73109b0918a3dd8984340">setBool</a>(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> MS::kUnknownParameter;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Technique 1: Hack the EM to force evaluate and cache attributes.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    To improve performance, Evaluation Manager aggressively skips evaluation of attributes which are not connected to other nodes.</span></div>
<div class="line"><span class="comment">    In cases where an external user of DG data (in this case the renderer) </span></div>
<div class="line"><span class="comment">    needs to read unconnected values from a node during or after EM evaluation,</span></div>
<div class="line"><span class="comment">    we need to take extra steps to ensure the data is evaluated by the EM (and cached).</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    The most notable rules used by the EM for skipping evaluation are:</span></div>
<div class="line"><span class="comment">        1. Output attributes without output-connections are not computed in EM (and are not eligible for caching).</span></div>
<div class="line"><span class="comment">        2. Input attributes are never cached in Evaluation Cache.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    In FootPrintNode, attributes &quot;outputSize&quot;, &quot;outputColor&quot;, &quot;geometryChanging&quot; are virtually connected to the renderer.</span></div>
<div class="line"><span class="comment">    But EM does not understand these &quot;virtual connection&quot;, and skips evaluation and caching for them.</span></div>
<div class="line"><span class="comment">    The current workaround are:</span></div>
<div class="line"><span class="comment">    1. To bypass rule 2, we made them a passing-through output attributes : inputSize-&gt;outputSize, inputColor-&gt;outputColor</span></div>
<div class="line"><span class="comment">    2. To bypass rule 1, repeat the affect relationship in setDependentsDirty(). [*]</span></div>
<div class="line"><span class="comment">        [*] Note, this is a trick that relies on some internal hack to EM.</span></div>
<div class="line"><span class="comment">            Maya may provide better API for this in future updates. </span></div>
<div class="line"><span class="comment">            When proper force evaluation API is come, you won&#39;t need to override this method.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> FootPrintNode::setDependentsDirty(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a>&amp; plug, <a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html">MPlugArray</a>&amp; plugArray)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Repeating the affect relationship we have specified</span></div>
<div class="line">    <span class="comment">// This method just mean to trick EM</span></div>
<div class="line">    <span class="comment">// No need to do this outside of EM graph construction (for the sake of performance)</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a name="a30"></a><a class="code" href="#!/url=./cpp_ref/class_m_evaluation_manager.html#aedb4df14a76f10672127a768071670f5">MEvaluationManager::graphConstructionActive</a>())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (plug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a3694e3dcc355fb7d654a0bb6a8a3ff1c">partialName</a>() == <span class="stringliteral">&quot;isz&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> thisNode = thisMObject();</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> osPlug(thisNode, outputSize);</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> scPlug(thisNode, geometryChanging);</div>
<div class="line">            plugArray.<a name="a31"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html#a12338b7a1987007e931b031646c9b4be">append</a>(osPlug);</div>
<div class="line">            plugArray.<a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html#a12338b7a1987007e931b031646c9b4be">append</a>(scPlug);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> parentPlug = plug.<a name="a32"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#aa2338038d1c59dc4d35f37f918aabfab">parent</a>(&amp;status);</div>
<div class="line">        <span class="keywordflow">if</span> (plug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a3694e3dcc355fb7d654a0bb6a8a3ff1c">partialName</a>() == <span class="stringliteral">&quot;ic&quot;</span> || (!parentPlug.<a name="a33"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ab7ec149d38b7c29ca55c5aa7b407d8f9">isNull</a>() &amp;&amp; parentPlug.<a class="code" href="#!/url=./cpp_ref/class_m_plug.html#a3694e3dcc355fb7d654a0bb6a8a3ff1c">partialName</a>() == <span class="stringliteral">&quot;ic&quot;</span>))</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> thisNode = thisMObject();</div>
<div class="line">            <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> ocPlug(thisNode, outputColor);</div>
<div class="line">            plugArray.<a class="code" href="#!/url=./cpp_ref/class_m_plug_array.html#a12338b7a1987007e931b031646c9b4be">append</a>(ocPlug);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Try not set any data or attribute value in this method</span></div>
<div class="line">    <span class="comment">// Because EM&#39;s parallel evaluation will not call this method at all</span></div>
<div class="line">    <span class="comment">// A widely used *bad* approach is to write &quot;mGeometryChanged=true&quot; when some attribute changed.</span></div>
<div class="line">    <span class="comment">// Use Technique 1.1 to avoid this.</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> FootPrintNode::postEvaluation(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_d_g_context.html">MDGContext</a> &amp; context, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a> &amp; evaluationNode, PostEvaluationType evalType)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// For cache restoration only</span></div>
<div class="line">    <span class="comment">// This method is responsible for fixing the &#39;geometryChanging&#39; flag in cache restore frames</span></div>
<div class="line">    <span class="comment">// Because in cache store phase,</span></div>
<div class="line">    <span class="comment">// PopulateGeometry &amp; Viewport-Caching happens before Evaluation-Cache store</span></div>
<div class="line">    <span class="comment">// The value of &#39;geometryChanging&#39; will always be set to &#39;false&#39; (it is already used by render)</span></div>
<div class="line">    <span class="comment">// Thus, we have to fix the geometryChanging attribute to the correct value </span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status;</div>
<div class="line">    <span class="keywordflow">if</span> (evalType == PostEvaluationEnum::kEvaluatedDirectly &amp;&amp; <span class="comment">// kEvaluatedDirectly indicates we are restoring from cache</span></div>
<div class="line">        evaluationNode.<a name="a34"></a><a class="code" href="#!/url=./cpp_ref/class_m_evaluation_node.html#abc632b073f3b3abeb4ca052f20573dd6">dirtyPlugExists</a>(geometryChanging,&amp;status) &amp;&amp; status)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a> data = forceCache();</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html">MDataHandle</a> boolHandle = data.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(geometryChanging, &amp;status);</div>
<div class="line">        <span class="keywordflow">if</span> (status != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) <span class="keywordflow">return</span> status;</div>
<div class="line">        boolHandle.<a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#ad1c723b684b73109b0918a3dd8984340">setBool</a>(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> FootPrintNode::getCacheSetup(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a>&amp; evalNode, <a class="code" href="#!/url=./cpp_ref/class_m_node_cache_disabling_info.html">MNodeCacheDisablingInfo</a>&amp; disablingInfo, <a class="code" href="#!/url=./cpp_ref/class_m_node_cache_setup_info.html">MNodeCacheSetupInfo</a>&amp; cacheSetupInfo, <a class="code" href="#!/url=./cpp_ref/class_m_object_array.html">MObjectArray</a>&amp; monitoredAttributes)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_px_locator_node.html#a7068b5cea353e8ed1ac2d27502f926ef">MPxLocatorNode::getCacheSetup</a>(evalNode, disablingInfo, cacheSetupInfo, monitoredAttributes);</div>
<div class="line">    assert(!disablingInfo.<a name="a35"></a><a class="code" href="#!/url=./cpp_ref/class_m_node_cache_disabling_info.html#a7a82d4f610253dd0b96d95e59153a429">getCacheDisabled</a>());</div>
<div class="line">    cacheSetupInfo.<a name="a36"></a><a class="code" href="#!/url=./cpp_ref/class_m_node_cache_setup_info.html#aa8e8aa3d550475221be89a27e48df13e">setPreference</a>(MNodeCacheSetupInfo::kWantToCacheByDefault, <span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a> FootPrintNode::boundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Get the outputSize</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> thisNode = thisMObject();</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_plug.html">MPlug</a> plug( thisNode, outputSize );</div>
<div class="line">    <a name="_a37"></a><a class="code" href="#!/url=./cpp_ref/class_m_distance.html">MDistance</a> sizeVal;</div>
<div class="line">    plug.<a name="a38"></a><a class="code" href="#!/url=./cpp_ref/class_m_plug.html#ab017c746e6e0c13bf994b2458d3b5eee">getValue</a>( sizeVal );</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> multiplier = sizeVal.<a name="a39"></a><a class="code" href="#!/url=./cpp_ref/class_m_distance.html#ace39ab92685b0f5ab1a2925e748efb1f">asCentimeters</a>();</div>
<div class="line"></div>
<div class="line">    <a name="_a40"></a><a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> corner1( -0.17, 0.0, -0.7 );</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_point.html">MPoint</a> corner2( 0.17, 0.0, 0.3 );</div>
<div class="line"></div>
<div class="line">    corner1 = corner1 * multiplier;</div>
<div class="line">    corner2 = corner2 * multiplier;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_bounding_box.html">MBoundingBox</a>( corner1, corner2 );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the footprint instance&#39;s color for rendering</span></div>
<div class="line"><span class="comment">// This code should only be called by a shader&#39;s PreDrawCallback</span></div>
<div class="line"><span class="comment">// See also, AnimatedColorShader::ShaderPreDrawCallback()</span></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> FootPrintNode::renderColor()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// The data block should always be ready in render time</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a> block = <span class="keyword">const_cast&lt;</span>FootPrintNode*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;forceCache();</div>
<div class="line">    <span class="comment">// Technique: Use outputValue() to read the attribute&#39;s value as-is (no evaluation)</span></div>
<div class="line">    <span class="comment">//      Never use inputValue() in renderer callbacks (except UpdateDG)</span></div>
<div class="line">    <a name="_a41"></a><a class="code" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> color = block.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(outputColor).<a name="a42"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a5e7d49f6ed0e237f1e9e43b639f06d07">asFloatVector</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>(color[0], color[1], color[2]);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Must be called after MPxGeometryOverride::updateDG()</span></div>
<div class="line"><span class="comment">// Typically used by MPxGeometryOverride::requiresGeometryUpdate()</span></div>
<div class="line"><span class="keywordtype">bool</span> FootPrintNode::isGeometryChanging()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a> block = <span class="keyword">const_cast&lt;</span>FootPrintNode*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;forceCache();</div>
<div class="line">    <span class="comment">// Use inputValue() to trigger evaluation here</span></div>
<div class="line">    <span class="comment">// Because MPxGeometryOverride::requiresGeometryUpdate() can be called outside of</span></div>
<div class="line">    <span class="comment">// MPxGeometryOverride::initialize()/updateDG()</span></div>
<div class="line">    <span class="comment">// This evaluation is safe because this attribute cannot be connected</span></div>
<div class="line">    <span class="comment">// And thus cannot reach other nodes</span></div>
<div class="line">    <span class="keywordflow">return</span> block.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(FootPrintNode::geometryChanging).<a name="a43"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a69fdebf4dcdf33c1b313eb4a426e0d45">asBool</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Workload for MPxGeometryOverride::updateDG()</span></div>
<div class="line"><span class="comment">// Updating all the attributes needed by the renderer</span></div>
<div class="line"><span class="comment">// Ensure these attributes can be accessed by outputValue() safely later</span></div>
<div class="line"><span class="keywordtype">void</span> FootPrintNode::updateRenderAttributes()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a> datablock = forceCache();</div>
<div class="line">    datablock.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(FootPrintNode::outputColor);</div>
<div class="line">    datablock.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(FootPrintNode::geometryChanging);</div>
<div class="line">    datablock.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#af4a356799acd4ed070d372ed7cfb4706">inputValue</a>(FootPrintNode::outputSize);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Should only be called from MPxGeometryOverride::populateGeometry()</span></div>
<div class="line"><span class="comment">// Returns the parameters required to update geometry</span></div>
<div class="line"><span class="comment">// Set &quot;FootPrintNode::geometryChanging&quot; to &quot;false&quot; to avoid duplicate update</span></div>
<div class="line"><span class="comment">// [[ensure : isGeometryChanging() == false]]</span></div>
<div class="line">FootPrintNode::GeometryParameters FootPrintNode::updatingGeometry()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_data_block.html">MDataBlock</a> block = <span class="keyword">const_cast&lt;</span>FootPrintNode*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;forceCache();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Reset the geometryChanging attribute to false so that we do not update the geometry multiple times</span></div>
<div class="line">    block.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(FootPrintNode::geometryChanging).<a name="a44"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#a2a75482f517f405a641c0eee0bd995ac">set</a>(<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">    GeometryParameters param;</div>
<div class="line">    param.Size = block.<a class="code" href="#!/url=./cpp_ref/class_m_data_block.html#a5e4082d6ab961bee4ec0281676bb4834">outputValue</a>(FootPrintNode::outputSize).<a name="a45"></a><a class="code" href="#!/url=./cpp_ref/class_m_data_handle.html#ab2badf40660ec1a0f391a1b1c515a0ce">asDistance</a>().<a class="code" href="#!/url=./cpp_ref/class_m_distance.html#ace39ab92685b0f5ab1a2925e748efb1f">asCentimeters</a>();</div>
<div class="line">    <span class="keywordflow">return</span> param;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="#!/url=./cpp_ref/namespace_m_h_w_render.html">MHWRender</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>ShaderDeleter {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a name="_a46"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader) {</div>
<div class="line">        <span class="keyword">auto</span>* rednerer = <a name="a47"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4678a72ac6959ed21d422d27928d0343">MRenderer::theRenderer</a>();</div>
<div class="line">        <span class="keyword">auto</span>* mgr = rednerer ? rednerer-&gt;getShaderManager() : <span class="keyword">nullptr</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (mgr)</div>
<div class="line">            mgr-&gt;releaseShader(shader);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Animated material shader (color)</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// This class encapsulated a MShaderInstance with a predefined PreDrawCallback</span></div>
<div class="line"><span class="comment">// So that we can update the shader&#39;s simple-parameters when time change</span></div>
<div class="line"><span class="comment">// In this case, the shader&#39;s PreDrawCallback will always update the shader&#39;s &quot;solidColor&quot; parameter</span></div>
<div class="line"><span class="keyword">class </span>AnimatedColorShader {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Demand a solid color instance with the proper PreDrawCallback setup</span></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* <span class="keyword">get</span>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Release the shader</span></div>
<div class="line">    <span class="keywordtype">void</span> reset() { mAnimateColorShader.reset(); }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Shader Pre-draw callback for update the animated color</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> ShaderPreDrawCallback(<a name="_a48"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a>&amp; context, <span class="keyword">const</span> <a name="_a49"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a>&amp; renderItemList, <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a> *shader);</div>
<div class="line"></div>
<div class="line">    std::unique_ptr&lt;MShaderInstance, ShaderDeleter&gt; mAnimateColorShader;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom data attached to the MRenderItem created for FootPrintNode</span></div>
<div class="line"><span class="comment">// Contains simply a pointer back to the node</span></div>
<div class="line"><span class="comment">// Check AnimatedColorShader::ShaderPreDrawCallback() and FootPrintGeometryOverrideAnimatedMaterial::updateRenderItems() for detail</span></div>
<div class="line"><span class="keyword">class </span>FootprintNodeRenderItemData : <span class="keyword">public</span> <a name="_a50"></a><a class="code" href="#!/url=./cpp_ref/class_m_user_data.html">MUserData</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FootprintNodeRenderItemData(FootPrintNode* node) : Node(node), <a class="code" href="#!/url=./cpp_ref/class_m_user_data.html">MUserData</a>(false) {}</div>
<div class="line">    FootPrintNode* Node;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// A simple store for sharing solid-color-shader with the given color</span></div>
<div class="line"><span class="comment">// This class is not memory-efficient</span></div>
<div class="line"><span class="comment">// One should add recycling mechanism for production usage</span></div>
<div class="line"><span class="keyword">class </span>SolidColorShaderStore {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* <span class="keyword">get</span>(<a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> color);</div>
<div class="line">    <span class="keywordtype">void</span> clear() { mShaders.clear(); }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> std::uint32_t encode(<a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> color);</div>
<div class="line">    std::unordered_map&lt;std::uint32_t, std::unique_ptr&lt;MShaderInstance, ShaderDeleter&gt;&gt; mShaders; <span class="comment">// Map a R8B8G8A8 color to a shader instance</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Global variables shared by all Footprint nodes</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// Do not use C++ class as global variables, because .dll/.so&#39;s actual unload time is managed by the OS</span></div>
<div class="line"><span class="comment">// Having a non-trivial DLL exit function called at a bad time may CRASH Maya</span></div>
<div class="line"><span class="comment">// And you should put all the startup / cleanup work in the initializePlugin() / uninitializePlugin() function</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Details:</span></div>
<div class="line"><span class="comment">// Case 1 : User is unloading this plugin without closing Maya</span></div>
<div class="line"><span class="comment">//          Everything goes well, uninitializePlugin() is called before the global variable destructor</span></div>
<div class="line"><span class="comment">//          We need to ensure all memories and shaders are being released</span></div>
<div class="line"><span class="comment">//          uninitializePlugin() will call Globals-&gt;clear() to clear everything</span></div>
<div class="line"><span class="comment">// Case 2 : User is closing Maya with this plugin loaded</span></div>
<div class="line"><span class="comment">//          In this case, uninitializePlugin() will NOT be called</span></div>
<div class="line"><span class="comment">//          And calling MShaderManager::ReleaseShader will CRASH Maya at exit time</span></div>
<div class="line"><span class="comment">//          Thus, we just leave whatever memories we allocated as-is</span></div>
<div class="line"><span class="comment">//          Since the application is closing anyway</span></div>
<div class="line"><span class="keyword">struct </span>GlobalVariables {</div>
<div class="line">    <span class="comment">// A helper that shares all static solid color shader with same color (for drawing highlighted footprints)</span></div>
<div class="line">    SolidColorShaderStore solidColorShaderStore;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Note, do not use std::unique_ptr&lt;GlobalVariables&gt; here</span></div>
<div class="line"><span class="comment">// Because we don&#39;t release memory / shaders at Maya exit</span></div>
<div class="line"><span class="keyword">static</span> GlobalVariables* Globals = <span class="keyword">nullptr</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Internal constants</span></div>
<div class="line"><span class="comment">// Primitive type constants are OK to be declared globally</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="comment">/*constexpr*/</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> ColorParameterName = <span class="stringliteral">&quot;solidColor&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="comment">/*constexpr*/</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> WireframeItemName  = <span class="stringliteral">&quot;footPrintLocatorWires&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="comment">/*constexpr*/</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> ShadedItemName     = <span class="stringliteral">&quot;footPrintLocatorTriangles&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="comment">/*constexpr*/</span> <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a>  ErrorColor         = { 1.0F, 0.0F,0.0F,1.0F };</div>
<div class="line"></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Viewport 2 GeometryOverride class declaration</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Customized rendering logic of FootPrintNode</span></div>
<div class="line"><span class="comment">// - This class is responsible for generating the geometry (vertex buffer) from the procedure geometry (defined by FootPrintNode::Size)</span></div>
<div class="line"><span class="comment">// - Also handles the proper shader for rendering it ( animated color shader )</span></div>
<div class="line"><span class="comment">// Beside rendering, the functions for generating geometry is also a crucial part in Viewport Caching (in contrast with Evaluation Caching)</span></div>
<div class="line"><span class="keyword">class </span>FootPrintGeometryOverrideAnimatedMaterial : <span class="keyword">public</span> <a name="_a51"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html">MPxGeometryOverride</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html">MPxGeometryOverride</a>* Creator(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; obj) { <span class="keywordflow">return</span> <span class="keyword">new</span> FootPrintGeometryOverrideAnimatedMaterial(obj); }</div>
<div class="line">    ~FootPrintGeometryOverrideAnimatedMaterial() <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support configuration functions :</span></div>
<div class="line">    DrawAPI supportedDrawAPIs()<span class="keyword"> const override          </span>{ <span class="keywordflow">return</span> (DrawAPI::kOpenGL | DrawAPI::kDirectX11 | DrawAPI::kOpenGLCoreProfile); }</div>
<div class="line">    <span class="keywordtype">bool</span> hasUIDrawables()<span class="keyword"> const override                            </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> supportsEvaluationManagerParallelUpdate()<span class="keyword"> const override   </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="comment">// Supporting Viewport Caching (VP2 Custom Caching)</span></div>
<div class="line">    <span class="comment">//      Viewport Cache for customize rendering nodes is caching the geometry data </span></div>
<div class="line">    <span class="comment">//      generated by MPxGeometryOverride::populateGeometry()</span></div>
<div class="line">    <span class="comment">//      Like the graphics API, the geometry data is usually expressed in three different objects:</span></div>
<div class="line">    <span class="comment">//          - Vertex Buffer     :   Viewport Cache</span></div>
<div class="line">    <span class="comment">//          - Index Buffer      :   No cache, must be time-independent</span></div>
<div class="line">    <span class="comment">//          - Uniform Buffer    :   Evaluation Cache</span></div>
<div class="line">    <span class="comment">//      Currently, *only* Vertex Buffer can be cached in Viewport Cache </span></div>
<div class="line">    <span class="comment">//      And all the data in Uniform Buffer (shader parameters such as Color), must be stored in Evaluation Cache</span></div>
<div class="line">    <span class="comment">//      Viewport Caching is helpful if you are generating the geometry data in CPU</span></div>
<div class="line">    <span class="comment">//      For GPU generated geometry, the benefit is limited</span></div>
<div class="line">    <span class="comment">//      To make the Viewport caching works properly the following constraints must be meet</span></div>
<div class="line">    <span class="comment">//          - requiresUpdateRenderItems(path) always return &#39;false&#39; in background-dg-context.</span></div>
<div class="line">    <span class="comment">//          - requiresGeometryUpdate() always return &#39;true&#39; when restored from cache (if geometry is animated).</span></div>
<div class="line">    <span class="comment">//          - populateGeometry() should be context-safe</span></div>
<div class="line">    <span class="comment">//      Check these methods for more detail</span></div>
<div class="line">    <span class="keywordtype">bool</span> supportsVP2CustomCaching()<span class="keyword"> const override                  </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">void</span> configCache(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a>&amp; evalNode, <a name="_a52"></a><a class="code" href="#!/url=./cpp_ref/class_m_cache_schema.html">MCacheSchema</a>&amp; schema) <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Interaction with FootPrintNode</span></div>
<div class="line">    <span class="comment">//  - This is the only method you can call Mplug::getValue() or Mdatablock::inputValue()</span></div>
<div class="line">    <span class="comment">//  - This method can be empty (in EM modes), if you have setup the node correctly with Technique 1.</span></div>
<div class="line">    <span class="keywordtype">void</span> updateDG() <span class="keyword">override</span>;</div>
<div class="line">    <span class="comment">// For the best practice, this method should contains no status data</span></div>
<div class="line">    <span class="keywordtype">void</span> cleanUp()<span class="keyword"> override </span>{};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Render item functions, only involves in foreground rendering, should not affect VP2 Caching at all</span></div>
<div class="line">    <span class="keywordtype">bool</span> requiresUpdateRenderItems(<span class="keyword">const</span> <a name="_a53"></a><a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a>&amp; path) <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> updateRenderItems(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;path, <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a>&amp; list) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Geometry update functions, major entry for support VP2 Custom Caching</span></div>
<div class="line">    <span class="keywordtype">bool</span> requiresGeometryUpdate() <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> isIndexingDirty(<span class="keyword">const</span> <a name="_a54"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a> &amp;item)<span class="keyword"> override          </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; } <span class="comment">// Viewport Caching does not support index buffer change (animated topology)</span></div>
<div class="line">    <span class="keywordtype">void</span> populateGeometry(<span class="keyword">const</span> <a name="_a55"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry_requirements.html">MGeometryRequirements</a> &amp;requirements, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a> &amp;renderItems, <a name="_a56"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html">MGeometry</a> &amp;data) <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Debugging functions</span></div>
<div class="line">    <span class="keywordtype">bool</span> traceCallSequence() <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> handleTraceMessage(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;message) <span class="keyword">const override</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    FootPrintGeometryOverrideAnimatedMaterial(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; obj);</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Helpers for generating the footprint geometry</span></div>
<div class="line">    <span class="keywordtype">void</span> fillFootprintSolidIndices(<span class="keywordtype">int</span> numIndex, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * indices);</div>
<div class="line">    <span class="keywordtype">void</span> fillFootprintWireframeIndices(<span class="keywordtype">int</span> numIndex, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * indices);</div>
<div class="line">    <span class="keywordtype">void</span> fillFootPrintVertices(<span class="keywordtype">float</span> * vertices, <span class="keywordtype">float</span> outputSize);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// To ensure the plugin works well with Viewport and Evaluation Caching</span></div>
<div class="line">    <span class="comment">// We recommend to use a state-less MpxGeometryOverride:</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">//  - Store all time-dependent data on the attributes of corresponding Maya node, Instead of a data member in MpxGeometryOverride.</span></div>
<div class="line">    <span class="comment">//  - updateDG() pulls (evaluates) all the time-dependent data on node by &quot;MDataBlock::inputValue()&quot;,</span></div>
<div class="line">    <span class="comment">//    but *not* store them in a data member of MPxGeometryOverride</span></div>
<div class="line">    <span class="comment">//  - Always access the time-dependent data by &quot;MDataBlock::outputValue()&quot; in the renderer</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Backgrounds of the recommendation : </span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">// In this plugin example, we have 3 different pipeline stages involved:</span></div>
<div class="line">    <span class="comment">//  1. Node Evaluation</span></div>
<div class="line">    <span class="comment">//  2. Geometry Update (MPxGeometryOverride invocation)</span></div>
<div class="line">    <span class="comment">//  3. Rendering (Shader-pre-draw-callback invocation)</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">// With (Evaluation or Viewport) Caching, some surprising mixture of stages happen concurrently :</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">//  - Foreground thread : -- MPxGeometryOverride ------&gt;------ Shader Callback --------&gt;    (Rendering on frame 10)</span></div>
<div class="line">    <span class="comment">//  - Background thread : -------- Node Evaluation -----&gt;-- MPxGeometryOverride -------&gt;    (Viewport cache fill on frame 20)</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Accessing the same data directly cross stage boundaries can cause incorrect result or even crash maya.</span></div>
<div class="line">    <span class="comment">// Thus we must use different storage for each data in each DG context (frame).</span></div>
<div class="line">    <span class="comment">// And, a depend node&#39;s attribute are always isolated for different context.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Beside, within the MPxGeometryOverride invocation stage, it is not always safe to access its data member :</span></div>
<div class="line">    <span class="comment">// During Viewport Cache Restoration, requiresGeometryUpdate() is the only method get called. (No updateDG() call)</span></div>
<div class="line">    <span class="comment">// Thus the data must be stored in the node.</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    FootPrintNode*              mFootPrintNode;             <span class="comment">// The node we are rendering</span></div>
<div class="line">    AnimatedColorShader         mAnimateColorShader;        <span class="comment">// Shader for render the shaded item with animated color</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// VP2 GeometryOverride implementation</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line">FootPrintGeometryOverrideAnimatedMaterial::FootPrintGeometryOverrideAnimatedMaterial(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a>&amp; obj)</div>
<div class="line">: <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html">MPxGeometryOverride</a>(obj)</div>
<div class="line">, mFootPrintNode(nullptr)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> returnStatus;</div>
<div class="line">    <a name="_a57"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_dependency_node.html">MFnDependencyNode</a> dependNode(obj, &amp;returnStatus);</div>
<div class="line">    <span class="keywordflow">if</span> (returnStatus != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) <span class="keywordflow">return</span>;</div>
<div class="line">    <a name="_a58"></a><a class="code" href="#!/url=./cpp_ref/class_m_px_node.html">MPxNode</a>* footPrintNode = dependNode.userNode(&amp;returnStatus);</div>
<div class="line">    <span class="keywordflow">if</span> (returnStatus != <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>) footPrintNode = <span class="keyword">nullptr</span>;</div>
<div class="line">    mFootPrintNode = <span class="keyword">dynamic_cast&lt;</span>FootPrintNode*<span class="keyword">&gt;</span>(footPrintNode);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">FootPrintGeometryOverrideAnimatedMaterial::~FootPrintGeometryOverrideAnimatedMaterial()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> FootPrintGeometryOverrideAnimatedMaterial::configCache(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_evaluation_node.html">MEvaluationNode</a>&amp; evalNode, <a class="code" href="#!/url=./cpp_ref/class_m_cache_schema.html">MCacheSchema</a>&amp; schema)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Rendering uses the output color, so we have to make sure it is cached.</span></div>
<div class="line">    <span class="comment">// If Evaluation Cache is not enabled on this node, we have to add it</span></div>
<div class="line">    <span class="comment">// to the list of attributes to cache.</span></div>
<div class="line">    <span class="keywordflow">if</span> (evalNode.<a class="code" href="#!/url=./cpp_ref/class_m_evaluation_node.html#abc632b073f3b3abeb4ca052f20573dd6">dirtyPlugExists</a>(FootPrintNode::outputColor)) {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> status = schema.<a name="a59"></a><a class="code" href="#!/url=./cpp_ref/class_m_cache_schema.html#a6cc91575e783deab18bb3e1d6721ca02">add</a>(FootPrintNode::outputColor);</div>
<div class="line">        assert(status);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> FootPrintGeometryOverrideAnimatedMaterial::updateDG()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Pull (evaluate) all attributes in FootPrintNode node we will be using</span></div>
<div class="line">    <span class="comment">// Here is the list of attributes we are pulling : </span></div>
<div class="line">    <span class="comment">// - geometryChanging   : Needed by requiresGeometryUpdate()                To check if we needs to update the vertex and index buffer</span></div>
<div class="line">    <span class="comment">// - outputSize         : Needed by populateGeometry()                      To generate the geometry</span></div>
<div class="line">    <span class="comment">// - outputColor        : Needed by mAnimateColorShader.PreDrawCallback()   To draw the geometry</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// It is very important that all the attributes pulled from this method are cached (with Technique 1)</span></div>
<div class="line">    <span class="comment">// Otherwise Evaluation Cache will not work</span></div>
<div class="line">    <span class="comment">// In fact, this method is not needed by EM Evaluation modes</span></div>
<div class="line">    mFootPrintNode-&gt;updateRenderAttributes();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> FootPrintGeometryOverrideAnimatedMaterial::requiresUpdateRenderItems(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp; path)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Override this function if you need a more complicated animated-material behavior</span></div>
<div class="line">    <span class="comment">// For example, you will need to change this to `return true` if object&#39;s associated shader</span></div>
<div class="line">    <span class="comment">// is changing at every frame. (This could be very expensive)</span></div>
<div class="line">    <span class="comment">// Note, this method have to return &#39;false&#39; in most case, otherwise VP2 caching may not work</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> FootPrintGeometryOverrideAnimatedMaterial::updateRenderItems( <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a>&amp; path, <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a>&amp; list )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This method will only happen for rendering, but not VP2 caching</span></div>
<div class="line">    <span class="comment">// And it is usually call when the selection status of the object is changed</span></div>
<div class="line"></div>
<div class="line">    DisplayStatus displayStatus = MGeometryUtilities::displayStatus(path);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Simplify the display status to [active, normal]</span></div>
<div class="line">    <span class="keywordtype">bool</span> active =   displayStatus == DisplayStatus::kLead || </div>
<div class="line">                    displayStatus == DisplayStatus::kActive || </div>
<div class="line">                    displayStatus == DisplayStatus::kHilite || </div>
<div class="line">                    displayStatus == DisplayStatus::kActiveComponent;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader;</div>
<div class="line">    <span class="keywordflow">if</span> (active)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Get an static solid color shader for selection highlight</span></div>
<div class="line">        <span class="comment">// Note, by sharing the solid color shader, we allow VP2 to consolidate multiple geometries together during the drawing process</span></div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> color = MGeometryUtilities::wireframeColor(path);</div>
<div class="line">        shader = Globals-&gt;solidColorShaderStore.get(color);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Get the animated color shader</span></div>
<div class="line">        <span class="comment">// Traditionally, we will need to setup the shader&#39;s &quot;solidColor&quot; parameter here to implement animated material</span></div>
<div class="line">        <span class="comment">// This is very inefficient because it will cause a full set of &#39;render-item-change&#39;-&gt;&#39;geometry-change&#39;</span></div>
<div class="line">        <span class="comment">// And reseting all the assets loaded into VP2</span></div>
<div class="line">        <span class="comment">// Thus, we will use the ShaderPreDrawCallback here to reduce the cost</span></div>
<div class="line">        <span class="comment">// </span></div>
<div class="line">        <span class="comment">// The shader&#39;s PreDrawCallback is configured to set its &quot;solidColor&quot; parameter with &quot;FootPrintNode::renderColor()&quot; before drawing</span></div>
<div class="line">        <span class="comment">// Thus, we do not need to change the shader&#39;s color parameter here</span></div>
<div class="line">        <span class="comment">// Note, FootPrintNode::renderColor() will not evaluate the &quot;FootPrintNode::outputColor&quot; attribute</span></div>
<div class="line">        <span class="comment">// Thus, it is important to update the attribute in updateDG()</span></div>
<div class="line">        shader = mAnimateColorShader.get();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create the wireframe render item</span></div>
<div class="line">    <span class="keywordtype">int</span> index = list.<a name="a60"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a4cfe9fc51a24bca06d2619a55542f689">indexOf</a>(WireframeItemName);</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>* wireframeItem = <span class="keyword">nullptr</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (index &lt; 0)</div>
<div class="line">    {</div>
<div class="line">        wireframeItem = MRenderItem::Create(</div>
<div class="line">            WireframeItemName,</div>
<div class="line">            MRenderItem::DecorationItem,</div>
<div class="line">            MGeometry::kLines);</div>
<div class="line">        wireframeItem-&gt;<a name="a61"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a8e28487092f00765128c2ffdd43d0fe4">setDrawMode</a>(MGeometry::kWireframe);</div>
<div class="line">        wireframeItem-&gt;<a name="a62"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a1e9d2a5708b2231a8e72d22dc3be53fe">enable</a>(<span class="keyword">true</span>);</div>
<div class="line">        wireframeItem-&gt;<a name="a63"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a6e865e2cf5c9d818b1cbb99af2360c47">depthPriority</a>(MRenderItem::sDormantWireDepthPriority);</div>
<div class="line">        <span class="comment">// Attach a pointer back to the node, to retrieve the color at shader-pre-draw time</span></div>
<div class="line">        wireframeItem-&gt;<a name="a64"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a1c029ea3297c266381dce0c7b042b793">setCustomData</a>(<span class="keyword">new</span> FootprintNodeRenderItemData(mFootPrintNode));</div>
<div class="line">        list.<a name="a65"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a238f55e85f694b4f74535aaedc6ebe01">append</a>(wireframeItem);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        wireframeItem = list.<a name="a66"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(index);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (wireframeItem)</div>
<div class="line">    {</div>
<div class="line">        wireframeItem-&gt;<a name="a67"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#ad283b157fa4f6c40bceb9d398c53a72a">setShader</a>(shader);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>* shadedItem = <span class="keyword">nullptr</span>;</div>
<div class="line">    index = list.<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a4cfe9fc51a24bca06d2619a55542f689">indexOf</a>(ShadedItemName);</div>
<div class="line">    <span class="keywordflow">if</span> (index &lt; 0)</div>
<div class="line">    {</div>
<div class="line">        shadedItem = MRenderItem::Create(</div>
<div class="line">            ShadedItemName,</div>
<div class="line">            MRenderItem::DecorationItem,</div>
<div class="line">            MGeometry::kTriangles);</div>
<div class="line">        shadedItem-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a8e28487092f00765128c2ffdd43d0fe4">setDrawMode</a>((MGeometry::DrawMode)(MGeometry::kShaded | MGeometry::kTextured));</div>
<div class="line">        shadedItem-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a6e865e2cf5c9d818b1cbb99af2360c47">depthPriority</a>(MRenderItem::sDormantFilledDepthPriority);</div>
<div class="line">        shadedItem-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a1e9d2a5708b2231a8e72d22dc3be53fe">enable</a>(<span class="keyword">true</span>);</div>
<div class="line">        shadedItem-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a1c029ea3297c266381dce0c7b042b793">setCustomData</a>(<span class="keyword">new</span> FootprintNodeRenderItemData(mFootPrintNode));</div>
<div class="line">        list.<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a238f55e85f694b4f74535aaedc6ebe01">append</a>(shadedItem);</div>
<div class="line">    } <span class="keywordflow">else</span>{</div>
<div class="line">        shadedItem = list.<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(index);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the shader based on if it is selected</span></div>
<div class="line">    <span class="keywordflow">if</span> (shadedItem)</div>
<div class="line">    {</div>
<div class="line">        shadedItem-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#ad283b157fa4f6c40bceb9d398c53a72a">setShader</a>(shader);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Animated material implementations</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> AnimatedColorShader::ShaderPreDrawCallback(<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_draw_context.html">MDrawContext</a>&amp; context, <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a>&amp; renderItemList, <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a> *shader)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> color = ErrorColor;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the color from the render-item</span></div>
<div class="line">    <span class="comment">// Just check the first render item is sufficient in this case</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>* renderItem = renderItemList.<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(0);</div>
<div class="line">    <span class="keywordflow">if</span> (renderItemList.<a name="a68"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>() &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// You may want to use dynamic_cast for extra safty</span></div>
<div class="line">        <span class="keyword">auto</span> customData = <span class="keyword">static_cast&lt;</span>FootprintNodeRenderItemData*<span class="keyword">&gt;</span>(renderItem-&gt;<a name="a69"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#afd8b782f19e9508747c851a990d8f5db">customData</a>());</div>
<div class="line">        <span class="keyword">auto</span> footprint = customData ? customData-&gt;Node : <span class="keyword">nullptr</span>;</div>
<div class="line">        <span class="comment">// Note, the call `footprint-&gt;renderColor()` cannot invoke DG evaluation</span></div>
<div class="line">        color = footprint ? footprint-&gt;renderColor() : ErrorColor;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the color parameter for the shader</span></div>
<div class="line">    shader-&gt;<a name="a70"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef">setParameter</a>(ColorParameterName, &amp;color.<a name="a71"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* AnimatedColorShader::get() {</div>
<div class="line">    <span class="keywordflow">if</span> (mAnimateColorShader)</div>
<div class="line">        <span class="keywordflow">return</span> mAnimateColorShader.get();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader = <span class="keyword">nullptr</span>;</div>
<div class="line">    <a name="_a72"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line">    <span class="keywordflow">if</span> (renderer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a name="_a73"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html">MShaderManager</a>* shaderMgr = renderer-&gt;<a name="a74"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125">getShaderManager</a>();</div>
<div class="line">        <span class="keywordflow">if</span> (shaderMgr)</div>
<div class="line">        {</div>
<div class="line">            shader = shaderMgr-&gt;<a name="a75"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a8e4ad27d691969622af2b05d8c6213d9">getStockShader</a>(</div>
<div class="line">                MShaderManager::k3dSolidShader,</div>
<div class="line">                &amp;AnimatedColorShader::ShaderPreDrawCallback);</div>
<div class="line">            mAnimateColorShader.reset(shader);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> shader;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Encode a MColor with R8B8G8A8 encoding</span></div>
<div class="line">std::uint32_t SolidColorShaderStore::encode(<a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> color)</div>
<div class="line">{</div>
<div class="line">    constexpr <span class="keywordtype">int</span> bitsPerChannel = 8;</div>
<div class="line">    constexpr std::uint32_t mask = (1 &lt;&lt; bitsPerChannel) - 1;</div>
<div class="line">    <span class="keywordflow">return</span></div>
<div class="line">        (static_cast&lt;std::uint32_t&gt;(color.<a class="code" href="#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a> * mask) &lt;&lt; (bitsPerChannel * 0)) |</div>
<div class="line">        (<span class="keyword">static_cast&lt;</span>std::uint32_t<span class="keyword">&gt;</span>(color.<a name="a76"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html#a8cf17d727651616de6f2b79ef32170cd">g</a> * mask) &lt;&lt; (bitsPerChannel * 1)) |</div>
<div class="line">        (static_cast&lt;std::uint32_t&gt;(color.<a name="a77"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html#a83fc1af92e29717b4513d121b0c72c7d">b</a> * mask) &lt;&lt; (bitsPerChannel * 2)) |</div>
<div class="line">        (<span class="keyword">static_cast&lt;</span>std::uint32_t<span class="keyword">&gt;</span>(color.<a name="a78"></a><a class="code" href="#!/url=./cpp_ref/class_m_color.html#a4aec1a5be9d9a4a394a2e49e9744286e">a</a> * mask) &lt;&lt; (bitsPerChannel * 3));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get or create a solid color shader of the given color</span></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a> * SolidColorShaderStore::get(<a class="code" href="#!/url=./cpp_ref/class_m_color.html">MColor</a> color) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; stored = mShaders[encode(color)];</div>
<div class="line">    <span class="keywordflow">if</span> (!stored)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html">MShaderInstance</a>* shader = <span class="keyword">nullptr</span>;</div>
<div class="line">        <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html">MRenderer</a>* renderer = MRenderer::theRenderer();</div>
<div class="line">        <span class="keywordflow">if</span> (renderer)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html">MShaderManager</a>* shaderMgr = renderer-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_renderer.html#a4603e18a1b89b798a2e4a4f36d9b5125">getShaderManager</a>();</div>
<div class="line">            <span class="keywordflow">if</span> (shaderMgr)</div>
<div class="line">            {</div>
<div class="line">                shader = shaderMgr-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_manager.html#a8e4ad27d691969622af2b05d8c6213d9">getStockShader</a>(MShaderManager::k3dSolidShader);</div>
<div class="line">                shader-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_shader_instance.html#aa17e2c9a17b86064950103066fa307ef">setParameter</a>(ColorParameterName, &amp;color.<a class="code" href="#!/url=./cpp_ref/class_m_color.html#a4788d82c901b9367dd5c0daff8a7616b">r</a>);</div>
<div class="line">                stored.reset(shader);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> stored.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Geometry update and VP2 cache implementations</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Return true when &#39;inputSize&#39; is changed in the FootPrintNode</span></div>
<div class="line"><span class="comment">// Which requires us to re-generate the geometry</span></div>
<div class="line"><span class="comment">// Note, this method must return the exact same value in a cache-restoration frame</span></div>
<div class="line"><span class="comment">// as it was in the corresponding cache-store frame</span></div>
<div class="line"><span class="keywordtype">bool</span> FootPrintGeometryOverrideAnimatedMaterial::requiresGeometryUpdate()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Checking the &quot;FootPrintNode::geometryChanging&quot; attribute</span></div>
<div class="line">    <span class="comment">// If any attribute affecting the geometry is changing, &quot;FootPrintNode::geometryChanging&quot; should be affected and dirtied</span></div>
<div class="line">    <span class="comment">// Also check FootPrintNode::updatingGeometry() </span></div>
<div class="line">    <span class="comment">// Warning, this method may be called outside of regular { update() : cleanUp() } scope.</span></div>
<div class="line">    <span class="comment">// Thus, we must invoke node-local evaluation to ensure the correctness</span></div>
<div class="line">    <span class="keywordflow">return</span> mFootPrintNode-&gt;isGeometryChanging();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">int</span> soleCount = 21;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">int</span> heelCount = 17;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate the geometry(vertex / index) from FootPrintNode&#39;s parameter data</span></div>
<div class="line"><span class="comment">// [[ensure : requiresGeometryUpdate() == false]]</span></div>
<div class="line"><span class="keywordtype">void</span> FootPrintGeometryOverrideAnimatedMaterial::populateGeometry(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry_requirements.html">MGeometryRequirements</a>&amp; requirements,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html">MRenderItemList</a>&amp; renderItems,</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html">MGeometry</a>&amp; data)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This call will ensure the post-condition that requiresGeometryUpdate() is false</span></div>
<div class="line">    FootPrintNode::GeometryParameters footprintParam = mFootPrintNode-&gt;updatingGeometry();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Generating the vertex and index buffer from the parameters</span></div>
<div class="line">    <a name="_a79"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html">MVertexBuffer</a>* verticesBuffer       = <span class="keyword">nullptr</span>;</div>
<div class="line">    <span class="keywordtype">float</span>* vertices                     = <span class="keyword">nullptr</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <a name="_a80"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor_list.html">MVertexBufferDescriptorList</a>&amp; vertexBufferDescriptorList = requirements.<a name="a81"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry_requirements.html#a960f411f65fde2d97da465a6b276d774">vertexRequirements</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> numberOfVertexRequirments = vertexBufferDescriptorList.<a name="a82"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>();</div>
<div class="line"></div>
<div class="line">    <a name="_a83"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html">MVertexBufferDescriptor</a> vertexBufferDescriptor;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> requirmentNumber = 0; requirmentNumber &lt; numberOfVertexRequirments; ++requirmentNumber)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!vertexBufferDescriptorList.<a name="a84"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor_list.html#ab5970217cd80acac6aa900cc1daec6b8">getDescriptor</a>(requirmentNumber, vertexBufferDescriptor))</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">switch</span> (vertexBufferDescriptor.<a name="a85"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html#abc8db8e8585a67a40d57c26811aaf8e2">semantic</a>())</div>
<div class="line">        {</div>
<div class="line">        <span class="keywordflow">case</span> MGeometry::kPosition:</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (!verticesBuffer)</div>
<div class="line">                {</div>
<div class="line">                    verticesBuffer = data.<a name="a86"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#acf6369e390e9831c0e180cc60c7db618">createVertexBuffer</a>(vertexBufferDescriptor);</div>
<div class="line">                    <span class="keywordflow">if</span> (verticesBuffer)</div>
<div class="line">                    {</div>
<div class="line">                        vertices = (<span class="keywordtype">float</span>*)verticesBuffer-&gt;<a name="a87"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(soleCount+heelCount, <span class="keyword">false</span>);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="comment">// do nothing for stuff we don&#39;t understand</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    fillFootPrintVertices(vertices, footprintParam.Size);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(verticesBuffer &amp;&amp; vertices)</div>
<div class="line">    {</div>
<div class="line">        verticesBuffer-&gt;<a name="a88"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(vertices);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Now fill the index data</span></div>
<div class="line">    <span class="comment">// Index data should not change with size</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; renderItems.<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a57b988236ee6a3a5e572d126d3fbccc1">length</a>(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html">MRenderItem</a>* item = renderItems.<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item_list.html#a82ed5d7ae96a2890f5f54f697bb0bab0">itemAt</a>(i);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!item)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <a name="_a89"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html">MIndexBuffer</a>* indexBuffer = data.<a name="a90"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_geometry.html#a649d0f008cdfbd368a4157dcd47ede67">createIndexBuffer</a>(MGeometry::kUnsignedInt32);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (item-&gt;<a name="a91"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#aca2cba4630391c78dcf1a828986160da">name</a>() == WireframeItemName )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">int</span> numPrimitive = heelCount + soleCount - 2;</div>
<div class="line">            <span class="keywordtype">int</span> numIndex = numPrimitive * 2;</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexBuffer-&gt;<a name="a92"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(numIndex);</div>
<div class="line"></div>
<div class="line">            fillFootprintWireframeIndices(numIndex, indices);</div>
<div class="line"></div>
<div class="line">            indexBuffer-&gt;<a name="a93"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(indices);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (item-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#aca2cba4630391c78dcf1a828986160da">name</a>() == ShadedItemName )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">int</span> numPrimitive = heelCount + soleCount - 4;</div>
<div class="line">            <span class="keywordtype">int</span> numIndex = numPrimitive * 3;</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)indexBuffer-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aff9e3c2ed40ad0c0f0fe55668670d071">acquire</a>(numIndex);</div>
<div class="line">            fillFootprintSolidIndices(numIndex, indices);</div>
<div class="line"></div>
<div class="line">            indexBuffer-&gt;<a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html#aafb3736206f8a73c0fc74757919cfb83">commit</a>(indices);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        item-&gt;<a name="a94"></a><a class="code" href="#!/url=./cpp_ref/class_m_h_w_render_1_1_m_render_item.html#a7d0f067f76206a54f4f716f63bcb6b19">associateWithIndexBuffer</a>(indexBuffer);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line">    <span class="comment">// Foot Data</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">    <span class="keywordtype">float</span> sole[][3] = { {  0.00f, 0.0f, -0.70f },</div>
<div class="line">                        {  0.04f, 0.0f, -0.69f },</div>
<div class="line">                        {  0.09f, 0.0f, -0.65f },</div>
<div class="line">                        {  0.13f, 0.0f, -0.61f },</div>
<div class="line">                        {  0.16f, 0.0f, -0.54f },</div>
<div class="line">                        {  0.17f, 0.0f, -0.46f },</div>
<div class="line">                        {  0.17f, 0.0f, -0.35f },</div>
<div class="line">                        {  0.16f, 0.0f, -0.25f },</div>
<div class="line">                        {  0.15f, 0.0f, -0.14f },</div>
<div class="line">                        {  0.13f, 0.0f,  0.00f },</div>
<div class="line">                        {  0.00f, 0.0f,  0.00f },</div>
<div class="line">                        { -0.13f, 0.0f,  0.00f },</div>
<div class="line">                        { -0.15f, 0.0f, -0.14f },</div>
<div class="line">                        { -0.16f, 0.0f, -0.25f },</div>
<div class="line">                        { -0.17f, 0.0f, -0.35f },</div>
<div class="line">                        { -0.17f, 0.0f, -0.46f },</div>
<div class="line">                        { -0.16f, 0.0f, -0.54f },</div>
<div class="line">                        { -0.13f, 0.0f, -0.61f },</div>
<div class="line">                        { -0.09f, 0.0f, -0.65f },</div>
<div class="line">                        { -0.04f, 0.0f, -0.69f },</div>
<div class="line">                        { -0.00f, 0.0f, -0.70f } };</div>
<div class="line">    <span class="keywordtype">float</span> heel[][3] = { {  0.00f, 0.0f,  0.06f },</div>
<div class="line">                        {  0.13f, 0.0f,  0.06f },</div>
<div class="line">                        {  0.14f, 0.0f,  0.15f },</div>
<div class="line">                        {  0.14f, 0.0f,  0.21f },</div>
<div class="line">                        {  0.13f, 0.0f,  0.25f },</div>
<div class="line">                        {  0.11f, 0.0f,  0.28f },</div>
<div class="line">                        {  0.09f, 0.0f,  0.29f },</div>
<div class="line">                        {  0.04f, 0.0f,  0.30f },</div>
<div class="line">                        {  0.00f, 0.0f,  0.30f },</div>
<div class="line">                        { -0.04f, 0.0f,  0.30f },</div>
<div class="line">                        { -0.09f, 0.0f,  0.29f },</div>
<div class="line">                        { -0.11f, 0.0f,  0.28f },</div>
<div class="line">                        { -0.13f, 0.0f,  0.25f },</div>
<div class="line">                        { -0.14f, 0.0f,  0.21f },</div>
<div class="line">                        { -0.14f, 0.0f,  0.15f },</div>
<div class="line">                        { -0.13f, 0.0f,  0.06f },</div>
<div class="line">                        { -0.00f, 0.0f,  0.06f } };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> FootPrintGeometryOverrideAnimatedMaterial::fillFootprintSolidIndices(<span class="keywordtype">int</span> numIndex, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * indices)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> primitiveIndex = 0;</div>
<div class="line">    <span class="keywordtype">int</span> startIndex = 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numIndex; )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (i &lt; (heelCount - 2) * 3)</div>
<div class="line">        {</div>
<div class="line">            startIndex = 0;</div>
<div class="line">            primitiveIndex = i / 3;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            startIndex = heelCount;</div>
<div class="line">            primitiveIndex = i / 3 - heelCount + 2;</div>
<div class="line">        }</div>
<div class="line">        indices[i++] = startIndex;</div>
<div class="line">        indices[i++] = startIndex + primitiveIndex + 1;</div>
<div class="line">        indices[i++] = startIndex + primitiveIndex + 2;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> FootPrintGeometryOverrideAnimatedMaterial::fillFootprintWireframeIndices(<span class="keywordtype">int</span> numIndex, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * indices)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> primitiveIndex = 0;</div>
<div class="line">    <span class="keywordtype">int</span> startIndex = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numIndex; )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (i &lt; (heelCount - 1) * 2)</div>
<div class="line">        {</div>
<div class="line">            startIndex = 0;</div>
<div class="line">            primitiveIndex = i / 2;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            startIndex = heelCount;</div>
<div class="line">            primitiveIndex = i / 2 - heelCount + 1;</div>
<div class="line">        }</div>
<div class="line">        indices[i++] = startIndex + primitiveIndex;</div>
<div class="line">        indices[i++] = startIndex + primitiveIndex + 1;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> FootPrintGeometryOverrideAnimatedMaterial::fillFootPrintVertices(<span class="keywordtype">float</span> * vertices, <span class="keywordtype">float</span> outputSize)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> verticesPointerOffset = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We concatenate the heel and sole positions into a single vertex buffer.</span></div>
<div class="line">    <span class="comment">// The index buffers will decide which positions will be selected for each render items.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> currentVertex = 0; currentVertex &lt; soleCount + heelCount; ++currentVertex)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (vertices)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (currentVertex &lt; heelCount)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">int</span> heelVtx = currentVertex;</div>
<div class="line">                vertices[verticesPointerOffset++] = heel[heelVtx][0] * outputSize;</div>
<div class="line">                vertices[verticesPointerOffset++] = heel[heelVtx][1] * outputSize;</div>
<div class="line">                vertices[verticesPointerOffset++] = heel[heelVtx][2] * outputSize;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">int</span> soleVtx = currentVertex - heelCount;</div>
<div class="line">                vertices[verticesPointerOffset++] = sole[soleVtx][0] * outputSize;</div>
<div class="line">                vertices[verticesPointerOffset++] = sole[soleVtx][1] * outputSize;</div>
<div class="line">                vertices[verticesPointerOffset++] = sole[soleVtx][2] * outputSize;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Debug functions</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Return true if internal tracing is desired.</span></div>
<div class="line"><span class="keywordtype">bool</span> FootPrintGeometryOverrideAnimatedMaterial::traceCallSequence()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    Tracing will look something like the following when in shaded mode (on selection change):</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        FootPrintGeometryOverrideAnimatedMaterial: Geometry override DG update: footPrint1</span></div>
<div class="line"><span class="comment">        FootPrintGeometryOverrideAnimatedMaterial: Start geometry override render item update: |transform1|footPrint1</span></div>
<div class="line"><span class="comment">        FootPrintGeometryOverrideAnimatedMaterial: - Call API to update render items</span></div>
<div class="line"><span class="comment">        FootPrintGeometryOverrideAnimatedMaterial: End geometry override render item update: |transform1|footPrint1</span></div>
<div class="line"><span class="comment">        FootPrintGeometryOverrideAnimatedMaterial: End geometry override clean up: footPrint1</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    This is based on the existing stream and indexing dirty flags being used</span></div>
<div class="line"><span class="comment">    which attempts to minimize the amount of render item, vertex buffer and indexing update.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> FootPrintGeometryOverrideAnimatedMaterial::handleTraceMessage(<span class="keyword">const</span> <a class="code" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp; message)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <a name="a95"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#a3d14e9f9ed022a80f664eac0136c2f7a">MGlobal::displayInfo</a>(gPluginNodeMessagePrefix + message);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Some simple custom message formatting.</span></div>
<div class="line">    fputs(gPluginNodeMessagePrefix, stderr);</div>
<div class="line">    fputs(message.<a name="a96"></a><a class="code" href="#!/url=./cpp_ref/class_m_string.html#aa9ab612f356c53479afc4c648c9ef94d">asChar</a>(), stderr);</div>
<div class="line">    fputs(<span class="stringliteral">&quot;\n&quot;</span>, stderr);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Plugin Registration</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> FootPrintNode::initialize()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Setup the FootPrintNode&#39;s attributes</span></div>
<div class="line">    <span class="comment">// Check the documentation in &quot;class FootPrintNode&quot; for detail</span></div>
<div class="line"></div>
<div class="line">    <a name="_a97"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_unit_attribute.html">MFnUnitAttribute</a> unitFn;</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>          stat;</div>
<div class="line"></div>
<div class="line">    outputSize = unitFn.<a name="a98"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_unit_attribute.html#a31f804de81a968aa11b510a6231e7874">create</a>(<span class="stringliteral">&quot;outputSize&quot;</span>, <span class="stringliteral">&quot;sz&quot;</span>, MFnUnitAttribute::kDistance);</div>
<div class="line">    unitFn.<a name="a99"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_unit_attribute.html#a02a46e1b4ae48c38d85678a8611e3e77">setDefault</a>(1.0);</div>
<div class="line">    unitFn.<a name="a100"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#a98bb3089ec3b7442383da68a5ef424c7">setWritable</a>(<span class="keyword">false</span>);</div>
<div class="line">    stat = addAttribute(outputSize);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a name="a101"></a><a class="code" href="#!/url=./cpp_ref/class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">&quot;addAttribute&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    inputSize = unitFn.<a class="code" href="#!/url=./cpp_ref/class_m_fn_unit_attribute.html#a31f804de81a968aa11b510a6231e7874">create</a>(<span class="stringliteral">&quot;inputSize&quot;</span>, <span class="stringliteral">&quot;isz&quot;</span>, MFnUnitAttribute::kDistance);</div>
<div class="line">    unitFn.<a class="code" href="#!/url=./cpp_ref/class_m_fn_unit_attribute.html#a02a46e1b4ae48c38d85678a8611e3e77">setDefault</a>(1.0);</div>
<div class="line">    stat = addAttribute(inputSize);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="#!/url=./cpp_ref/class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">&quot;addAttribute&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <a name="_a102"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html">MFnNumericAttribute</a> attrFn;</div>
<div class="line">    geometryChanging = attrFn.<a name="a103"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#a5c08a5ce5e7123cc444c95a0e4a50f29">create</a>(<span class="stringliteral">&quot;geometryChanging&quot;</span>, <span class="stringliteral">&quot;gcg&quot;</span>, MFnNumericData::kBoolean, <span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a name="a104"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>(<span class="keyword">false</span>);</div>
<div class="line">    attrFn.<a name="a105"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#ab8e48be1f1009a30d0e40dfcaf9e649d">setHidden</a>(<span class="keyword">true</span>);</div>
<div class="line">    attrFn.<a name="a106"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#ab1986dcbce4e2fd86c5cb0bff5119dc0">setConnectable</a>(<span class="keyword">false</span>);</div>
<div class="line">    stat = addAttribute(geometryChanging);</div>
<div class="line">    <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="#!/url=./cpp_ref/class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">&quot;addAttribute&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html">MFnNumericAttribute</a> nAttr;</div>
<div class="line">    inputColor = nAttr.<a name="a107"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#a3b53a86b42bc4da537c4be835797c4d5">createColor</a>(<span class="stringliteral">&quot;inputColor&quot;</span>, <span class="stringliteral">&quot;ic&quot;</span>);</div>
<div class="line">    nAttr.<a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>(<span class="keyword">true</span>);</div>
<div class="line">    nAttr.<a name="a108"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>(<span class="keyword">true</span>);</div>
<div class="line">    nAttr.<a name="a109"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#aae3f2fbbbce06e006f1838a1fb6fdcdd">setDefault</a>(0.6f, 0.6f, 0.6f);</div>
<div class="line">    stat = addAttribute(inputColor);</div>
<div class="line">    <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="#!/url=./cpp_ref/class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">&quot;addAttribute&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    outputColor = nAttr.<a class="code" href="#!/url=./cpp_ref/class_m_fn_numeric_attribute.html#a3b53a86b42bc4da537c4be835797c4d5">createColor</a>(<span class="stringliteral">&quot;outputColor&quot;</span>, <span class="stringliteral">&quot;ocl&quot;</span>, &amp;stat);</div>
<div class="line">    <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="#!/url=./cpp_ref/class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">&quot;addAttribute&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line">    nAttr.<a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#a8d2be80de133a200a455bf9e2ac1b709">setStorable</a>(<span class="keyword">false</span>);</div>
<div class="line">    nAttr.<a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#a9e68a8b4af016b37f6567cfa6d68e551">setKeyable</a>(<span class="keyword">false</span>);</div>
<div class="line">    nAttr.<a name="a110"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#af41aae76c0dc31dbcd1f4ecea52d694e">setReadable</a>(<span class="keyword">true</span>);</div>
<div class="line">    nAttr.<a class="code" href="#!/url=./cpp_ref/class_m_fn_attribute.html#a98bb3089ec3b7442383da68a5ef424c7">setWritable</a>(<span class="keyword">false</span>);</div>
<div class="line">    stat = addAttribute(outputColor);</div>
<div class="line">    <span class="keywordflow">if</span> (!stat) {</div>
<div class="line">        stat.<a class="code" href="#!/url=./cpp_ref/class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">&quot;addAttribute&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> stat;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    attributeAffects(inputSize, outputSize);</div>
<div class="line">    attributeAffects(inputSize, geometryChanging);</div>
<div class="line">    attributeAffects(inputColor, outputColor);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> MS::kSuccess;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> initializePlugin(<a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> obj)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>   status;</div>
<div class="line">    <a name="_a111"></a><a class="code" href="#!/url=./cpp_ref/class_m_fn_plugin.html">MFnPlugin</a> plugin(obj, PLUGIN_COMPANY, <span class="stringliteral">&quot;3.0&quot;</span>, <span class="stringliteral">&quot;Any&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Initialize the global variables</span></div>
<div class="line">    Globals = <span class="keyword">new</span> GlobalVariables();</div>
<div class="line"></div>
<div class="line">    status = plugin.registerNode(</div>
<div class="line">        gPluginNodeName,</div>
<div class="line">        FootPrintNode::id,</div>
<div class="line">        &amp;FootPrintNode::creator,</div>
<div class="line">        &amp;FootPrintNode::initialize,</div>
<div class="line">        MPxNode::kLocatorNode,</div>
<div class="line">        &amp;FootPrintNode::drawDbClassification);</div>
<div class="line">    <span class="keywordflow">if</span> (!status) {</div>
<div class="line">        status.<a class="code" href="#!/url=./cpp_ref/class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">&quot;registerNode&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> status;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    status = MDrawRegistry::registerGeometryOverrideCreator(</div>
<div class="line">        FootPrintNode::drawDbClassification,</div>
<div class="line">        FootPrintNode::drawRegistrantId,</div>
<div class="line">        FootPrintGeometryOverrideAnimatedMaterial::Creator);</div>
<div class="line">    <span class="keywordflow">if</span> (!status) {</div>
<div class="line">        status.<a class="code" href="#!/url=./cpp_ref/class_m_status.html#a1f01a4748fea4d8bcced082df83f804d">perror</a>(<span class="stringliteral">&quot;registerDrawOverrideCreator&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> status;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Register a custom selection mask with priority 2 (same as locators</span></div>
<div class="line">    <span class="comment">// by default).</span></div>
<div class="line">    <a name="a112"></a><a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html#ab4cc6ba8300a9924dd443bb64b736744">MSelectionMask::registerSelectionType</a>(gPluginSelectionMask, 2);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">char</span> cmd[256];</div>
<div class="line">    snprintf(cmd, <span class="keyword">sizeof</span>(cmd), <span class="stringliteral">&quot;selectType -byName \&quot;%s\&quot; 1&quot;</span>, gPluginSelectionMask);</div>
<div class="line">    status = <a name="a113"></a><a class="code" href="#!/url=./cpp_ref/class_m_global.html#a09e405631e7cf680f8ac9d934ad73434">MGlobal::executeCommand</a>(cmd);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> uninitializePlugin(<a class="code" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> obj)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">delete</span> Globals;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Do not check the return code and return here</span></div>
<div class="line">    <span class="comment">// Plugin uninitialization should never fail</span></div>
<div class="line">    MDrawRegistry::deregisterGeometryOverrideCreator(</div>
<div class="line">        FootPrintNode::drawDbClassification,</div>
<div class="line">        FootPrintNode::drawRegistrantId);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="#!/url=./cpp_ref/class_m_fn_plugin.html">MFnPlugin</a> plugin(obj);</div>
<div class="line">    plugin.deregisterNode(FootPrintNode::id);</div>
<div class="line"></div>
<div class="line">    <a name="a114"></a><a class="code" href="#!/url=./cpp_ref/class_m_selection_mask.html#ae82a6cf818deb6b6310ad06e60b269ed">MSelectionMask::deregisterSelectionType</a>(gPluginSelectionMask);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// There is nothing we can do if any of the deregister process failed</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="#!/url=./cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1">MStatus::kSuccess</a>;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->

      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../style/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../../scripts/prettify.js"></script><script src="../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="pandoc" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><script type="text/javascript" src="../../scripts/utils/adsk.redirect.js"></script>
      <title>MPxToolCommand</title>
   </head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>MPxToolCommand</h1>
         </div>

<div class='section'><a id="mpxtoolcommand"></a></div>
<p>The <span class='code'><a href="javascript:void(0)" data-symbol="MPxToolCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxToolCommand</a></span> is the base class for creating commands that can be executed from within a context. Tool commands are similar to regular commands in that they are defined with command flags and can be executed from the Maya command line. However, they must perform extra duties, as the actions taken by a context do not come from the normal Maya command mechanism but from inside the methods of the <span class='code'><a href="javascript:void(0)" data-symbol="MPxContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_context.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxContext</a></span> class. These duties are to alert Maya of the execution of the command so that the undo/redo and journalling mechanisms operate correctly on the command. The <span class='code'><a href="javascript:void(0)" data-symbol="MPxToolCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxToolCommand</a></span> is a subclass of <span class='code'><a href="javascript:void(0)" data-symbol="MPxCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_command.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxCommand</a></span> with the additional methods.</p>
<p>If a context wants to perform its own command, it must register the command when the context and context command are registered. A context can only have one tool command associated with it.</p>
<p>The following is an example of a tool command, the helixTool. As with the marqueeTool, the list of include files is omitted for brevity. See the helixTool.cpp file in the Developer Kit for the complete example.</p>
<div class="codeBlock"><pre class="prettyprint">#define NUMBER_OF_CVS 20
class helixTool : public <a href="javascript:void(0)" data-symbol="MPxToolCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxToolCommand</a>
{
    public:
        helixTool(); 
        virtual ~helixTool(); 
        static void* creator();
        <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> doIt( const <a href="javascript:void(0)" data-symbol="MArgList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArgList</a>&amp; args );
        <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> redoIt();
        <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> undoIt();
        bool isUndoable() const;
        <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> finalize();
        static <a href="javascript:void(0)" data-symbol="MSyntax" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_syntax.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSyntax</a> newSyntax();

</pre></div><p>The set of methods on <span class='code'><a href="javascript:void(0)" data-symbol="MPxToolCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_tool_command.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxToolCommand</a></span> are similar to those on <span class='code'><a href="javascript:void(0)" data-symbol="MPxCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_command.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxCommand</a></span> but with the addition of <span class='code'>finalize()</span>. The finalize method is used to create a string representing the command and its arguments.</p>
<div class="codeBlock"><pre class="prettyprint">        void setRadius( double newRadius );
        void setPitch( double newPitch );
        void setNumCVs( unsigned newNumCVs );
        void setUpsideDown( bool newUpsideDown );

</pre></div><p>These methods are necessary since the properties of the helix will be set from the context object.</p>
<div class="codeBlock"><pre class="prettyprint">    private:
        double radius; // Helix radius
        double pitch; // Helix pitch
        unsigned numCV; // Helix number of CVs
        bool upDown; // Helis upsideDown
        <a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDagPath</a> path; // Dag path to the curve.
        // Don’t save the pointer!
};
void* helixTool::creator()
{
    return new helixTool;
}
helixTool::~helixTool() {}

</pre></div><p>These first two methods are identical to the earlier &quot;helix2&quot; example.</p>
<div class="codeBlock"><pre class="prettyprint">helixTool::helixTool()
{ 
    numCV = NUMBER_OF_CVS;
    upDown = false;
    setCommandString( &quot;helixToolCmd&quot; );
}

</pre></div><p>The constructor saves away the name of the MEL command for later use in the <span class='code'>finalize()</span> method.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MSyntax" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_syntax.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSyntax</a> helixTool::newSyntax()
{
    <a href="javascript:void(0)" data-symbol="MSyntax" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_syntax.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSyntax</a> syntax;
    syntax.addFlag(kPitchFlag, kPitchFlagLong,
    MSyntax::kDouble);
    syntax.addFlag(kRadiusFlag, kRadiusFlagLong,
    MSyntax::kDouble);
    syntax.addFlag(kNumberCVsFlag, kNumberCVsFlagLong,
    MSyntax::kUnsigned);
    syntax.addFlag(kUpsideDownFlag, kUpsideDownFlagLong,
    MSyntax::kBoolean);
    return syntax;
}
<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixTool::doIt( const <a href="javascript:void(0)" data-symbol="MArgList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArgList</a> &amp;args )
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> status;
    status = parseArgs(args);
    if (MS::kSuccess != status)
        return status;
    return redoIt();
}
<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixTool::parseArgs(const <a href="javascript:void(0)" data-symbol="MArgList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArgList</a> &amp;args)
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> status;
    <a href="javascript:void(0)" data-symbol="MArgDatabase" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_database.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_arg_database.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArgDatabase</a> argData(syntax(), args);
    if (argData.isFlagSet(kPitchFlag)) {
        double tmp;
        status = argData.getFlagArgument(kPitchFlag, 0, tmp);
        if (!status) {
            status.perror(&quot;pitch flag parsing failed.&quot;);
            return status;
        }
        pitch = tmp;
    }
    if (argData.isFlagSet(kRadiusFlag)) {
        double tmp;
        status = argData.getFlagArgument(kRadiusFlag, 0, tmp);
        if (!status) {
            status.perror(&quot;radius flag parsing failed.&quot;);
            return status;
        }
        radius = tmp;
    }
    if (argData.isFlagSet(kNumberCVsFlag)) {
        unsigned tmp;
        status = argData.getFlagArgument(kNumberCVsFlag,
            0, tmp);
        if (!status) {
            status.perror(&quot;numCVs flag parsing failed.&quot;);
            return status;
        }
        numCV = tmp;
    }
    if (argData.isFlagSet(kUpsideDownFlag)) {
        bool tmp;
        status = argData.getFlagArgument(kUpsideDownFlag,
            0, tmp);
        if (!status) {
            status.perror(&quot;upside down flag parsing failed.&quot;);
            return status;
        }
        upDown = tmp;
    }
    return MS::kSuccess;
}

</pre></div><p>This method is similar to the earlier helix example—it parses the arguments and uses them to set its internal state. In general, this command will be used through the UI, but since it is still a MEL command, it can be invoked from the MEL command shell.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixTool::redoIt()
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> stat;
    const unsigned deg = 3; // Curve Degree
    const unsigned ncvs = NUMBER_OF_CVS;// Number of CVs
    const unsigned spans = ncvs - deg; // Number of spans
    const unsigned nknots = spans+2*deg-1;// Number of knots
    unsigned i;
    <a href="javascript:void(0)" data-symbol="MPointArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_point_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPointArray</a> controlVertices;
    <a href="javascript:void(0)" data-symbol="MDoubleArray" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_double_array.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDoubleArray</a> knotSequences;
    int upFactor;
    if (upDown) upFactor = -1;
    else upFactor = 1;
    // Set up cvs and knots for the helix
    //
    for (i = 0; i &lt; ncvs; i++)
        controlVertices.append( <a href="javascript:void(0)" data-symbol="MPoint" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_point.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPoint</a>(
        radius * cos( (double)i ),
        upFactor * pitch * (double)i,
        radius * sin( (double)i ) ) );
    for (i = 0; i &lt; nknots; i++)
        knotSequences.append( (double)i );
    // Now create the curve
    //
    <a href="javascript:void(0)" data-symbol="MFnNurbsCurve" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_nurbs_curve.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNurbsCurve</a> curveFn;
    <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> curve = curveFn.create( controlVertices,
        knotSequences, deg, MFnNurbsCurve::kOpen,
        false, false, <a href="javascript:void(0)" data-symbol="MObject::kNullObj" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html#af2a707b4254eb54763167aeced863e63&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject::kNullObj</a>, &amp;stat );
    if ( !stat )
    {
        stat.perror(&quot;Error creating curve&quot;);
        return stat;
    }
    stat = curveFn.getPath( path );
    return stat;
}

</pre></div><p>This is essentially the same as the earlier helix example.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixTool::undoIt()
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> stat; 
    <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> transform = path.transform();
    stat = <a href="javascript:void(0)" data-symbol="MGlobal::removeFromModel" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_global.html#acccac5ce696c5ab724ff96947f46c41b&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGlobal::removeFromModel</a>( transform );
    return stat;
}

</pre></div><p>Again this is essentially the same as the earlier helix example. You should be noticing a pattern developing. It is quite easy to change a command into a tool. Little of the command has to be changed, additions just have to be made to hook the tool up to the UI.</p>
<div class="codeBlock"><pre class="prettyprint">bool helixTool::isUndoable() const
{
    return true; 
}

</pre></div><p>This tool is undoable.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixTool::finalize()
{
    <a href="javascript:void(0)" data-symbol="MArgList" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_list.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArgList</a> command;
    command.addArg( commandString() );
    command.addArg( <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>(kRadiusFlag) );
    command.addArg( radius );
    command.addArg( <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>(kPitchFlag) );
    command.addArg( pitch );
    command.addArg( <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>(kNumberCVsFlag) );
    command.addArg( (int)numCV );
    command.addArg( <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>(kUpsideDownFlag) );
    command.addArg( upDown );
    return <a href="javascript:void(0)" data-symbol="MPxToolCommand::doFinalize" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tool_command.html#a453a8fb7a2285d97888cf2a60fa64712&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxToolCommand::doFinalize</a>( command );
}

</pre></div><p>This method is the one noticeable addition to the tool which wasn’t necessary in the command. When a command is typed in it is easy to take it and print it out to a journal file. Since a tool is not typed in, but created through mouse input, no text string exists to be output to a journal file. The <span class='code'>finalize()</span> method solves this by outputting a string when the tool has completed. It is necessary for you to call <span class='code'><a href="javascript:void(0)" data-symbol="MPxToolCommand::doFinalize()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_tool_command.html#a453a8fb7a2285d97888cf2a60fa64712&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_tool_command.html#adf6d293860cfea905a954f2931f7c3c5&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxToolCommand::doFinalize()</a></span> to have the command output to the journal file.</p>
<div class="codeBlock"><pre class="prettyprint">void helixTool::setRadius( double newRadius )
{
    radius = newRadius;
}
void helixTool::setPitch( double newPitch )
{
    pitch = newPitch;
}
void helixTool::setNumCVs( unsigned newNumCVs )
{
    numCV = newNumCVs;
}
void helixTool::setUpsideDown( double newUpsideDown )
{
    upDown = newUpsideDown;
}
const char helpString[] = &quot;Click and drag to draw helix&quot;;
class helixContext : public <a href="javascript:void(0)" data-symbol="MPxContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_context.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxContext</a>
{

</pre></div><p>This is the context which will be executing the helixTool command.</p>
<div class="codeBlock"><pre class="prettyprint">    public:
        helixContext();
        virtual void toolOnSetup( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; event );
        virtual <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> doPress( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; event );
        virtual <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> doDrag( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; event );
        virtual <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> doRelease( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; event );
        virtual <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> doEnterRegion( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; event );

</pre></div><p>The set of methods are the same as for the marqueeTool example.</p>
<div class="codeBlock"><pre class="prettyprint">    private:
        short startPos_x, startPos_y;
        short endPos_x, endPos_y;
        unsigned numCV;
        bool upDown;
        <a href="javascript:void(0)" data-symbol="M3dView" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">M3dView</a> view;
        GLdouble height,radius;
};
helixContext::helixContext() 
{
    setTitleString( &quot;Helix Tool&quot; );
}
void helixContext::toolOnSetup( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; )
{
    setHelpString( helpString );
}
<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixContext::doPress( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; event )
{
    event.getPosition( startPos_x, startPos_y );
    view = MGlobal::active3dView();
    view.beginGL();
    view.beginOverlayDrawing();
    return MS::kSuccess;
}

</pre></div><p>These three methods are essentially the same as the marqueeTool examples, the only difference being that <span class='code'>doPress()</span> for the helixTool does not need to determine the modifier key state.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixContext::doDrag( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; event )
{
    event.getPosition( endPos_x, endPos_y );
    view.clearOverlayPlane();
    glIndexi( 2 );
    int upFactor;
    if (upDown) upFactor = 1;
    else upFactor = -1;
    // Draw the guide cylinder
    //
    glMatrixMode( GL_MODELVIEW );
    glPushMatrix();
    glRotatef( upFactor * 90.0, 1.0f, 0.0f, 0.0f );
    GLUquadricObj *qobj = gluNewQuadric();
    gluQuadricDrawStyle(qobj, GLU_LINE);
    GLdouble factor = (GLdouble)numCV;
    radius = fabs(endPos_x - startPos_x)/factor + 0.1;
    height = fabs(endPos_y - startPos_y)/factor + 0.1;
    gluCylinder( qobj, radius, radius, height, 8, 1 );
    glPopMatrix();

</pre></div><p>This code draws a cylinder in the current view defining the outlines of the helix that will be generated.</p>
<div class="codeBlock"><pre class="prettyprint">#ifndef _WIN32
    glXSwapBuffers(view.display(), view.window() );
#else
    SwapBuffers(view.deviceContext() );
#endif
    return MS::kSuccess;
}
<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixContext::doRelease( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; )
{
    // Clear the overlay plane &amp; restore from overlay drawing
    //
    view.clearOverlayPlane();
    view.endOverlayDrawing();
    view.endGL();

</pre></div><p>The user has released the mouse so this code cleans up the OpenGL drawing.</p>
<div class="codeBlock"><pre class="prettyprint">    helixTool * cmd = (helixTool*)newToolCommand();
    cmd-&gt;setPitch( height/NumCVs );
    cmd-&gt;setRadius( radius );
    cmd-&gt;setNumCVs( numCV );
    cmd-&gt;setUpsideDown( upDown );
    cmd-&gt;redoIt();
    cmd-&gt;finalize();

</pre></div><p>This code creates the actual helixTool command, by calling the helixTool::creator method that you will register later, sets the radius and pitch, and then calls the <span class='code'>redoIt()</span> method to generate the data. As a last step, the <span class='code'>finalize()</span> method is called to ensure that this command is written out to the journal file.</p>
<div class="codeBlock"><pre class="prettyprint">    return MS::kSuccess;
}
<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixContext::doEnterRegion( <a href="javascript:void(0)" data-symbol="MEvent" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_event.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MEvent</a> &amp; )
{
    return setHelpString( helpString );
}
void helixContext::getClassName( <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> &amp;name ) const
{
    name.set(&quot;helix&quot;);
}

</pre></div><p>The next four methods are used in the interaction between the context and the contextCommand’s edit and query methods. These will be called by the tool property sheet for the context. The <span class='code'><a href="javascript:void(0)" data-symbol="MToolsInfo::setDirtyFlag()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_tools_info.html#a5f1bc27778c881159a7e486934261015&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MToolsInfo::setDirtyFlag()</a></span> method alerts the tool property sheet so it can redraw itself with the new property values for the context.</p>
<div class="codeBlock"><pre class="prettyprint">void helixContext::setNumCVs( unsigned newNumCVs )
{
    numCV = newNumCVs;
    <a href="javascript:void(0)" data-symbol="MToolsInfo::setDirtyFlag" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_tools_info.html#a5f1bc27778c881159a7e486934261015&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MToolsInfo::setDirtyFlag</a>(*this);
}
void helixContext::setUpsideDown( bool newUpsideDown )
{
    upDown = newUpsideDown;
    <a href="javascript:void(0)" data-symbol="MToolsInfo::setDirtyFlag" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_tools_info.html#a5f1bc27778c881159a7e486934261015&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MToolsInfo::setDirtyFlag</a>(*this);
}
unsigned helixContext::numCVs()
{
    return numCV;
}
bool helixContext::upsideDown()
{
    return upDown;
}

</pre></div><p>The next class and implementation repeats the code from the marqueeTool example. This class is necessary to create instances of the tool context.</p>
<div class="codeBlock"><pre class="prettyprint">class helixContextCmd : public <a href="javascript:void(0)" data-symbol="MPxContextCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_context_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxContextCommand</a>
{
    public: 
        helixContextCmd();
        virtual <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> doEditFlags();
        virtual <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> doQueryFlags();
        virtual <a href="javascript:void(0)" data-symbol="MPxContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_context.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxContext</a>* makeObj();
        virtual <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> appendSyntax();
        static void* creator();
    protected:
        helixContext * fHelixContext;
};
helixContextCmd::helixContextCmd() {}
<a href="javascript:void(0)" data-symbol="MPxContext" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_context.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_u_i_1_1_m_px_context.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxContext</a>* helixContextCmd::makeObj()
{
    fHelixContext = new helixContext();
    return fHelixContext;
}
void* helixContextCmd::creator()
{
    return new helixContextCmd;
}

</pre></div><p>The next two methods handle the argument parsing for the command. There are two types of arguments—those which make modifications to the properties of a context, and those which query the properties of a context.</p>
<blockquote>
<p><strong>Note:</strong> Argument parsing is done through the <span class='code'><a href="javascript:void(0)" data-symbol="MPxContextCommand::parser()" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_context_command.html#aa367dd5b853c97af707d0fb44aa37971&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxContextCommand::parser()</a></span> method which returns an <span class='code'><a href="javascript:void(0)" data-symbol="MArgParser" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_parser.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_arg_parser.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArgParser</a></span>. This class is analogous to the <span class='code'><a href="javascript:void(0)" data-symbol="MArgDatabase" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_database.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_arg_database.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArgDatabase</a></span> class that is used with the <span class='code'><a href="javascript:void(0)" data-symbol="MPxCommand" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_px_command.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_px_command.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPxCommand</a></span> class.</p>
</blockquote>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixContextCmd::doEditFlags()
{
    <a href="javascript:void(0)" data-symbol="MArgParser" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_parser.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_arg_parser.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArgParser</a> argData = parser();
    if (argData.isFlagSet(kNumberCVsFlag)) {
        unsigned numCVs;
        status = argData.getFlagArgument(kNumberCVsFlag,
            0, numCVs);
        if (!status) {
            status.perror(&quot;numCVs flag parsing failed.&quot;);
            return status;
        }
        fHelixContext-&gt;setNumCVs(numCVs);
    }
    if (argData.isFlagSet(kUpsideDownFlag)) {
        bool upsideDown;
        status = argData.getFlagArgument(kUpsideDownFlag,
            0, upsideDown);
        if (!status) {
            status.perror(&quot;upsideDown flag parsing failed.&quot;);
            return status;
        }
        fHelixContext-&gt;setUpsideDown(upsideDown);
    }

    return MS::kSuccess;
}
<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixContextCmd::doQueryFlags()
{
    <a href="javascript:void(0)" data-symbol="MArgParser" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_arg_parser.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_arg_parser.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MArgParser</a> argData = parser();
    if (argData.isFlagSet(kNumberCVsFlag)) {
        setResult((int) fHelixContext-&gt;numCVs());
    }
    if (argData.isFlagSet(kUpsideDownFlag)) {
        setResult(fHelixContext-&gt;upsideDown());
    }
    return MS::kSuccess;
}
<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> helixContextCmd::appendSyntax()
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> status;
    <a href="javascript:void(0)" data-symbol="MSyntax" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_syntax.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MSyntax</a> mySyntax = syntax();
    if (MS::kSuccess != mySyntax.addFlag(kNumberCVsFlag,
        kNumberCVsFlagLong, MSyntax::kUnsigned)) {
            return MS::kFailure;
    }
    if (MS::kSuccess != mySyntax.addFlag(kUpsideDownFlag,
        kUpsideDownFlagLong, MSyntax::kBoolean)) {
            return MS::kFailure;
    }
    return MS::kSuccess;
}
<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> initializePlugin( <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> obj )
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> status;
    <a href="javascript:void(0)" data-symbol="MFnPlugin" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_plugin.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnPlugin</a> plugin( obj, &quot;Autodesk&quot;, &quot;1.0&quot;, &quot;Any&quot;);
    // Register the context creation command and the tool
    // command that the helixContext will use.
    // 
    status = plugin.registerContextCommand(
        &quot;helixToolContext&quot;, helixContextCmd::creator,
        &quot;helixToolCmd&quot;, helixTool::creator,
        helixTool::newSyntax);
    if (!status) {
        status.perror(&quot;registerContextCommand&quot;);
        return status;
    }
    return status;
}

</pre></div><p>The <span class='code'>initializePlugin()</span> method registers both the helix command and the context via a single register call.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> uninitializePlugin( <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> obj)
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> status;
    <a href="javascript:void(0)" data-symbol="MFnPlugin" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_plugin.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnPlugin</a> plugin( obj );
    // Deregister the tool command and the context
    // creation command.
    //
    status = plugin.deregisterContextCommand(
        &quot;helixToolContext&quot; &quot;helixToolCmd&quot;);
    if (!status) {
        status.perror(&quot;deregisterContextCommand&quot;);
        return status;
    }
    return status;
}

</pre></div><p>MEL code similar to the marqueeTool example’s is necessary to attach the helixTool to the UI.</p>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

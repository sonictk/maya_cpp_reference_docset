<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../style/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../../scripts/prettify.js"></script><script src="../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="pandoc" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><script type="text/javascript" src="../../scripts/utils/adsk.redirect.js"></script>
      <title>A hardware shading node plug-in example</title>
   </head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>A hardware shading node plug-in example</h1>
         </div>

<div class='section'><a id="a-hardware-shading-node-plug-in-example"></a></div>
<p>The <span class='code'>hwPhongShader</span> node plug-in is available in the Maya Developer Kit. In this example, a cube-environment map is used to perform per pixel Phong shading. The light direction is currently fixed at the eye position.</p>
<blockquote>
<p><strong>Note:</strong> The node based interface used in this example only encompasses a subset of the Viewport 2.0 interfaces. For more information about this interface, see <a href='#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Plug-in-Entry-Points/Effect-Overrides.html' title=''>Effect Overrides</a>.</p>
</blockquote>
<div class='section'><a id="initializing-and-un-initializing-the-plug-in"></a><h2 id="initializing-and-un-initializing-the-plug-in">Initializing and un-initializing the Plug-in</h2></div>
<p>Initializing the plug-in is a straight forward process. In initialize, the swatch classification string is built and the node and drag and drop behavior classes are registered. Note that the drag and drop behavior does not require a unique <span class='code'><a href="javascript:void(0)" data-symbol="MTypeId" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_type_id.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_type_id.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MTypeId</a></span>. A simple text string to name the behavior is sufficient.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> initializePlugin( <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> obj )
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a>   status;

    const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>&amp; swatchName = <a href="javascript:void(0)" data-symbol="MHWShaderSwatchGenerator::initialize" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_shader_swatch_generator.html#acf0030e7f24277ad6805a14be529539f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHWShaderSwatchGenerator::initialize</a>();
    const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a> UserClassify( &quot;shader/surface/utility/:drawdb/shader/surface/hwPhongShader:swatch/&quot;+swatchName );

    <a href="javascript:void(0)" data-symbol="MFnPlugin" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_plugin.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnPlugin</a> plugin( obj, PLUGIN_COMPANY, &quot;4.5&quot;, &quot;Any&quot;);
    status = plugin.registerNode( &quot;hwPhongShader&quot;, hwPhongShader::id,
                                   hwPhongShader::creator, hwPhongShader::initialize,
                                   MPxNode::kHwShaderNode, &amp;UserClassify );
    if (!status) {
        status.perror(&quot;registerNode&quot;);
        return status;
    }

    plugin.registerDragAndDropBehavior(&quot;hwPhongShaderBehavior&quot;,
                                        hwPhongShaderBehavior::creator);

    // Register a shader override for this node
    <a href="javascript:void(0)" data-symbol="MHWRender::MDrawRegistry::registerShaderOverrideCreator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_registry.html#a7436ee759c9ea5113f5a222085dbfe6e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHWRender::MDrawRegistry::registerShaderOverrideCreator</a>(
        &quot;drawdb/shader/surface/hwPhongShader&quot;,
        sHWPhongShaderRegistrantId,
        hwPhongShaderOverride::Creator);
    if (status != MS::kSuccess) return status;

    return MS::kSuccess;
}

</pre></div><p>Un-initializing the plug-in de-registers the Phong node and the drag and drop behavior.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> uninitializePlugin( <a href="javascript:void(0)" data-symbol="MObject" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_object.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MObject</a> obj )
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a>   status;

    <a href="javascript:void(0)" data-symbol="MFnPlugin" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_plugin.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnPlugin</a> plugin( obj );

    // Unregister all chamelion shader nodes
    plugin.deregisterNode( hwPhongShader::id );
    if (!status) {
        status.perror(&quot;deregisterNode&quot;);
        return status;
     }

     plugin.deregisterDragAndDropBehavior(&quot;hwPhongShaderBehavior&quot;);

     // Deregister the shader override
     status = <a href="javascript:void(0)" data-symbol="MHWRender::MDrawRegistry::deregisterShaderOverrideCreator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_registry.html#a11ddbef3eada4895397b8acb6c77eb2e&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHWRender::MDrawRegistry::deregisterShaderOverrideCreator</a>(
               &quot;drawdb/shader/surface/hwPhongShader&quot;, sHWPhongShaderRegistrantId);
     if (status != MS::kSuccess) return status;

     return MS::kSuccess;
}
</pre></div><div class='section'><a id="initializing-the-node"></a><h2 id="initializing-the-node">Initializing the node</h2></div>
<p>The hardware shader plug-in’s <span class='code'>initialize()</span> method’s attributes that are used in the Dependency Graph are pre-configured. Standard color attributes are added and flagged with properties based on how they are meant to work. Attributes are first created, then added and then finally relationships between the attributes are set. This example configures attributes as cached and internal for performance.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::initialize()
{
   // Make sure that all attributes are cached internal for
   // optimal performance !

   <a href="javascript:void(0)" data-symbol="MFnNumericAttribute" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_numeric_attribute.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnNumericAttribute</a> nAttr;
   <a href="javascript:void(0)" data-symbol="MFnCompoundAttribute" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_fn_compound_attribute.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFnCompoundAttribute</a> cAttr;

   // Create input attributes
   aColor = nAttr.createColor( &quot;color&quot;, &quot;c&quot;);
   nAttr.setStorable(true);
   nAttr.setKeyable(true);
   nAttr.setDefault(0.1f, 0.1f, 0.1f);
   nAttr.setCached( true );
   nAttr.setInternal( true );
   nAttr.setAffectsAppearance( true );
    
   aTransparency = nAttr.create( &quot;transparency&quot;, &quot;tr&quot;, MFnNumericData::kFloat );
   nAttr.setStorable(true);
   nAttr.setKeyable(true);
   nAttr.setDefault(0.0f);
   nAttr.setMax(1.0f);
   nAttr.setMin(0.0f);
   nAttr.setCached( true );
   nAttr.setInternal( true );
   nAttr.setAffectsAppearance( true );

   aDiffuseColor = nAttr.createColor( &quot;diffuseColor&quot;, &quot;dc&quot; );
   nAttr.setStorable(true);
   nAttr.setKeyable(true);
   nAttr.setDefault(1.f, 0.5f, 0.5f);
   nAttr.setCached( true );
   nAttr.setInternal( true );
   nAttr.setAffectsAppearance( true );

   aSpecularColor = nAttr.createColor( &quot;specularColor&quot;, &quot;sc&quot; );
   nAttr.setStorable(true);
   nAttr.setKeyable(true);
   nAttr.setDefault(0.5f, 0.5f, 0.5f);
   nAttr.setCached( true );
   nAttr.setInternal( true );
   nAttr.setAffectsAppearance( true );

   // This is defined as a compound attribute, users can easily enter
   // values beyond 1.
   aShininessX = nAttr.create( &quot;shininessX&quot;, &quot;shx&quot;, MFnNumericData::kFloat, 100.0 );
   aShininessY = nAttr.create( &quot;shininessY&quot;, &quot;shy&quot;, MFnNumericData::kFloat, 100.0 );
   aShininessZ = nAttr.create( &quot;shininessZ&quot;, &quot;shz&quot;, MFnNumericData::kFloat, 100.0 );
   aShininess = cAttr.create( &quot;shininess&quot;, &quot;sh&quot; );
   cAttr.addChild(aShininessX);
   cAttr.addChild(aShininessY);
   cAttr.addChild(aShininessZ) ;
   nAttr.setStorable(true);
   nAttr.setKeyable(true);
   nAttr.setCached( true );
   nAttr.setInternal( true );
   nAttr.setAffectsAppearance(true);    
   cAttr.setHidden(false);
    
   aGeometryShape = nAttr.create( &quot;geometryShape&quot;, &quot;gs&quot;, MFnNumericData::kInt );
   nAttr.setStorable(true);
   nAttr.setKeyable(true);
   nAttr.setDefault(0);
   nAttr.setCached( true );
   nAttr.setInternal( true );

   // create output attributes here
   // outColor is the only output attribute and it is inherited
   // so we do not need to create or add it.
   //

   // Add the attributes here

   addAttribute(aColor);
   addAttribute(aTransparency);
   addAttribute(aDiffuseColor);
   addAttribute(aSpecularColor);
   addAttribute(aShininess);
   addAttribute(aGeometryShape);

   attributeAffects (aColor,            outColor);
   attributeAffects (aTransparency, outColor);
   attributeAffects (aDiffuseColor, outColor);
   attributeAffects (aSpecularColor,    outColor);
   attributeAffects (aShininessX,       outColor);
   attributeAffects (aShininessY,       outColor);
   attributeAffects (aShininessZ,       outColor);
   attributeAffects (aShininess,        outColor);

   return MS::kSuccess;
}

</pre></div><div class='section'><a id="compute-method"></a><h2 id="compute-method">Compute method</h2></div>
<p>The following is a description of the simple implementation of <span class='code'>compute()</span> on this class. This method is configured to only handle the <span class='code'>outColor</span> attribute. Any other attributes passed to this method will result in <span class='code'>MS::kUnknownParameter</span> being returned, which will cause Maya to handle these attributes. Otherwise, the attribute <span class='code'>aDiffuseColor</span> is accessed from the datablock and its value is used to set the out color.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::compute(
const <a href="javascript:void(0)" data-symbol="MPlug" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_plug.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MPlug</a>&amp;      plug,
   <a href="javascript:void(0)" data-symbol="MDataBlock" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_data_block.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDataBlock</a>&amp; block )
{

   if ((plug != outColor) &amp;&amp; (plug.parent() != outColor))
      return MS::kUnknownParameter;

   <a href="javascript:void(0)" data-symbol="MFloatVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_float_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFloatVector</a> &amp; color  = block.inputValue( aDiffuseColor ).asFloatVector();

   // set output color attribute
   <a href="javascript:void(0)" data-symbol="MDataHandle" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_data_handle.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDataHandle</a> outColorHandle = block.outputValue( outColor );
   <a href="javascript:void(0)" data-symbol="MFloatVector" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_float_vector.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MFloatVector</a>&amp; outColor = outColorHandle.asFloatVector();
   outColor = color;

   outColorHandle.setClean();
   return MS::kSuccess;
}

</pre></div><p>By implementing this method, the hardware shader node plug-in will be visible in software rendering. If software rendering is not required, there is no need to implement this method.</p>
<div class='section'><a id="reference-information-for-legacy-default-viewport"></a><h2 id="reference-information-for-legacy-default-viewport">Reference information for Legacy Default Viewport</h2></div>
<p>The following sections contain reference information for hardware shaders that render in the Legacy Default Viewport. The current recommendation is to create shaders for use with Viewport 2.0. See <a href='#!/url=./dev_help/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide.html' title=''>Maya Viewport 2.0 API Guide</a>.</p>
<div class='section'><a id="bind-draw-and-unbind-methods"></a><h3 id="bind-draw-and-unbind-methods">Bind, draw and unbind methods</h3></div>
<p>The <span class='code'>bind()</span> and <span class='code'>glBind()</span> methods follow the same strategy. If required attributes have changed or the Phong texture has not been set, then the Phong texture is initialized.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::bind(const <a href="javascript:void(0)" data-symbol="MDrawRequest" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_request.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawRequest</a>&amp; request, <a href="javascript:void(0)" data-symbol="M3dView" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">M3dView</a>&amp; view)

{
    if (mAttributesChanged || (phong_map_id == 0))
    {
        init_Phong_texture ();
    }
    return MS::kSuccess;
}


<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::glBind(const <a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDagPath</a>&amp;)
{
    if ( mAttributesChanged || (phong_map_id == 0))
    {
        init_Phong_texture ();
    }

    return MS::kSuccess;
}
        
</pre></div><p>The <span class='code'>unbind()</span> and <span class='code'>glUnbind()</span> methods in this example only return <span class='code'>MS::kSuccess</span> since there is an alternate way written for releasing resources. In the <span class='code'>hwPhongShader</span> examples, messages are checked via the API and resources are released before events such as file new, file open and file reference. Please consult the full example code for more details.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::unbind(const <a href="javascript:void(0)" data-symbol="MDrawRequest" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_request.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawRequest</a>&amp; request, <a href="javascript:void(0)" data-symbol="M3dView" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">M3dView</a>&amp; view)
{
    // The texture may have been allocated by the draw; it&#39;s kept
    // around for use again. When scene new or open is performed this
    // texture will be released in releaseEverything().
    return MS::kSuccess;
}


<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::glUnbind(const <a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDagPath</a>&amp;)
{
    // The texture may have been allocated by the draw; it&#39;s kept
    // around for use again. When scene new or open is performed this
    // texture will be released in releaseEverything().
    return MS::kSuccess;
}
</pre></div><p>The <span class='code'>geometry()</span> and <span class='code'>glGeometry()</span> methods are set up similarly. Each makes a call to the interface independent <span class='code'>draw()</span> method to avoid duplicating the draw code.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::geometry( const <a href="javascript:void(0)" data-symbol="MDrawRequest" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_draw_request.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDrawRequest</a>&amp; request,
                                <a href="javascript:void(0)" data-symbol="M3dView" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m3d_view.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">M3dView</a>&amp; view,
                                int prim,
                                unsigned int writable,
                                int indexCount,
                                const unsigned int * indexArray,
                                int vertexCount,
                                const int * vertexIDs,
                                const float * vertexArray,
                                int normalCount,
                                const float ** normalArrays,
                                int colorCount,
                                const float ** colorArrays,
                                int texCoordCount,
                                const float ** texCoordArrays)
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> stat = <a href="javascript:void(0)" data-symbol="MStatus::kSuccess" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus::kSuccess</a>;
    if (mGeometryShape != 0)
        drawDefaultGeometry();
    else
        stat = draw( prim, writable, indexCount, indexArray, vertexCount,
        vertexIDs, vertexArray, normalCount, normalArrays,
        colorCount, colorArrays, texCoordCount, texCoordArrays);
    return stat;
}

<a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::glGeometry(const <a href="javascript:void(0)" data-symbol="MDagPath" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_dag_path.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MDagPath</a> &amp; path,
                                  int prim,
                                  unsigned int writable,
                                  int indexCount,
                                  const unsigned int * indexArray,
                                  int vertexCount,
                                  const int * vertexIDs,
                                  const float * vertexArray,
                                  int normalCount,
                                  const float ** normalArrays,
                                  int colorCount,
                                  const float ** colorArrays,
                                  int texCoordCount,
                                  const float ** texCoordArrays)
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> stat = <a href="javascript:void(0)" data-symbol="MStatus::kSuccess" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus::kSuccess</a>;
    if (mGeometryShape != 0)
        drawDefaultGeometry();
    else
        stat = draw( prim, writable, indexCount, indexArray, vertexCount,
        vertexIDs, vertexArray, normalCount, normalArrays,
        colorCount, colorArrays, texCoordCount, texCoordArrays);
    return stat;
}
        
</pre></div><div class='section'><a id="drawing"></a><h3 id="drawing">Drawing</h3></div>
<p>The <span class='code'>draw()</span> method parameters are used to pass information to OpenGL for rendering the information to screen. It is very important to note that the <span class='code'>indexArray</span> is used to access information from the other arrays.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::draw(int prim,
                            unsigned int writable,
                            int indexCount,
                            const unsigned int * indexArray,
                            int vertexCount,
                            const int * vertexIDs,
                            const float * vertexArray,
                            int normalCount,
                            const float ** normalArrays,
                            int colorCount,
                            const float ** colorArrays,
                            int texCoordCount,
                            const float ** texCoordArrays)
{
    if ( prim != GL_TRIANGLES &amp;&amp; prim != GL_TRIANGLE_STRIP) {
        return MS::kFailure;
    }

    {
        glPushAttrib ( GL_ENABLE_BIT );
        glDisable ( GL_LIGHTING );
        glDisable ( GL_TEXTURE_1D );
        glDisable ( GL_TEXTURE_2D );

        // Setup cube map generation
        glEnable ( GL_TEXTURE_CUBE_MAP_EXT );
        glBindTexture ( GL_TEXTURE_CUBE_MAP_EXT, phong_map_id );
        glEnable ( GL_TEXTURE_GEN_S );
        glEnable ( GL_TEXTURE_GEN_T );
        glEnable ( GL_TEXTURE_GEN_R );
        glTexGeni ( GL_S, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_EXT );
        glTexGeni ( GL_T, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_EXT );
        glTexGeni ( GL_R, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_EXT );
        glTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_WRAP_S, GL_CLAMP);
        glTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_WRAP_T, GL_CLAMP);
        glTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

        glTexEnvi ( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

        // Could modify the texture matrix here to do light tracking...
        glMatrixMode ( GL_TEXTURE );
        glPushMatrix ();
        glLoadIdentity ();
        glMatrixMode ( GL_MODELVIEW );
    }

        // Draw the surface.
        //
    {
        glPushClientAttrib ( GL_CLIENT_VERTEX_ARRAY_BIT );
        glEnableClientState( GL_VERTEX_ARRAY );
        glEnableClientState( GL_NORMAL_ARRAY );

        glVertexPointer ( 3, GL_FLOAT, 0, &amp;vertexArray[0] );
        glNormalPointer ( GL_FLOAT, 0, &amp;normalArrays[0][0] );

        glDrawElements ( prim, indexCount, GL_UNSIGNED_INT, indexArray );

        // The client attribute is already being popped. You
        glPopClientAttrib();
    }

    {
        glMatrixMode ( GL_TEXTURE );
        glPopMatrix ();
        glMatrixMode ( GL_MODELVIEW );

        glDisable ( GL_TEXTURE_CUBE_MAP_EXT );
        glDisable ( GL_TEXTURE_GEN_S );
        glDisable ( GL_TEXTURE_GEN_T );
        glDisable ( GL_TEXTURE_GEN_R );

        glPopAttrib();
    }

        return MS::kSuccess;
}

</pre></div><div class='section'><a id="drawing-the-swatch"></a><h4 id="drawing-the-swatch">Drawing the swatch</h4></div>
<p>Drawing the swatch involves implementing the virtual <span class='code'>renderSwatchImage()</span> and using the <span class='code'><a href="javascript:void(0)" data-symbol="MHardwareRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer</a></span> class in conjunction with <span class='code'><a href="javascript:void(0)" data-symbol="MGeometryData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_geometry_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGeometryData</a></span> and OpenGL to draw the image. The <span class='code'><a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a></span> passed to <span class='code'>renderSwatchImage()</span> contains information on the <span class='code'>width</span> and height of the <span class='code'>output</span> that is required.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> hwPhongShader::renderSwatchImage( <a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a> &amp; outImage )
{
    <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> status = <a href="javascript:void(0)" data-symbol="MStatus::kFailure" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus::kFailure</a>;

    // Get the hardware renderer utility class
    <a href="javascript:void(0)" data-symbol="MHardwareRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer</a> *pRenderer = <a href="javascript:void(0)" data-symbol="MHardwareRenderer::theRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html#a93fef222f7278c123e8df750f7f0ea5b&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer::theRenderer</a>();
    if (pRenderer)
    {
        const <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MString</a>&amp; backEndStr = pRenderer-&gt;backEndString();

        // Get geometry
        // ============
        unsigned int* pIndexing = 0;
        unsigned int numberOfData = 0;
        unsigned int indexCount = 0;
        <a href="javascript:void(0)" data-symbol="MHardwareRenderer::GeometricShape" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html#a5f45789e2294fc128af5b04595d96505&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer::GeometricShape</a> gshape =
            <a href="javascript:void(0)" data-symbol="MHardwareRenderer::kDefaultSphere" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html#a5f45789e2294fc128af5b04595d96505acb4a5f68a3b6cd8c05b1dc9c5a487c88&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer::kDefaultSphere</a>;
        if (mGeometryShape == 2)
        {
            gshape = <a href="javascript:void(0)" data-symbol="MHardwareRenderer::kDefaultCube" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html#a5f45789e2294fc128af5b04595d96505a86db3fcd02f093aba91aa87457074701&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer::kDefaultCube</a>;
        }
        else if (mGeometryShape == 3)
        {
            gshape = <a href="javascript:void(0)" data-symbol="MHardwareRenderer::kDefaultPlane" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html#a5f45789e2294fc128af5b04595d96505a184eac47c82e5c13dd2dd52420cbf89f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer::kDefaultPlane</a>;
        }
        <a href="javascript:void(0)" data-symbol="MGeometryData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_geometry_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGeometryData</a>* pGeomData =
            pRenderer-&gt;referenceDefaultGeometry( gshape, numberOfData, pIndexing, indexCount );
        if( !pGeomData )
        {
            return <a href="javascript:void(0)" data-symbol="MStatus::kFailure" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus::kFailure</a>;
        }

        // Make the swatch context current
        // ===============================
        //
        unsigned int width, height;
        outImage.getSize( width, height );
        unsigned int origWidth = width;
        unsigned int origHeight = height;

        <a href="javascript:void(0)" data-symbol="MStatus" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus</a> status2 = pRenderer-&gt;makeSwatchContextCurrent( backEndStr,
            width, height );

        if( status2 == MS::kSuccess )
        {
            // Note:  Must be called after makeSwatchContextCurrent()
            glPushAttrib ( GL_ALL_ATTRIB_BITS );

            // Get camera
            // ==========
            {
                // Get the camera frustum from the API
                double l, r, b, t, n, f;
                pRenderer-&gt;getSwatchOrthoCameraSetting( l, r, b, t, n, f );

                glMatrixMode(GL_PROJECTION);
                glLoadIdentity();
                glOrtho( l, r, b, t, n, f );
                glMatrixMode(GL_MODELVIEW);
                glLoadIdentity();
                // Rotate the cube a bit so we don&#39;t see it head on
                if (gshape == <a href="javascript:void(0)" data-symbol="MHardwareRenderer::kDefaultCube" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html#a5f45789e2294fc128af5b04595d96505a86db3fcd02f093aba91aa87457074701&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer::kDefaultCube</a>)
                    glRotatef( 45, 1.0, 1.0, 1.0 );
                else if (gshape == <a href="javascript:void(0)" data-symbol="MHardwareRenderer::kDefaultPlane" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html#a5f45789e2294fc128af5b04595d96505a184eac47c82e5c13dd2dd52420cbf89f&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer::kDefaultPlane</a>)
                    glScalef( 1.5, 1.5, 1.5 );
                            else
                                glScalef( 1.0, 1.0, 1.0 );
            }

                // Draw The Swatch
                // ===============
                drawTheSwatch( pGeomData, pIndexing, numberOfData, indexCount );

                // Read pixels back from swatch context to <a href="javascript:void(0)" data-symbol="MImage" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_image.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_1_1_m_image.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MImage</a>
                // ==============================================
                pRenderer-&gt;readSwatchContextPixels( backEndStr, outImage );

                // Double check the outing going image size as image resizing
                // was required to properly read from the swatch context
                outImage.getSize( width, height );
                if (width != origWidth || height != origHeight)
                {
                    status = <a href="javascript:void(0)" data-symbol="MStatus::kFailure" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80a1ef6c2d725fb4bec3e7e840d28adbc00&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus::kFailure</a>;
                }
                else
                {
                    status = <a href="javascript:void(0)" data-symbol="MStatus::kSuccess" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_status.html#a02ab596f4febca68da503aaf8dde3a80af0536797208144380691e2b376ffc1d1&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MStatus::kSuccess</a>;
                }

                glPopAttrib();
        }
        else
        {
            pRenderer-&gt;dereferenceGeometry( pGeomData, numberOfData );
        }
    }
    return status;
}

</pre></div><p>The method <span class='code'>drawTheSwatch()</span> is invoked from the <span class='code'>renderSwatchImage()</span> method. It performs the OpenGL drawing on the image.</p>
<div class="codeBlock"><pre class="prettyprint">void            
hwPhongShader::drawTheSwatch( <a href="javascript:void(0)" data-symbol="MGeometryData" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_geometry_data.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MGeometryData</a>* pGeomData,
                             unsigned int* pIndexing,
                             unsigned int numberOfData,
                             unsigned int indexCount )
{
    <a href="javascript:void(0)" data-symbol="MHardwareRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer</a> *pRenderer = <a href="javascript:void(0)" data-symbol="MHardwareRenderer::theRenderer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_hardware_renderer.html#a93fef222f7278c123e8df750f7f0ea5b&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHardwareRenderer::theRenderer</a>();
    if( !pRenderer )    return;
    if ( mAttributesChanged || (phong_map_id == 0))
    {
        init_Phong_texture ();
    }

    // Get the default background color
    float r, g, b, a;
    <a href="javascript:void(0)" data-symbol="MHWShaderSwatchGenerator::getSwatchBackgroundColor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_shader_swatch_generator.html#a95a6855572205246f2741796ed8c5bdc&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../&quot;}]">MHWShaderSwatchGenerator::getSwatchBackgroundColor</a>( r, g, b, a );
    glClearColor( r, g, b, a );
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glShadeModel(GL_SMOOTH);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

    glDisable ( GL_LIGHTING );
    glDisable ( GL_TEXTURE_1D );
    glDisable ( GL_TEXTURE_2D );
    {
        glEnable ( GL_TEXTURE_CUBE_MAP_EXT );
        glBindTexture ( GL_TEXTURE_CUBE_MAP_EXT, phong_map_id );
        glEnable ( GL_TEXTURE_GEN_S );
        glEnable ( GL_TEXTURE_GEN_T );
        glEnable ( GL_TEXTURE_GEN_R );
        glTexGeni ( GL_S, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_EXT );
        glTexGeni ( GL_T, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_EXT );
        glTexGeni ( GL_R, GL_TEXTURE_GEN_MODE, GL_NORMAL_MAP_EXT );
        glTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_WRAP_S, GL_CLAMP);
        glTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_WRAP_T, GL_CLAMP);
        glTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

        glTexEnvi ( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

        // Could modify the texture matrix here to do light tracking...
        glMatrixMode ( GL_TEXTURE );
        glPushMatrix ();
        glLoadIdentity ();
        glRotatef( 5.0, -1.0, 0.0, 0.0 );
        glRotatef( 10.0, 0.0, 1.0, 0.0 );
        glMatrixMode ( GL_MODELVIEW );
    }

        // Draw default geometry
    {
        if (pGeomData)
        {
            glPushClientAttrib ( GL_CLIENT_VERTEX_ARRAY_BIT );

            float *vertexData = (float *)( pGeomData[0].data() );
            if (vertexData)
            {
                glEnableClientState( GL_VERTEX_ARRAY );
                glVertexPointer ( 3, GL_FLOAT, 0, vertexData );
            }
            float *normalData = (float *)( pGeomData[1].data() );
            if (normalData)
            {
                glEnableClientState( GL_NORMAL_ARRAY );
                glNormalPointer ( GL_FLOAT, 0, normalData );
            }

            if (vertexData &amp;&amp; normalData &amp;&amp; pIndexing )
                glDrawElements ( GL_TRIANGLES, indexCount, GL_UNSIGNED_INT, pIndexing );

            glPopClientAttrib();

            // Release data references
            pRenderer-&gt;dereferenceGeometry( pGeomData, numberOfData );
        }
    }

    {
        glMatrixMode ( GL_TEXTURE );
        glPopMatrix ();
        glMatrixMode ( GL_MODELVIEW );
        glDisable ( GL_TEXTURE_CUBE_MAP_EXT );
        glDisable ( GL_TEXTURE_GEN_S );
        glDisable ( GL_TEXTURE_GEN_T );
        glDisable ( GL_TEXTURE_GEN_R );
    }
}
</pre></div>      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>

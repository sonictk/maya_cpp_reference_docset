<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head>
<link href="../../../../style/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../../../../scripts/prettify.js"></script><script src="../../../../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="pandoc" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><script type="text/javascript" src="../../../../scripts/utils/adsk.redirect.js"></script>
      <title>Customizing Geometric Data for Shaders</title>
   </head>
   <body height="100%"><div class="body_content" id="body-content"><style type="text/css">code{white-space: pre;}</style><script>$(document).ready(function() { yepnope.injectJs("./scripts/multireflink.js"); });</script><script>$(document).ready(function () { prettyPrint(); } );</script><script></script><script></script><div id="reflinkdiv"></div>
      <div>
         <div class="head">
            <h1>Customizing Geometric Data for Shaders</h1>
         </div>

<div class='section'><a id="customizing-geometric-data-for-shaders"></a></div>
<p>The data representation for Maya DAG objects dictates both the format as well as the types of geometric streams that can be used as inputs for shading algorithms. For a given shader it is possible that either the format or the type of stream provided may be insufficient.</p>
<p>To address these issues, an API to provide data customization is provided to:</p>
<ul>
<li>Allow for customized data streams to be provided.</li>
<li>Allow for more custom data formats.</li>
<li>Allow for data repackaging.</li>
</ul>
<p>All interfaces work within a unified system, which allows for any or all customizations to be used in conjunction with each other.</p>
<p>There are two interfaces which provide the ability for a plug-in to provide custom data streams and custom data indexing.</p>
<div class='section'><a id="geometry-generators"></a><h2 id="geometry-generators">Geometry Generators</h2></div>
<p>Custom streams can be provided using an <span class='code'><a href="javascript:void(0)" data-symbol="MPxVertexBufferGenerator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_vertex_buffer_generator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_vertex_buffer_generator.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxVertexBufferGenerator</a></span>. There is no equivalent legacy class to which matches this functionality.</p>
<p>A generator can supply a stream based on new data and/or existing stream data.</p>
<p>In order to use an <span class='code'><a href="javascript:void(0)" data-symbol="MPxVertexBufferGenerator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_vertex_buffer_generator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_vertex_buffer_generator.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxVertexBufferGenerator</a></span>, it needs to be registered via the <span class='code'><a href="javascript:void(0)" data-symbol="MDrawRegistry" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_registry.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_registry.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDrawRegistry</a></span> class in a similar fashion to how overrides are registered.</p>
<p>When a shader requires certain data streams, it specifies its requirements using <span class='code'>MVertexBufferDescriptors</span>. Each <span class='code'><a href="javascript:void(0)" data-symbol="MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBufferDescriptor</a></span> specifies its stream using a stream name and a semantic. Every <span class='code'><a href="javascript:void(0)" data-symbol="MPxVertexBufferGenerator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_vertex_buffer_generator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_vertex_buffer_generator.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxVertexBufferGenerator</a></span> is required to have an associated name. To reference a generator, this name can be used by an <span class='code'><a href="javascript:void(0)" data-symbol="MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBufferDescriptor</a></span> as its semantic name.</p>
<p>The following is an example for an <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span> which specifies the requirement for two custom streams:</p>
<div class="codeBlock"><pre class="prettyprint">// Create a custom position stream requirement. Set a unique semantic name for lookup.
// Add to the list of requirements.
<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a> positionDesc(
                empty, 
                MHWRender::MGeometry::kPosition,
                MHWRender::MGeometry::kFloat,
                3);

positionDesc.setSemanticName(&quot;customPositionStream&quot;);
addGeometryRequirement(positionDesc);

// Create a custom normal stream requirement. Set a unique semantic name for lookup.
// Add to the list of requirements.
<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a> normalDesc(
                empty,
                MHWRender::MGeometry:: kNormal,
                MHWRender::MGeometry::kFloat,
                3);
normalDesc.setSemanticName(&quot;customNormalStream&quot;);
addGeometryRequirement(normalDesc);

</pre></div><p>A generator is called to fill in data via its <span class='code'>createVertexStreams()</span> method. For the given DAG path, the generator updates and returns an <span class='code'><a href="javascript:void(0)" data-symbol="MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBuffer</a></span>.</p>
<p>A set of existing source streams can be supplied for situations where new data is generated based on existing data. The specific streams that are required are returned via a query to the generator (<span class='code'>getSourceStreams()</span>) before <span class='code'>createVertexStreams()</span> is invoked.</p>
<p>As an example, existing position and normal streams can be combined to form a new stream. Since the input streams (<span class='code'>MVertexBuffers</span>) are GPU resources, they need to be mapped to CPU memory before they can be read from. Any source stream data should never be modified.</p>
<p>In order to fill in the data correctly, the indexing which is used to reference the data stream is also provided. The generator provides the desired indexing for the custom stream (<span class='code'>getSourceIndexing()</span>). It is possible that indexing optimization may be performed based on the indexing for all internal and custom streams. Both the original and the shared indexing data are provided to the generator at stream creation time. Indexing is specified using an <span class='code'><a href="javascript:void(0)" data-symbol="MComponentDataIndexing" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_component_data_indexing.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_component_data_indexing.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MComponentDataIndexing</a></span> instance. This is a wrapper for a set of index values and a component type.</p>
<p>It is the responsibility of the generator to perform the correct allocation and transfer of data into the <span class='code'><a href="javascript:void(0)" data-symbol="MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBuffer</a></span> that it is supplied.</p>
<div class='figure'><img src='dev_help/images/aa0f8d61.jpg' title='' /></div>
<p>Figure 69: The flow of execution is roughly shown based on the ordering of the methods on the buffer generator. From the top downwards, source stream and indexing requirements are queried. At creation time any requested source streams, the relevant dag path and the overall shared indexing are provided as inputs. The generator is responsible for filling in the <span class='code'><a href="javascript:void(0)" data-symbol="MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBuffer</a></span>. In this case, it swizzles an input position and a normal stream into a new stream.</p>
<p>Custom stream indexing should be provided using an: <span class='code'><a href="javascript:void(0)" data-symbol="MPxPrimitiveGenerator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_primitive_generator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_primitive_generator.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxPrimitiveGenerator</a></span>.</p>
<p>As with stream generators a unique name is used to identify the indexing that can be used. For indexing, a shader instance specifies the required indexing using a <span class='code'><a href="javascript:void(0)" data-symbol="MIndexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MIndexBufferDescriptor</a></span>. The primitive name in the descriptor can be set to the name of the primitive generator.</p>
<p>In order to use an <span class='code'><a href="javascript:void(0)" data-symbol="MPxPrimitiveGenerator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_primitive_generator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_primitive_generator.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxPrimitiveGenerator</a></span>, it needs to be registered via the <span class='code'><a href="javascript:void(0)" data-symbol="MDrawRegistry" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_registry.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_registry.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDrawRegistry</a></span> class in a similar fashion to that of an <span class='code'><a href="javascript:void(0)" data-symbol="MPxVertexBufferGenerator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_vertex_buffer_generator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_vertex_buffer_generator.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxVertexBufferGenerator</a></span>.</p>
<p>There are two entry points which currently can support adding in indexing requirements: For an <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span> this is the point when its geometry requirements are defined and for an <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride</a></span> this is the point when geometry requirements are defined for additional render items. In either case, the requirements are specified by a <span class='code'><a href="javascript:void(0)" data-symbol="MIndexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MIndexBufferDescriptor</a></span>.</p>
<p>To add custom indexing as a requirement, an appropriately set up <span class='code'><a href="javascript:void(0)" data-symbol="MIndexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MIndexBufferDescriptor</a></span> must be added. The type must be set to “custom” and a unique name set. This name should match the name of a registered generator.</p>
<p>This is an example of how a non-custom index requirement is added for an <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride</a></span>:</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MHWRender::MGeometryRequirements" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_geometry_requirements.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MGeometryRequirements</a> geomRequirements;

// As we are not using MIndexBufferDescriptor::kCustom for custom named index buffers
// just use an empty string here.
<a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> noName;

// Add in a triangle indexing requirement
<a href="javascript:void(0)" data-symbol="MHWRender::MIndexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MIndexBufferDescriptor</a> triangleDesc(
        MHWRender::MIndexBufferDescriptor::kTriangle, 
        noName, 
        MHWRender::MGeometry::kTriangles, 
        3, 
        compObj);

geomRequirements.addIndexingRequirement(triangleDesc);
</pre></div><p>This is an example of adding a custom indexing requirement for a <span class='code'><a href="javascript:void(0)" data-symbol="MPxShaderOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_shader_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxShaderOverride</a></span>:</p>
<div class="codeBlock"><pre class="prettyprint">// Name of custom indexing 
<a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> customPrimitiveName(&quot;customPrimitive&quot;);

// Add in a custom triangle indexing requirement
<a href="javascript:void(0)" data-symbol="MHWRender::MIndexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MIndexBufferDescriptor</a> indexingRequirement( 
        MHWRender::MIndexBufferDescriptor::kCustom, 
        customPrimitiveName, 
        MHWRender::MGeometry::kTriangles);
        
addIndexingRequirement(indexingRequirement);
<div class='figure'><img src='dev_help/images/aa0f8d67.jpg' title=''></div>
</pre></div><p>Figure 70: Resulting relationship based on code example.</p>
<p>When custom indexing is required the appropriate calls to a generator instance are made. The generator first provides the indexing size relative to a DAG object and DAG component (<span class='code'>computeIndexingCount()</span>). The generator is then asked to create the actual indexing. The source and target indexing data is also provided. An <span class='code'><a href="javascript:void(0)" data-symbol="MIndexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_index_buffer.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MIndexBuffer</a></span> must be updated and returned. As this is a GPU resource, it must be mapped back to CPU memory, updated, and then transferred back to GPU memory.</p>
<div class='figure'><img src='dev_help/images/aa0f8d6d.jpg' title='' /></div>
<p>Figure 71</p>
<p>Examples provided in the Developer Kit include:</p>
<ul>
<li><em>vertexBufferGenerator</em>: Performs the swizzle of position and normal as previously described. Note that this plug-ins is dependent on the dx11Shader and cgfxShaderNode plug-ins which parse the sample effects files for semantic names and uses them as the name key to activate the generator. There is a slight difference different shader semantics used for CgFx and HLSL. For CgFx, arbitrary string names cannot be used and thus the generator uses attribute name semantics “ATTR7” and “ATTR8”; whereas for HLSL, the names “myCustomStream” and “myCustomStream2” can be used instead.</li>
<li><em>customPrimitiveGenerator</em>: An example of a primitive generator. The usage of this generator can be activated via the <em>hwPhongShader</em> plug-in.</li>
<li><p><em>crackFreePrimitiveGenerator</em>: An example of indexing mutator which is used for producing custom indexing and data to support tessellation shaders in the dx11Shader plug-in.</p>
<div class='figure'><img src='dev_help/images/aa0f8d73.jpg' title='' /></div>
<p>Figure 72</p></li>
</ul>
<p>The crack free mutator creates an indexing buffer with more information than that of a normal triangle list. The triangle indexing provides, for each triangle, the indices of their 3 vertices. The crack free mutator provides indexing fit for tessellation.</p>
<p>The sample currently implements support for the modes “PN-AEN9” and “PN-AEN18” (Point-Normal Triangles using Adjacent Edge Normals).</p>
<p>The PN-AEN9 mode creates indexing for each triangle with the following data:</p>
<ul>
<li>the 3 triangle vertices indexes,</li>
<li>the 6 vertex indexes of the adjacent edges.</li>
</ul>
<p>This results in a stride of 9 for the index array. Hence, the name PN-AEN9.</p>
<p>Based on the above diagram, for a triangle represented by the vertices a, b and c, the PNAEN9 code generates the following indexing:</p>
<div class="codeBlock"><pre class="prettyprint"> [a b c] [d e f g h i]
</pre></div><p>The PN-AEN18 adds even more data than PN-AEN9:</p>
<ul>
<li>3 triangle vertices indices</li>
<li>6 vertex indices of the adjacent edges</li>
<li>6 vertex indices of the dominant edges</li>
<li>3 vertices of the dominant uv position.</li>
</ul>
<p>This results in a stride of 18 for the index array.</p>
<p>A dominant edge is the edge that has the lowest vertex indices. In the same example above, the dominant edge between <span class='code'>[ab]</span> and <span class='code'>[de]</span> for triangle <span class='code'>[abc]</span> will be <span class='code'>[ab]</span> and for triangle <span class='code'>[dej]</span> it will still be <span class='code'>[ab]</span></p>
<p>A dominant uv position is the triangle for which each vertex has the lowest uv coordinates. In the example above, the dominant position for triangle <span class='code'>[abc]</span> is <span class='code'>[afh]</span></p>
<ul>
<li>if the uv coordinates of <span class='code'>[a]</span> are lower than those of <span class='code'>[d]</span>, <span class='code'>[i]</span>, <span class='code'>[r]</span> and <span class='code'>[s]</span></li>
<li>if the uv coordinates of <span class='code'>[f]</span> are lower than those of <span class='code'>[b], [e], [k], [l]</span> and <span class='code'>[m]</span></li>
<li>if the uv coordinates of <span class='code'>[h]</span> are lower than those of <span class='code'>[c], [g], [o], [p]</span> and <span class='code'>[q]</span></li>
</ul>
<p>The PN-AEN18 code generates the following indexing:</p>
<div class="codeBlock"><pre class="prettyprint">[a b c] [d e f g h i] [a b f g h i] [a f h]
</pre></div><p>The dx11Shader and CgFx plug-in respectively show usage of generators for HLSL and CgFx. The dx11Shader explicitly registers the crack-free tesselator mutators for shader semantics “PNAEN9” and “PNAEN18”.</p>
<p>The SDK provided sample shader (AutodeskUberShader.fx) uses the following technique declaration to notify the API of the special indexing requirements:</p>
<div class="codeBlock"><pre class="prettyprint">technique11 TessellationON
&lt;
    string index_buffer_type = &quot;PNAEN18&quot;; // Indicate index buffer type required
&gt;
{  
    pass p0
    {
        SetRasterizerState(CullFront);
        SetDepthStencilState(DepthNormal, 0);
        SetVertexShader(CompileShader(vs_5_0, vt()));
        SetHullShader(CompileShader(hs_5_0, HS()));
        SetDomainShader(CompileShader(ds_5_0, DS()));
        SetGeometryShader(NULL);                                
        SetPixelShader(CompileShader(ps_5_0, f()));
    }
}

</pre></div><p>In this case, an annotation per technique is being parsed within the plug-in code. The <em>customIndexingMutatorName</em> string value “PNAEN18” is the semantic name on an index descriptor requirement, which, at update time, calls the registered crack-free indexing mutator.</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> customIndexingMutatorName;

ID3DX11EffectTechnique * mpD3DTechnique;

ID3DX11EffectVariable* indexBufferType = 
        mpD3DTechnique-&gt;GetAnnotationByName(&quot;index_buffer_type&quot;);

if(indexBufferType &amp;&amp; indexBufferType-&gt;IsValid())
{
    ID3DX11EffectStringVariable* indexBufferTypeStr = indexBufferType-&gt;AsString();
    if(indexBufferTypeStr &amp;&amp; indexBufferTypeStr-&gt;IsValid())
    {
        LPCSTR value; 
        if( SUCCEEDED ( indexBufferTypeStr-&gt;GetString( &amp;value ) ) )
        {
            customIndexingMutatorName = <a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a>(value);
        }
    }
}
</pre></div><div class='section'><a id="geometry-mutators"></a><h2 id="geometry-mutators">Geometry Mutators</h2></div>
<p>As the name implies a mutator can be used to modify the packing of data for a given existing vertex buffer (<span class='code'><a href="javascript:void(0)" data-symbol="MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBuffer</a></span>). As with stream generators, mutators are associated with a descriptor through name matching between the mutator and the semantic name on a descriptor (<span class='code'><a href="javascript:void(0)" data-symbol="MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBufferDescriptor</a></span>)</p>
<p>A mutator is represented as an <span class='code'><a href="javascript:void(0)" data-symbol="MPxVertexBufferMutator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_vertex_buffer_mutator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_vertex_buffer_mutator.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxVertexBufferMutator</a></span>. Mutators must be registered with <span class='code'><a href="javascript:void(0)" data-symbol="MDrawRegistry" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_registry.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_registry.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDrawRegistry</a></span>.</p>
<p>This example illustrates how to specify an existing mutator for use:</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MString" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_string.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MString</a> empty;

<a href="javascript:void(0)" data-symbol="MHWRender::MVertexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MVertexBufferDescriptor</a> positionDesc(
        empty,
        MHWRender::MGeometry::kPosition,
        MHWRender::MGeometry::kFloat,
        3);
        
// Use the custom semantic name &quot;swizzlePosition&quot; which corresponds to a plug-in which will
// swizzle the x,y, and z channels of a position stream using this positionDesc.setSemanticName(&quot;swizzlePosition&quot;); 

// Add the descriptor as part of the requirements for this shader
addGeometryRequirement(positionDesc);

</pre></div><p>The following diagram illustrates the relationship of the above code example. An additional “customMutator” is added to show the lookup by semantic name.</p>
<div class='figure'><img src='dev_help/images/aa0f8d79.jpg' title='' /></div>
<p>Figure 73</p>
<p>When a mutator is required to perform an update, an associated Maya DAG path and data stream indexing are passed in. An existing <span class='code'><a href="javascript:void(0)" data-symbol="MVertexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_vertex_buffer.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MVertexBuffer</a></span> is passed in for update and data is modified in-place.</p>
<div class='figure'><img src='dev_help/images/aa0f8d7f.jpg' title='' /></div>
<p>Figure 74</p>
<p>The Developer Kit example <em>vertexBufferMutator</em> has the full code for registering a mutator which performs the swizzle. The hwPhongShader plug-in has code which demonstrates the usage of the custom swizzle.</p>
<p>The following is an excerpt from the sample code which shows how in-place editing is performed:</p>
<div class="codeBlock"><pre class="prettyprint">// Input argument
MVertexBuffer&amp; vertexBuffer;

unsigned int vertexCount = vertexBuffer.vertexCount();
if (vertexCount &lt;= 0)
    return;
    
// Acquire the buffer to fill with data. Data is not in CPU memory
float* buffer = (float*)vertexBuffer.acquire(vertexCount);
float* start = buffer;

for (unsigned int i = 0; i &lt; vertexCount; ++i)
{
    // Here we swap the x, y and z values
    float x = buffer[0];
    buffer[0] = buffer[1];    // y --&gt; x
    buffer[1] = buffer[2];    // z --&gt; y
    buffer[2] = x;            // x --&gt; z
    buffer += 3;
}

// Commit the buffer to signal completion. CPU data will be transferred to GPU memory.
vertexBuffer.commit(start);

</pre></div><div class='section'><a id="indexing-mutators"></a><h2 id="indexing-mutators">Indexing Mutators</h2></div>
<p>An indexing mutator can be used to modify the data for a given existing index buffer (<span class='code'><a href="javascript:void(0)" data-symbol="MIndexBuffer" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_index_buffer.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MIndexBuffer</a></span>). Mutators are associated with a descriptor through name matching between the mutator and the semantic name on a descriptor (<span class='code'><a href="javascript:void(0)" data-symbol="MIndexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MIndexBufferDescriptor</a></span>)</p>
<p>A mutator is represented as an <span class='code'><a href="javascript:void(0)" data-symbol="MPxIndexBufferMutator" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_index_buffer_mutator.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_index_buffer_mutator.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxIndexBufferMutator</a></span>. Mutators must be registered with <span class='code'><a href="javascript:void(0)" data-symbol="MDrawRegistry" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_draw_registry.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_draw_registry.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MDrawRegistry</a></span>.</p>
<p>This example illustrates how to specify an existing mutator for use:</p>
<div class="codeBlock"><pre class="prettyprint"><a href="javascript:void(0)" data-symbol="MHWRender::MIndexBufferDescriptor" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_index_buffer_descriptor.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MHWRender::MIndexBufferDescriptor</a> indexingRequirement(
        MHWRender::MIndexBufferDescriptor::kCustom,
        customIndexingMutatorName,
        MHWRender::MGeometry::kTriangles);
        
// Add the descriptor as part of the requirements for this shader
addIndexingRequirement(indexingRequirement);

</pre></div><p>The following diagram illustrates the relationship of the above code example. An additional “customMutator” is added to show the lookup by semantic name.</p>
<div class='figure'><img src='dev_help/images/Maya%20Viewport%202%20supplementary%20diagram%2061.png' title='' /></div>
<p>Figure 75</p>
<p>When a mutator is required to perform an update, an associated data stream indexing and previously generated vetex buffer array are passed in. An existing MIndexBuffer is passed in for update and data is modified in-place.</p>
<div class='figure'><img src='dev_help/images/Maya%20Viewport%202%20supplementary%20diagram%2061+.png' title='' /></div>
<p>Figure 76</p>
<p>The Developer Kit example <em>crackFreePrimitiveGenerator</em>, part of the dx11Shader project has the full code for registering a mutator which performs PN AEN patch generation. The dx11Shader plug-in has code which demonstrates the usage of the custom patch when the “TessellationON” or “Wireframe” techniques of the MayaUberShader.fx effect file is selected.</p>
<p>The following is an excerpt from the sample code which shows how in-place editing is performed:</p>
<div class="codeBlock"><pre class="prettyprint">// Input argument
MIndexBuffer&amp; indexBuffer;

// Acquire the buffer to fill with data. Data is not in CPU memory
unsigned int* buffer = (unsigned int *) indexBuffer.acquire(numTri * triSize, true);
unsigned int* start = buffer;

for (unsigned int i = 0; i &lt; numTri; ++i)
{
    // Here we fill PN AEN information
    buffer[0] = vertexId0; 
    buffer[1] = vertexId1;
    buffer[2] = vertexId2;
    // ...
    buffer[17] = dominantVertex2;
    buffer += triSize;
}

// Commit the buffer to signal completion. CPU data will be transferred to GPU memory.
indexBuffer.commit(start);
primitiveStride = triSize; // Output argument
return MHWRender::MGeometry::kPatch;

</pre></div><p><strong>Pipeline Summary:</strong></p>
<div class='figure'><img src='dev_help/images/aa0f99e6.jpg' title='' /></div>
<p>Figure 77</p>
<p>The above diagram shows how generators and mutators fit in the overall pipeline. Shown is a shader override which has custom requirements (based on shader parameters) for the generation and mutation of vertex buffers, and primitive generation (as represented by the descriptors). When updates need to occur (Update phase), the shader requirements on an <span class='code'><a href="javascript:void(0)" data-symbol="MPxGeometryOverride" class="a_multireflink" data-reflinkdata="[{&quot;path&quot;:&quot;cpp_ref/class_m_h_w_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;C++ API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;},{&quot;path&quot;:&quot;py_ref/class_open_maya_render_1_1_m_px_geometry_override.html&quot;,&quot;title&quot;:&quot;Python 2.0 API Reference&quot;,&quot;relpathtoroot&quot;:&quot;../../../../&quot;}]">MPxGeometryOverride</a></span> are name matched to generators and mutators which are invoked to update or create vertex and index buffers. These custom buffers can be used by one or more render items which flow down the pipeline until it reaches the Draw Phase. At this point, the custom vertex and index buffers can be bound to the shader parameters which initiated the custom data requirement.</p>
      <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
